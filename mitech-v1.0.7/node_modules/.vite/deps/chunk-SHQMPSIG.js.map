{
  "version": 3,
  "sources": ["../../../packages/components/affix/src/affix.ts", "../../../packages/components/affix/src/affix.vue", "../../../packages/components/affix/index.ts"],
  "sourcesContent": ["import {\n  buildProps,\n  definePropType,\n  isBoolean,\n  isNumber,\n} from '@element-plus/utils'\nimport { CHANGE_EVENT } from '@element-plus/constants'\nimport type { ExtractPropTypes } from 'vue'\nimport type { ZIndexProperty } from 'csstype'\nimport type Affix from './affix.vue'\n\nexport const affixProps = buildProps({\n  /**\n   * @description affix element zIndex value\n   * */\n  zIndex: {\n    type: definePropType<ZIndexProperty>([Number, String]),\n    default: 100,\n  },\n  /**\n   * @description target container. (CSS selector)\n   */\n  target: {\n    type: String,\n    default: '',\n  },\n  /**\n   * @description offset distance\n   * */\n  offset: {\n    type: Number,\n    default: 0,\n  },\n  /**\n   * @description position of affix\n   * */\n  position: {\n    type: String,\n    values: ['top', 'bottom'],\n    default: 'top',\n  },\n} as const)\nexport type AffixProps = ExtractPropTypes<typeof affixProps>\n\nexport const affixEmits = {\n  scroll: ({ scrollTop, fixed }: { scrollTop: number; fixed: boolean }) =>\n    isNumber(scrollTop) && isBoolean(fixed),\n  [CHANGE_EVENT]: (fixed: boolean) => isBoolean(fixed),\n}\nexport type AffixEmits = typeof affixEmits\n\nexport type AffixInstance = InstanceType<typeof Affix>\n", "<template>\n  <div ref=\"root\" :class=\"ns.b()\" :style=\"rootStyle\">\n    <div :class=\"{ [ns.m('fixed')]: fixed }\" :style=\"affixStyle\">\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, onMounted, ref, shallowRef, watch, watchEffect } from 'vue'\nimport {\n  useElementBounding,\n  useEventListener,\n  useWindowSize,\n} from '@vueuse/core'\nimport { addUnit, getScrollContainer, throwError } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { affixEmits, affixProps } from './affix'\nimport type { CSSProperties } from 'vue'\n\nconst COMPONENT_NAME = 'ElAffix'\ndefineOptions({\n  name: COMPONENT_NAME,\n})\n\nconst props = defineProps(affixProps)\nconst emit = defineEmits(affixEmits)\n\nconst ns = useNamespace('affix')\n\nconst target = shallowRef<HTMLElement>()\nconst root = shallowRef<HTMLDivElement>()\nconst scrollContainer = shallowRef<HTMLElement | Window>()\nconst { height: windowHeight } = useWindowSize()\nconst {\n  height: rootHeight,\n  width: rootWidth,\n  top: rootTop,\n  bottom: rootBottom,\n  update: updateRoot,\n} = useElementBounding(root, { windowScroll: false })\nconst targetRect = useElementBounding(target)\n\nconst fixed = ref(false)\nconst scrollTop = ref(0)\nconst transform = ref(0)\n\nconst rootStyle = computed<CSSProperties>(() => {\n  return {\n    height: fixed.value ? `${rootHeight.value}px` : '',\n    width: fixed.value ? `${rootWidth.value}px` : '',\n  }\n})\n\nconst affixStyle = computed<CSSProperties>(() => {\n  if (!fixed.value) return {}\n\n  const offset = props.offset ? addUnit(props.offset) : 0\n  return {\n    height: `${rootHeight.value}px`,\n    width: `${rootWidth.value}px`,\n    top: props.position === 'top' ? offset : '',\n    bottom: props.position === 'bottom' ? offset : '',\n    transform: transform.value ? `translateY(${transform.value}px)` : '',\n    zIndex: props.zIndex,\n  }\n})\n\nconst update = () => {\n  if (!scrollContainer.value) return\n\n  scrollTop.value =\n    scrollContainer.value instanceof Window\n      ? document.documentElement.scrollTop\n      : scrollContainer.value.scrollTop || 0\n\n  if (props.position === 'top') {\n    if (props.target) {\n      const difference =\n        targetRect.bottom.value - props.offset - rootHeight.value\n      fixed.value = props.offset > rootTop.value && targetRect.bottom.value > 0\n      transform.value = difference < 0 ? difference : 0\n    } else {\n      fixed.value = props.offset > rootTop.value\n    }\n  } else if (props.target) {\n    const difference =\n      windowHeight.value -\n      targetRect.top.value -\n      props.offset -\n      rootHeight.value\n    fixed.value =\n      windowHeight.value - props.offset < rootBottom.value &&\n      windowHeight.value > targetRect.top.value\n    transform.value = difference < 0 ? -difference : 0\n  } else {\n    fixed.value = windowHeight.value - props.offset < rootBottom.value\n  }\n}\n\nconst handleScroll = () => {\n  updateRoot()\n  emit('scroll', {\n    scrollTop: scrollTop.value,\n    fixed: fixed.value,\n  })\n}\n\nwatch(fixed, (val) => emit('change', val))\n\nonMounted(() => {\n  if (props.target) {\n    target.value =\n      document.querySelector<HTMLElement>(props.target) ?? undefined\n    if (!target.value)\n      throwError(COMPONENT_NAME, `Target is not existed: ${props.target}`)\n  } else {\n    target.value = document.documentElement\n  }\n  scrollContainer.value = getScrollContainer(root.value!, true)\n  updateRoot()\n})\n\nuseEventListener(scrollContainer, 'scroll', handleScroll)\nwatchEffect(update)\n\ndefineExpose({\n  /** @description update affix status */\n  update,\n  /** @description update rootRect info */\n  updateRoot,\n})\n</script>\n", "import { withInstall } from '@element-plus/utils'\n\nimport Affix from './src/affix.vue'\n\nexport const ElAffix = withInstall(Affix)\nexport default ElAffix\n\nexport * from './src/affix'\n"],
  "mappings": "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",
  "names": []
}
