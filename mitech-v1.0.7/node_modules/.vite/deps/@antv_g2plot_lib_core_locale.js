import {
  require_tslib
} from "./chunk-7FGIQIMC.js";
import {
  esm_exports,
  esm_exports3 as esm_exports2,
  init_esm,
  init_esm3 as init_esm2
} from "./chunk-FCE3RKM2.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-CLC6CPQL.js";

// node_modules/@antv/g2plot/lib/utils/invariant.js
var require_invariant = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/invariant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.log = exports.invariant = exports.LEVEL = void 0;
    var tslib_1 = require_tslib();
    var LEVEL;
    (function(LEVEL2) {
      LEVEL2["ERROR"] = "error";
      LEVEL2["WARN"] = "warn";
      LEVEL2["INFO"] = "log";
    })(LEVEL = exports.LEVEL || (exports.LEVEL = {}));
    var BRAND = "AntV/G2Plot";
    function getMessage(format) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var argIndex = 0;
      return "".concat(BRAND, ": ").concat(format.replace(/%s/g, function() {
        return "".concat(args[argIndex++]);
      }));
    }
    function invariant(condition, format) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (!condition) {
        var error = new Error(getMessage.apply(void 0, tslib_1.__spreadArray([format], args, false)));
        error.name = BRAND;
        throw error;
      }
    }
    exports.invariant = invariant;
    function log(level, condition, format) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      if (!condition) {
        console[level](getMessage.apply(void 0, tslib_1.__spreadArray([format], args, false)));
      }
    }
    exports.log = log;
  }
});

// node_modules/@antv/g2plot/lib/utils/pick.js
var require_pick = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/pick.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pick = void 0;
    function pick(obj, keys) {
      var r = {};
      if (obj !== null && typeof obj === "object") {
        keys.forEach(function(key) {
          var v = obj[key];
          if (v !== void 0) {
            r[key] = v;
          }
        });
      }
      return r;
    }
    exports.pick = pick;
  }
});

// node_modules/@antv/g2plot/lib/utils/data.js
var require_data = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.processIllegalData = exports.transformDataToNodeLinkData = exports.adjustYMetaByZero = void 0;
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    var invariant_1 = require_invariant();
    var pick_1 = require_pick();
    function adjustYMetaByZero(data, field) {
      if (!data)
        return {};
      var numberData = data.filter(function(datum) {
        var v = (0, util_1.get)(datum, [field]);
        return (0, util_1.isNumber)(v) && !isNaN(v);
      });
      var gtZero = numberData.every(function(datum) {
        return (0, util_1.get)(datum, [field]) >= 0;
      });
      var ltZero = numberData.every(function(datum) {
        return (0, util_1.get)(datum, [field]) <= 0;
      });
      if (gtZero) {
        return { min: 0 };
      }
      if (ltZero) {
        return { max: 0 };
      }
      return {};
    }
    exports.adjustYMetaByZero = adjustYMetaByZero;
    function transformDataToNodeLinkData(data, sourceField, targetField, weightField, rawFields) {
      if (rawFields === void 0) {
        rawFields = [];
      }
      if (!Array.isArray(data)) {
        return {
          nodes: [],
          links: []
        };
      }
      var links = [];
      var nodesMap = {};
      var nodesIndex = -1;
      data.forEach(function(datum) {
        var source = datum[sourceField];
        var target = datum[targetField];
        var weight = datum[weightField];
        var rawData = (0, pick_1.pick)(datum, rawFields);
        if (!nodesMap[source]) {
          nodesMap[source] = tslib_1.__assign({ id: ++nodesIndex, name: source }, rawData);
        }
        if (!nodesMap[target]) {
          nodesMap[target] = tslib_1.__assign({ id: ++nodesIndex, name: target }, rawData);
        }
        links.push(tslib_1.__assign({
          source: nodesMap[source].id,
          target: nodesMap[target].id,
          // sourceName: source,
          // targetName: target,
          value: weight
        }, rawData));
      });
      return {
        // 需要按照 id 的顺序
        nodes: Object.values(nodesMap).sort(function(a, b) {
          return a.id - b.id;
        }),
        links
      };
    }
    exports.transformDataToNodeLinkData = transformDataToNodeLinkData;
    function processIllegalData(data, field) {
      var processData = (0, util_1.filter)(data, function(d) {
        var v = d[field];
        return v === null || typeof v === "number" && !isNaN(v);
      });
      (0, invariant_1.log)(invariant_1.LEVEL.WARN, processData.length === data.length, "illegal data existed in chart data.");
      return processData;
    }
    exports.processIllegalData = processIllegalData;
  }
});

// node_modules/@antv/g2plot/lib/utils/deep-assign.js
var require_deep_assign = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/deep-assign.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepAssign = void 0;
    var MAX_MIX_LEVEL = 5;
    var toString = {}.toString;
    var isType = function(value, type) {
      return toString.call(value) === "[object " + type + "]";
    };
    var isArray = function(value) {
      return isType(value, "Array");
    };
    var isObjectLike = function(value) {
      return typeof value === "object" && value !== null;
    };
    var isPlainObject = function(value) {
      if (!isObjectLike(value) || !isType(value, "Object")) {
        return false;
      }
      var proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    };
    var deep = function(dist, src, level, maxLevel) {
      level = level || 0;
      maxLevel = maxLevel || MAX_MIX_LEVEL;
      for (var key in src) {
        if (Object.prototype.hasOwnProperty.call(src, key)) {
          var value = src[key];
          if (!value) {
            dist[key] = value;
          } else {
            if (isPlainObject(value)) {
              if (!isPlainObject(dist[key])) {
                dist[key] = {};
              }
              if (level < maxLevel) {
                deep(dist[key], value, level + 1, maxLevel);
              } else {
                dist[key] = src[key];
              }
            } else if (isArray(value)) {
              dist[key] = [];
              dist[key] = dist[key].concat(value);
            } else {
              dist[key] = value;
            }
          }
        }
      }
    };
    var deepAssign = function(rst) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      for (var i = 0; i < args.length; i += 1) {
        deep(rst, args[i]);
      }
      return rst;
    };
    exports.deepAssign = deepAssign;
  }
});

// node_modules/@antv/g2plot/lib/utils/dom.js
var require_dom = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/dom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerSize = void 0;
    function getContainerSize(ele) {
      if (!ele) {
        return { width: 0, height: 0 };
      }
      var style = getComputedStyle(ele);
      return {
        width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
        height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
      };
    }
    exports.getContainerSize = getContainerSize;
  }
});

// node_modules/@antv/g2plot/lib/utils/flow.js
var require_flow = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/flow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flow = void 0;
    function flow() {
      var flows = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        flows[_i] = arguments[_i];
      }
      return function(param) {
        return flows.reduce(function(result, f) {
          return f(result);
        }, param);
      };
    }
    exports.flow = flow;
  }
});

// node_modules/@antv/g2plot/lib/utils/geometry.js
var require_geometry = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/geometry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAllGeometriesRecursively = exports.getAllElementsRecursively = exports.getAllElements = exports.findGeometry = void 0;
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    function findGeometry(view, type) {
      return view.geometries.find(function(g) {
        return g.type === type;
      });
    }
    exports.findGeometry = findGeometry;
    function getAllElements(view) {
      return (0, util_1.reduce)(view.geometries, function(r, geometry) {
        return r.concat(geometry.elements);
      }, []);
    }
    exports.getAllElements = getAllElements;
    function getAllElementsRecursively(view) {
      if ((0, util_1.get)(view, ["views", "length"], 0) <= 0) {
        return getAllElements(view);
      }
      return (0, util_1.reduce)(view.views, function(ele, subView) {
        return ele.concat(getAllElementsRecursively(subView));
      }, getAllElements(view));
    }
    exports.getAllElementsRecursively = getAllElementsRecursively;
    function getAllGeometriesRecursively(view) {
      if ((0, util_1.get)(view, ["views", "length"], 0) <= 0) {
        return view.geometries;
      }
      return (0, util_1.reduce)(view.views, function(ele, subView) {
        return ele.concat(subView.geometries);
      }, view.geometries);
    }
    exports.getAllGeometriesRecursively = getAllGeometriesRecursively;
  }
});

// node_modules/@antv/g2plot/lib/utils/kebab-case.js
var require_kebab_case = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/kebab-case.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kebabCase = void 0;
    function kebabCase(word) {
      if (!word) {
        return word;
      }
      var result = word.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g);
      return result.map(function(s) {
        return s.toLowerCase();
      }).join("-");
    }
    exports.kebabCase = kebabCase;
  }
});

// node_modules/@antv/g2plot/lib/utils/label.js
var require_label = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/label.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformLabel = void 0;
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    function transformLabel(labelOptions) {
      if (!(0, util_1.isType)(labelOptions, "Object")) {
        return labelOptions;
      }
      var label = tslib_1.__assign({}, labelOptions);
      if (label.formatter && !label.content) {
        label.content = label.formatter;
      }
      return label;
    }
    exports.transformLabel = transformLabel;
  }
});

// node_modules/@antv/g2plot/lib/utils/context.js
var require_context = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCanvasContext = void 0;
    var ctx;
    function getCanvasContext() {
      if (!ctx) {
        ctx = document.createElement("canvas").getContext("2d");
      }
      return ctx;
    }
    exports.getCanvasContext = getCanvasContext;
  }
});

// node_modules/@antv/g2plot/lib/utils/measure-text.js
var require_measure_text = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/measure-text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.measureTextWidth = void 0;
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    var context_1 = require_context();
    exports.measureTextWidth = (0, util_1.memoize)(function(text, font) {
      if (font === void 0) {
        font = {};
      }
      var fontSize = font.fontSize, _a = font.fontFamily, fontFamily = _a === void 0 ? "sans-serif" : _a, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
      var ctx = (0, context_1.getCanvasContext)();
      ctx.font = [fontStyle, fontWeight, fontVariant, "".concat(fontSize, "px"), fontFamily].join(" ");
      var metrics = ctx.measureText((0, util_1.isString)(text) ? text : "");
      return metrics.width;
    }, function(text, font) {
      if (font === void 0) {
        font = {};
      }
      return tslib_1.__spreadArray([text], (0, util_1.values)(font), true).join("");
    });
  }
});

// node_modules/@antv/g2plot/lib/utils/number.js
var require_number = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBetween = exports.isRealNumber = void 0;
    function isRealNumber(v) {
      return typeof v === "number" && !isNaN(v);
    }
    exports.isRealNumber = isRealNumber;
    function isBetween(value, start, end) {
      var min = Math.min(start, end);
      var max = Math.max(start, end);
      return value >= min && value <= max;
    }
    exports.isBetween = isBetween;
  }
});

// node_modules/@antv/g2plot/lib/utils/padding.js
var require_padding = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/padding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveAllPadding = exports.getAdjustAppendPadding = exports.normalPadding = void 0;
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    function normalPadding(padding) {
      if ((0, util_1.isNumber)(padding)) {
        return [padding, padding, padding, padding];
      }
      if ((0, util_1.isArray)(padding)) {
        var length_1 = padding.length;
        if (length_1 === 1) {
          return [padding[0], padding[0], padding[0], padding[0]];
        }
        if (length_1 === 2) {
          return [padding[0], padding[1], padding[0], padding[1]];
        }
        if (length_1 === 3) {
          return [padding[0], padding[1], padding[2], padding[1]];
        }
        if (length_1 === 4) {
          return padding;
        }
      }
      return [0, 0, 0, 0];
    }
    exports.normalPadding = normalPadding;
    function getAdjustAppendPadding(padding, position, append) {
      if (position === void 0) {
        position = "bottom";
      }
      if (append === void 0) {
        append = 25;
      }
      var currentAppendPadding = normalPadding(padding);
      var PADDING = [
        position.startsWith("top") ? append : 0,
        position.startsWith("right") ? append : 0,
        position.startsWith("bottom") ? append : 0,
        position.startsWith("left") ? append : 0
      ];
      return [
        currentAppendPadding[0] + PADDING[0],
        currentAppendPadding[1] + PADDING[1],
        currentAppendPadding[2] + PADDING[2],
        currentAppendPadding[3] + PADDING[3]
      ];
    }
    exports.getAdjustAppendPadding = getAdjustAppendPadding;
    function resolveAllPadding(paddings) {
      var normalPaddings = paddings.map(function(item) {
        return normalPadding(item);
      });
      var finalPadding = [0, 0, 0, 0];
      if (normalPaddings.length > 0) {
        finalPadding = finalPadding.map(function(item, index) {
          normalPaddings.forEach(function(d, i) {
            item += normalPaddings[i][index];
          });
          return item;
        });
      }
      return finalPadding;
    }
    exports.resolveAllPadding = resolveAllPadding;
  }
});

// node_modules/@antv/g2plot/lib/utils/path.js
var require_path = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSplinePath = exports.catmullRom2bezier = exports.smoothBezier = exports.points2Path = void 0;
    var matrix_util_1 = (init_esm2(), __toCommonJS(esm_exports2));
    function points2Path(points, isInCircle) {
      var path = [];
      if (points.length) {
        path.push(["M", points[0].x, points[0].y]);
        for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
          var item = points[i];
          path.push(["L", item.x, item.y]);
        }
        if (isInCircle) {
          path.push(["Z"]);
        }
      }
      return path;
    }
    exports.points2Path = points2Path;
    var smoothBezier = function(points, smooth, isLoop, constraint) {
      var cps = [];
      var prevPoint;
      var nextPoint;
      var hasConstraint = !!constraint;
      var min;
      var max;
      if (hasConstraint) {
        min = [Infinity, Infinity];
        max = [-Infinity, -Infinity];
        for (var i = 0, l = points.length; i < l; i++) {
          var point = points[i];
          min = matrix_util_1.vec2.min([0, 0], min, point);
          max = matrix_util_1.vec2.max([0, 0], max, point);
        }
        min = matrix_util_1.vec2.min([0, 0], min, constraint[0]);
        max = matrix_util_1.vec2.max([0, 0], max, constraint[1]);
      }
      for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (isLoop) {
          prevPoint = points[i ? i - 1 : len - 1];
          nextPoint = points[(i + 1) % len];
        } else {
          if (i === 0 || i === len - 1) {
            cps.push(point);
            continue;
          } else {
            prevPoint = points[i - 1];
            nextPoint = points[i + 1];
          }
        }
        var v = [0, 0];
        v = matrix_util_1.vec2.sub(v, nextPoint, prevPoint);
        v = matrix_util_1.vec2.scale(v, v, smooth);
        var d0 = matrix_util_1.vec2.distance(point, prevPoint);
        var d1 = matrix_util_1.vec2.distance(point, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
          d0 /= sum;
          d1 /= sum;
        }
        var v1 = matrix_util_1.vec2.scale([0, 0], v, -d0);
        var v2 = matrix_util_1.vec2.scale([0, 0], v, d1);
        var cp0 = matrix_util_1.vec2.add([0, 0], point, v1);
        var cp1 = matrix_util_1.vec2.add([0, 0], point, v2);
        if (hasConstraint) {
          cp0 = matrix_util_1.vec2.max([0, 0], cp0, min);
          cp0 = matrix_util_1.vec2.min([0, 0], cp0, max);
          cp1 = matrix_util_1.vec2.max([0, 0], cp1, min);
          cp1 = matrix_util_1.vec2.min([0, 0], cp1, max);
        }
        cps.push(cp0);
        cps.push(cp1);
      }
      if (isLoop) {
        cps.push(cps.shift());
      }
      return cps;
    };
    exports.smoothBezier = smoothBezier;
    function catmullRom2bezier(crp, z, constraint) {
      var isLoop = !!z;
      var pointList = [];
      for (var i = 0, l = crp.length; i < l; i += 2) {
        pointList.push([crp[i], crp[i + 1]]);
      }
      var controlPointList = (0, exports.smoothBezier)(pointList, 0.4, isLoop, constraint);
      var len = pointList.length;
      var d1 = [];
      var cp1;
      var cp2;
      var p;
      for (var i = 0; i < len - 1; i++) {
        cp1 = controlPointList[i * 2];
        cp2 = controlPointList[i * 2 + 1];
        p = pointList[i + 1];
        d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
      }
      if (isLoop) {
        cp1 = controlPointList[len];
        cp2 = controlPointList[len + 1];
        p = pointList[0];
        d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
      }
      return d1;
    }
    exports.catmullRom2bezier = catmullRom2bezier;
    function getSplinePath(points, isInCircle, constaint) {
      var data = [];
      var first = points[0];
      var prePoint = null;
      if (points.length <= 2) {
        return points2Path(points, isInCircle);
      }
      for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
          data.push(point.x);
          data.push(point.y);
          prePoint = point;
        }
      }
      var constraint = constaint || [
        // 范围
        [0, 0],
        [1, 1]
      ];
      var splinePath = catmullRom2bezier(data, isInCircle, constraint);
      splinePath.unshift(["M", first.x, first.y]);
      return splinePath;
    }
    exports.getSplinePath = getSplinePath;
  }
});

// node_modules/@antv/g2plot/lib/utils/statistic.js
var require_statistic = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/statistic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.renderGaugeStatistic = exports.renderStatistic = exports.setStatisticContainerStyle = exports.adapteStyle = void 0;
    var tslib_1 = require_tslib();
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    var kebab_case_1 = require_kebab_case();
    var pick_1 = require_pick();
    function adapteStyle(style) {
      var styleObject = {
        overflow: "hidden",
        "white-space": "nowrap",
        "text-overflow": "ellipsis",
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      };
      var shapeStyleKeys = [
        "stroke",
        "lineWidth",
        "shadowColor",
        "strokeOpacity",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "fill"
      ];
      if ((0, util_1.get)(style, "fill")) {
        styleObject["color"] = style["fill"];
      }
      var _a = (0, pick_1.pick)(style, shapeStyleKeys), shadowColor = _a.shadowColor, _b = _a.shadowBlur, shadowBlur = _b === void 0 ? 0 : _b, _c = _a.shadowOffsetX, shadowOffsetX = _c === void 0 ? 0 : _c, _d = _a.shadowOffsetY, shadowOffsetY = _d === void 0 ? 0 : _d;
      styleObject["text-shadow"] = "".concat([shadowColor, "".concat(shadowOffsetX, "px"), "".concat(shadowOffsetY, "px"), "".concat(shadowBlur, "px")].join(" "));
      var _e = (0, pick_1.pick)(style, shapeStyleKeys), stroke = _e.stroke, _f = _e.lineWidth, lineWidth = _f === void 0 ? 0 : _f;
      styleObject["-webkit-text-stroke"] = "".concat(["".concat(lineWidth, "px"), stroke].join(" "));
      (0, util_1.each)(style, function(v, k) {
        if (["fontSize"].includes(k) && (0, util_1.isNumber)(v)) {
          styleObject[(0, kebab_case_1.kebabCase)(k)] = "".concat(v, "px");
        } else if (k && !shapeStyleKeys.includes(k)) {
          styleObject[(0, kebab_case_1.kebabCase)(k)] = "".concat(v);
        }
      });
      return styleObject;
    }
    exports.adapteStyle = adapteStyle;
    function setStatisticContainerStyle(container, style) {
      container.style["pointer-events"] = "none";
      (0, util_1.each)(style, function(v, k) {
        if (k && v) {
          container.style[k] = v;
        }
      });
    }
    exports.setStatisticContainerStyle = setStatisticContainerStyle;
    var renderStatistic = function(chart, options, datum) {
      var statistic = options.statistic, plotType = options.plotType;
      var titleOpt = statistic.title, contentOpt = statistic.content;
      [titleOpt, contentOpt].forEach(function(option, idx) {
        if (!option) {
          return;
        }
        var transform = "";
        if (idx === 0) {
          transform = contentOpt ? "translate(-50%, -100%)" : "translate(-50%, -50%)";
        } else {
          transform = titleOpt ? "translate(-50%, 0)" : "translate(-50%, -50%)";
        }
        var style = (0, util_1.isFunction)(option.style) ? option.style(datum) : option.style;
        chart.annotation().html(tslib_1.__assign(
          {
            position: ["50%", "50%"],
            html: function(container, view) {
              var coordinate = view.getCoordinate();
              var containerW = 0;
              if (plotType === "pie" || plotType === "ring-progress") {
                containerW = coordinate.getRadius() * coordinate.innerRadius * 2;
              } else if (plotType === "liquid") {
                var liquidShape = (0, util_1.get)(view.geometries, [0, "elements", 0, "shape"]);
                if (liquidShape) {
                  var path = liquidShape.find(function(t) {
                    return t.get("name") === "wrap";
                  });
                  var width = path.getCanvasBBox().width;
                  containerW = width;
                }
              } else if (!containerW) {
                containerW = coordinate.getWidth();
              }
              setStatisticContainerStyle(container, tslib_1.__assign({ width: "".concat(containerW, "px"), transform }, adapteStyle(style)));
              var filteredData = view.getData();
              if (option.customHtml) {
                return option.customHtml(container, view, datum, filteredData);
              }
              var text = option.content;
              if (option.formatter) {
                text = option.formatter(datum, filteredData);
              }
              return text ? (0, util_1.isString)(text) ? text : "".concat(text) : "<div></div>";
            },
            // @ts-ignore
            key: "".concat(idx === 0 ? "top" : "bottom", "-statistic")
          },
          (0, pick_1.pick)(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])
          /** 透传配置 */
        ));
      });
    };
    exports.renderStatistic = renderStatistic;
    var renderGaugeStatistic = function(chart, options, datum) {
      var statistic = options.statistic;
      var titleOpt = statistic.title, contentOpt = statistic.content;
      [titleOpt, contentOpt].forEach(function(option) {
        if (!option) {
          return;
        }
        var style = (0, util_1.isFunction)(option.style) ? option.style(datum) : option.style;
        chart.annotation().html(tslib_1.__assign(
          { position: ["50%", "100%"], html: function(container, view) {
            var coordinate = view.getCoordinate();
            var polarCoord = view.views[0].getCoordinate();
            var polarCenter = polarCoord.getCenter();
            var polarRadius = polarCoord.getRadius();
            var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
            var offsetY = polarCenter.y + polarMaxY - coordinate.y.start - parseFloat((0, util_1.get)(style, "fontSize", 0));
            var containerWidth = coordinate.getRadius() * coordinate.innerRadius * 2;
            setStatisticContainerStyle(container, tslib_1.__assign({ width: "".concat(containerWidth, "px"), transform: "translate(-50%, ".concat(offsetY, "px)") }, adapteStyle(style)));
            var filteredData = view.getData();
            if (option.customHtml) {
              return option.customHtml(container, view, datum, filteredData);
            }
            var text = option.content;
            if (option.formatter) {
              text = option.formatter(datum, filteredData);
            }
            return text ? (0, util_1.isString)(text) ? text : "".concat(text) : "<div></div>";
          } },
          (0, pick_1.pick)(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])
          /** 透传配置 */
        ));
      });
    };
    exports.renderGaugeStatistic = renderGaugeStatistic;
  }
});

// node_modules/@antv/g2plot/lib/utils/template.js
var require_template = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/template.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.template = void 0;
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    function template(source, data) {
      if (!data) {
        return source;
      }
      return (0, util_1.reduce)(
        // @ts-ignore
        data,
        function(r, v, k) {
          return r.replace(new RegExp("{\\s*".concat(k, "\\s*}"), "g"), v);
        },
        source
      );
    }
    exports.template = template;
  }
});

// node_modules/@antv/g2plot/lib/utils/view.js
var require_view = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/view.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addViewAnimation = exports.getSiblingViews = exports.getViews = exports.findViewById = void 0;
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    function findViewById(chart, id) {
      return chart.views.find(function(view) {
        return view.id === id;
      });
    }
    exports.findViewById = findViewById;
    function getViews(view) {
      var parent = view.parent;
      return parent ? parent.views : [];
    }
    exports.getViews = getViews;
    function getSiblingViews(view) {
      return getViews(view).filter(function(sub) {
        return sub !== view;
      });
    }
    exports.getSiblingViews = getSiblingViews;
    function addViewAnimation(view, animation, geometries) {
      if (geometries === void 0) {
        geometries = view.geometries;
      }
      if (typeof animation === "boolean") {
        view.animate(animation);
      } else {
        view.animate(true);
      }
      (0, util_1.each)(geometries, function(g) {
        var animationCfg;
        if ((0, util_1.isFunction)(animation)) {
          animationCfg = animation(g.type || g.shapeType, g) || true;
        } else {
          animationCfg = animation;
        }
        g.animate(animationCfg);
      });
    }
    exports.addViewAnimation = addViewAnimation;
  }
});

// node_modules/@antv/g2plot/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/@antv/g2plot/lib/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getViews = exports.getSiblingViews = exports.findViewById = exports.addViewAnimation = exports.template = exports.renderStatistic = exports.renderGaugeStatistic = exports.pick = exports.getSplinePath = exports.isRealNumber = exports.isBetween = exports.measureTextWidth = exports.transformLabel = exports.kebabCase = exports.log = exports.LEVEL = exports.invariant = exports.flow = exports.getContainerSize = exports.deepAssign = void 0;
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_data(), exports);
    var deep_assign_1 = require_deep_assign();
    Object.defineProperty(exports, "deepAssign", { enumerable: true, get: function() {
      return deep_assign_1.deepAssign;
    } });
    var dom_1 = require_dom();
    Object.defineProperty(exports, "getContainerSize", { enumerable: true, get: function() {
      return dom_1.getContainerSize;
    } });
    var flow_1 = require_flow();
    Object.defineProperty(exports, "flow", { enumerable: true, get: function() {
      return flow_1.flow;
    } });
    tslib_1.__exportStar(require_geometry(), exports);
    var invariant_1 = require_invariant();
    Object.defineProperty(exports, "invariant", { enumerable: true, get: function() {
      return invariant_1.invariant;
    } });
    Object.defineProperty(exports, "LEVEL", { enumerable: true, get: function() {
      return invariant_1.LEVEL;
    } });
    Object.defineProperty(exports, "log", { enumerable: true, get: function() {
      return invariant_1.log;
    } });
    var kebab_case_1 = require_kebab_case();
    Object.defineProperty(exports, "kebabCase", { enumerable: true, get: function() {
      return kebab_case_1.kebabCase;
    } });
    var label_1 = require_label();
    Object.defineProperty(exports, "transformLabel", { enumerable: true, get: function() {
      return label_1.transformLabel;
    } });
    var measure_text_1 = require_measure_text();
    Object.defineProperty(exports, "measureTextWidth", { enumerable: true, get: function() {
      return measure_text_1.measureTextWidth;
    } });
    var number_1 = require_number();
    Object.defineProperty(exports, "isBetween", { enumerable: true, get: function() {
      return number_1.isBetween;
    } });
    Object.defineProperty(exports, "isRealNumber", { enumerable: true, get: function() {
      return number_1.isRealNumber;
    } });
    tslib_1.__exportStar(require_padding(), exports);
    var path_1 = require_path();
    Object.defineProperty(exports, "getSplinePath", { enumerable: true, get: function() {
      return path_1.getSplinePath;
    } });
    var pick_1 = require_pick();
    Object.defineProperty(exports, "pick", { enumerable: true, get: function() {
      return pick_1.pick;
    } });
    var statistic_1 = require_statistic();
    Object.defineProperty(exports, "renderGaugeStatistic", { enumerable: true, get: function() {
      return statistic_1.renderGaugeStatistic;
    } });
    Object.defineProperty(exports, "renderStatistic", { enumerable: true, get: function() {
      return statistic_1.renderStatistic;
    } });
    var template_1 = require_template();
    Object.defineProperty(exports, "template", { enumerable: true, get: function() {
      return template_1.template;
    } });
    var view_1 = require_view();
    Object.defineProperty(exports, "addViewAnimation", { enumerable: true, get: function() {
      return view_1.addViewAnimation;
    } });
    Object.defineProperty(exports, "findViewById", { enumerable: true, get: function() {
      return view_1.findViewById;
    } });
    Object.defineProperty(exports, "getSiblingViews", { enumerable: true, get: function() {
      return view_1.getSiblingViews;
    } });
    Object.defineProperty(exports, "getViews", { enumerable: true, get: function() {
      return view_1.getViews;
    } });
  }
});

// node_modules/@antv/g2plot/lib/core/global.js
var require_global = __commonJS({
  "node_modules/@antv/g2plot/lib/core/global.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setGlobal = exports.GLOBAL = void 0;
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    exports.GLOBAL = {
      /** 全局语言 */
      locale: "en-US"
    };
    function setGlobal(datum) {
      (0, util_1.each)(datum, function(v, k) {
        return exports.GLOBAL[k] = v;
      });
    }
    exports.setGlobal = setGlobal;
  }
});

// node_modules/@antv/g2plot/lib/core/locale.js
var require_locale = __commonJS({
  "node_modules/@antv/g2plot/lib/core/locale.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocale = exports.registerLocale = void 0;
    var util_1 = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils();
    var global_1 = require_global();
    var LocaleMap = {};
    function registerLocale(locale, localeObj) {
      LocaleMap[locale] = localeObj;
    }
    exports.registerLocale = registerLocale;
    function getLocale(locale) {
      return {
        get: function(key, obj) {
          return (0, utils_1.template)((0, util_1.get)(LocaleMap[locale], key) || (0, util_1.get)(LocaleMap[global_1.GLOBAL.locale], key) || (0, util_1.get)(LocaleMap["en-US"], key) || key, obj);
        }
      };
    }
    exports.getLocale = getLocale;
  }
});
export default require_locale();
//# sourceMappingURL=@antv_g2plot_lib_core_locale.js.map
