{
  "version": 3,
  "sources": ["../../../packages/utils/vue/install.ts", "../../../packages/constants/aria.ts", "../../../packages/constants/date.ts", "../../../packages/constants/event.ts", "../../../packages/constants/key.ts", "../../../packages/constants/size.ts", "../../../packages/utils/dom/aria.ts", "../../../packages/utils/dom/event.ts", "../../@vueuse/shared/index.mjs", "../../@vueuse/core/index.mjs", "../../../packages/utils/browser.ts", "../../../packages/utils/dom/position.ts", "../../../packages/utils/types.ts", "../../../packages/utils/strings.ts", "../../../packages/utils/objects.ts", "../../../packages/utils/error.ts", "../../../packages/utils/dom/style.ts", "../../../packages/utils/dom/scroll.ts", "../../../packages/utils/vue/global-node.ts", "../../../packages/utils/vue/props/runtime.ts", "../../../packages/utils/vue/icon.ts", "../../../packages/utils/vue/refs.ts", "../../../packages/utils/vue/size.ts", "../../../packages/utils/vue/validator.ts", "../../../packages/utils/vue/vnode.ts", "../../../packages/utils/arrays.ts", "../../../packages/utils/i18n.ts", "../../../packages/utils/raf.ts", "../../../packages/utils/rand.ts", "../../../packages/utils/typescript.ts", "../../../packages/hooks/use-attrs/index.ts", "../../../packages/hooks/use-deprecated/index.ts", "../../../packages/hooks/use-draggable/index.ts", "../../../packages/hooks/use-focus/index.ts", "../../../packages/locale/lang/en.ts", "../../../packages/hooks/use-locale/index.ts", "../../../packages/hooks/use-namespace/index.ts", "../../../packages/hooks/use-lockscreen/index.ts", "../../../packages/hooks/use-modal/index.ts", "../../../packages/hooks/use-model-toggle/index.ts", "../../../packages/hooks/use-prevent-global/index.ts", "../../../packages/hooks/use-prop/index.ts", "../../../packages/hooks/use-popper/index.ts", "../../../packages/hooks/use-same-target/index.ts", "../../../packages/hooks/use-teleport/index.ts", "../../../packages/hooks/use-throttle-render/index.ts", "../../../packages/hooks/use-timeout/index.ts", "../../../packages/hooks/use-transition-fallthrough/index.ts", "../../../packages/hooks/use-id/index.ts", "../../../packages/hooks/use-escape-keydown/index.ts", "../../../packages/hooks/use-popper-container/index.ts", "../../../packages/hooks/use-intermediate-render/index.ts", "../../../packages/hooks/use-delayed-toggle/index.ts", "../../../packages/hooks/use-forward-ref/index.ts", "../../../packages/hooks/use-z-index/index.ts", "../../@floating-ui/utils/dist/floating-ui.utils.esm.js", "../../@floating-ui/core/dist/floating-ui.core.esm.js", "../../@floating-ui/utils/dom/dist/floating-ui.utils.dom.esm.js", "../../@floating-ui/dom/dist/floating-ui.dom.esm.js", "../../../packages/hooks/use-floating/index.ts", "../../../packages/hooks/use-cursor/index.ts", "../../../packages/hooks/use-ordered-children/index.ts", "../../../packages/hooks/use-size/index.ts", "../../../packages/hooks/use-focus-controller/index.ts", "../../../internal/build/plugin-vue:export-helper"],
  "sourcesContent": ["import { NOOP } from '@vue/shared'\n\nimport type { App, Directive } from 'vue'\nimport type { SFCInstallWithContext, SFCWithInstall } from './typescript'\n\nexport const withInstall = <T, E extends Record<string, any>>(\n  main: T,\n  extra?: E\n) => {\n  ;(main as SFCWithInstall<T>).install = (app): void => {\n    for (const comp of [main, ...Object.values(extra ?? {})]) {\n      app.component(comp.name, comp)\n    }\n  }\n\n  if (extra) {\n    for (const [key, comp] of Object.entries(extra)) {\n      ;(main as any)[key] = comp\n    }\n  }\n  return main as SFCWithInstall<T> & E\n}\n\nexport const withInstallFunction = <T>(fn: T, name: string) => {\n  ;(fn as SFCWithInstall<T>).install = (app: App) => {\n    ;(fn as SFCInstallWithContext<T>)._context = app._context\n    app.config.globalProperties[name] = fn\n  }\n\n  return fn as SFCInstallWithContext<T>\n}\n\nexport const withInstallDirective = <T extends Directive>(\n  directive: T,\n  name: string\n) => {\n  ;(directive as SFCWithInstall<T>).install = (app: App): void => {\n    app.directive(name, directive)\n  }\n\n  return directive as SFCWithInstall<T>\n}\n\nexport const withNoopInstall = <T>(component: T) => {\n  ;(component as SFCWithInstall<T>).install = NOOP\n\n  return component as SFCWithInstall<T>\n}\n", "export const EVENT_CODE = {\n  tab: 'Tab',\n  enter: 'Enter',\n  space: 'Space',\n  left: 'ArrowLeft', // 37\n  up: 'ArrowUp', // 38\n  right: 'ArrowRight', // 39\n  down: 'ArrowDown', // 40\n  esc: 'Escape',\n  delete: 'Delete',\n  backspace: 'Backspace',\n  numpadEnter: 'NumpadEnter',\n  pageUp: 'PageUp',\n  pageDown: 'PageDown',\n  home: 'Home',\n  end: 'End',\n}\n", "export const datePickTypes = [\n  'year',\n  'month',\n  'date',\n  'dates',\n  'week',\n  'datetime',\n  'datetimerange',\n  'daterange',\n  'monthrange',\n] as const\n\nexport const WEEK_DAYS = [\n  'sun',\n  'mon',\n  'tue',\n  'wed',\n  'thu',\n  'fri',\n  'sat',\n] as const\n\nexport type DatePickType = typeof datePickTypes[number]\n", "export const UPDATE_MODEL_EVENT = 'update:modelValue'\nexport const CHANGE_EVENT = 'change'\nexport const INPUT_EVENT = 'input'\n", "export const INSTALLED_KEY = Symbol('INSTALLED_KEY')\n", "export const componentSizes = ['', 'default', 'small', 'large'] as const\n\nexport type ComponentSize = typeof componentSizes[number]\n\nexport const componentSizeMap = {\n  large: 40,\n  default: 32,\n  small: 24,\n} as const\n", "const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`\n\n/**\n * Determine if the testing element is visible on screen no matter if its on the viewport or not\n */\nexport const isVisible = (element: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return true\n  const computed = getComputedStyle(element)\n  // element.offsetParent won't work on fix positioned\n  // WARNING: potential issue here, going to need some expert advices on this issue\n  return computed.position === 'fixed' ? false : element.offsetParent !== null\n}\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  return Array.from(\n    element.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENT_SELECTORS)\n  ).filter((item: HTMLElement) => isFocusable(item) && isVisible(item))\n}\n\n/**\n * @desc Determine if target element is focusable\n * @param element {HTMLElement}\n * @returns {Boolean} true if it is focusable\n */\nexport const isFocusable = (element: HTMLElement): boolean => {\n  if (\n    element.tabIndex > 0 ||\n    (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)\n  ) {\n    return true\n  }\n  // HTMLButtonElement has disabled\n  if ((element as HTMLButtonElement).disabled) {\n    return false\n  }\n\n  switch (element.nodeName) {\n    case 'A': {\n      // casting current element to Specific HTMLElement in order to be more type precise\n      return (\n        !!(element as HTMLAnchorElement).href &&\n        (element as HTMLAnchorElement).rel !== 'ignore'\n      )\n    }\n    case 'INPUT': {\n      return !(\n        (element as HTMLInputElement).type === 'hidden' ||\n        (element as HTMLInputElement).type === 'file'\n      )\n    }\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA': {\n      return true\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * @desc Set Attempt to set focus on the current node.\n * @param element\n *          The node to attempt to focus on.\n * @returns\n *  true if element is focused.\n */\nexport const attemptFocus = (element: HTMLElement): boolean => {\n  if (!isFocusable(element)) {\n    return false\n  }\n  // Remove the old try catch block since there will be no error to be thrown\n  element.focus?.()\n  return document.activeElement === element\n}\n\n/**\n * Trigger an event\n * mouseenter, mouseleave, mouseover, keyup, change, click, etc.\n * @param  {HTMLElement} elm\n * @param  {String} name\n * @param  {*} opts\n */\nexport const triggerEvent = function (\n  elm: HTMLElement,\n  name: string,\n  ...opts: Array<boolean>\n): HTMLElement {\n  let eventName: string\n\n  if (name.includes('mouse') || name.includes('click')) {\n    eventName = 'MouseEvents'\n  } else if (name.includes('key')) {\n    eventName = 'KeyboardEvent'\n  } else {\n    eventName = 'HTMLEvents'\n  }\n  const evt = document.createEvent(eventName)\n\n  evt.initEvent(name, ...opts)\n  elm.dispatchEvent(evt)\n  return elm\n}\n\nexport const isLeaf = (el: HTMLElement) => !el.getAttribute('aria-owns')\n\nexport const getSibling = (\n  el: HTMLElement,\n  distance: number,\n  elClass: string\n) => {\n  const { parentNode } = el\n  if (!parentNode) return null\n  const siblings = parentNode.querySelectorAll(elClass)\n  const index = Array.prototype.indexOf.call(siblings, el)\n  return siblings[index + distance] || null\n}\n\nexport const focusNode = (el: HTMLElement) => {\n  if (!el) return\n  el.focus()\n  !isLeaf(el) && el.click()\n}\n", "export const composeEventHandlers = <E>(\n  theirsHandler?: (event: E) => boolean | void,\n  oursHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) => {\n  const handleEvent = (event: E) => {\n    const shouldPrevent = theirsHandler?.(event)\n\n    if (checkForDefaultPrevented === false || !shouldPrevent) {\n      return oursHandler?.(event)\n    }\n  }\n  return handleEvent\n}\n\ntype WhenMouseHandler = (e: PointerEvent) => any\nexport const whenMouse = (handler: WhenMouseHandler): WhenMouseHandler => {\n  return (e: PointerEvent) =>\n    e.pointerType === 'mouse' ? handler(e) : undefined\n}\n", "import { shallowRef, watchEffect, readonly, unref, ref, isVue3, version, watch, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject, isRef, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\r\n\r\nvar __defProp$9 = Object.defineProperty;\r\nvar __defProps$6 = Object.defineProperties;\r\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$9 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$b.call(b, prop))\r\n      __defNormalProp$9(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$b)\r\n    for (var prop of __getOwnPropSymbols$b(b)) {\r\n      if (__propIsEnum$b.call(b, prop))\r\n        __defNormalProp$9(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\r\nfunction computedEager(fn, options) {\r\n  var _a;\r\n  const result = shallowRef();\r\n  watchEffect(() => {\r\n    result.value = fn();\r\n  }, __spreadProps$6(__spreadValues$9({}, options), {\r\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\r\n  }));\r\n  return readonly(result);\r\n}\r\n\r\nvar _a;\r\nconst isClient = typeof window !== \"undefined\";\r\nconst isDef = (val) => typeof val !== \"undefined\";\r\nconst assert = (condition, ...infos) => {\r\n  if (!condition)\r\n    console.warn(...infos);\r\n};\r\nconst toString = Object.prototype.toString;\r\nconst isBoolean = (val) => typeof val === \"boolean\";\r\nconst isFunction = (val) => typeof val === \"function\";\r\nconst isNumber = (val) => typeof val === \"number\";\r\nconst isString = (val) => typeof val === \"string\";\r\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\r\nconst isWindow = (val) => typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\r\nconst now = () => Date.now();\r\nconst timestamp = () => +Date.now();\r\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\r\nconst noop = () => {\r\n};\r\nconst rand = (min, max) => {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n};\r\nconst isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\r\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\r\n\r\nfunction resolveUnref(r) {\r\n  return typeof r === \"function\" ? r() : unref(r);\r\n}\r\n\r\nfunction createFilterWrapper(filter, fn) {\r\n  function wrapper(...args) {\r\n    return new Promise((resolve, reject) => {\r\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\r\n    });\r\n  }\r\n  return wrapper;\r\n}\r\nconst bypassFilter = (invoke) => {\r\n  return invoke();\r\n};\r\nfunction debounceFilter(ms, options = {}) {\r\n  let timer;\r\n  let maxTimer;\r\n  let lastRejector = noop;\r\n  const _clearTimeout = (timer2) => {\r\n    clearTimeout(timer2);\r\n    lastRejector();\r\n    lastRejector = noop;\r\n  };\r\n  const filter = (invoke) => {\r\n    const duration = resolveUnref(ms);\r\n    const maxDuration = resolveUnref(options.maxWait);\r\n    if (timer)\r\n      _clearTimeout(timer);\r\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\r\n      if (maxTimer) {\r\n        _clearTimeout(maxTimer);\r\n        maxTimer = null;\r\n      }\r\n      return Promise.resolve(invoke());\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      lastRejector = options.rejectOnCancel ? reject : resolve;\r\n      if (maxDuration && !maxTimer) {\r\n        maxTimer = setTimeout(() => {\r\n          if (timer)\r\n            _clearTimeout(timer);\r\n          maxTimer = null;\r\n          resolve(invoke());\r\n        }, maxDuration);\r\n      }\r\n      timer = setTimeout(() => {\r\n        if (maxTimer)\r\n          _clearTimeout(maxTimer);\r\n        maxTimer = null;\r\n        resolve(invoke());\r\n      }, duration);\r\n    });\r\n  };\r\n  return filter;\r\n}\r\nfunction throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {\r\n  let lastExec = 0;\r\n  let timer;\r\n  let isLeading = true;\r\n  let lastRejector = noop;\r\n  let lastValue;\r\n  const clear = () => {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timer = void 0;\r\n      lastRejector();\r\n      lastRejector = noop;\r\n    }\r\n  };\r\n  const filter = (_invoke) => {\r\n    const duration = resolveUnref(ms);\r\n    const elapsed = Date.now() - lastExec;\r\n    const invoke = () => {\r\n      return lastValue = _invoke();\r\n    };\r\n    clear();\r\n    if (duration <= 0) {\r\n      lastExec = Date.now();\r\n      return invoke();\r\n    }\r\n    if (elapsed > duration && (leading || !isLeading)) {\r\n      lastExec = Date.now();\r\n      invoke();\r\n    } else if (trailing) {\r\n      lastValue = new Promise((resolve, reject) => {\r\n        lastRejector = rejectOnCancel ? reject : resolve;\r\n        timer = setTimeout(() => {\r\n          lastExec = Date.now();\r\n          isLeading = true;\r\n          resolve(invoke());\r\n          clear();\r\n        }, Math.max(0, duration - elapsed));\r\n      });\r\n    }\r\n    if (!leading && !timer)\r\n      timer = setTimeout(() => isLeading = true, duration);\r\n    isLeading = false;\r\n    return lastValue;\r\n  };\r\n  return filter;\r\n}\r\nfunction pausableFilter(extendFilter = bypassFilter) {\r\n  const isActive = ref(true);\r\n  function pause() {\r\n    isActive.value = false;\r\n  }\r\n  function resume() {\r\n    isActive.value = true;\r\n  }\r\n  const eventFilter = (...args) => {\r\n    if (isActive.value)\r\n      extendFilter(...args);\r\n  };\r\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\r\n}\r\n\r\nfunction __onlyVue3(name = \"this function\") {\r\n  if (isVue3)\r\n    return;\r\n  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);\r\n}\r\nfunction __onlyVue27Plus(name = \"this function\") {\r\n  if (isVue3 || version.startsWith(\"2.7.\"))\r\n    return;\r\n  throw new Error(`[VueUse] ${name} is only works on Vue 2.7 or above.`);\r\n}\r\nconst directiveHooks = {\r\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\r\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\r\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\r\n};\r\n\r\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\r\n  return new Promise((resolve, reject) => {\r\n    if (throwOnTimeout)\r\n      setTimeout(() => reject(reason), ms);\r\n    else\r\n      setTimeout(resolve, ms);\r\n  });\r\n}\r\nfunction identity(arg) {\r\n  return arg;\r\n}\r\nfunction createSingletonPromise(fn) {\r\n  let _promise;\r\n  function wrapper() {\r\n    if (!_promise)\r\n      _promise = fn();\r\n    return _promise;\r\n  }\r\n  wrapper.reset = async () => {\r\n    const _prev = _promise;\r\n    _promise = void 0;\r\n    if (_prev)\r\n      await _prev;\r\n  };\r\n  return wrapper;\r\n}\r\nfunction invoke(fn) {\r\n  return fn();\r\n}\r\nfunction containsProp(obj, ...props) {\r\n  return props.some((k) => k in obj);\r\n}\r\nfunction increaseWithUnit(target, delta) {\r\n  var _a;\r\n  if (typeof target === \"number\")\r\n    return target + delta;\r\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\r\n  const unit = target.slice(value.length);\r\n  const result = parseFloat(value) + delta;\r\n  if (Number.isNaN(result))\r\n    return target;\r\n  return result + unit;\r\n}\r\nfunction objectPick(obj, keys, omitUndefined = false) {\r\n  return keys.reduce((n, k) => {\r\n    if (k in obj) {\r\n      if (!omitUndefined || obj[k] !== void 0)\r\n        n[k] = obj[k];\r\n    }\r\n    return n;\r\n  }, {});\r\n}\r\n\r\nfunction computedWithControl(source, fn) {\r\n  let v = void 0;\r\n  let track;\r\n  let trigger;\r\n  const dirty = ref(true);\r\n  const update = () => {\r\n    dirty.value = true;\r\n    trigger();\r\n  };\r\n  watch(source, update, { flush: \"sync\" });\r\n  const get = isFunction(fn) ? fn : fn.get;\r\n  const set = isFunction(fn) ? void 0 : fn.set;\r\n  const result = customRef((_track, _trigger) => {\r\n    track = _track;\r\n    trigger = _trigger;\r\n    return {\r\n      get() {\r\n        if (dirty.value) {\r\n          v = get();\r\n          dirty.value = false;\r\n        }\r\n        track();\r\n        return v;\r\n      },\r\n      set(v2) {\r\n        set == null ? void 0 : set(v2);\r\n      }\r\n    };\r\n  });\r\n  if (Object.isExtensible(result))\r\n    result.trigger = update;\r\n  return result;\r\n}\r\n\r\nfunction tryOnScopeDispose(fn) {\r\n  if (getCurrentScope()) {\r\n    onScopeDispose(fn);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction createEventHook() {\r\n  const fns = [];\r\n  const off = (fn) => {\r\n    const index = fns.indexOf(fn);\r\n    if (index !== -1)\r\n      fns.splice(index, 1);\r\n  };\r\n  const on = (fn) => {\r\n    fns.push(fn);\r\n    const offFn = () => off(fn);\r\n    tryOnScopeDispose(offFn);\r\n    return {\r\n      off: offFn\r\n    };\r\n  };\r\n  const trigger = (param) => {\r\n    fns.forEach((fn) => fn(param));\r\n  };\r\n  return {\r\n    on,\r\n    off,\r\n    trigger\r\n  };\r\n}\r\n\r\nfunction createGlobalState(stateFactory) {\r\n  let initialized = false;\r\n  let state;\r\n  const scope = effectScope(true);\r\n  return () => {\r\n    if (!initialized) {\r\n      state = scope.run(stateFactory);\r\n      initialized = true;\r\n    }\r\n    return state;\r\n  };\r\n}\r\n\r\nfunction createInjectionState(composable) {\r\n  const key = Symbol(\"InjectionState\");\r\n  const useProvidingState = (...args) => {\r\n    const state = composable(...args);\r\n    provide(key, state);\r\n    return state;\r\n  };\r\n  const useInjectedState = () => inject(key);\r\n  return [useProvidingState, useInjectedState];\r\n}\r\n\r\nfunction createSharedComposable(composable) {\r\n  let subscribers = 0;\r\n  let state;\r\n  let scope;\r\n  const dispose = () => {\r\n    subscribers -= 1;\r\n    if (scope && subscribers <= 0) {\r\n      scope.stop();\r\n      state = void 0;\r\n      scope = void 0;\r\n    }\r\n  };\r\n  return (...args) => {\r\n    subscribers += 1;\r\n    if (!state) {\r\n      scope = effectScope(true);\r\n      state = scope.run(() => composable(...args));\r\n    }\r\n    tryOnScopeDispose(dispose);\r\n    return state;\r\n  };\r\n}\r\n\r\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\r\n  __onlyVue27Plus();\r\n  for (const [key, value] of Object.entries(extend)) {\r\n    if (key === \"value\")\r\n      continue;\r\n    if (isRef(value) && unwrap) {\r\n      Object.defineProperty(ref, key, {\r\n        get() {\r\n          return value.value;\r\n        },\r\n        set(v) {\r\n          value.value = v;\r\n        },\r\n        enumerable\r\n      });\r\n    } else {\r\n      Object.defineProperty(ref, key, { value, enumerable });\r\n    }\r\n  }\r\n  return ref;\r\n}\r\n\r\nfunction get(obj, key) {\r\n  if (key == null)\r\n    return unref(obj);\r\n  return unref(obj)[key];\r\n}\r\n\r\nfunction isDefined(v) {\r\n  return unref(v) != null;\r\n}\r\n\r\nvar __defProp$8 = Object.defineProperty;\r\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$8 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$a.call(b, prop))\r\n      __defNormalProp$8(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$a)\r\n    for (var prop of __getOwnPropSymbols$a(b)) {\r\n      if (__propIsEnum$a.call(b, prop))\r\n        __defNormalProp$8(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction makeDestructurable(obj, arr) {\r\n  if (typeof Symbol !== \"undefined\") {\r\n    const clone = __spreadValues$8({}, obj);\r\n    Object.defineProperty(clone, Symbol.iterator, {\r\n      enumerable: false,\r\n      value() {\r\n        let index = 0;\r\n        return {\r\n          next: () => ({\r\n            value: arr[index++],\r\n            done: index > arr.length\r\n          })\r\n        };\r\n      }\r\n    });\r\n    return clone;\r\n  } else {\r\n    return Object.assign([...arr], obj);\r\n  }\r\n}\r\n\r\nfunction reactify(fn, options) {\r\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : resolveUnref;\r\n  return function(...args) {\r\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\r\n  };\r\n}\r\n\r\nfunction reactifyObject(obj, optionsOrKeys = {}) {\r\n  let keys = [];\r\n  let options;\r\n  if (Array.isArray(optionsOrKeys)) {\r\n    keys = optionsOrKeys;\r\n  } else {\r\n    options = optionsOrKeys;\r\n    const { includeOwnProperties = true } = optionsOrKeys;\r\n    keys.push(...Object.keys(obj));\r\n    if (includeOwnProperties)\r\n      keys.push(...Object.getOwnPropertyNames(obj));\r\n  }\r\n  return Object.fromEntries(keys.map((key) => {\r\n    const value = obj[key];\r\n    return [\r\n      key,\r\n      typeof value === \"function\" ? reactify(value.bind(obj), options) : value\r\n    ];\r\n  }));\r\n}\r\n\r\nfunction toReactive(objectRef) {\r\n  if (!isRef(objectRef))\r\n    return reactive(objectRef);\r\n  const proxy = new Proxy({}, {\r\n    get(_, p, receiver) {\r\n      return unref(Reflect.get(objectRef.value, p, receiver));\r\n    },\r\n    set(_, p, value) {\r\n      if (isRef(objectRef.value[p]) && !isRef(value))\r\n        objectRef.value[p].value = value;\r\n      else\r\n        objectRef.value[p] = value;\r\n      return true;\r\n    },\r\n    deleteProperty(_, p) {\r\n      return Reflect.deleteProperty(objectRef.value, p);\r\n    },\r\n    has(_, p) {\r\n      return Reflect.has(objectRef.value, p);\r\n    },\r\n    ownKeys() {\r\n      return Object.keys(objectRef.value);\r\n    },\r\n    getOwnPropertyDescriptor() {\r\n      return {\r\n        enumerable: true,\r\n        configurable: true\r\n      };\r\n    }\r\n  });\r\n  return reactive(proxy);\r\n}\r\n\r\nfunction reactiveComputed(fn) {\r\n  return toReactive(computed(fn));\r\n}\r\n\r\nfunction reactiveOmit(obj, ...keys) {\r\n  const flatKeys = keys.flat();\r\n  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\r\n}\r\n\r\nfunction reactivePick(obj, ...keys) {\r\n  const flatKeys = keys.flat();\r\n  return reactive(Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\r\n}\r\n\r\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\r\n  return customRef((track, trigger) => {\r\n    let value = defaultValue;\r\n    let timer;\r\n    const resetAfter = () => setTimeout(() => {\r\n      value = defaultValue;\r\n      trigger();\r\n    }, resolveUnref(afterMs));\r\n    tryOnScopeDispose(() => {\r\n      clearTimeout(timer);\r\n    });\r\n    return {\r\n      get() {\r\n        track();\r\n        return value;\r\n      },\r\n      set(newValue) {\r\n        value = newValue;\r\n        trigger();\r\n        clearTimeout(timer);\r\n        timer = resetAfter();\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nfunction useDebounceFn(fn, ms = 200, options = {}) {\r\n  return createFilterWrapper(debounceFilter(ms, options), fn);\r\n}\r\n\r\nfunction refDebounced(value, ms = 200, options = {}) {\r\n  const debounced = ref(value.value);\r\n  const updater = useDebounceFn(() => {\r\n    debounced.value = value.value;\r\n  }, ms, options);\r\n  watch(value, () => updater());\r\n  return debounced;\r\n}\r\n\r\nfunction refDefault(source, defaultValue) {\r\n  return computed({\r\n    get() {\r\n      var _a;\r\n      return (_a = source.value) != null ? _a : defaultValue;\r\n    },\r\n    set(value) {\r\n      source.value = value;\r\n    }\r\n  });\r\n}\r\n\r\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\r\n  return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);\r\n}\r\n\r\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\r\n  if (delay <= 0)\r\n    return value;\r\n  const throttled = ref(value.value);\r\n  const updater = useThrottleFn(() => {\r\n    throttled.value = value.value;\r\n  }, delay, trailing, leading);\r\n  watch(value, () => updater());\r\n  return throttled;\r\n}\r\n\r\nfunction refWithControl(initial, options = {}) {\r\n  let source = initial;\r\n  let track;\r\n  let trigger;\r\n  const ref = customRef((_track, _trigger) => {\r\n    track = _track;\r\n    trigger = _trigger;\r\n    return {\r\n      get() {\r\n        return get();\r\n      },\r\n      set(v) {\r\n        set(v);\r\n      }\r\n    };\r\n  });\r\n  function get(tracking = true) {\r\n    if (tracking)\r\n      track();\r\n    return source;\r\n  }\r\n  function set(value, triggering = true) {\r\n    var _a, _b;\r\n    if (value === source)\r\n      return;\r\n    const old = source;\r\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\r\n      return;\r\n    source = value;\r\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\r\n    if (triggering)\r\n      trigger();\r\n  }\r\n  const untrackedGet = () => get(false);\r\n  const silentSet = (v) => set(v, false);\r\n  const peek = () => get(false);\r\n  const lay = (v) => set(v, false);\r\n  return extendRef(ref, {\r\n    get,\r\n    set,\r\n    untrackedGet,\r\n    silentSet,\r\n    peek,\r\n    lay\r\n  }, { enumerable: true });\r\n}\r\nconst controlledRef = refWithControl;\r\n\r\nfunction resolveRef(r) {\r\n  return typeof r === \"function\" ? computed(r) : ref(r);\r\n}\r\n\r\nfunction set(...args) {\r\n  if (args.length === 2) {\r\n    const [ref, value] = args;\r\n    ref.value = value;\r\n  }\r\n  if (args.length === 3) {\r\n    if (isVue2) {\r\n      set$1(...args);\r\n    } else {\r\n      const [target, key, value] = args;\r\n      target[key] = value;\r\n    }\r\n  }\r\n}\r\n\r\nfunction syncRef(left, right, options = {}) {\r\n  var _a, _b;\r\n  const {\r\n    flush = \"sync\",\r\n    deep = false,\r\n    immediate = true,\r\n    direction = \"both\",\r\n    transform = {}\r\n  } = options;\r\n  let watchLeft;\r\n  let watchRight;\r\n  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;\r\n  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;\r\n  if (direction === \"both\" || direction === \"ltr\") {\r\n    watchLeft = watch(left, (newValue) => right.value = transformLTR(newValue), { flush, deep, immediate });\r\n  }\r\n  if (direction === \"both\" || direction === \"rtl\") {\r\n    watchRight = watch(right, (newValue) => left.value = transformRTL(newValue), { flush, deep, immediate });\r\n  }\r\n  return () => {\r\n    watchLeft == null ? void 0 : watchLeft();\r\n    watchRight == null ? void 0 : watchRight();\r\n  };\r\n}\r\n\r\nfunction syncRefs(source, targets, options = {}) {\r\n  const {\r\n    flush = \"sync\",\r\n    deep = false,\r\n    immediate = true\r\n  } = options;\r\n  if (!Array.isArray(targets))\r\n    targets = [targets];\r\n  return watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });\r\n}\r\n\r\nvar __defProp$7 = Object.defineProperty;\r\nvar __defProps$5 = Object.defineProperties;\r\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$7 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$9.call(b, prop))\r\n      __defNormalProp$7(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$9)\r\n    for (var prop of __getOwnPropSymbols$9(b)) {\r\n      if (__propIsEnum$9.call(b, prop))\r\n        __defNormalProp$7(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\r\nfunction toRefs(objectRef) {\r\n  if (!isRef(objectRef))\r\n    return toRefs$1(objectRef);\r\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\r\n  for (const key in objectRef.value) {\r\n    result[key] = customRef(() => ({\r\n      get() {\r\n        return objectRef.value[key];\r\n      },\r\n      set(v) {\r\n        if (Array.isArray(objectRef.value)) {\r\n          const copy = [...objectRef.value];\r\n          copy[key] = v;\r\n          objectRef.value = copy;\r\n        } else {\r\n          const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });\r\n          Object.setPrototypeOf(newObject, objectRef.value);\r\n          objectRef.value = newObject;\r\n        }\r\n      }\r\n    }));\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction tryOnBeforeMount(fn, sync = true) {\r\n  if (getCurrentInstance())\r\n    onBeforeMount(fn);\r\n  else if (sync)\r\n    fn();\r\n  else\r\n    nextTick(fn);\r\n}\r\n\r\nfunction tryOnBeforeUnmount(fn) {\r\n  if (getCurrentInstance())\r\n    onBeforeUnmount(fn);\r\n}\r\n\r\nfunction tryOnMounted(fn, sync = true) {\r\n  if (getCurrentInstance())\r\n    onMounted(fn);\r\n  else if (sync)\r\n    fn();\r\n  else\r\n    nextTick(fn);\r\n}\r\n\r\nfunction tryOnUnmounted(fn) {\r\n  if (getCurrentInstance())\r\n    onUnmounted(fn);\r\n}\r\n\r\nfunction createUntil(r, isNot = false) {\r\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\r\n    let stop = null;\r\n    const watcher = new Promise((resolve) => {\r\n      stop = watch(r, (v) => {\r\n        if (condition(v) !== isNot) {\r\n          stop == null ? void 0 : stop();\r\n          resolve(v);\r\n        }\r\n      }, {\r\n        flush,\r\n        deep,\r\n        immediate: true\r\n      });\r\n    });\r\n    const promises = [watcher];\r\n    if (timeout != null) {\r\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => stop == null ? void 0 : stop()));\r\n    }\r\n    return Promise.race(promises);\r\n  }\r\n  function toBe(value, options) {\r\n    if (!isRef(value))\r\n      return toMatch((v) => v === value, options);\r\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\r\n    let stop = null;\r\n    const watcher = new Promise((resolve) => {\r\n      stop = watch([r, value], ([v1, v2]) => {\r\n        if (isNot !== (v1 === v2)) {\r\n          stop == null ? void 0 : stop();\r\n          resolve(v1);\r\n        }\r\n      }, {\r\n        flush,\r\n        deep,\r\n        immediate: true\r\n      });\r\n    });\r\n    const promises = [watcher];\r\n    if (timeout != null) {\r\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => {\r\n        stop == null ? void 0 : stop();\r\n        return resolveUnref(r);\r\n      }));\r\n    }\r\n    return Promise.race(promises);\r\n  }\r\n  function toBeTruthy(options) {\r\n    return toMatch((v) => Boolean(v), options);\r\n  }\r\n  function toBeNull(options) {\r\n    return toBe(null, options);\r\n  }\r\n  function toBeUndefined(options) {\r\n    return toBe(void 0, options);\r\n  }\r\n  function toBeNaN(options) {\r\n    return toMatch(Number.isNaN, options);\r\n  }\r\n  function toContains(value, options) {\r\n    return toMatch((v) => {\r\n      const array = Array.from(v);\r\n      return array.includes(value) || array.includes(resolveUnref(value));\r\n    }, options);\r\n  }\r\n  function changed(options) {\r\n    return changedTimes(1, options);\r\n  }\r\n  function changedTimes(n = 1, options) {\r\n    let count = -1;\r\n    return toMatch(() => {\r\n      count += 1;\r\n      return count >= n;\r\n    }, options);\r\n  }\r\n  if (Array.isArray(resolveUnref(r))) {\r\n    const instance = {\r\n      toMatch,\r\n      toContains,\r\n      changed,\r\n      changedTimes,\r\n      get not() {\r\n        return createUntil(r, !isNot);\r\n      }\r\n    };\r\n    return instance;\r\n  } else {\r\n    const instance = {\r\n      toMatch,\r\n      toBe,\r\n      toBeTruthy,\r\n      toBeNull,\r\n      toBeNaN,\r\n      toBeUndefined,\r\n      changed,\r\n      changedTimes,\r\n      get not() {\r\n        return createUntil(r, !isNot);\r\n      }\r\n    };\r\n    return instance;\r\n  }\r\n}\r\nfunction until(r) {\r\n  return createUntil(r);\r\n}\r\n\r\nfunction useArrayEvery(list, fn) {\r\n  return computed(() => resolveUnref(list).every((element, index, array) => fn(resolveUnref(element), index, array)));\r\n}\r\n\r\nfunction useArrayFilter(list, fn) {\r\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).filter(fn));\r\n}\r\n\r\nfunction useArrayFind(list, fn) {\r\n  return computed(() => resolveUnref(resolveUnref(list).find((element, index, array) => fn(resolveUnref(element), index, array))));\r\n}\r\n\r\nfunction useArrayFindIndex(list, fn) {\r\n  return computed(() => resolveUnref(list).findIndex((element, index, array) => fn(resolveUnref(element), index, array)));\r\n}\r\n\r\nfunction findLast(arr, cb) {\r\n  let index = arr.length;\r\n  while (index-- > 0) {\r\n    if (cb(arr[index], index, arr))\r\n      return arr[index];\r\n  }\r\n  return void 0;\r\n}\r\nfunction useArrayFindLast(list, fn) {\r\n  return computed(() => resolveUnref(!Array.prototype.findLast ? findLast(resolveUnref(list), (element, index, array) => fn(resolveUnref(element), index, array)) : resolveUnref(list).findLast((element, index, array) => fn(resolveUnref(element), index, array))));\r\n}\r\n\r\nfunction useArrayJoin(list, separator) {\r\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).join(resolveUnref(separator)));\r\n}\r\n\r\nfunction useArrayMap(list, fn) {\r\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).map(fn));\r\n}\r\n\r\nfunction useArrayReduce(list, reducer, ...args) {\r\n  const reduceCallback = (sum, value, index) => reducer(resolveUnref(sum), resolveUnref(value), index);\r\n  return computed(() => {\r\n    const resolved = resolveUnref(list);\r\n    return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);\r\n  });\r\n}\r\n\r\nfunction useArraySome(list, fn) {\r\n  return computed(() => resolveUnref(list).some((element, index, array) => fn(resolveUnref(element), index, array)));\r\n}\r\n\r\nfunction useArrayUnique(list) {\r\n  return computed(() => [...new Set(resolveUnref(list).map((element) => resolveUnref(element)))]);\r\n}\r\n\r\nfunction useCounter(initialValue = 0, options = {}) {\r\n  const count = ref(initialValue);\r\n  const {\r\n    max = Infinity,\r\n    min = -Infinity\r\n  } = options;\r\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\r\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\r\n  const get = () => count.value;\r\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\r\n  const reset = (val = initialValue) => {\r\n    initialValue = val;\r\n    return set(val);\r\n  };\r\n  return { count, inc, dec, get, set, reset };\r\n}\r\n\r\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\r\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\r\nconst defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {\r\n  let m = hours < 12 ? \"AM\" : \"PM\";\r\n  if (hasPeriod)\r\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\r\n  return isLowercase ? m.toLowerCase() : m;\r\n};\r\nconst formatDate = (date, formatStr, options = {}) => {\r\n  var _a;\r\n  const years = date.getFullYear();\r\n  const month = date.getMonth();\r\n  const days = date.getDate();\r\n  const hours = date.getHours();\r\n  const minutes = date.getMinutes();\r\n  const seconds = date.getSeconds();\r\n  const milliseconds = date.getMilliseconds();\r\n  const day = date.getDay();\r\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\r\n  const matches = {\r\n    YY: () => String(years).slice(-2),\r\n    YYYY: () => years,\r\n    M: () => month + 1,\r\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\r\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\r\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\r\n    D: () => String(days),\r\n    DD: () => `${days}`.padStart(2, \"0\"),\r\n    H: () => String(hours),\r\n    HH: () => `${hours}`.padStart(2, \"0\"),\r\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\r\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\r\n    m: () => String(minutes),\r\n    mm: () => `${minutes}`.padStart(2, \"0\"),\r\n    s: () => String(seconds),\r\n    ss: () => `${seconds}`.padStart(2, \"0\"),\r\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\r\n    d: () => day,\r\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\r\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\r\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\r\n    A: () => meridiem(hours, minutes),\r\n    AA: () => meridiem(hours, minutes, false, true),\r\n    a: () => meridiem(hours, minutes, true),\r\n    aa: () => meridiem(hours, minutes, true, true)\r\n  };\r\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());\r\n};\r\nconst normalizeDate = (date) => {\r\n  if (date === null)\r\n    return new Date(NaN);\r\n  if (date === void 0)\r\n    return new Date();\r\n  if (date instanceof Date)\r\n    return new Date(date);\r\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\r\n    const d = date.match(REGEX_PARSE);\r\n    if (d) {\r\n      const m = d[2] - 1 || 0;\r\n      const ms = (d[7] || \"0\").substring(0, 3);\r\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\r\n    }\r\n  }\r\n  return new Date(date);\r\n};\r\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\r\n  return computed(() => formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options));\r\n}\r\n\r\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\r\n  const {\r\n    immediate = true,\r\n    immediateCallback = false\r\n  } = options;\r\n  let timer = null;\r\n  const isActive = ref(false);\r\n  function clean() {\r\n    if (timer) {\r\n      clearInterval(timer);\r\n      timer = null;\r\n    }\r\n  }\r\n  function pause() {\r\n    isActive.value = false;\r\n    clean();\r\n  }\r\n  function resume() {\r\n    const intervalValue = resolveUnref(interval);\r\n    if (intervalValue <= 0)\r\n      return;\r\n    isActive.value = true;\r\n    if (immediateCallback)\r\n      cb();\r\n    clean();\r\n    timer = setInterval(cb, intervalValue);\r\n  }\r\n  if (immediate && isClient)\r\n    resume();\r\n  if (isRef(interval) || isFunction(interval)) {\r\n    const stopWatch = watch(interval, () => {\r\n      if (isActive.value && isClient)\r\n        resume();\r\n    });\r\n    tryOnScopeDispose(stopWatch);\r\n  }\r\n  tryOnScopeDispose(pause);\r\n  return {\r\n    isActive,\r\n    pause,\r\n    resume\r\n  };\r\n}\r\n\r\nvar __defProp$6 = Object.defineProperty;\r\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$6 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$8.call(b, prop))\r\n      __defNormalProp$6(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$8)\r\n    for (var prop of __getOwnPropSymbols$8(b)) {\r\n      if (__propIsEnum$8.call(b, prop))\r\n        __defNormalProp$6(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useInterval(interval = 1e3, options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    immediate = true,\r\n    callback\r\n  } = options;\r\n  const counter = ref(0);\r\n  const update = () => counter.value += 1;\r\n  const reset = () => {\r\n    counter.value = 0;\r\n  };\r\n  const controls = useIntervalFn(callback ? () => {\r\n    update();\r\n    callback(counter.value);\r\n  } : update, interval, { immediate });\r\n  if (exposeControls) {\r\n    return __spreadValues$6({\r\n      counter,\r\n      reset\r\n    }, controls);\r\n  } else {\r\n    return counter;\r\n  }\r\n}\r\n\r\nfunction useLastChanged(source, options = {}) {\r\n  var _a;\r\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\r\n  watch(source, () => ms.value = timestamp(), options);\r\n  return ms;\r\n}\r\n\r\nfunction useTimeoutFn(cb, interval, options = {}) {\r\n  const {\r\n    immediate = true\r\n  } = options;\r\n  const isPending = ref(false);\r\n  let timer = null;\r\n  function clear() {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timer = null;\r\n    }\r\n  }\r\n  function stop() {\r\n    isPending.value = false;\r\n    clear();\r\n  }\r\n  function start(...args) {\r\n    clear();\r\n    isPending.value = true;\r\n    timer = setTimeout(() => {\r\n      isPending.value = false;\r\n      timer = null;\r\n      cb(...args);\r\n    }, resolveUnref(interval));\r\n  }\r\n  if (immediate) {\r\n    isPending.value = true;\r\n    if (isClient)\r\n      start();\r\n  }\r\n  tryOnScopeDispose(stop);\r\n  return {\r\n    isPending: readonly(isPending),\r\n    start,\r\n    stop\r\n  };\r\n}\r\n\r\nvar __defProp$5 = Object.defineProperty;\r\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$5 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$7.call(b, prop))\r\n      __defNormalProp$5(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$7)\r\n    for (var prop of __getOwnPropSymbols$7(b)) {\r\n      if (__propIsEnum$7.call(b, prop))\r\n        __defNormalProp$5(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useTimeout(interval = 1e3, options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    callback\r\n  } = options;\r\n  const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);\r\n  const ready = computed(() => !controls.isPending.value);\r\n  if (exposeControls) {\r\n    return __spreadValues$5({\r\n      ready\r\n    }, controls);\r\n  } else {\r\n    return ready;\r\n  }\r\n}\r\n\r\nfunction useToNumber(value, options = {}) {\r\n  const {\r\n    method = \"parseFloat\",\r\n    radix,\r\n    nanToZero\r\n  } = options;\r\n  return computed(() => {\r\n    let resolved = resolveUnref(value);\r\n    if (typeof resolved === \"string\")\r\n      resolved = Number[method](resolved, radix);\r\n    if (nanToZero && isNaN(resolved))\r\n      resolved = 0;\r\n    return resolved;\r\n  });\r\n}\r\n\r\nfunction useToString(value) {\r\n  return computed(() => `${resolveUnref(value)}`);\r\n}\r\n\r\nfunction useToggle(initialValue = false, options = {}) {\r\n  const {\r\n    truthyValue = true,\r\n    falsyValue = false\r\n  } = options;\r\n  const valueIsRef = isRef(initialValue);\r\n  const _value = ref(initialValue);\r\n  function toggle(value) {\r\n    if (arguments.length) {\r\n      _value.value = value;\r\n      return _value.value;\r\n    } else {\r\n      const truthy = resolveUnref(truthyValue);\r\n      _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;\r\n      return _value.value;\r\n    }\r\n  }\r\n  if (valueIsRef)\r\n    return toggle;\r\n  else\r\n    return [_value, toggle];\r\n}\r\n\r\nfunction watchArray(source, cb, options) {\r\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [\r\n    ...source instanceof Function ? source() : Array.isArray(source) ? source : unref(source)\r\n  ];\r\n  return watch(source, (newList, _, onCleanup) => {\r\n    const oldListRemains = new Array(oldList.length);\r\n    const added = [];\r\n    for (const obj of newList) {\r\n      let found = false;\r\n      for (let i = 0; i < oldList.length; i++) {\r\n        if (!oldListRemains[i] && obj === oldList[i]) {\r\n          oldListRemains[i] = true;\r\n          found = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!found)\r\n        added.push(obj);\r\n    }\r\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\r\n    cb(newList, oldList, added, removed, onCleanup);\r\n    oldList = [...newList];\r\n  }, options);\r\n}\r\n\r\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\r\nvar __objRest$5 = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$6)\r\n    for (var prop of __getOwnPropSymbols$6(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nfunction watchWithFilter(source, cb, options = {}) {\r\n  const _a = options, {\r\n    eventFilter = bypassFilter\r\n  } = _a, watchOptions = __objRest$5(_a, [\r\n    \"eventFilter\"\r\n  ]);\r\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\r\n}\r\n\r\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\r\nvar __objRest$4 = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$5)\r\n    for (var prop of __getOwnPropSymbols$5(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nfunction watchAtMost(source, cb, options) {\r\n  const _a = options, {\r\n    count\r\n  } = _a, watchOptions = __objRest$4(_a, [\r\n    \"count\"\r\n  ]);\r\n  const current = ref(0);\r\n  const stop = watchWithFilter(source, (...args) => {\r\n    current.value += 1;\r\n    if (current.value >= resolveUnref(count))\r\n      nextTick(() => stop());\r\n    cb(...args);\r\n  }, watchOptions);\r\n  return { count: current, stop };\r\n}\r\n\r\nvar __defProp$4 = Object.defineProperty;\r\nvar __defProps$4 = Object.defineProperties;\r\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$4 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$4.call(b, prop))\r\n      __defNormalProp$4(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$4)\r\n    for (var prop of __getOwnPropSymbols$4(b)) {\r\n      if (__propIsEnum$4.call(b, prop))\r\n        __defNormalProp$4(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\r\nvar __objRest$3 = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$4)\r\n    for (var prop of __getOwnPropSymbols$4(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nfunction watchDebounced(source, cb, options = {}) {\r\n  const _a = options, {\r\n    debounce = 0,\r\n    maxWait = void 0\r\n  } = _a, watchOptions = __objRest$3(_a, [\r\n    \"debounce\",\r\n    \"maxWait\"\r\n  ]);\r\n  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {\r\n    eventFilter: debounceFilter(debounce, { maxWait })\r\n  }));\r\n}\r\n\r\nvar __defProp$3 = Object.defineProperty;\r\nvar __defProps$3 = Object.defineProperties;\r\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$3 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$3.call(b, prop))\r\n      __defNormalProp$3(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$3)\r\n    for (var prop of __getOwnPropSymbols$3(b)) {\r\n      if (__propIsEnum$3.call(b, prop))\r\n        __defNormalProp$3(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\r\nvar __objRest$2 = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$3)\r\n    for (var prop of __getOwnPropSymbols$3(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nfunction watchIgnorable(source, cb, options = {}) {\r\n  const _a = options, {\r\n    eventFilter = bypassFilter\r\n  } = _a, watchOptions = __objRest$2(_a, [\r\n    \"eventFilter\"\r\n  ]);\r\n  const filteredCb = createFilterWrapper(eventFilter, cb);\r\n  let ignoreUpdates;\r\n  let ignorePrevAsyncUpdates;\r\n  let stop;\r\n  if (watchOptions.flush === \"sync\") {\r\n    const ignore = ref(false);\r\n    ignorePrevAsyncUpdates = () => {\r\n    };\r\n    ignoreUpdates = (updater) => {\r\n      ignore.value = true;\r\n      updater();\r\n      ignore.value = false;\r\n    };\r\n    stop = watch(source, (...args) => {\r\n      if (!ignore.value)\r\n        filteredCb(...args);\r\n    }, watchOptions);\r\n  } else {\r\n    const disposables = [];\r\n    const ignoreCounter = ref(0);\r\n    const syncCounter = ref(0);\r\n    ignorePrevAsyncUpdates = () => {\r\n      ignoreCounter.value = syncCounter.value;\r\n    };\r\n    disposables.push(watch(source, () => {\r\n      syncCounter.value++;\r\n    }, __spreadProps$3(__spreadValues$3({}, watchOptions), { flush: \"sync\" })));\r\n    ignoreUpdates = (updater) => {\r\n      const syncCounterPrev = syncCounter.value;\r\n      updater();\r\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\r\n    };\r\n    disposables.push(watch(source, (...args) => {\r\n      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\r\n      ignoreCounter.value = 0;\r\n      syncCounter.value = 0;\r\n      if (ignore)\r\n        return;\r\n      filteredCb(...args);\r\n    }, watchOptions));\r\n    stop = () => {\r\n      disposables.forEach((fn) => fn());\r\n    };\r\n  }\r\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\r\n}\r\n\r\nfunction watchOnce(source, cb, options) {\r\n  const stop = watch(source, (...args) => {\r\n    nextTick(() => stop());\r\n    return cb(...args);\r\n  }, options);\r\n}\r\n\r\nvar __defProp$2 = Object.defineProperty;\r\nvar __defProps$2 = Object.defineProperties;\r\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$2 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$2.call(b, prop))\r\n      __defNormalProp$2(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$2)\r\n    for (var prop of __getOwnPropSymbols$2(b)) {\r\n      if (__propIsEnum$2.call(b, prop))\r\n        __defNormalProp$2(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\r\nvar __objRest$1 = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$2)\r\n    for (var prop of __getOwnPropSymbols$2(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nfunction watchPausable(source, cb, options = {}) {\r\n  const _a = options, {\r\n    eventFilter: filter\r\n  } = _a, watchOptions = __objRest$1(_a, [\r\n    \"eventFilter\"\r\n  ]);\r\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\r\n  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {\r\n    eventFilter\r\n  }));\r\n  return { stop, pause, resume, isActive };\r\n}\r\n\r\nvar __defProp$1 = Object.defineProperty;\r\nvar __defProps$1 = Object.defineProperties;\r\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$1 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$1.call(b, prop))\r\n      __defNormalProp$1(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$1)\r\n    for (var prop of __getOwnPropSymbols$1(b)) {\r\n      if (__propIsEnum$1.call(b, prop))\r\n        __defNormalProp$1(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\r\nvar __objRest = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$1)\r\n    for (var prop of __getOwnPropSymbols$1(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nfunction watchThrottled(source, cb, options = {}) {\r\n  const _a = options, {\r\n    throttle = 0,\r\n    trailing = true,\r\n    leading = true\r\n  } = _a, watchOptions = __objRest(_a, [\r\n    \"throttle\",\r\n    \"trailing\",\r\n    \"leading\"\r\n  ]);\r\n  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {\r\n    eventFilter: throttleFilter(throttle, trailing, leading)\r\n  }));\r\n}\r\n\r\nvar __defProp = Object.defineProperty;\r\nvar __defProps = Object.defineProperties;\r\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp.call(b, prop))\r\n      __defNormalProp(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols)\r\n    for (var prop of __getOwnPropSymbols(b)) {\r\n      if (__propIsEnum.call(b, prop))\r\n        __defNormalProp(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\r\nfunction watchTriggerable(source, cb, options = {}) {\r\n  let cleanupFn;\r\n  function onEffect() {\r\n    if (!cleanupFn)\r\n      return;\r\n    const fn = cleanupFn;\r\n    cleanupFn = void 0;\r\n    fn();\r\n  }\r\n  function onCleanup(callback) {\r\n    cleanupFn = callback;\r\n  }\r\n  const _cb = (value, oldValue) => {\r\n    onEffect();\r\n    return cb(value, oldValue, onCleanup);\r\n  };\r\n  const res = watchIgnorable(source, _cb, options);\r\n  const { ignoreUpdates } = res;\r\n  const trigger = () => {\r\n    let res2;\r\n    ignoreUpdates(() => {\r\n      res2 = _cb(getWatchSources(source), getOldValue(source));\r\n    });\r\n    return res2;\r\n  };\r\n  return __spreadProps(__spreadValues({}, res), {\r\n    trigger\r\n  });\r\n}\r\nfunction getWatchSources(sources) {\r\n  if (isReactive(sources))\r\n    return sources;\r\n  if (Array.isArray(sources))\r\n    return sources.map((item) => getOneWatchSource(item));\r\n  return getOneWatchSource(sources);\r\n}\r\nfunction getOneWatchSource(source) {\r\n  return typeof source === \"function\" ? source() : unref(source);\r\n}\r\nfunction getOldValue(source) {\r\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\r\n}\r\n\r\nfunction whenever(source, cb, options) {\r\n  return watch(source, (v, ov, onInvalidate) => {\r\n    if (v)\r\n      cb(v, ov, onInvalidate);\r\n  }, options);\r\n}\r\n\r\nexport { __onlyVue27Plus, __onlyVue3, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, makeDestructurable, noop, normalizeDate, now, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\r\n", "import { noop, resolveUnref, isClient, isString, tryOnScopeDispose, isIOS, tryOnMounted, computedWithControl, promiseTimeout, isFunction, resolveRef, increaseWithUnit, useTimeoutFn, pausableWatch, createEventHook, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, createSingletonPromise, toRefs, containsProp, until, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, isObject, isNumber, useIntervalFn, clamp, syncRef, objectPick, tryOnUnmounted, watchWithFilter, identity, isDef } from '@vueuse/shared';\r\nexport * from '@vueuse/shared';\r\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, unref, watch, getCurrentInstance, customRef, onUpdated, reactive, nextTick, onMounted, markRaw, readonly, getCurrentScope, isVue2, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\r\n\r\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\r\n  let options;\r\n  if (isRef(optionsOrRef)) {\r\n    options = {\r\n      evaluating: optionsOrRef\r\n    };\r\n  } else {\r\n    options = optionsOrRef || {};\r\n  }\r\n  const {\r\n    lazy = false,\r\n    evaluating = void 0,\r\n    shallow = false,\r\n    onError = noop\r\n  } = options;\r\n  const started = ref(!lazy);\r\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\r\n  let counter = 0;\r\n  watchEffect(async (onInvalidate) => {\r\n    if (!started.value)\r\n      return;\r\n    counter++;\r\n    const counterAtBeginning = counter;\r\n    let hasFinished = false;\r\n    if (evaluating) {\r\n      Promise.resolve().then(() => {\r\n        evaluating.value = true;\r\n      });\r\n    }\r\n    try {\r\n      const result = await evaluationCallback((cancelCallback) => {\r\n        onInvalidate(() => {\r\n          if (evaluating)\r\n            evaluating.value = false;\r\n          if (!hasFinished)\r\n            cancelCallback();\r\n        });\r\n      });\r\n      if (counterAtBeginning === counter)\r\n        current.value = result;\r\n    } catch (e) {\r\n      onError(e);\r\n    } finally {\r\n      if (evaluating && counterAtBeginning === counter)\r\n        evaluating.value = false;\r\n      hasFinished = true;\r\n    }\r\n  });\r\n  if (lazy) {\r\n    return computed(() => {\r\n      started.value = true;\r\n      return current.value;\r\n    });\r\n  } else {\r\n    return current;\r\n  }\r\n}\r\n\r\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\r\n  let source = inject(key);\r\n  if (defaultSource)\r\n    source = inject(key, defaultSource);\r\n  if (treatDefaultAsFactory)\r\n    source = inject(key, defaultSource, treatDefaultAsFactory);\r\n  if (typeof options === \"function\") {\r\n    return computed((ctx) => options(source, ctx));\r\n  } else {\r\n    return computed({\r\n      get: (ctx) => options.get(source, ctx),\r\n      set: options.set\r\n    });\r\n  }\r\n}\r\n\r\nconst createUnrefFn = (fn) => {\r\n  return function(...args) {\r\n    return fn.apply(this, args.map((i) => unref(i)));\r\n  };\r\n};\r\n\r\nfunction unrefElement(elRef) {\r\n  var _a;\r\n  const plain = resolveUnref(elRef);\r\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\r\n}\r\n\r\nconst defaultWindow = isClient ? window : void 0;\r\nconst defaultDocument = isClient ? window.document : void 0;\r\nconst defaultNavigator = isClient ? window.navigator : void 0;\r\nconst defaultLocation = isClient ? window.location : void 0;\r\n\r\nfunction useEventListener(...args) {\r\n  let target;\r\n  let events;\r\n  let listeners;\r\n  let options;\r\n  if (isString(args[0]) || Array.isArray(args[0])) {\r\n    [events, listeners, options] = args;\r\n    target = defaultWindow;\r\n  } else {\r\n    [target, events, listeners, options] = args;\r\n  }\r\n  if (!target)\r\n    return noop;\r\n  if (!Array.isArray(events))\r\n    events = [events];\r\n  if (!Array.isArray(listeners))\r\n    listeners = [listeners];\r\n  const cleanups = [];\r\n  const cleanup = () => {\r\n    cleanups.forEach((fn) => fn());\r\n    cleanups.length = 0;\r\n  };\r\n  const register = (el, event, listener, options2) => {\r\n    el.addEventListener(event, listener, options2);\r\n    return () => el.removeEventListener(event, listener, options2);\r\n  };\r\n  const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {\r\n    cleanup();\r\n    if (!el)\r\n      return;\r\n    cleanups.push(...events.flatMap((event) => {\r\n      return listeners.map((listener) => register(el, event, listener, options2));\r\n    }));\r\n  }, { immediate: true, flush: \"post\" });\r\n  const stop = () => {\r\n    stopWatch();\r\n    cleanup();\r\n  };\r\n  tryOnScopeDispose(stop);\r\n  return stop;\r\n}\r\n\r\nlet _iOSWorkaround = false;\r\nfunction onClickOutside(target, handler, options = {}) {\r\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\r\n  if (!window)\r\n    return;\r\n  if (isIOS && !_iOSWorkaround) {\r\n    _iOSWorkaround = true;\r\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\r\n  }\r\n  let shouldListen = true;\r\n  const shouldIgnore = (event) => {\r\n    return ignore.some((target2) => {\r\n      if (typeof target2 === \"string\") {\r\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\r\n      } else {\r\n        const el = unrefElement(target2);\r\n        return el && (event.target === el || event.composedPath().includes(el));\r\n      }\r\n    });\r\n  };\r\n  const listener = (event) => {\r\n    const el = unrefElement(target);\r\n    if (!el || el === event.target || event.composedPath().includes(el))\r\n      return;\r\n    if (event.detail === 0)\r\n      shouldListen = !shouldIgnore(event);\r\n    if (!shouldListen) {\r\n      shouldListen = true;\r\n      return;\r\n    }\r\n    handler(event);\r\n  };\r\n  const cleanup = [\r\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\r\n    useEventListener(window, \"pointerdown\", (e) => {\r\n      const el = unrefElement(target);\r\n      if (el)\r\n        shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);\r\n    }, { passive: true }),\r\n    detectIframe && useEventListener(window, \"blur\", (event) => {\r\n      var _a;\r\n      const el = unrefElement(target);\r\n      if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\r\n        handler(event);\r\n    })\r\n  ].filter(Boolean);\r\n  const stop = () => cleanup.forEach((fn) => fn());\r\n  return stop;\r\n}\r\n\r\nvar __defProp$n = Object.defineProperty;\r\nvar __defProps$9 = Object.defineProperties;\r\nvar __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$p = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$p = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$p = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$n = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$p.call(b, prop))\r\n      __defNormalProp$n(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$p)\r\n    for (var prop of __getOwnPropSymbols$p(b)) {\r\n      if (__propIsEnum$p.call(b, prop))\r\n        __defNormalProp$n(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));\r\nconst createKeyPredicate = (keyFilter) => {\r\n  if (typeof keyFilter === \"function\")\r\n    return keyFilter;\r\n  else if (typeof keyFilter === \"string\")\r\n    return (event) => event.key === keyFilter;\r\n  else if (Array.isArray(keyFilter))\r\n    return (event) => keyFilter.includes(event.key);\r\n  return () => true;\r\n};\r\nfunction onKeyStroke(...args) {\r\n  let key;\r\n  let handler;\r\n  let options = {};\r\n  if (args.length === 3) {\r\n    key = args[0];\r\n    handler = args[1];\r\n    options = args[2];\r\n  } else if (args.length === 2) {\r\n    if (typeof args[1] === \"object\") {\r\n      key = true;\r\n      handler = args[0];\r\n      options = args[1];\r\n    } else {\r\n      key = args[0];\r\n      handler = args[1];\r\n    }\r\n  } else {\r\n    key = true;\r\n    handler = args[0];\r\n  }\r\n  const { target = defaultWindow, eventName = \"keydown\", passive = false } = options;\r\n  const predicate = createKeyPredicate(key);\r\n  const listener = (e) => {\r\n    if (predicate(e))\r\n      handler(e);\r\n  };\r\n  return useEventListener(target, eventName, listener, passive);\r\n}\r\nfunction onKeyDown(key, handler, options = {}) {\r\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$n({}, options), { eventName: \"keydown\" }));\r\n}\r\nfunction onKeyPressed(key, handler, options = {}) {\r\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$n({}, options), { eventName: \"keypress\" }));\r\n}\r\nfunction onKeyUp(key, handler, options = {}) {\r\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$n({}, options), { eventName: \"keyup\" }));\r\n}\r\n\r\nconst DEFAULT_DELAY = 500;\r\nfunction onLongPress(target, handler, options) {\r\n  var _a, _b;\r\n  const elementRef = computed(() => unrefElement(target));\r\n  let timeout;\r\n  function clear() {\r\n    if (timeout) {\r\n      clearTimeout(timeout);\r\n      timeout = void 0;\r\n    }\r\n  }\r\n  function onDown(ev) {\r\n    var _a2, _b2, _c, _d;\r\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\r\n      return;\r\n    clear();\r\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\r\n      ev.preventDefault();\r\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\r\n      ev.stopPropagation();\r\n    timeout = setTimeout(() => handler(ev), (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY);\r\n  }\r\n  const listenerOptions = {\r\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\r\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\r\n  };\r\n  useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions);\r\n  useEventListener(elementRef, \"pointerup\", clear, listenerOptions);\r\n  useEventListener(elementRef, \"pointerleave\", clear, listenerOptions);\r\n}\r\n\r\nconst isFocusedElementEditable = () => {\r\n  const { activeElement, body } = document;\r\n  if (!activeElement)\r\n    return false;\r\n  if (activeElement === body)\r\n    return false;\r\n  switch (activeElement.tagName) {\r\n    case \"INPUT\":\r\n    case \"TEXTAREA\":\r\n      return true;\r\n  }\r\n  return activeElement.hasAttribute(\"contenteditable\");\r\n};\r\nconst isTypedCharValid = ({\r\n  keyCode,\r\n  metaKey,\r\n  ctrlKey,\r\n  altKey\r\n}) => {\r\n  if (metaKey || ctrlKey || altKey)\r\n    return false;\r\n  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)\r\n    return true;\r\n  if (keyCode >= 65 && keyCode <= 90)\r\n    return true;\r\n  return false;\r\n};\r\nfunction onStartTyping(callback, options = {}) {\r\n  const { document: document2 = defaultDocument } = options;\r\n  const keydown = (event) => {\r\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\r\n  };\r\n  if (document2)\r\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\r\n}\r\n\r\nfunction templateRef(key, initialValue = null) {\r\n  const instance = getCurrentInstance();\r\n  let _trigger = () => {\r\n  };\r\n  const element = customRef((track, trigger) => {\r\n    _trigger = trigger;\r\n    return {\r\n      get() {\r\n        var _a, _b;\r\n        track();\r\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\r\n      },\r\n      set() {\r\n      }\r\n    };\r\n  });\r\n  tryOnMounted(_trigger);\r\n  onUpdated(_trigger);\r\n  return element;\r\n}\r\n\r\nfunction useActiveElement(options = {}) {\r\n  var _a;\r\n  const { window = defaultWindow } = options;\r\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\r\n  const activeElement = computedWithControl(() => null, () => document == null ? void 0 : document.activeElement);\r\n  if (window) {\r\n    useEventListener(window, \"blur\", (event) => {\r\n      if (event.relatedTarget !== null)\r\n        return;\r\n      activeElement.trigger();\r\n    }, true);\r\n    useEventListener(window, \"focus\", activeElement.trigger, true);\r\n  }\r\n  return activeElement;\r\n}\r\n\r\nfunction useAsyncQueue(tasks, options = {}) {\r\n  const {\r\n    interrupt = true,\r\n    onError = noop,\r\n    onFinished = noop\r\n  } = options;\r\n  const promiseState = {\r\n    pending: \"pending\",\r\n    rejected: \"rejected\",\r\n    fulfilled: \"fulfilled\"\r\n  };\r\n  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));\r\n  const result = reactive(initialResult);\r\n  const activeIndex = ref(-1);\r\n  if (!tasks || tasks.length === 0) {\r\n    onFinished();\r\n    return {\r\n      activeIndex,\r\n      result\r\n    };\r\n  }\r\n  function updateResult(state, res) {\r\n    activeIndex.value++;\r\n    result[activeIndex.value].data = res;\r\n    result[activeIndex.value].state = state;\r\n  }\r\n  tasks.reduce((prev, curr) => {\r\n    return prev.then((prevRes) => {\r\n      var _a;\r\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\r\n        onFinished();\r\n        return;\r\n      }\r\n      return curr(prevRes).then((currentRes) => {\r\n        updateResult(promiseState.fulfilled, currentRes);\r\n        activeIndex.value === tasks.length - 1 && onFinished();\r\n        return currentRes;\r\n      });\r\n    }).catch((e) => {\r\n      updateResult(promiseState.rejected, e);\r\n      onError();\r\n      return e;\r\n    });\r\n  }, Promise.resolve());\r\n  return {\r\n    activeIndex,\r\n    result\r\n  };\r\n}\r\n\r\nfunction useAsyncState(promise, initialState, options) {\r\n  const {\r\n    immediate = true,\r\n    delay = 0,\r\n    onError = noop,\r\n    onSuccess = noop,\r\n    resetOnExecute = true,\r\n    shallow = true,\r\n    throwError\r\n  } = options != null ? options : {};\r\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\r\n  const isReady = ref(false);\r\n  const isLoading = ref(false);\r\n  const error = ref(void 0);\r\n  async function execute(delay2 = 0, ...args) {\r\n    if (resetOnExecute)\r\n      state.value = initialState;\r\n    error.value = void 0;\r\n    isReady.value = false;\r\n    isLoading.value = true;\r\n    if (delay2 > 0)\r\n      await promiseTimeout(delay2);\r\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\r\n    try {\r\n      const data = await _promise;\r\n      state.value = data;\r\n      isReady.value = true;\r\n      onSuccess(data);\r\n    } catch (e) {\r\n      error.value = e;\r\n      onError(e);\r\n      if (throwError)\r\n        throw error;\r\n    } finally {\r\n      isLoading.value = false;\r\n    }\r\n    return state.value;\r\n  }\r\n  if (immediate)\r\n    execute(delay);\r\n  return {\r\n    state,\r\n    isReady,\r\n    isLoading,\r\n    error,\r\n    execute\r\n  };\r\n}\r\n\r\nconst defaults = {\r\n  array: (v) => JSON.stringify(v),\r\n  object: (v) => JSON.stringify(v),\r\n  set: (v) => JSON.stringify(Array.from(v)),\r\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\r\n  null: () => \"\"\r\n};\r\nfunction getDefaultSerialization(target) {\r\n  if (!target)\r\n    return defaults.null;\r\n  if (target instanceof Map)\r\n    return defaults.map;\r\n  else if (target instanceof Set)\r\n    return defaults.set;\r\n  else if (Array.isArray(target))\r\n    return defaults.array;\r\n  else\r\n    return defaults.object;\r\n}\r\n\r\nfunction useBase64(target, options) {\r\n  const base64 = ref(\"\");\r\n  const promise = ref();\r\n  function execute() {\r\n    if (!isClient)\r\n      return;\r\n    promise.value = new Promise((resolve, reject) => {\r\n      try {\r\n        const _target = resolveUnref(target);\r\n        if (_target == null) {\r\n          resolve(\"\");\r\n        } else if (typeof _target === \"string\") {\r\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\r\n        } else if (_target instanceof Blob) {\r\n          resolve(blobToBase64(_target));\r\n        } else if (_target instanceof ArrayBuffer) {\r\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\r\n        } else if (_target instanceof HTMLCanvasElement) {\r\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\r\n        } else if (_target instanceof HTMLImageElement) {\r\n          const img = _target.cloneNode(false);\r\n          img.crossOrigin = \"Anonymous\";\r\n          imgLoaded(img).then(() => {\r\n            const canvas = document.createElement(\"canvas\");\r\n            const ctx = canvas.getContext(\"2d\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\r\n          }).catch(reject);\r\n        } else if (typeof _target === \"object\") {\r\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\r\n          const serialized = _serializeFn(_target);\r\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\r\n        } else {\r\n          reject(new Error(\"target is unsupported types\"));\r\n        }\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n    promise.value.then((res) => base64.value = res);\r\n    return promise.value;\r\n  }\r\n  if (isRef(target) || isFunction(target))\r\n    watch(target, execute, { immediate: true });\r\n  else\r\n    execute();\r\n  return {\r\n    base64,\r\n    promise,\r\n    execute\r\n  };\r\n}\r\nfunction imgLoaded(img) {\r\n  return new Promise((resolve, reject) => {\r\n    if (!img.complete) {\r\n      img.onload = () => {\r\n        resolve();\r\n      };\r\n      img.onerror = reject;\r\n    } else {\r\n      resolve();\r\n    }\r\n  });\r\n}\r\nfunction blobToBase64(blob) {\r\n  return new Promise((resolve, reject) => {\r\n    const fr = new FileReader();\r\n    fr.onload = (e) => {\r\n      resolve(e.target.result);\r\n    };\r\n    fr.onerror = reject;\r\n    fr.readAsDataURL(blob);\r\n  });\r\n}\r\n\r\nfunction useSupported(callback, sync = false) {\r\n  const isSupported = ref();\r\n  const update = () => isSupported.value = Boolean(callback());\r\n  update();\r\n  tryOnMounted(update, sync);\r\n  return isSupported;\r\n}\r\n\r\nfunction useBattery({ navigator = defaultNavigator } = {}) {\r\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\r\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator);\r\n  const charging = ref(false);\r\n  const chargingTime = ref(0);\r\n  const dischargingTime = ref(0);\r\n  const level = ref(1);\r\n  let battery;\r\n  function updateBatteryInfo() {\r\n    charging.value = this.charging;\r\n    chargingTime.value = this.chargingTime || 0;\r\n    dischargingTime.value = this.dischargingTime || 0;\r\n    level.value = this.level;\r\n  }\r\n  if (isSupported.value) {\r\n    navigator.getBattery().then((_battery) => {\r\n      battery = _battery;\r\n      updateBatteryInfo.call(battery);\r\n      for (const event of events)\r\n        useEventListener(battery, event, updateBatteryInfo, { passive: true });\r\n    });\r\n  }\r\n  return {\r\n    isSupported,\r\n    charging,\r\n    chargingTime,\r\n    dischargingTime,\r\n    level\r\n  };\r\n}\r\n\r\nfunction useBluetooth(options) {\r\n  let {\r\n    acceptAllDevices = false\r\n  } = options || {};\r\n  const {\r\n    filters = void 0,\r\n    optionalServices = void 0,\r\n    navigator = defaultNavigator\r\n  } = options || {};\r\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\r\n  const device = shallowRef(void 0);\r\n  const error = shallowRef(null);\r\n  watch(device, () => {\r\n    connectToBluetoothGATTServer();\r\n  });\r\n  async function requestDevice() {\r\n    if (!isSupported.value)\r\n      return;\r\n    error.value = null;\r\n    if (filters && filters.length > 0)\r\n      acceptAllDevices = false;\r\n    try {\r\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\r\n        acceptAllDevices,\r\n        filters,\r\n        optionalServices\r\n      }));\r\n    } catch (err) {\r\n      error.value = err;\r\n    }\r\n  }\r\n  const server = ref();\r\n  const isConnected = computed(() => {\r\n    var _a;\r\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\r\n  });\r\n  async function connectToBluetoothGATTServer() {\r\n    error.value = null;\r\n    if (device.value && device.value.gatt) {\r\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\r\n      });\r\n      try {\r\n        server.value = await device.value.gatt.connect();\r\n      } catch (err) {\r\n        error.value = err;\r\n      }\r\n    }\r\n  }\r\n  tryOnMounted(() => {\r\n    var _a;\r\n    if (device.value)\r\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\r\n  });\r\n  tryOnScopeDispose(() => {\r\n    var _a;\r\n    if (device.value)\r\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\r\n  });\r\n  return {\r\n    isSupported,\r\n    isConnected,\r\n    device,\r\n    requestDevice,\r\n    server,\r\n    error\r\n  };\r\n}\r\n\r\nfunction useMediaQuery(query, options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\r\n  let mediaQuery;\r\n  const matches = ref(false);\r\n  const cleanup = () => {\r\n    if (!mediaQuery)\r\n      return;\r\n    if (\"removeEventListener\" in mediaQuery)\r\n      mediaQuery.removeEventListener(\"change\", update);\r\n    else\r\n      mediaQuery.removeListener(update);\r\n  };\r\n  const update = () => {\r\n    if (!isSupported.value)\r\n      return;\r\n    cleanup();\r\n    mediaQuery = window.matchMedia(resolveRef(query).value);\r\n    matches.value = mediaQuery.matches;\r\n    if (\"addEventListener\" in mediaQuery)\r\n      mediaQuery.addEventListener(\"change\", update);\r\n    else\r\n      mediaQuery.addListener(update);\r\n  };\r\n  watchEffect(update);\r\n  tryOnScopeDispose(() => cleanup());\r\n  return matches;\r\n}\r\n\r\nconst breakpointsTailwind = {\r\n  \"sm\": 640,\r\n  \"md\": 768,\r\n  \"lg\": 1024,\r\n  \"xl\": 1280,\r\n  \"2xl\": 1536\r\n};\r\nconst breakpointsBootstrapV5 = {\r\n  sm: 576,\r\n  md: 768,\r\n  lg: 992,\r\n  xl: 1200,\r\n  xxl: 1400\r\n};\r\nconst breakpointsVuetify = {\r\n  xs: 600,\r\n  sm: 960,\r\n  md: 1264,\r\n  lg: 1904\r\n};\r\nconst breakpointsAntDesign = {\r\n  xs: 480,\r\n  sm: 576,\r\n  md: 768,\r\n  lg: 992,\r\n  xl: 1200,\r\n  xxl: 1600\r\n};\r\nconst breakpointsQuasar = {\r\n  xs: 600,\r\n  sm: 1024,\r\n  md: 1440,\r\n  lg: 1920\r\n};\r\nconst breakpointsSematic = {\r\n  mobileS: 320,\r\n  mobileM: 375,\r\n  mobileL: 425,\r\n  tablet: 768,\r\n  laptop: 1024,\r\n  laptopL: 1440,\r\n  desktop4K: 2560\r\n};\r\nconst breakpointsMasterCss = {\r\n  \"3xs\": 360,\r\n  \"2xs\": 480,\r\n  \"xs\": 600,\r\n  \"sm\": 768,\r\n  \"md\": 1024,\r\n  \"lg\": 1280,\r\n  \"xl\": 1440,\r\n  \"2xl\": 1600,\r\n  \"3xl\": 1920,\r\n  \"4xl\": 2560\r\n};\r\n\r\nvar __defProp$m = Object.defineProperty;\r\nvar __getOwnPropSymbols$o = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$o = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$o = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$m = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$o.call(b, prop))\r\n      __defNormalProp$m(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$o)\r\n    for (var prop of __getOwnPropSymbols$o(b)) {\r\n      if (__propIsEnum$o.call(b, prop))\r\n        __defNormalProp$m(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useBreakpoints(breakpoints, options = {}) {\r\n  function getValue(k, delta) {\r\n    let v = breakpoints[k];\r\n    if (delta != null)\r\n      v = increaseWithUnit(v, delta);\r\n    if (typeof v === \"number\")\r\n      v = `${v}px`;\r\n    return v;\r\n  }\r\n  const { window = defaultWindow } = options;\r\n  function match(query) {\r\n    if (!window)\r\n      return false;\r\n    return window.matchMedia(query).matches;\r\n  }\r\n  const greaterOrEqual = (k) => {\r\n    return useMediaQuery(`(min-width: ${getValue(k)})`, options);\r\n  };\r\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\r\n    Object.defineProperty(shortcuts, k, {\r\n      get: () => greaterOrEqual(k),\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    return shortcuts;\r\n  }, {});\r\n  return __spreadValues$m({\r\n    greater(k) {\r\n      return useMediaQuery(`(min-width: ${getValue(k, 0.1)})`, options);\r\n    },\r\n    greaterOrEqual,\r\n    smaller(k) {\r\n      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);\r\n    },\r\n    smallerOrEqual(k) {\r\n      return useMediaQuery(`(max-width: ${getValue(k)})`, options);\r\n    },\r\n    between(a, b) {\r\n      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\r\n    },\r\n    isGreater(k) {\r\n      return match(`(min-width: ${getValue(k, 0.1)})`);\r\n    },\r\n    isGreaterOrEqual(k) {\r\n      return match(`(min-width: ${getValue(k)})`);\r\n    },\r\n    isSmaller(k) {\r\n      return match(`(max-width: ${getValue(k, -0.1)})`);\r\n    },\r\n    isSmallerOrEqual(k) {\r\n      return match(`(max-width: ${getValue(k)})`);\r\n    },\r\n    isInBetween(a, b) {\r\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\r\n    }\r\n  }, shortcutMethods);\r\n}\r\n\r\nconst useBroadcastChannel = (options) => {\r\n  const {\r\n    name,\r\n    window = defaultWindow\r\n  } = options;\r\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\r\n  const isClosed = ref(false);\r\n  const channel = ref();\r\n  const data = ref();\r\n  const error = ref(null);\r\n  const post = (data2) => {\r\n    if (channel.value)\r\n      channel.value.postMessage(data2);\r\n  };\r\n  const close = () => {\r\n    if (channel.value)\r\n      channel.value.close();\r\n    isClosed.value = true;\r\n  };\r\n  if (isSupported.value) {\r\n    tryOnMounted(() => {\r\n      error.value = null;\r\n      channel.value = new BroadcastChannel(name);\r\n      channel.value.addEventListener(\"message\", (e) => {\r\n        data.value = e.data;\r\n      }, { passive: true });\r\n      channel.value.addEventListener(\"messageerror\", (e) => {\r\n        error.value = e;\r\n      }, { passive: true });\r\n      channel.value.addEventListener(\"close\", () => {\r\n        isClosed.value = true;\r\n      });\r\n    });\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    close();\r\n  });\r\n  return {\r\n    isSupported,\r\n    channel,\r\n    data,\r\n    post,\r\n    close,\r\n    error,\r\n    isClosed\r\n  };\r\n};\r\n\r\nfunction useBrowserLocation({ window = defaultWindow } = {}) {\r\n  const buildState = (trigger) => {\r\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\r\n    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window == null ? void 0 : window.location) || {};\r\n    return {\r\n      trigger,\r\n      state: state2,\r\n      length,\r\n      hash,\r\n      host,\r\n      hostname,\r\n      href,\r\n      origin,\r\n      pathname,\r\n      port,\r\n      protocol,\r\n      search\r\n    };\r\n  };\r\n  const state = ref(buildState(\"load\"));\r\n  if (window) {\r\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\r\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\r\n  }\r\n  return state;\r\n}\r\n\r\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\r\n  const cachedValue = ref(refValue.value);\r\n  watch(() => refValue.value, (value) => {\r\n    if (!comparator(value, cachedValue.value))\r\n      cachedValue.value = value;\r\n  }, watchOptions);\r\n  return cachedValue;\r\n}\r\n\r\nfunction useClipboard(options = {}) {\r\n  const {\r\n    navigator = defaultNavigator,\r\n    read = false,\r\n    source,\r\n    copiedDuring = 1500,\r\n    legacy = false\r\n  } = options;\r\n  const events = [\"copy\", \"cut\"];\r\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\r\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\r\n  const text = ref(\"\");\r\n  const copied = ref(false);\r\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\r\n  function updateText() {\r\n    if (isClipboardApiSupported.value) {\r\n      navigator.clipboard.readText().then((value) => {\r\n        text.value = value;\r\n      });\r\n    } else {\r\n      text.value = legacyRead();\r\n    }\r\n  }\r\n  if (isSupported.value && read) {\r\n    for (const event of events)\r\n      useEventListener(event, updateText);\r\n  }\r\n  async function copy(value = resolveUnref(source)) {\r\n    if (isSupported.value && value != null) {\r\n      if (isClipboardApiSupported.value)\r\n        await navigator.clipboard.writeText(value);\r\n      else\r\n        legacyCopy(value);\r\n      text.value = value;\r\n      copied.value = true;\r\n      timeout.start();\r\n    }\r\n  }\r\n  function legacyCopy(value) {\r\n    const ta = document.createElement(\"textarea\");\r\n    ta.value = value != null ? value : \"\";\r\n    ta.style.position = \"absolute\";\r\n    ta.style.opacity = \"0\";\r\n    document.body.appendChild(ta);\r\n    ta.select();\r\n    document.execCommand(\"copy\");\r\n    ta.remove();\r\n  }\r\n  function legacyRead() {\r\n    var _a, _b, _c;\r\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\r\n  }\r\n  return {\r\n    isSupported,\r\n    text,\r\n    copied,\r\n    copy\r\n  };\r\n}\r\n\r\nvar __defProp$l = Object.defineProperty;\r\nvar __defProps$8 = Object.defineProperties;\r\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$n = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$n = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$n = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$l = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$n.call(b, prop))\r\n      __defNormalProp$l(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$n)\r\n    for (var prop of __getOwnPropSymbols$n(b)) {\r\n      if (__propIsEnum$n.call(b, prop))\r\n        __defNormalProp$l(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\r\nfunction cloneFnJSON(source) {\r\n  return JSON.parse(JSON.stringify(source));\r\n}\r\nfunction useCloned(source, options = {}) {\r\n  const cloned = ref({});\r\n  const {\r\n    manual,\r\n    clone = cloneFnJSON,\r\n    deep = true,\r\n    immediate = true\r\n  } = options;\r\n  function sync() {\r\n    cloned.value = clone(unref(source));\r\n  }\r\n  if (!manual && isRef(source)) {\r\n    watch(source, sync, __spreadProps$8(__spreadValues$l({}, options), {\r\n      deep,\r\n      immediate\r\n    }));\r\n  } else {\r\n    sync();\r\n  }\r\n  return { cloned, sync };\r\n}\r\n\r\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\r\nconst globalKey = \"__vueuse_ssr_handlers__\";\r\n_global[globalKey] = _global[globalKey] || {};\r\nconst handlers = _global[globalKey];\r\nfunction getSSRHandler(key, fallback) {\r\n  return handlers[key] || fallback;\r\n}\r\nfunction setSSRHandler(key, fn) {\r\n  handlers[key] = fn;\r\n}\r\n\r\nfunction guessSerializerType(rawInit) {\r\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\r\n}\r\n\r\nvar __defProp$k = Object.defineProperty;\r\nvar __getOwnPropSymbols$m = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$m = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$m = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$k = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$m.call(b, prop))\r\n      __defNormalProp$k(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$m)\r\n    for (var prop of __getOwnPropSymbols$m(b)) {\r\n      if (__propIsEnum$m.call(b, prop))\r\n        __defNormalProp$k(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nconst StorageSerializers = {\r\n  boolean: {\r\n    read: (v) => v === \"true\",\r\n    write: (v) => String(v)\r\n  },\r\n  object: {\r\n    read: (v) => JSON.parse(v),\r\n    write: (v) => JSON.stringify(v)\r\n  },\r\n  number: {\r\n    read: (v) => Number.parseFloat(v),\r\n    write: (v) => String(v)\r\n  },\r\n  any: {\r\n    read: (v) => v,\r\n    write: (v) => String(v)\r\n  },\r\n  string: {\r\n    read: (v) => v,\r\n    write: (v) => String(v)\r\n  },\r\n  map: {\r\n    read: (v) => new Map(JSON.parse(v)),\r\n    write: (v) => JSON.stringify(Array.from(v.entries()))\r\n  },\r\n  set: {\r\n    read: (v) => new Set(JSON.parse(v)),\r\n    write: (v) => JSON.stringify(Array.from(v))\r\n  },\r\n  date: {\r\n    read: (v) => new Date(v),\r\n    write: (v) => v.toISOString()\r\n  }\r\n};\r\nconst customStorageEventName = \"vueuse-storage\";\r\nfunction useStorage(key, defaults, storage, options = {}) {\r\n  var _a;\r\n  const {\r\n    flush = \"pre\",\r\n    deep = true,\r\n    listenToStorageChanges = true,\r\n    writeDefaults = true,\r\n    mergeDefaults = false,\r\n    shallow,\r\n    window = defaultWindow,\r\n    eventFilter,\r\n    onError = (e) => {\r\n      console.error(e);\r\n    }\r\n  } = options;\r\n  const data = (shallow ? shallowRef : ref)(defaults);\r\n  if (!storage) {\r\n    try {\r\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\r\n        var _a2;\r\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\r\n      })();\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  }\r\n  if (!storage)\r\n    return data;\r\n  const rawInit = resolveUnref(defaults);\r\n  const type = guessSerializerType(rawInit);\r\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\r\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(data, () => write(data.value), { flush, deep, eventFilter });\r\n  if (window && listenToStorageChanges) {\r\n    useEventListener(window, \"storage\", update);\r\n    useEventListener(window, customStorageEventName, updateFromCustomEvent);\r\n  }\r\n  update();\r\n  return data;\r\n  function write(v) {\r\n    try {\r\n      if (v == null) {\r\n        storage.removeItem(key);\r\n      } else {\r\n        const serialized = serializer.write(v);\r\n        const oldValue = storage.getItem(key);\r\n        if (oldValue !== serialized) {\r\n          storage.setItem(key, serialized);\r\n          if (window) {\r\n            window.dispatchEvent(new CustomEvent(customStorageEventName, {\r\n              detail: {\r\n                key,\r\n                oldValue,\r\n                newValue: serialized,\r\n                storageArea: storage\r\n              }\r\n            }));\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  }\r\n  function read(event) {\r\n    const rawValue = event ? event.newValue : storage.getItem(key);\r\n    if (rawValue == null) {\r\n      if (writeDefaults && rawInit !== null)\r\n        storage.setItem(key, serializer.write(rawInit));\r\n      return rawInit;\r\n    } else if (!event && mergeDefaults) {\r\n      const value = serializer.read(rawValue);\r\n      if (isFunction(mergeDefaults))\r\n        return mergeDefaults(value, rawInit);\r\n      else if (type === \"object\" && !Array.isArray(value))\r\n        return __spreadValues$k(__spreadValues$k({}, rawInit), value);\r\n      return value;\r\n    } else if (typeof rawValue !== \"string\") {\r\n      return rawValue;\r\n    } else {\r\n      return serializer.read(rawValue);\r\n    }\r\n  }\r\n  function updateFromCustomEvent(event) {\r\n    update(event.detail);\r\n  }\r\n  function update(event) {\r\n    if (event && event.storageArea !== storage)\r\n      return;\r\n    if (event && event.key == null) {\r\n      data.value = rawInit;\r\n      return;\r\n    }\r\n    if (event && event.key !== key)\r\n      return;\r\n    pauseWatch();\r\n    try {\r\n      data.value = read(event);\r\n    } catch (e) {\r\n      onError(e);\r\n    } finally {\r\n      if (event)\r\n        nextTick(resumeWatch);\r\n      else\r\n        resumeWatch();\r\n    }\r\n  }\r\n}\r\n\r\nfunction usePreferredDark(options) {\r\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\r\n}\r\n\r\nvar __defProp$j = Object.defineProperty;\r\nvar __getOwnPropSymbols$l = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$l = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$l = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$j = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$l.call(b, prop))\r\n      __defNormalProp$j(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$l)\r\n    for (var prop of __getOwnPropSymbols$l(b)) {\r\n      if (__propIsEnum$l.call(b, prop))\r\n        __defNormalProp$j(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useColorMode(options = {}) {\r\n  const {\r\n    selector = \"html\",\r\n    attribute = \"class\",\r\n    initialValue = \"auto\",\r\n    window = defaultWindow,\r\n    storage,\r\n    storageKey = \"vueuse-color-scheme\",\r\n    listenToStorageChanges = true,\r\n    storageRef,\r\n    emitAuto\r\n  } = options;\r\n  const modes = __spreadValues$j({\r\n    auto: \"\",\r\n    light: \"light\",\r\n    dark: \"dark\"\r\n  }, options.modes || {});\r\n  const preferredDark = usePreferredDark({ window });\r\n  const preferredMode = computed(() => preferredDark.value ? \"dark\" : \"light\");\r\n  const store = storageRef || (storageKey == null ? ref(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\r\n  const state = computed({\r\n    get() {\r\n      return store.value === \"auto\" && !emitAuto ? preferredMode.value : store.value;\r\n    },\r\n    set(v) {\r\n      store.value = v;\r\n    }\r\n  });\r\n  const updateHTMLAttrs = getSSRHandler(\"updateHTMLAttrs\", (selector2, attribute2, value) => {\r\n    const el = window == null ? void 0 : window.document.querySelector(selector2);\r\n    if (!el)\r\n      return;\r\n    if (attribute2 === \"class\") {\r\n      const current = value.split(/\\s/g);\r\n      Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\r\n        if (current.includes(v))\r\n          el.classList.add(v);\r\n        else\r\n          el.classList.remove(v);\r\n      });\r\n    } else {\r\n      el.setAttribute(attribute2, value);\r\n    }\r\n  });\r\n  function defaultOnChanged(mode) {\r\n    var _a;\r\n    const resolvedMode = mode === \"auto\" ? preferredMode.value : mode;\r\n    updateHTMLAttrs(selector, attribute, (_a = modes[resolvedMode]) != null ? _a : resolvedMode);\r\n  }\r\n  function onChanged(mode) {\r\n    if (options.onChanged)\r\n      options.onChanged(mode, defaultOnChanged);\r\n    else\r\n      defaultOnChanged(mode);\r\n  }\r\n  watch(state, onChanged, { flush: \"post\", immediate: true });\r\n  if (emitAuto)\r\n    watch(preferredMode, () => onChanged(state.value), { flush: \"post\" });\r\n  tryOnMounted(() => onChanged(state.value));\r\n  return state;\r\n}\r\n\r\nfunction useConfirmDialog(revealed = ref(false)) {\r\n  const confirmHook = createEventHook();\r\n  const cancelHook = createEventHook();\r\n  const revealHook = createEventHook();\r\n  let _resolve = noop;\r\n  const reveal = (data) => {\r\n    revealHook.trigger(data);\r\n    revealed.value = true;\r\n    return new Promise((resolve) => {\r\n      _resolve = resolve;\r\n    });\r\n  };\r\n  const confirm = (data) => {\r\n    revealed.value = false;\r\n    confirmHook.trigger(data);\r\n    _resolve({ data, isCanceled: false });\r\n  };\r\n  const cancel = (data) => {\r\n    revealed.value = false;\r\n    cancelHook.trigger(data);\r\n    _resolve({ data, isCanceled: true });\r\n  };\r\n  return {\r\n    isRevealed: computed(() => revealed.value),\r\n    reveal,\r\n    confirm,\r\n    cancel,\r\n    onReveal: revealHook.on,\r\n    onConfirm: confirmHook.on,\r\n    onCancel: cancelHook.on\r\n  };\r\n}\r\n\r\nfunction useCssVar(prop, target, { window = defaultWindow, initialValue = \"\" } = {}) {\r\n  const variable = ref(initialValue);\r\n  const elRef = computed(() => {\r\n    var _a;\r\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\r\n  });\r\n  watch([elRef, () => resolveUnref(prop)], ([el, prop2]) => {\r\n    var _a;\r\n    if (el && window) {\r\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(prop2)) == null ? void 0 : _a.trim();\r\n      variable.value = value || initialValue;\r\n    }\r\n  }, { immediate: true });\r\n  watch(variable, (val) => {\r\n    var _a;\r\n    if ((_a = elRef.value) == null ? void 0 : _a.style)\r\n      elRef.value.style.setProperty(resolveUnref(prop), val);\r\n  });\r\n  return variable;\r\n}\r\n\r\nfunction useCurrentElement() {\r\n  const vm = getCurrentInstance();\r\n  const currentElement = computedWithControl(() => null, () => vm.proxy.$el);\r\n  onUpdated(currentElement.trigger);\r\n  onMounted(currentElement.trigger);\r\n  return currentElement;\r\n}\r\n\r\nfunction useCycleList(list, options) {\r\n  var _a;\r\n  const state = shallowRef((_a = options == null ? void 0 : options.initialValue) != null ? _a : list[0]);\r\n  const index = computed({\r\n    get() {\r\n      var _a2;\r\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list) : list.indexOf(state.value);\r\n      if (index2 < 0)\r\n        index2 = (_a2 = options == null ? void 0 : options.fallbackIndex) != null ? _a2 : 0;\r\n      return index2;\r\n    },\r\n    set(v) {\r\n      set(v);\r\n    }\r\n  });\r\n  function set(i) {\r\n    const length = list.length;\r\n    const index2 = (i % length + length) % length;\r\n    const value = list[index2];\r\n    state.value = value;\r\n    return value;\r\n  }\r\n  function shift(delta = 1) {\r\n    return set(index.value + delta);\r\n  }\r\n  function next(n = 1) {\r\n    return shift(n);\r\n  }\r\n  function prev(n = 1) {\r\n    return shift(-n);\r\n  }\r\n  return {\r\n    state,\r\n    index,\r\n    next,\r\n    prev\r\n  };\r\n}\r\n\r\nvar __defProp$i = Object.defineProperty;\r\nvar __defProps$7 = Object.defineProperties;\r\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$k = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$k = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$k = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$i = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$k.call(b, prop))\r\n      __defNormalProp$i(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$k)\r\n    for (var prop of __getOwnPropSymbols$k(b)) {\r\n      if (__propIsEnum$k.call(b, prop))\r\n        __defNormalProp$i(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\r\nfunction useDark(options = {}) {\r\n  const {\r\n    valueDark = \"dark\",\r\n    valueLight = \"\",\r\n    window = defaultWindow\r\n  } = options;\r\n  const mode = useColorMode(__spreadProps$7(__spreadValues$i({}, options), {\r\n    onChanged: (mode2, defaultHandler) => {\r\n      var _a;\r\n      if (options.onChanged)\r\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\");\r\n      else\r\n        defaultHandler(mode2);\r\n    },\r\n    modes: {\r\n      dark: valueDark,\r\n      light: valueLight\r\n    }\r\n  }));\r\n  const preferredDark = usePreferredDark({ window });\r\n  const isDark = computed({\r\n    get() {\r\n      return mode.value === \"dark\";\r\n    },\r\n    set(v) {\r\n      if (v === preferredDark.value)\r\n        mode.value = \"auto\";\r\n      else\r\n        mode.value = v ? \"dark\" : \"light\";\r\n    }\r\n  });\r\n  return isDark;\r\n}\r\n\r\nconst fnBypass = (v) => v;\r\nconst fnSetSource = (source, value) => source.value = value;\r\nfunction defaultDump(clone) {\r\n  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;\r\n}\r\nfunction defaultParse(clone) {\r\n  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;\r\n}\r\nfunction useManualRefHistory(source, options = {}) {\r\n  const {\r\n    clone = false,\r\n    dump = defaultDump(clone),\r\n    parse = defaultParse(clone),\r\n    setSource = fnSetSource\r\n  } = options;\r\n  function _createHistoryRecord() {\r\n    return markRaw({\r\n      snapshot: dump(source.value),\r\n      timestamp: timestamp()\r\n    });\r\n  }\r\n  const last = ref(_createHistoryRecord());\r\n  const undoStack = ref([]);\r\n  const redoStack = ref([]);\r\n  const _setSource = (record) => {\r\n    setSource(source, parse(record.snapshot));\r\n    last.value = record;\r\n  };\r\n  const commit = () => {\r\n    undoStack.value.unshift(last.value);\r\n    last.value = _createHistoryRecord();\r\n    if (options.capacity && undoStack.value.length > options.capacity)\r\n      undoStack.value.splice(options.capacity, Infinity);\r\n    if (redoStack.value.length)\r\n      redoStack.value.splice(0, redoStack.value.length);\r\n  };\r\n  const clear = () => {\r\n    undoStack.value.splice(0, undoStack.value.length);\r\n    redoStack.value.splice(0, redoStack.value.length);\r\n  };\r\n  const undo = () => {\r\n    const state = undoStack.value.shift();\r\n    if (state) {\r\n      redoStack.value.unshift(last.value);\r\n      _setSource(state);\r\n    }\r\n  };\r\n  const redo = () => {\r\n    const state = redoStack.value.shift();\r\n    if (state) {\r\n      undoStack.value.unshift(last.value);\r\n      _setSource(state);\r\n    }\r\n  };\r\n  const reset = () => {\r\n    _setSource(last.value);\r\n  };\r\n  const history = computed(() => [last.value, ...undoStack.value]);\r\n  const canUndo = computed(() => undoStack.value.length > 0);\r\n  const canRedo = computed(() => redoStack.value.length > 0);\r\n  return {\r\n    source,\r\n    undoStack,\r\n    redoStack,\r\n    last,\r\n    history,\r\n    canUndo,\r\n    canRedo,\r\n    clear,\r\n    commit,\r\n    reset,\r\n    undo,\r\n    redo\r\n  };\r\n}\r\n\r\nvar __defProp$h = Object.defineProperty;\r\nvar __defProps$6 = Object.defineProperties;\r\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$j = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$j = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$j = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$h = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$j.call(b, prop))\r\n      __defNormalProp$h(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$j)\r\n    for (var prop of __getOwnPropSymbols$j(b)) {\r\n      if (__propIsEnum$j.call(b, prop))\r\n        __defNormalProp$h(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\r\nfunction useRefHistory(source, options = {}) {\r\n  const {\r\n    deep = false,\r\n    flush = \"pre\",\r\n    eventFilter\r\n  } = options;\r\n  const {\r\n    eventFilter: composedFilter,\r\n    pause,\r\n    resume: resumeTracking,\r\n    isActive: isTracking\r\n  } = pausableFilter(eventFilter);\r\n  const {\r\n    ignoreUpdates,\r\n    ignorePrevAsyncUpdates,\r\n    stop\r\n  } = watchIgnorable(source, commit, { deep, flush, eventFilter: composedFilter });\r\n  function setSource(source2, value) {\r\n    ignorePrevAsyncUpdates();\r\n    ignoreUpdates(() => {\r\n      source2.value = value;\r\n    });\r\n  }\r\n  const manualHistory = useManualRefHistory(source, __spreadProps$6(__spreadValues$h({}, options), { clone: options.clone || deep, setSource }));\r\n  const { clear, commit: manualCommit } = manualHistory;\r\n  function commit() {\r\n    ignorePrevAsyncUpdates();\r\n    manualCommit();\r\n  }\r\n  function resume(commitNow) {\r\n    resumeTracking();\r\n    if (commitNow)\r\n      commit();\r\n  }\r\n  function batch(fn) {\r\n    let canceled = false;\r\n    const cancel = () => canceled = true;\r\n    ignoreUpdates(() => {\r\n      fn(cancel);\r\n    });\r\n    if (!canceled)\r\n      commit();\r\n  }\r\n  function dispose() {\r\n    stop();\r\n    clear();\r\n  }\r\n  return __spreadProps$6(__spreadValues$h({}, manualHistory), {\r\n    isTracking,\r\n    pause,\r\n    resume,\r\n    commit,\r\n    batch,\r\n    dispose\r\n  });\r\n}\r\n\r\nvar __defProp$g = Object.defineProperty;\r\nvar __defProps$5 = Object.defineProperties;\r\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$i = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$i = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$i = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$g = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$i.call(b, prop))\r\n      __defNormalProp$g(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$i)\r\n    for (var prop of __getOwnPropSymbols$i(b)) {\r\n      if (__propIsEnum$i.call(b, prop))\r\n        __defNormalProp$g(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\r\nfunction useDebouncedRefHistory(source, options = {}) {\r\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\r\n  const history = useRefHistory(source, __spreadProps$5(__spreadValues$g({}, options), { eventFilter: filter }));\r\n  return __spreadValues$g({}, history);\r\n}\r\n\r\nfunction useDeviceMotion(options = {}) {\r\n  const {\r\n    window = defaultWindow,\r\n    eventFilter = bypassFilter\r\n  } = options;\r\n  const acceleration = ref({ x: null, y: null, z: null });\r\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\r\n  const interval = ref(0);\r\n  const accelerationIncludingGravity = ref({\r\n    x: null,\r\n    y: null,\r\n    z: null\r\n  });\r\n  if (window) {\r\n    const onDeviceMotion = createFilterWrapper(eventFilter, (event) => {\r\n      acceleration.value = event.acceleration;\r\n      accelerationIncludingGravity.value = event.accelerationIncludingGravity;\r\n      rotationRate.value = event.rotationRate;\r\n      interval.value = event.interval;\r\n    });\r\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\r\n  }\r\n  return {\r\n    acceleration,\r\n    accelerationIncludingGravity,\r\n    rotationRate,\r\n    interval\r\n  };\r\n}\r\n\r\nfunction useDeviceOrientation(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\r\n  const isAbsolute = ref(false);\r\n  const alpha = ref(null);\r\n  const beta = ref(null);\r\n  const gamma = ref(null);\r\n  if (window && isSupported.value) {\r\n    useEventListener(window, \"deviceorientation\", (event) => {\r\n      isAbsolute.value = event.absolute;\r\n      alpha.value = event.alpha;\r\n      beta.value = event.beta;\r\n      gamma.value = event.gamma;\r\n    });\r\n  }\r\n  return {\r\n    isSupported,\r\n    isAbsolute,\r\n    alpha,\r\n    beta,\r\n    gamma\r\n  };\r\n}\r\n\r\nfunction useDevicePixelRatio({\r\n  window = defaultWindow\r\n} = {}) {\r\n  const pixelRatio = ref(1);\r\n  if (window) {\r\n    let observe = function() {\r\n      pixelRatio.value = window.devicePixelRatio;\r\n      cleanup();\r\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\r\n      media.addEventListener(\"change\", observe, { once: true });\r\n    }, cleanup = function() {\r\n      media == null ? void 0 : media.removeEventListener(\"change\", observe);\r\n    };\r\n    let media;\r\n    observe();\r\n    tryOnScopeDispose(cleanup);\r\n  }\r\n  return { pixelRatio };\r\n}\r\n\r\nfunction usePermission(permissionDesc, options = {}) {\r\n  const {\r\n    controls = false,\r\n    navigator = defaultNavigator\r\n  } = options;\r\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\r\n  let permissionStatus;\r\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\r\n  const state = ref();\r\n  const onChange = () => {\r\n    if (permissionStatus)\r\n      state.value = permissionStatus.state;\r\n  };\r\n  const query = createSingletonPromise(async () => {\r\n    if (!isSupported.value)\r\n      return;\r\n    if (!permissionStatus) {\r\n      try {\r\n        permissionStatus = await navigator.permissions.query(desc);\r\n        useEventListener(permissionStatus, \"change\", onChange);\r\n        onChange();\r\n      } catch (e) {\r\n        state.value = \"prompt\";\r\n      }\r\n    }\r\n    return permissionStatus;\r\n  });\r\n  query();\r\n  if (controls) {\r\n    return {\r\n      state,\r\n      isSupported,\r\n      query\r\n    };\r\n  } else {\r\n    return state;\r\n  }\r\n}\r\n\r\nfunction useDevicesList(options = {}) {\r\n  const {\r\n    navigator = defaultNavigator,\r\n    requestPermissions = false,\r\n    constraints = { audio: true, video: true },\r\n    onUpdated\r\n  } = options;\r\n  const devices = ref([]);\r\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\r\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\r\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\r\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\r\n  const permissionGranted = ref(false);\r\n  async function update() {\r\n    if (!isSupported.value)\r\n      return;\r\n    devices.value = await navigator.mediaDevices.enumerateDevices();\r\n    onUpdated == null ? void 0 : onUpdated(devices.value);\r\n  }\r\n  async function ensurePermissions() {\r\n    if (!isSupported.value)\r\n      return false;\r\n    if (permissionGranted.value)\r\n      return true;\r\n    const { state, query } = usePermission(\"camera\", { controls: true });\r\n    await query();\r\n    if (state.value !== \"granted\") {\r\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\r\n      stream.getTracks().forEach((t) => t.stop());\r\n      update();\r\n      permissionGranted.value = true;\r\n    } else {\r\n      permissionGranted.value = true;\r\n    }\r\n    return permissionGranted.value;\r\n  }\r\n  if (isSupported.value) {\r\n    if (requestPermissions)\r\n      ensurePermissions();\r\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\r\n    update();\r\n  }\r\n  return {\r\n    devices,\r\n    ensurePermissions,\r\n    permissionGranted,\r\n    videoInputs,\r\n    audioInputs,\r\n    audioOutputs,\r\n    isSupported\r\n  };\r\n}\r\n\r\nfunction useDisplayMedia(options = {}) {\r\n  var _a;\r\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\r\n  const video = options.video;\r\n  const audio = options.audio;\r\n  const { navigator = defaultNavigator } = options;\r\n  const isSupported = useSupported(() => {\r\n    var _a2;\r\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\r\n  });\r\n  const constraint = { audio, video };\r\n  const stream = shallowRef();\r\n  async function _start() {\r\n    if (!isSupported.value || stream.value)\r\n      return;\r\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\r\n    return stream.value;\r\n  }\r\n  async function _stop() {\r\n    var _a2;\r\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\r\n    stream.value = void 0;\r\n  }\r\n  function stop() {\r\n    _stop();\r\n    enabled.value = false;\r\n  }\r\n  async function start() {\r\n    await _start();\r\n    if (stream.value)\r\n      enabled.value = true;\r\n    return stream.value;\r\n  }\r\n  watch(enabled, (v) => {\r\n    if (v)\r\n      _start();\r\n    else\r\n      _stop();\r\n  }, { immediate: true });\r\n  return {\r\n    isSupported,\r\n    stream,\r\n    start,\r\n    stop,\r\n    enabled\r\n  };\r\n}\r\n\r\nfunction useDocumentVisibility({ document = defaultDocument } = {}) {\r\n  if (!document)\r\n    return ref(\"visible\");\r\n  const visibility = ref(document.visibilityState);\r\n  useEventListener(document, \"visibilitychange\", () => {\r\n    visibility.value = document.visibilityState;\r\n  });\r\n  return visibility;\r\n}\r\n\r\nvar __defProp$f = Object.defineProperty;\r\nvar __defProps$4 = Object.defineProperties;\r\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$h = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$h = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$h = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$f = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$h.call(b, prop))\r\n      __defNormalProp$f(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$h)\r\n    for (var prop of __getOwnPropSymbols$h(b)) {\r\n      if (__propIsEnum$h.call(b, prop))\r\n        __defNormalProp$f(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\r\nfunction useDraggable(target, options = {}) {\r\n  var _a, _b, _c;\r\n  const draggingElement = (_a = options.draggingElement) != null ? _a : defaultWindow;\r\n  const draggingHandle = (_b = options.handle) != null ? _b : target;\r\n  const position = ref((_c = resolveUnref(options.initialValue)) != null ? _c : { x: 0, y: 0 });\r\n  const pressedDelta = ref();\r\n  const filterEvent = (e) => {\r\n    if (options.pointerTypes)\r\n      return options.pointerTypes.includes(e.pointerType);\r\n    return true;\r\n  };\r\n  const handleEvent = (e) => {\r\n    if (resolveUnref(options.preventDefault))\r\n      e.preventDefault();\r\n    if (resolveUnref(options.stopPropagation))\r\n      e.stopPropagation();\r\n  };\r\n  const start = (e) => {\r\n    var _a2;\r\n    if (!filterEvent(e))\r\n      return;\r\n    if (resolveUnref(options.exact) && e.target !== resolveUnref(target))\r\n      return;\r\n    const rect = resolveUnref(target).getBoundingClientRect();\r\n    const pos = {\r\n      x: e.clientX - rect.left,\r\n      y: e.clientY - rect.top\r\n    };\r\n    if (((_a2 = options.onStart) == null ? void 0 : _a2.call(options, pos, e)) === false)\r\n      return;\r\n    pressedDelta.value = pos;\r\n    handleEvent(e);\r\n  };\r\n  const move = (e) => {\r\n    var _a2;\r\n    if (!filterEvent(e))\r\n      return;\r\n    if (!pressedDelta.value)\r\n      return;\r\n    position.value = {\r\n      x: e.clientX - pressedDelta.value.x,\r\n      y: e.clientY - pressedDelta.value.y\r\n    };\r\n    (_a2 = options.onMove) == null ? void 0 : _a2.call(options, position.value, e);\r\n    handleEvent(e);\r\n  };\r\n  const end = (e) => {\r\n    var _a2;\r\n    if (!filterEvent(e))\r\n      return;\r\n    if (!pressedDelta.value)\r\n      return;\r\n    pressedDelta.value = void 0;\r\n    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, position.value, e);\r\n    handleEvent(e);\r\n  };\r\n  if (isClient) {\r\n    useEventListener(draggingHandle, \"pointerdown\", start, true);\r\n    useEventListener(draggingElement, \"pointermove\", move, true);\r\n    useEventListener(draggingElement, \"pointerup\", end, true);\r\n  }\r\n  return __spreadProps$4(__spreadValues$f({}, toRefs(position)), {\r\n    position,\r\n    isDragging: computed(() => !!pressedDelta.value),\r\n    style: computed(() => `left:${position.value.x}px;top:${position.value.y}px;`)\r\n  });\r\n}\r\n\r\nfunction useDropZone(target, onDrop) {\r\n  const isOverDropZone = ref(false);\r\n  let counter = 0;\r\n  if (isClient) {\r\n    useEventListener(target, \"dragenter\", (event) => {\r\n      event.preventDefault();\r\n      counter += 1;\r\n      isOverDropZone.value = true;\r\n    });\r\n    useEventListener(target, \"dragover\", (event) => {\r\n      event.preventDefault();\r\n    });\r\n    useEventListener(target, \"dragleave\", (event) => {\r\n      event.preventDefault();\r\n      counter -= 1;\r\n      if (counter === 0)\r\n        isOverDropZone.value = false;\r\n    });\r\n    useEventListener(target, \"drop\", (event) => {\r\n      var _a, _b;\r\n      event.preventDefault();\r\n      counter = 0;\r\n      isOverDropZone.value = false;\r\n      const files = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\r\n      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);\r\n    });\r\n  }\r\n  return {\r\n    isOverDropZone\r\n  };\r\n}\r\n\r\nvar __getOwnPropSymbols$g = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$g = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$g = Object.prototype.propertyIsEnumerable;\r\nvar __objRest$2 = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$g)\r\n    for (var prop of __getOwnPropSymbols$g(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nfunction useResizeObserver(target, callback, options = {}) {\r\n  const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, [\"window\"]);\r\n  let observer;\r\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\r\n  const cleanup = () => {\r\n    if (observer) {\r\n      observer.disconnect();\r\n      observer = void 0;\r\n    }\r\n  };\r\n  const stopWatch = watch(() => unrefElement(target), (el) => {\r\n    cleanup();\r\n    if (isSupported.value && window && el) {\r\n      observer = new ResizeObserver(callback);\r\n      observer.observe(el, observerOptions);\r\n    }\r\n  }, { immediate: true, flush: \"post\" });\r\n  const stop = () => {\r\n    cleanup();\r\n    stopWatch();\r\n  };\r\n  tryOnScopeDispose(stop);\r\n  return {\r\n    isSupported,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useElementBounding(target, options = {}) {\r\n  const {\r\n    reset = true,\r\n    windowResize = true,\r\n    windowScroll = true,\r\n    immediate = true\r\n  } = options;\r\n  const height = ref(0);\r\n  const bottom = ref(0);\r\n  const left = ref(0);\r\n  const right = ref(0);\r\n  const top = ref(0);\r\n  const width = ref(0);\r\n  const x = ref(0);\r\n  const y = ref(0);\r\n  function update() {\r\n    const el = unrefElement(target);\r\n    if (!el) {\r\n      if (reset) {\r\n        height.value = 0;\r\n        bottom.value = 0;\r\n        left.value = 0;\r\n        right.value = 0;\r\n        top.value = 0;\r\n        width.value = 0;\r\n        x.value = 0;\r\n        y.value = 0;\r\n      }\r\n      return;\r\n    }\r\n    const rect = el.getBoundingClientRect();\r\n    height.value = rect.height;\r\n    bottom.value = rect.bottom;\r\n    left.value = rect.left;\r\n    right.value = rect.right;\r\n    top.value = rect.top;\r\n    width.value = rect.width;\r\n    x.value = rect.x;\r\n    y.value = rect.y;\r\n  }\r\n  useResizeObserver(target, update);\r\n  watch(() => unrefElement(target), (ele) => !ele && update());\r\n  if (windowScroll)\r\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\r\n  if (windowResize)\r\n    useEventListener(\"resize\", update, { passive: true });\r\n  tryOnMounted(() => {\r\n    if (immediate)\r\n      update();\r\n  });\r\n  return {\r\n    height,\r\n    bottom,\r\n    left,\r\n    right,\r\n    top,\r\n    width,\r\n    x,\r\n    y,\r\n    update\r\n  };\r\n}\r\n\r\nfunction useRafFn(fn, options = {}) {\r\n  const {\r\n    immediate = true,\r\n    window = defaultWindow\r\n  } = options;\r\n  const isActive = ref(false);\r\n  let previousFrameTimestamp = 0;\r\n  let rafId = null;\r\n  function loop(timestamp) {\r\n    if (!isActive.value || !window)\r\n      return;\r\n    const delta = timestamp - previousFrameTimestamp;\r\n    fn({ delta, timestamp });\r\n    previousFrameTimestamp = timestamp;\r\n    rafId = window.requestAnimationFrame(loop);\r\n  }\r\n  function resume() {\r\n    if (!isActive.value && window) {\r\n      isActive.value = true;\r\n      rafId = window.requestAnimationFrame(loop);\r\n    }\r\n  }\r\n  function pause() {\r\n    isActive.value = false;\r\n    if (rafId != null && window) {\r\n      window.cancelAnimationFrame(rafId);\r\n      rafId = null;\r\n    }\r\n  }\r\n  if (immediate)\r\n    resume();\r\n  tryOnScopeDispose(pause);\r\n  return {\r\n    isActive: readonly(isActive),\r\n    pause,\r\n    resume\r\n  };\r\n}\r\n\r\nvar __defProp$e = Object.defineProperty;\r\nvar __getOwnPropSymbols$f = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$f = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$f = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$e = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$f.call(b, prop))\r\n      __defNormalProp$e(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$f)\r\n    for (var prop of __getOwnPropSymbols$f(b)) {\r\n      if (__propIsEnum$f.call(b, prop))\r\n        __defNormalProp$e(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useElementByPoint(options) {\r\n  const element = ref(null);\r\n  const { x, y, document = defaultDocument } = options;\r\n  const controls = useRafFn(() => {\r\n    element.value = (document == null ? void 0 : document.elementFromPoint(resolveUnref(x), resolveUnref(y))) || null;\r\n  });\r\n  return __spreadValues$e({\r\n    element\r\n  }, controls);\r\n}\r\n\r\nfunction useElementHover(el, options = {}) {\r\n  const delayEnter = options ? options.delayEnter : 0;\r\n  const delayLeave = options ? options.delayLeave : 0;\r\n  const isHovered = ref(false);\r\n  let timer;\r\n  const toggle = (entering) => {\r\n    const delay = entering ? delayEnter : delayLeave;\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timer = void 0;\r\n    }\r\n    if (delay)\r\n      timer = setTimeout(() => isHovered.value = entering, delay);\r\n    else\r\n      isHovered.value = entering;\r\n  };\r\n  if (!window)\r\n    return isHovered;\r\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\r\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\r\n  return isHovered;\r\n}\r\n\r\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\r\n  const { window = defaultWindow, box = \"content-box\" } = options;\r\n  const isSVG = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\r\n  });\r\n  const width = ref(initialSize.width);\r\n  const height = ref(initialSize.height);\r\n  useResizeObserver(target, ([entry]) => {\r\n    const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\r\n    if (window && isSVG.value) {\r\n      const $elem = unrefElement(target);\r\n      if ($elem) {\r\n        const styles = window.getComputedStyle($elem);\r\n        width.value = parseFloat(styles.width);\r\n        height.value = parseFloat(styles.height);\r\n      }\r\n    } else {\r\n      if (boxSize) {\r\n        const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\r\n        width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\r\n        height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\r\n      } else {\r\n        width.value = entry.contentRect.width;\r\n        height.value = entry.contentRect.height;\r\n      }\r\n    }\r\n  }, options);\r\n  watch(() => unrefElement(target), (ele) => {\r\n    width.value = ele ? initialSize.width : 0;\r\n    height.value = ele ? initialSize.height : 0;\r\n  });\r\n  return {\r\n    width,\r\n    height\r\n  };\r\n}\r\n\r\nfunction useElementVisibility(element, { window = defaultWindow, scrollTarget } = {}) {\r\n  const elementIsVisible = ref(false);\r\n  const testBounding = () => {\r\n    if (!window)\r\n      return;\r\n    const document = window.document;\r\n    const el = unrefElement(element);\r\n    if (!el) {\r\n      elementIsVisible.value = false;\r\n    } else {\r\n      const rect = el.getBoundingClientRect();\r\n      elementIsVisible.value = rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0;\r\n    }\r\n  };\r\n  watch(() => unrefElement(element), () => testBounding(), { immediate: true, flush: \"post\" });\r\n  if (window) {\r\n    useEventListener(scrollTarget || window, \"scroll\", testBounding, {\r\n      capture: false,\r\n      passive: true\r\n    });\r\n  }\r\n  return elementIsVisible;\r\n}\r\n\r\nconst events = new Map();\r\n\r\nfunction useEventBus(key) {\r\n  const scope = getCurrentScope();\r\n  function on(listener) {\r\n    var _a;\r\n    const listeners = events.get(key) || [];\r\n    listeners.push(listener);\r\n    events.set(key, listeners);\r\n    const _off = () => off(listener);\r\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\r\n    return _off;\r\n  }\r\n  function once(listener) {\r\n    function _listener(...args) {\r\n      off(_listener);\r\n      listener(...args);\r\n    }\r\n    return on(_listener);\r\n  }\r\n  function off(listener) {\r\n    const listeners = events.get(key);\r\n    if (!listeners)\r\n      return;\r\n    const index = listeners.indexOf(listener);\r\n    if (index > -1)\r\n      listeners.splice(index, 1);\r\n    if (!listeners.length)\r\n      events.delete(key);\r\n  }\r\n  function reset() {\r\n    events.delete(key);\r\n  }\r\n  function emit(event, payload) {\r\n    var _a;\r\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\r\n  }\r\n  return { on, once, off, emit, reset };\r\n}\r\n\r\nfunction useEventSource(url, events = [], options = {}) {\r\n  const event = ref(null);\r\n  const data = ref(null);\r\n  const status = ref(\"CONNECTING\");\r\n  const eventSource = ref(null);\r\n  const error = ref(null);\r\n  const {\r\n    withCredentials = false\r\n  } = options;\r\n  const close = () => {\r\n    if (eventSource.value) {\r\n      eventSource.value.close();\r\n      eventSource.value = null;\r\n      status.value = \"CLOSED\";\r\n    }\r\n  };\r\n  const es = new EventSource(url, { withCredentials });\r\n  eventSource.value = es;\r\n  es.onopen = () => {\r\n    status.value = \"OPEN\";\r\n    error.value = null;\r\n  };\r\n  es.onerror = (e) => {\r\n    status.value = \"CLOSED\";\r\n    error.value = e;\r\n  };\r\n  es.onmessage = (e) => {\r\n    event.value = null;\r\n    data.value = e.data;\r\n  };\r\n  for (const event_name of events) {\r\n    useEventListener(es, event_name, (e) => {\r\n      event.value = event_name;\r\n      data.value = e.data || null;\r\n    });\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    close();\r\n  });\r\n  return {\r\n    eventSource,\r\n    event,\r\n    data,\r\n    status,\r\n    error,\r\n    close\r\n  };\r\n}\r\n\r\nfunction useEyeDropper(options = {}) {\r\n  const { initialValue = \"\" } = options;\r\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\r\n  const sRGBHex = ref(initialValue);\r\n  async function open(openOptions) {\r\n    if (!isSupported.value)\r\n      return;\r\n    const eyeDropper = new window.EyeDropper();\r\n    const result = await eyeDropper.open(openOptions);\r\n    sRGBHex.value = result.sRGBHex;\r\n    return result;\r\n  }\r\n  return { isSupported, sRGBHex, open };\r\n}\r\n\r\nfunction useFavicon(newIcon = null, options = {}) {\r\n  const {\r\n    baseUrl = \"\",\r\n    rel = \"icon\",\r\n    document = defaultDocument\r\n  } = options;\r\n  const favicon = resolveRef(newIcon);\r\n  const applyIcon = (icon) => {\r\n    document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`).forEach((el) => el.href = `${baseUrl}${icon}`);\r\n  };\r\n  watch(favicon, (i, o) => {\r\n    if (isString(i) && i !== o)\r\n      applyIcon(i);\r\n  }, { immediate: true });\r\n  return favicon;\r\n}\r\n\r\nvar __defProp$d = Object.defineProperty;\r\nvar __defProps$3 = Object.defineProperties;\r\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$e = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$e = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$e = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$d = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$e.call(b, prop))\r\n      __defNormalProp$d(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$e)\r\n    for (var prop of __getOwnPropSymbols$e(b)) {\r\n      if (__propIsEnum$e.call(b, prop))\r\n        __defNormalProp$d(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\r\nconst payloadMapping = {\r\n  json: \"application/json\",\r\n  text: \"text/plain\"\r\n};\r\nfunction isFetchOptions(obj) {\r\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\");\r\n}\r\nfunction isAbsoluteURL(url) {\r\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\r\n}\r\nfunction headersToObject(headers) {\r\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\r\n    return Object.fromEntries([...headers.entries()]);\r\n  return headers;\r\n}\r\nfunction combineCallbacks(combination, ...callbacks) {\r\n  if (combination === \"overwrite\") {\r\n    return async (ctx) => {\r\n      const callback = callbacks[callbacks.length - 1];\r\n      if (callback !== void 0)\r\n        await callback(ctx);\r\n      return ctx;\r\n    };\r\n  } else {\r\n    return async (ctx) => {\r\n      await callbacks.reduce((prevCallback, callback) => prevCallback.then(async () => {\r\n        if (callback)\r\n          ctx = __spreadValues$d(__spreadValues$d({}, ctx), await callback(ctx));\r\n      }), Promise.resolve());\r\n      return ctx;\r\n    };\r\n  }\r\n}\r\nfunction createFetch(config = {}) {\r\n  const _combination = config.combination || \"chain\";\r\n  const _options = config.options || {};\r\n  const _fetchOptions = config.fetchOptions || {};\r\n  function useFactoryFetch(url, ...args) {\r\n    const computedUrl = computed(() => {\r\n      const baseUrl = resolveUnref(config.baseUrl);\r\n      const targetUrl = resolveUnref(url);\r\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\r\n    });\r\n    let options = _options;\r\n    let fetchOptions = _fetchOptions;\r\n    if (args.length > 0) {\r\n      if (isFetchOptions(args[0])) {\r\n        options = __spreadProps$3(__spreadValues$d(__spreadValues$d({}, options), args[0]), {\r\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\r\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\r\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\r\n        });\r\n      } else {\r\n        fetchOptions = __spreadProps$3(__spreadValues$d(__spreadValues$d({}, fetchOptions), args[0]), {\r\n          headers: __spreadValues$d(__spreadValues$d({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})\r\n        });\r\n      }\r\n    }\r\n    if (args.length > 1 && isFetchOptions(args[1])) {\r\n      options = __spreadProps$3(__spreadValues$d(__spreadValues$d({}, options), args[1]), {\r\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\r\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\r\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\r\n      });\r\n    }\r\n    return useFetch(computedUrl, fetchOptions, options);\r\n  }\r\n  return useFactoryFetch;\r\n}\r\nfunction useFetch(url, ...args) {\r\n  var _a;\r\n  const supportsAbort = typeof AbortController === \"function\";\r\n  let fetchOptions = {};\r\n  let options = { immediate: true, refetch: false, timeout: 0 };\r\n  const config = {\r\n    method: \"GET\",\r\n    type: \"text\",\r\n    payload: void 0\r\n  };\r\n  if (args.length > 0) {\r\n    if (isFetchOptions(args[0]))\r\n      options = __spreadValues$d(__spreadValues$d({}, options), args[0]);\r\n    else\r\n      fetchOptions = args[0];\r\n  }\r\n  if (args.length > 1) {\r\n    if (isFetchOptions(args[1]))\r\n      options = __spreadValues$d(__spreadValues$d({}, options), args[1]);\r\n  }\r\n  const {\r\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\r\n    initialData,\r\n    timeout\r\n  } = options;\r\n  const responseEvent = createEventHook();\r\n  const errorEvent = createEventHook();\r\n  const finallyEvent = createEventHook();\r\n  const isFinished = ref(false);\r\n  const isFetching = ref(false);\r\n  const aborted = ref(false);\r\n  const statusCode = ref(null);\r\n  const response = shallowRef(null);\r\n  const error = shallowRef(null);\r\n  const data = shallowRef(initialData);\r\n  const canAbort = computed(() => supportsAbort && isFetching.value);\r\n  let controller;\r\n  let timer;\r\n  const abort = () => {\r\n    if (supportsAbort && controller) {\r\n      controller.abort();\r\n      controller = void 0;\r\n    }\r\n  };\r\n  const loading = (isLoading) => {\r\n    isFetching.value = isLoading;\r\n    isFinished.value = !isLoading;\r\n  };\r\n  if (timeout)\r\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\r\n  const execute = async (throwOnFailed = false) => {\r\n    var _a2;\r\n    loading(true);\r\n    error.value = null;\r\n    statusCode.value = null;\r\n    aborted.value = false;\r\n    if (supportsAbort) {\r\n      abort();\r\n      controller = new AbortController();\r\n      controller.signal.onabort = () => aborted.value = true;\r\n      fetchOptions = __spreadProps$3(__spreadValues$d({}, fetchOptions), {\r\n        signal: controller.signal\r\n      });\r\n    }\r\n    const defaultFetchOptions = {\r\n      method: config.method,\r\n      headers: {}\r\n    };\r\n    if (config.payload) {\r\n      const headers = headersToObject(defaultFetchOptions.headers);\r\n      if (config.payloadType)\r\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\r\n      const payload = resolveUnref(config.payload);\r\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\r\n    }\r\n    let isCanceled = false;\r\n    const context = {\r\n      url: resolveUnref(url),\r\n      options: __spreadValues$d(__spreadValues$d({}, defaultFetchOptions), fetchOptions),\r\n      cancel: () => {\r\n        isCanceled = true;\r\n      }\r\n    };\r\n    if (options.beforeFetch)\r\n      Object.assign(context, await options.beforeFetch(context));\r\n    if (isCanceled || !fetch) {\r\n      loading(false);\r\n      return Promise.resolve(null);\r\n    }\r\n    let responseData = null;\r\n    if (timer)\r\n      timer.start();\r\n    return new Promise((resolve, reject) => {\r\n      var _a3;\r\n      fetch(context.url, __spreadProps$3(__spreadValues$d(__spreadValues$d({}, defaultFetchOptions), context.options), {\r\n        headers: __spreadValues$d(__spreadValues$d({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))\r\n      })).then(async (fetchResponse) => {\r\n        response.value = fetchResponse;\r\n        statusCode.value = fetchResponse.status;\r\n        responseData = await fetchResponse[config.type]();\r\n        if (options.afterFetch && statusCode.value >= 200 && statusCode.value < 300)\r\n          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));\r\n        data.value = responseData;\r\n        if (!fetchResponse.ok)\r\n          throw new Error(fetchResponse.statusText);\r\n        responseEvent.trigger(fetchResponse);\r\n        return resolve(fetchResponse);\r\n      }).catch(async (fetchError) => {\r\n        let errorData = fetchError.message || fetchError.name;\r\n        if (options.onFetchError)\r\n          ({ data: responseData, error: errorData } = await options.onFetchError({ data: responseData, error: fetchError, response: response.value }));\r\n        data.value = responseData;\r\n        error.value = errorData;\r\n        errorEvent.trigger(fetchError);\r\n        if (throwOnFailed)\r\n          return reject(fetchError);\r\n        return resolve(null);\r\n      }).finally(() => {\r\n        loading(false);\r\n        if (timer)\r\n          timer.stop();\r\n        finallyEvent.trigger(null);\r\n      });\r\n    });\r\n  };\r\n  const refetch = resolveRef(options.refetch);\r\n  watch([\r\n    refetch,\r\n    resolveRef(url)\r\n  ], ([refetch2]) => refetch2 && execute(), { deep: true });\r\n  const shell = {\r\n    isFinished,\r\n    statusCode,\r\n    response,\r\n    error,\r\n    data,\r\n    isFetching,\r\n    canAbort,\r\n    aborted,\r\n    abort,\r\n    execute,\r\n    onFetchResponse: responseEvent.on,\r\n    onFetchError: errorEvent.on,\r\n    onFetchFinally: finallyEvent.on,\r\n    get: setMethod(\"GET\"),\r\n    put: setMethod(\"PUT\"),\r\n    post: setMethod(\"POST\"),\r\n    delete: setMethod(\"DELETE\"),\r\n    patch: setMethod(\"PATCH\"),\r\n    head: setMethod(\"HEAD\"),\r\n    options: setMethod(\"OPTIONS\"),\r\n    json: setType(\"json\"),\r\n    text: setType(\"text\"),\r\n    blob: setType(\"blob\"),\r\n    arrayBuffer: setType(\"arrayBuffer\"),\r\n    formData: setType(\"formData\")\r\n  };\r\n  function setMethod(method) {\r\n    return (payload, payloadType) => {\r\n      if (!isFetching.value) {\r\n        config.method = method;\r\n        config.payload = payload;\r\n        config.payloadType = payloadType;\r\n        if (isRef(config.payload)) {\r\n          watch([\r\n            refetch,\r\n            resolveRef(config.payload)\r\n          ], ([refetch2]) => refetch2 && execute(), { deep: true });\r\n        }\r\n        const rawPayload = resolveUnref(config.payload);\r\n        if (!payloadType && rawPayload && Object.getPrototypeOf(rawPayload) === Object.prototype && !(rawPayload instanceof FormData))\r\n          config.payloadType = \"json\";\r\n        return __spreadProps$3(__spreadValues$d({}, shell), {\r\n          then(onFulfilled, onRejected) {\r\n            return waitUntilFinished().then(onFulfilled, onRejected);\r\n          }\r\n        });\r\n      }\r\n      return void 0;\r\n    };\r\n  }\r\n  function waitUntilFinished() {\r\n    return new Promise((resolve, reject) => {\r\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\r\n    });\r\n  }\r\n  function setType(type) {\r\n    return () => {\r\n      if (!isFetching.value) {\r\n        config.type = type;\r\n        return __spreadProps$3(__spreadValues$d({}, shell), {\r\n          then(onFulfilled, onRejected) {\r\n            return waitUntilFinished().then(onFulfilled, onRejected);\r\n          }\r\n        });\r\n      }\r\n      return void 0;\r\n    };\r\n  }\r\n  if (options.immediate)\r\n    setTimeout(execute, 0);\r\n  return __spreadProps$3(__spreadValues$d({}, shell), {\r\n    then(onFulfilled, onRejected) {\r\n      return waitUntilFinished().then(onFulfilled, onRejected);\r\n    }\r\n  });\r\n}\r\nfunction joinPaths(start, end) {\r\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\r\n    return `${start}/${end}`;\r\n  return `${start}${end}`;\r\n}\r\n\r\nvar __defProp$c = Object.defineProperty;\r\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$c = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$d.call(b, prop))\r\n      __defNormalProp$c(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$d)\r\n    for (var prop of __getOwnPropSymbols$d(b)) {\r\n      if (__propIsEnum$d.call(b, prop))\r\n        __defNormalProp$c(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nconst DEFAULT_OPTIONS = {\r\n  multiple: true,\r\n  accept: \"*\"\r\n};\r\nfunction useFileDialog(options = {}) {\r\n  const {\r\n    document = defaultDocument\r\n  } = options;\r\n  const files = ref(null);\r\n  let input;\r\n  if (document) {\r\n    input = document.createElement(\"input\");\r\n    input.type = \"file\";\r\n    input.onchange = (event) => {\r\n      const result = event.target;\r\n      files.value = result.files;\r\n    };\r\n  }\r\n  const open = (localOptions) => {\r\n    if (!input)\r\n      return;\r\n    const _options = __spreadValues$c(__spreadValues$c(__spreadValues$c({}, DEFAULT_OPTIONS), options), localOptions);\r\n    input.multiple = _options.multiple;\r\n    input.accept = _options.accept;\r\n    if (hasOwn(_options, \"capture\"))\r\n      input.capture = _options.capture;\r\n    input.click();\r\n  };\r\n  const reset = () => {\r\n    files.value = null;\r\n    if (input)\r\n      input.value = \"\";\r\n  };\r\n  return {\r\n    files: readonly(files),\r\n    open,\r\n    reset\r\n  };\r\n}\r\n\r\nvar __defProp$b = Object.defineProperty;\r\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$b = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$c.call(b, prop))\r\n      __defNormalProp$b(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$c)\r\n    for (var prop of __getOwnPropSymbols$c(b)) {\r\n      if (__propIsEnum$c.call(b, prop))\r\n        __defNormalProp$b(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useFileSystemAccess(options = {}) {\r\n  const {\r\n    window: _window = defaultWindow,\r\n    dataType = \"Text\"\r\n  } = unref(options);\r\n  const window = _window;\r\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\r\n  const fileHandle = ref();\r\n  const data = ref();\r\n  const file = ref();\r\n  const fileName = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\r\n  });\r\n  const fileMIME = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\r\n  });\r\n  const fileSize = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\r\n  });\r\n  const fileLastModified = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\r\n  });\r\n  async function open(_options = {}) {\r\n    if (!isSupported.value)\r\n      return;\r\n    const [handle] = await window.showOpenFilePicker(__spreadValues$b(__spreadValues$b({}, unref(options)), _options));\r\n    fileHandle.value = handle;\r\n    await updateFile();\r\n    await updateData();\r\n  }\r\n  async function create(_options = {}) {\r\n    if (!isSupported.value)\r\n      return;\r\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$b(__spreadValues$b({}, unref(options)), _options));\r\n    data.value = void 0;\r\n    await updateFile();\r\n    await updateData();\r\n  }\r\n  async function save(_options = {}) {\r\n    if (!isSupported.value)\r\n      return;\r\n    if (!fileHandle.value)\r\n      return saveAs(_options);\r\n    if (data.value) {\r\n      const writableStream = await fileHandle.value.createWritable();\r\n      await writableStream.write(data.value);\r\n      await writableStream.close();\r\n    }\r\n    await updateFile();\r\n  }\r\n  async function saveAs(_options = {}) {\r\n    if (!isSupported.value)\r\n      return;\r\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$b(__spreadValues$b({}, unref(options)), _options));\r\n    if (data.value) {\r\n      const writableStream = await fileHandle.value.createWritable();\r\n      await writableStream.write(data.value);\r\n      await writableStream.close();\r\n    }\r\n    await updateFile();\r\n  }\r\n  async function updateFile() {\r\n    var _a;\r\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\r\n  }\r\n  async function updateData() {\r\n    var _a, _b;\r\n    if (unref(dataType) === \"Text\")\r\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\r\n    if (unref(dataType) === \"ArrayBuffer\")\r\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\r\n    if (unref(dataType) === \"Blob\")\r\n      data.value = file.value;\r\n  }\r\n  watch(() => unref(dataType), updateData);\r\n  return {\r\n    isSupported,\r\n    data,\r\n    file,\r\n    fileName,\r\n    fileMIME,\r\n    fileSize,\r\n    fileLastModified,\r\n    open,\r\n    create,\r\n    save,\r\n    saveAs,\r\n    updateData\r\n  };\r\n}\r\n\r\nfunction useFocus(target, options = {}) {\r\n  const { initialValue = false } = options;\r\n  const innerFocused = ref(false);\r\n  const targetElement = computed(() => unrefElement(target));\r\n  useEventListener(targetElement, \"focus\", () => innerFocused.value = true);\r\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\r\n  const focused = computed({\r\n    get: () => innerFocused.value,\r\n    set(value) {\r\n      var _a, _b;\r\n      if (!value && innerFocused.value)\r\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\r\n      else if (value && !innerFocused.value)\r\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\r\n    }\r\n  });\r\n  watch(targetElement, () => {\r\n    focused.value = initialValue;\r\n  }, { immediate: true, flush: \"post\" });\r\n  return { focused };\r\n}\r\n\r\nfunction useFocusWithin(target, options = {}) {\r\n  const activeElement = useActiveElement(options);\r\n  const targetElement = computed(() => unrefElement(target));\r\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\r\n  return { focused };\r\n}\r\n\r\nfunction useFps(options) {\r\n  var _a;\r\n  const fps = ref(0);\r\n  if (typeof performance === \"undefined\")\r\n    return fps;\r\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\r\n  let last = performance.now();\r\n  let ticks = 0;\r\n  useRafFn(() => {\r\n    ticks += 1;\r\n    if (ticks >= every) {\r\n      const now = performance.now();\r\n      const diff = now - last;\r\n      fps.value = Math.round(1e3 / (diff / ticks));\r\n      last = now;\r\n      ticks = 0;\r\n    }\r\n  });\r\n  return fps;\r\n}\r\n\r\nconst functionsMap = [\r\n  [\r\n    \"requestFullscreen\",\r\n    \"exitFullscreen\",\r\n    \"fullscreenElement\",\r\n    \"fullscreenEnabled\",\r\n    \"fullscreenchange\",\r\n    \"fullscreenerror\"\r\n  ],\r\n  [\r\n    \"webkitRequestFullscreen\",\r\n    \"webkitExitFullscreen\",\r\n    \"webkitFullscreenElement\",\r\n    \"webkitFullscreenEnabled\",\r\n    \"webkitfullscreenchange\",\r\n    \"webkitfullscreenerror\"\r\n  ],\r\n  [\r\n    \"webkitRequestFullScreen\",\r\n    \"webkitCancelFullScreen\",\r\n    \"webkitCurrentFullScreenElement\",\r\n    \"webkitCancelFullScreen\",\r\n    \"webkitfullscreenchange\",\r\n    \"webkitfullscreenerror\"\r\n  ],\r\n  [\r\n    \"mozRequestFullScreen\",\r\n    \"mozCancelFullScreen\",\r\n    \"mozFullScreenElement\",\r\n    \"mozFullScreenEnabled\",\r\n    \"mozfullscreenchange\",\r\n    \"mozfullscreenerror\"\r\n  ],\r\n  [\r\n    \"msRequestFullscreen\",\r\n    \"msExitFullscreen\",\r\n    \"msFullscreenElement\",\r\n    \"msFullscreenEnabled\",\r\n    \"MSFullscreenChange\",\r\n    \"MSFullscreenError\"\r\n  ]\r\n];\r\nfunction useFullscreen(target, options = {}) {\r\n  const { document = defaultDocument, autoExit = false } = options;\r\n  const targetRef = target || (document == null ? void 0 : document.querySelector(\"html\"));\r\n  const isFullscreen = ref(false);\r\n  let map = functionsMap[0];\r\n  const isSupported = useSupported(() => {\r\n    if (!document) {\r\n      return false;\r\n    } else {\r\n      for (const m of functionsMap) {\r\n        if (m[1] in document) {\r\n          map = m;\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  });\r\n  const [REQUEST, EXIT, ELEMENT, , EVENT] = map;\r\n  async function exit() {\r\n    if (!isSupported.value)\r\n      return;\r\n    if (document == null ? void 0 : document[ELEMENT])\r\n      await document[EXIT]();\r\n    isFullscreen.value = false;\r\n  }\r\n  async function enter() {\r\n    if (!isSupported.value)\r\n      return;\r\n    await exit();\r\n    const target2 = unrefElement(targetRef);\r\n    if (target2) {\r\n      await target2[REQUEST]();\r\n      isFullscreen.value = true;\r\n    }\r\n  }\r\n  async function toggle() {\r\n    if (isFullscreen.value)\r\n      await exit();\r\n    else\r\n      await enter();\r\n  }\r\n  if (document) {\r\n    useEventListener(document, EVENT, () => {\r\n      isFullscreen.value = !!(document == null ? void 0 : document[ELEMENT]);\r\n    }, false);\r\n  }\r\n  if (autoExit)\r\n    tryOnScopeDispose(exit);\r\n  return {\r\n    isSupported,\r\n    isFullscreen,\r\n    enter,\r\n    exit,\r\n    toggle\r\n  };\r\n}\r\n\r\nfunction mapGamepadToXbox360Controller(gamepad) {\r\n  return computed(() => {\r\n    if (gamepad.value) {\r\n      return {\r\n        buttons: {\r\n          a: gamepad.value.buttons[0],\r\n          b: gamepad.value.buttons[1],\r\n          x: gamepad.value.buttons[2],\r\n          y: gamepad.value.buttons[3]\r\n        },\r\n        bumper: {\r\n          left: gamepad.value.buttons[4],\r\n          right: gamepad.value.buttons[5]\r\n        },\r\n        triggers: {\r\n          left: gamepad.value.buttons[6],\r\n          right: gamepad.value.buttons[7]\r\n        },\r\n        stick: {\r\n          left: {\r\n            horizontal: gamepad.value.axes[0],\r\n            vertical: gamepad.value.axes[1],\r\n            button: gamepad.value.buttons[10]\r\n          },\r\n          right: {\r\n            horizontal: gamepad.value.axes[2],\r\n            vertical: gamepad.value.axes[3],\r\n            button: gamepad.value.buttons[11]\r\n          }\r\n        },\r\n        dpad: {\r\n          up: gamepad.value.buttons[12],\r\n          down: gamepad.value.buttons[13],\r\n          left: gamepad.value.buttons[14],\r\n          right: gamepad.value.buttons[15]\r\n        },\r\n        back: gamepad.value.buttons[8],\r\n        start: gamepad.value.buttons[9]\r\n      };\r\n    }\r\n    return null;\r\n  });\r\n}\r\nfunction useGamepad(options = {}) {\r\n  const {\r\n    navigator = defaultNavigator\r\n  } = options;\r\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\r\n  const gamepads = ref([]);\r\n  const onConnectedHook = createEventHook();\r\n  const onDisconnectedHook = createEventHook();\r\n  const stateFromGamepad = (gamepad) => {\r\n    const hapticActuators = [];\r\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\r\n    if (vibrationActuator)\r\n      hapticActuators.push(vibrationActuator);\r\n    if (gamepad.hapticActuators)\r\n      hapticActuators.push(...gamepad.hapticActuators);\r\n    return {\r\n      id: gamepad.id,\r\n      hapticActuators,\r\n      index: gamepad.index,\r\n      mapping: gamepad.mapping,\r\n      connected: gamepad.connected,\r\n      timestamp: gamepad.timestamp,\r\n      axes: gamepad.axes.map((axes) => axes),\r\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\r\n    };\r\n  };\r\n  const updateGamepadState = () => {\r\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\r\n    for (let i = 0; i < _gamepads.length; ++i) {\r\n      const gamepad = _gamepads[i];\r\n      if (gamepad) {\r\n        const index = gamepads.value.findIndex(({ index: index2 }) => index2 === gamepad.index);\r\n        if (index > -1)\r\n          gamepads.value[index] = stateFromGamepad(gamepad);\r\n      }\r\n    }\r\n  };\r\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\r\n  const onGamepadConnected = (gamepad) => {\r\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\r\n      gamepads.value.push(stateFromGamepad(gamepad));\r\n      onConnectedHook.trigger(gamepad.index);\r\n    }\r\n    resume();\r\n  };\r\n  const onGamepadDisconnected = (gamepad) => {\r\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\r\n    onDisconnectedHook.trigger(gamepad.index);\r\n  };\r\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\r\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\r\n  tryOnMounted(() => {\r\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\r\n    if (_gamepads) {\r\n      for (let i = 0; i < _gamepads.length; ++i) {\r\n        const gamepad = _gamepads[i];\r\n        if (gamepad)\r\n          onGamepadConnected(gamepad);\r\n      }\r\n    }\r\n  });\r\n  pause();\r\n  return {\r\n    isSupported,\r\n    onConnected: onConnectedHook.on,\r\n    onDisconnected: onDisconnectedHook.on,\r\n    gamepads,\r\n    pause,\r\n    resume,\r\n    isActive\r\n  };\r\n}\r\n\r\nfunction useGeolocation(options = {}) {\r\n  const {\r\n    enableHighAccuracy = true,\r\n    maximumAge = 3e4,\r\n    timeout = 27e3,\r\n    navigator = defaultNavigator,\r\n    immediate = true\r\n  } = options;\r\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\r\n  const locatedAt = ref(null);\r\n  const error = ref(null);\r\n  const coords = ref({\r\n    accuracy: 0,\r\n    latitude: Infinity,\r\n    longitude: Infinity,\r\n    altitude: null,\r\n    altitudeAccuracy: null,\r\n    heading: null,\r\n    speed: null\r\n  });\r\n  function updatePosition(position) {\r\n    locatedAt.value = position.timestamp;\r\n    coords.value = position.coords;\r\n    error.value = null;\r\n  }\r\n  let watcher;\r\n  function resume() {\r\n    if (isSupported.value) {\r\n      watcher = navigator.geolocation.watchPosition(updatePosition, (err) => error.value = err, {\r\n        enableHighAccuracy,\r\n        maximumAge,\r\n        timeout\r\n      });\r\n    }\r\n  }\r\n  if (immediate)\r\n    resume();\r\n  function pause() {\r\n    if (watcher && navigator)\r\n      navigator.geolocation.clearWatch(watcher);\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    pause();\r\n  });\r\n  return {\r\n    isSupported,\r\n    coords,\r\n    locatedAt,\r\n    error,\r\n    resume,\r\n    pause\r\n  };\r\n}\r\n\r\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\r\nconst oneMinute = 6e4;\r\nfunction useIdle(timeout = oneMinute, options = {}) {\r\n  const {\r\n    initialState = false,\r\n    listenForVisibilityChange = true,\r\n    events = defaultEvents$1,\r\n    window = defaultWindow,\r\n    eventFilter = throttleFilter(50)\r\n  } = options;\r\n  const idle = ref(initialState);\r\n  const lastActive = ref(timestamp());\r\n  let timer;\r\n  const onEvent = createFilterWrapper(eventFilter, () => {\r\n    idle.value = false;\r\n    lastActive.value = timestamp();\r\n    clearTimeout(timer);\r\n    timer = setTimeout(() => idle.value = true, timeout);\r\n  });\r\n  if (window) {\r\n    const document = window.document;\r\n    for (const event of events)\r\n      useEventListener(window, event, onEvent, { passive: true });\r\n    if (listenForVisibilityChange) {\r\n      useEventListener(document, \"visibilitychange\", () => {\r\n        if (!document.hidden)\r\n          onEvent();\r\n      });\r\n    }\r\n  }\r\n  timer = setTimeout(() => idle.value = true, timeout);\r\n  return { idle, lastActive };\r\n}\r\n\r\nvar __defProp$a = Object.defineProperty;\r\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$a = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$b.call(b, prop))\r\n      __defNormalProp$a(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$b)\r\n    for (var prop of __getOwnPropSymbols$b(b)) {\r\n      if (__propIsEnum$b.call(b, prop))\r\n        __defNormalProp$a(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nasync function loadImage(options) {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    const { src, srcset, sizes } = options;\r\n    img.src = src;\r\n    if (srcset)\r\n      img.srcset = srcset;\r\n    if (sizes)\r\n      img.sizes = sizes;\r\n    img.onload = () => resolve(img);\r\n    img.onerror = reject;\r\n  });\r\n}\r\nconst useImage = (options, asyncStateOptions = {}) => {\r\n  const state = useAsyncState(() => loadImage(resolveUnref(options)), void 0, __spreadValues$a({\r\n    resetOnExecute: true\r\n  }, asyncStateOptions));\r\n  watch(() => resolveUnref(options), () => state.execute(asyncStateOptions.delay), { deep: true });\r\n  return state;\r\n};\r\n\r\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\r\nfunction useScroll(element, options = {}) {\r\n  const {\r\n    throttle = 0,\r\n    idle = 200,\r\n    onStop = noop,\r\n    onScroll = noop,\r\n    offset = {\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0\r\n    },\r\n    eventListenerOptions = {\r\n      capture: false,\r\n      passive: true\r\n    },\r\n    behavior = \"auto\"\r\n  } = options;\r\n  const internalX = ref(0);\r\n  const internalY = ref(0);\r\n  const x = computed({\r\n    get() {\r\n      return internalX.value;\r\n    },\r\n    set(x2) {\r\n      scrollTo(x2, void 0);\r\n    }\r\n  });\r\n  const y = computed({\r\n    get() {\r\n      return internalY.value;\r\n    },\r\n    set(y2) {\r\n      scrollTo(void 0, y2);\r\n    }\r\n  });\r\n  function scrollTo(_x, _y) {\r\n    var _a, _b, _c;\r\n    const _element = resolveUnref(element);\r\n    if (!_element)\r\n      return;\r\n    (_c = _element instanceof Document ? document.body : _element) == null ? void 0 : _c.scrollTo({\r\n      top: (_a = resolveUnref(_y)) != null ? _a : y.value,\r\n      left: (_b = resolveUnref(_x)) != null ? _b : x.value,\r\n      behavior: resolveUnref(behavior)\r\n    });\r\n  }\r\n  const isScrolling = ref(false);\r\n  const arrivedState = reactive({\r\n    left: true,\r\n    right: false,\r\n    top: true,\r\n    bottom: false\r\n  });\r\n  const directions = reactive({\r\n    left: false,\r\n    right: false,\r\n    top: false,\r\n    bottom: false\r\n  });\r\n  const onScrollEnd = (e) => {\r\n    if (!isScrolling.value)\r\n      return;\r\n    isScrolling.value = false;\r\n    directions.left = false;\r\n    directions.right = false;\r\n    directions.top = false;\r\n    directions.bottom = false;\r\n    onStop(e);\r\n  };\r\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\r\n  const onScrollHandler = (e) => {\r\n    const eventTarget = e.target === document ? e.target.documentElement : e.target;\r\n    const scrollLeft = eventTarget.scrollLeft;\r\n    directions.left = scrollLeft < internalX.value;\r\n    directions.right = scrollLeft > internalY.value;\r\n    arrivedState.left = scrollLeft <= 0 + (offset.left || 0);\r\n    arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\r\n    internalX.value = scrollLeft;\r\n    let scrollTop = eventTarget.scrollTop;\r\n    if (e.target === document && !scrollTop)\r\n      scrollTop = document.body.scrollTop;\r\n    directions.top = scrollTop < internalY.value;\r\n    directions.bottom = scrollTop > internalY.value;\r\n    arrivedState.top = scrollTop <= 0 + (offset.top || 0);\r\n    arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\r\n    internalY.value = scrollTop;\r\n    isScrolling.value = true;\r\n    onScrollEndDebounced(e);\r\n    onScroll(e);\r\n  };\r\n  useEventListener(element, \"scroll\", throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler, eventListenerOptions);\r\n  useEventListener(element, \"scrollend\", onScrollEnd, eventListenerOptions);\r\n  return {\r\n    x,\r\n    y,\r\n    isScrolling,\r\n    arrivedState,\r\n    directions\r\n  };\r\n}\r\n\r\nvar __defProp$9 = Object.defineProperty;\r\nvar __defProps$2 = Object.defineProperties;\r\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$9 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$a.call(b, prop))\r\n      __defNormalProp$9(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$a)\r\n    for (var prop of __getOwnPropSymbols$a(b)) {\r\n      if (__propIsEnum$a.call(b, prop))\r\n        __defNormalProp$9(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\r\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\r\n  var _a, _b;\r\n  const direction = (_a = options.direction) != null ? _a : \"bottom\";\r\n  const state = reactive(useScroll(element, __spreadProps$2(__spreadValues$9({}, options), {\r\n    offset: __spreadValues$9({\r\n      [direction]: (_b = options.distance) != null ? _b : 0\r\n    }, options.offset)\r\n  })));\r\n  watch(() => state.arrivedState[direction], async (v) => {\r\n    var _a2, _b2;\r\n    if (v) {\r\n      const elem = resolveUnref(element);\r\n      const previous = {\r\n        height: (_a2 = elem == null ? void 0 : elem.scrollHeight) != null ? _a2 : 0,\r\n        width: (_b2 = elem == null ? void 0 : elem.scrollWidth) != null ? _b2 : 0\r\n      };\r\n      await onLoadMore(state);\r\n      if (options.preserveScrollPosition && elem) {\r\n        nextTick(() => {\r\n          elem.scrollTo({\r\n            top: elem.scrollHeight - previous.height,\r\n            left: elem.scrollWidth - previous.width\r\n          });\r\n        });\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction useIntersectionObserver(target, callback, options = {}) {\r\n  const {\r\n    root,\r\n    rootMargin = \"0px\",\r\n    threshold = 0.1,\r\n    window = defaultWindow\r\n  } = options;\r\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\r\n  let cleanup = noop;\r\n  const stopWatch = isSupported.value ? watch(() => ({\r\n    el: unrefElement(target),\r\n    root: unrefElement(root)\r\n  }), ({ el, root: root2 }) => {\r\n    cleanup();\r\n    if (!el)\r\n      return;\r\n    const observer = new IntersectionObserver(callback, {\r\n      root: root2,\r\n      rootMargin,\r\n      threshold\r\n    });\r\n    observer.observe(el);\r\n    cleanup = () => {\r\n      observer.disconnect();\r\n      cleanup = noop;\r\n    };\r\n  }, { immediate: true, flush: \"post\" }) : noop;\r\n  const stop = () => {\r\n    cleanup();\r\n    stopWatch();\r\n  };\r\n  tryOnScopeDispose(stop);\r\n  return {\r\n    isSupported,\r\n    stop\r\n  };\r\n}\r\n\r\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\r\nfunction useKeyModifier(modifier, options = {}) {\r\n  const {\r\n    events = defaultEvents,\r\n    document = defaultDocument,\r\n    initial = null\r\n  } = options;\r\n  const state = ref(initial);\r\n  if (document) {\r\n    events.forEach((listenerEvent) => {\r\n      useEventListener(document, listenerEvent, (evt) => {\r\n        if (typeof evt.getModifierState === \"function\")\r\n          state.value = evt.getModifierState(modifier);\r\n      });\r\n    });\r\n  }\r\n  return state;\r\n}\r\n\r\nfunction useLocalStorage(key, initialValue, options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\r\n}\r\n\r\nconst DefaultMagicKeysAliasMap = {\r\n  ctrl: \"control\",\r\n  command: \"meta\",\r\n  cmd: \"meta\",\r\n  option: \"alt\",\r\n  up: \"arrowup\",\r\n  down: \"arrowdown\",\r\n  left: \"arrowleft\",\r\n  right: \"arrowright\"\r\n};\r\n\r\nfunction useMagicKeys(options = {}) {\r\n  const {\r\n    reactive: useReactive = false,\r\n    target = defaultWindow,\r\n    aliasMap = DefaultMagicKeysAliasMap,\r\n    passive = true,\r\n    onEventFired = noop\r\n  } = options;\r\n  const current = reactive(new Set());\r\n  const obj = {\r\n    toJSON() {\r\n      return {};\r\n    },\r\n    current\r\n  };\r\n  const refs = useReactive ? reactive(obj) : obj;\r\n  const metaDeps = new Set();\r\n  const usedKeys = new Set();\r\n  function setRefs(key, value) {\r\n    if (key in refs) {\r\n      if (useReactive)\r\n        refs[key] = value;\r\n      else\r\n        refs[key].value = value;\r\n    }\r\n  }\r\n  function reset() {\r\n    current.clear();\r\n    for (const key of usedKeys)\r\n      setRefs(key, false);\r\n  }\r\n  function updateRefs(e, value) {\r\n    var _a, _b;\r\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\r\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\r\n    const values = [code, key].filter(Boolean);\r\n    if (key) {\r\n      if (value)\r\n        current.add(key);\r\n      else\r\n        current.delete(key);\r\n    }\r\n    for (const key2 of values) {\r\n      usedKeys.add(key2);\r\n      setRefs(key2, value);\r\n    }\r\n    if (key === \"meta\" && !value) {\r\n      metaDeps.forEach((key2) => {\r\n        current.delete(key2);\r\n        setRefs(key2, false);\r\n      });\r\n      metaDeps.clear();\r\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\r\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\r\n    }\r\n  }\r\n  useEventListener(target, \"keydown\", (e) => {\r\n    updateRefs(e, true);\r\n    return onEventFired(e);\r\n  }, { passive });\r\n  useEventListener(target, \"keyup\", (e) => {\r\n    updateRefs(e, false);\r\n    return onEventFired(e);\r\n  }, { passive });\r\n  useEventListener(\"blur\", reset, { passive: true });\r\n  useEventListener(\"focus\", reset, { passive: true });\r\n  const proxy = new Proxy(refs, {\r\n    get(target2, prop, rec) {\r\n      if (typeof prop !== \"string\")\r\n        return Reflect.get(target2, prop, rec);\r\n      prop = prop.toLowerCase();\r\n      if (prop in aliasMap)\r\n        prop = aliasMap[prop];\r\n      if (!(prop in refs)) {\r\n        if (/[+_-]/.test(prop)) {\r\n          const keys = prop.split(/[+_-]/g).map((i) => i.trim());\r\n          refs[prop] = computed(() => keys.every((key) => unref(proxy[key])));\r\n        } else {\r\n          refs[prop] = ref(false);\r\n        }\r\n      }\r\n      const r = Reflect.get(target2, prop, rec);\r\n      return useReactive ? unref(r) : r;\r\n    }\r\n  });\r\n  return proxy;\r\n}\r\n\r\nvar __defProp$8 = Object.defineProperty;\r\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$8 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$9.call(b, prop))\r\n      __defNormalProp$8(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$9)\r\n    for (var prop of __getOwnPropSymbols$9(b)) {\r\n      if (__propIsEnum$9.call(b, prop))\r\n        __defNormalProp$8(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction usingElRef(source, cb) {\r\n  if (resolveUnref(source))\r\n    cb(resolveUnref(source));\r\n}\r\nfunction timeRangeToArray(timeRanges) {\r\n  let ranges = [];\r\n  for (let i = 0; i < timeRanges.length; ++i)\r\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\r\n  return ranges;\r\n}\r\nfunction tracksToArray(tracks) {\r\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\r\n}\r\nconst defaultOptions = {\r\n  src: \"\",\r\n  tracks: []\r\n};\r\nfunction useMediaControls(target, options = {}) {\r\n  options = __spreadValues$8(__spreadValues$8({}, defaultOptions), options);\r\n  const {\r\n    document = defaultDocument\r\n  } = options;\r\n  const currentTime = ref(0);\r\n  const duration = ref(0);\r\n  const seeking = ref(false);\r\n  const volume = ref(1);\r\n  const waiting = ref(false);\r\n  const ended = ref(false);\r\n  const playing = ref(false);\r\n  const rate = ref(1);\r\n  const stalled = ref(false);\r\n  const buffered = ref([]);\r\n  const tracks = ref([]);\r\n  const selectedTrack = ref(-1);\r\n  const isPictureInPicture = ref(false);\r\n  const muted = ref(false);\r\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\r\n  const sourceErrorEvent = createEventHook();\r\n  const disableTrack = (track) => {\r\n    usingElRef(target, (el) => {\r\n      if (track) {\r\n        const id = isNumber(track) ? track : track.id;\r\n        el.textTracks[id].mode = \"disabled\";\r\n      } else {\r\n        for (let i = 0; i < el.textTracks.length; ++i)\r\n          el.textTracks[i].mode = \"disabled\";\r\n      }\r\n      selectedTrack.value = -1;\r\n    });\r\n  };\r\n  const enableTrack = (track, disableTracks = true) => {\r\n    usingElRef(target, (el) => {\r\n      const id = isNumber(track) ? track : track.id;\r\n      if (disableTracks)\r\n        disableTrack();\r\n      el.textTracks[id].mode = \"showing\";\r\n      selectedTrack.value = id;\r\n    });\r\n  };\r\n  const togglePictureInPicture = () => {\r\n    return new Promise((resolve, reject) => {\r\n      usingElRef(target, async (el) => {\r\n        if (supportsPictureInPicture) {\r\n          if (!isPictureInPicture.value) {\r\n            el.requestPictureInPicture().then(resolve).catch(reject);\r\n          } else {\r\n            document.exitPictureInPicture().then(resolve).catch(reject);\r\n          }\r\n        }\r\n      });\r\n    });\r\n  };\r\n  watchEffect(() => {\r\n    if (!document)\r\n      return;\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    const src = resolveUnref(options.src);\r\n    let sources = [];\r\n    if (!src)\r\n      return;\r\n    if (isString(src))\r\n      sources = [{ src }];\r\n    else if (Array.isArray(src))\r\n      sources = src;\r\n    else if (isObject(src))\r\n      sources = [src];\r\n    el.querySelectorAll(\"source\").forEach((e) => {\r\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\r\n      e.remove();\r\n    });\r\n    sources.forEach(({ src: src2, type }) => {\r\n      const source = document.createElement(\"source\");\r\n      source.setAttribute(\"src\", src2);\r\n      source.setAttribute(\"type\", type || \"\");\r\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\r\n      el.appendChild(source);\r\n    });\r\n    el.load();\r\n  });\r\n  tryOnScopeDispose(() => {\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\r\n  });\r\n  watch(volume, (vol) => {\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    el.volume = vol;\r\n  });\r\n  watch(muted, (mute) => {\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    el.muted = mute;\r\n  });\r\n  watch(rate, (rate2) => {\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    el.playbackRate = rate2;\r\n  });\r\n  watchEffect(() => {\r\n    if (!document)\r\n      return;\r\n    const textTracks = resolveUnref(options.tracks);\r\n    const el = resolveUnref(target);\r\n    if (!textTracks || !textTracks.length || !el)\r\n      return;\r\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\r\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\r\n      const track = document.createElement(\"track\");\r\n      track.default = isDefault || false;\r\n      track.kind = kind;\r\n      track.label = label;\r\n      track.src = src;\r\n      track.srclang = srcLang;\r\n      if (track.default)\r\n        selectedTrack.value = i;\r\n      el.appendChild(track);\r\n    });\r\n  });\r\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    el.currentTime = time;\r\n  });\r\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    isPlaying ? el.play() : el.pause();\r\n  });\r\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = resolveUnref(target).currentTime));\r\n  useEventListener(target, \"durationchange\", () => duration.value = resolveUnref(target).duration);\r\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(resolveUnref(target).buffered));\r\n  useEventListener(target, \"seeking\", () => seeking.value = true);\r\n  useEventListener(target, \"seeked\", () => seeking.value = false);\r\n  useEventListener(target, \"waiting\", () => waiting.value = true);\r\n  useEventListener(target, \"playing\", () => {\r\n    waiting.value = false;\r\n    ended.value = false;\r\n  });\r\n  useEventListener(target, \"ratechange\", () => rate.value = resolveUnref(target).playbackRate);\r\n  useEventListener(target, \"stalled\", () => stalled.value = true);\r\n  useEventListener(target, \"ended\", () => ended.value = true);\r\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\r\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\r\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\r\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\r\n  useEventListener(target, \"volumechange\", () => {\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    volume.value = el.volume;\r\n    muted.value = el.muted;\r\n  });\r\n  const listeners = [];\r\n  const stop = watch([target], () => {\r\n    const el = resolveUnref(target);\r\n    if (!el)\r\n      return;\r\n    stop();\r\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\r\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\r\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\r\n  });\r\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\r\n  return {\r\n    currentTime,\r\n    duration,\r\n    waiting,\r\n    seeking,\r\n    ended,\r\n    stalled,\r\n    buffered,\r\n    playing,\r\n    rate,\r\n    volume,\r\n    muted,\r\n    tracks,\r\n    selectedTrack,\r\n    enableTrack,\r\n    disableTrack,\r\n    supportsPictureInPicture,\r\n    togglePictureInPicture,\r\n    isPictureInPicture,\r\n    onSourceError: sourceErrorEvent.on\r\n  };\r\n}\r\n\r\nconst getMapVue2Compat = () => {\r\n  const data = reactive({});\r\n  return {\r\n    get: (key) => data[key],\r\n    set: (key, value) => set(data, key, value),\r\n    has: (key) => hasOwn(data, key),\r\n    delete: (key) => del(data, key),\r\n    clear: () => {\r\n      Object.keys(data).forEach((key) => {\r\n        del(data, key);\r\n      });\r\n    }\r\n  };\r\n};\r\nfunction useMemoize(resolver, options) {\r\n  const initCache = () => {\r\n    if (options == null ? void 0 : options.cache)\r\n      return reactive(options.cache);\r\n    if (isVue2)\r\n      return getMapVue2Compat();\r\n    return reactive(new Map());\r\n  };\r\n  const cache = initCache();\r\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\r\n  const _loadData = (key, ...args) => {\r\n    cache.set(key, resolver(...args));\r\n    return cache.get(key);\r\n  };\r\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\r\n  const deleteData = (...args) => {\r\n    cache.delete(generateKey(...args));\r\n  };\r\n  const clearData = () => {\r\n    cache.clear();\r\n  };\r\n  const memoized = (...args) => {\r\n    const key = generateKey(...args);\r\n    if (cache.has(key))\r\n      return cache.get(key);\r\n    return _loadData(key, ...args);\r\n  };\r\n  memoized.load = loadData;\r\n  memoized.delete = deleteData;\r\n  memoized.clear = clearData;\r\n  memoized.generateKey = generateKey;\r\n  memoized.cache = cache;\r\n  return memoized;\r\n}\r\n\r\nfunction useMemory(options = {}) {\r\n  const memory = ref();\r\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\r\n  if (isSupported.value) {\r\n    const { interval = 1e3 } = options;\r\n    useIntervalFn(() => {\r\n      memory.value = performance.memory;\r\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\r\n  }\r\n  return { isSupported, memory };\r\n}\r\n\r\nfunction useMounted() {\r\n  const isMounted = ref(false);\r\n  onMounted(() => {\r\n    isMounted.value = true;\r\n  });\r\n  return isMounted;\r\n}\r\n\r\nfunction useMouse(options = {}) {\r\n  const {\r\n    type = \"page\",\r\n    touch = true,\r\n    resetOnTouchEnds = false,\r\n    initialValue = { x: 0, y: 0 },\r\n    window = defaultWindow,\r\n    eventFilter\r\n  } = options;\r\n  const x = ref(initialValue.x);\r\n  const y = ref(initialValue.y);\r\n  const sourceType = ref(null);\r\n  const mouseHandler = (event) => {\r\n    if (type === \"page\") {\r\n      x.value = event.pageX;\r\n      y.value = event.pageY;\r\n    } else if (type === \"client\") {\r\n      x.value = event.clientX;\r\n      y.value = event.clientY;\r\n    } else if (type === \"movement\") {\r\n      x.value = event.movementX;\r\n      y.value = event.movementY;\r\n    }\r\n    sourceType.value = \"mouse\";\r\n  };\r\n  const reset = () => {\r\n    x.value = initialValue.x;\r\n    y.value = initialValue.y;\r\n  };\r\n  const touchHandler = (event) => {\r\n    if (event.touches.length > 0) {\r\n      const touch2 = event.touches[0];\r\n      if (type === \"page\") {\r\n        x.value = touch2.pageX;\r\n        y.value = touch2.pageY;\r\n      } else if (type === \"client\") {\r\n        x.value = touch2.clientX;\r\n        y.value = touch2.clientY;\r\n      }\r\n      sourceType.value = \"touch\";\r\n    }\r\n  };\r\n  const mouseHandlerWrapper = (event) => {\r\n    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});\r\n  };\r\n  const touchHandlerWrapper = (event) => {\r\n    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});\r\n  };\r\n  if (window) {\r\n    useEventListener(window, \"mousemove\", mouseHandlerWrapper, { passive: true });\r\n    useEventListener(window, \"dragover\", mouseHandlerWrapper, { passive: true });\r\n    if (touch && type !== \"movement\") {\r\n      useEventListener(window, \"touchstart\", touchHandlerWrapper, { passive: true });\r\n      useEventListener(window, \"touchmove\", touchHandlerWrapper, { passive: true });\r\n      if (resetOnTouchEnds)\r\n        useEventListener(window, \"touchend\", reset, { passive: true });\r\n    }\r\n  }\r\n  return {\r\n    x,\r\n    y,\r\n    sourceType\r\n  };\r\n}\r\n\r\nfunction useMouseInElement(target, options = {}) {\r\n  const {\r\n    handleOutside = true,\r\n    window = defaultWindow\r\n  } = options;\r\n  const { x, y, sourceType } = useMouse(options);\r\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\r\n  const elementX = ref(0);\r\n  const elementY = ref(0);\r\n  const elementPositionX = ref(0);\r\n  const elementPositionY = ref(0);\r\n  const elementHeight = ref(0);\r\n  const elementWidth = ref(0);\r\n  const isOutside = ref(true);\r\n  let stop = () => {\r\n  };\r\n  if (window) {\r\n    stop = watch([targetRef, x, y], () => {\r\n      const el = unrefElement(targetRef);\r\n      if (!el)\r\n        return;\r\n      const {\r\n        left,\r\n        top,\r\n        width,\r\n        height\r\n      } = el.getBoundingClientRect();\r\n      elementPositionX.value = left + window.pageXOffset;\r\n      elementPositionY.value = top + window.pageYOffset;\r\n      elementHeight.value = height;\r\n      elementWidth.value = width;\r\n      const elX = x.value - elementPositionX.value;\r\n      const elY = y.value - elementPositionY.value;\r\n      isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\r\n      if (handleOutside || !isOutside.value) {\r\n        elementX.value = elX;\r\n        elementY.value = elY;\r\n      }\r\n    }, { immediate: true });\r\n    useEventListener(document, \"mouseleave\", () => {\r\n      isOutside.value = true;\r\n    });\r\n  }\r\n  return {\r\n    x,\r\n    y,\r\n    sourceType,\r\n    elementX,\r\n    elementY,\r\n    elementPositionX,\r\n    elementPositionY,\r\n    elementHeight,\r\n    elementWidth,\r\n    isOutside,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useMousePressed(options = {}) {\r\n  const {\r\n    touch = true,\r\n    drag = true,\r\n    initialValue = false,\r\n    window = defaultWindow\r\n  } = options;\r\n  const pressed = ref(initialValue);\r\n  const sourceType = ref(null);\r\n  if (!window) {\r\n    return {\r\n      pressed,\r\n      sourceType\r\n    };\r\n  }\r\n  const onPressed = (srcType) => () => {\r\n    pressed.value = true;\r\n    sourceType.value = srcType;\r\n  };\r\n  const onReleased = () => {\r\n    pressed.value = false;\r\n    sourceType.value = null;\r\n  };\r\n  const target = computed(() => unrefElement(options.target) || window);\r\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true });\r\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true });\r\n  useEventListener(window, \"mouseup\", onReleased, { passive: true });\r\n  if (drag) {\r\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true });\r\n    useEventListener(window, \"drop\", onReleased, { passive: true });\r\n    useEventListener(window, \"dragend\", onReleased, { passive: true });\r\n  }\r\n  if (touch) {\r\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true });\r\n    useEventListener(window, \"touchend\", onReleased, { passive: true });\r\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true });\r\n  }\r\n  return {\r\n    pressed,\r\n    sourceType\r\n  };\r\n}\r\n\r\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\r\nvar __objRest$1 = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$8)\r\n    for (var prop of __getOwnPropSymbols$8(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nfunction useMutationObserver(target, callback, options = {}) {\r\n  const _a = options, { window = defaultWindow } = _a, mutationOptions = __objRest$1(_a, [\"window\"]);\r\n  let observer;\r\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\r\n  const cleanup = () => {\r\n    if (observer) {\r\n      observer.disconnect();\r\n      observer = void 0;\r\n    }\r\n  };\r\n  const stopWatch = watch(() => unrefElement(target), (el) => {\r\n    cleanup();\r\n    if (isSupported.value && window && el) {\r\n      observer = new MutationObserver(callback);\r\n      observer.observe(el, mutationOptions);\r\n    }\r\n  }, { immediate: true });\r\n  const stop = () => {\r\n    cleanup();\r\n    stopWatch();\r\n  };\r\n  tryOnScopeDispose(stop);\r\n  return {\r\n    isSupported,\r\n    stop\r\n  };\r\n}\r\n\r\nconst useNavigatorLanguage = (options = {}) => {\r\n  const { window = defaultWindow } = options;\r\n  const navigator = window == null ? void 0 : window.navigator;\r\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\r\n  const language = ref(navigator == null ? void 0 : navigator.language);\r\n  useEventListener(window, \"languagechange\", () => {\r\n    if (navigator)\r\n      language.value = navigator.language;\r\n  });\r\n  return {\r\n    isSupported,\r\n    language\r\n  };\r\n};\r\n\r\nfunction useNetwork(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const navigator = window == null ? void 0 : window.navigator;\r\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\r\n  const isOnline = ref(true);\r\n  const saveData = ref(false);\r\n  const offlineAt = ref(void 0);\r\n  const onlineAt = ref(void 0);\r\n  const downlink = ref(void 0);\r\n  const downlinkMax = ref(void 0);\r\n  const rtt = ref(void 0);\r\n  const effectiveType = ref(void 0);\r\n  const type = ref(\"unknown\");\r\n  const connection = isSupported.value && navigator.connection;\r\n  function updateNetworkInformation() {\r\n    if (!navigator)\r\n      return;\r\n    isOnline.value = navigator.onLine;\r\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\r\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\r\n    if (connection) {\r\n      downlink.value = connection.downlink;\r\n      downlinkMax.value = connection.downlinkMax;\r\n      effectiveType.value = connection.effectiveType;\r\n      rtt.value = connection.rtt;\r\n      saveData.value = connection.saveData;\r\n      type.value = connection.type;\r\n    }\r\n  }\r\n  if (window) {\r\n    useEventListener(window, \"offline\", () => {\r\n      isOnline.value = false;\r\n      offlineAt.value = Date.now();\r\n    });\r\n    useEventListener(window, \"online\", () => {\r\n      isOnline.value = true;\r\n      onlineAt.value = Date.now();\r\n    });\r\n  }\r\n  if (connection)\r\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\r\n  updateNetworkInformation();\r\n  return {\r\n    isSupported,\r\n    isOnline,\r\n    saveData,\r\n    offlineAt,\r\n    onlineAt,\r\n    downlink,\r\n    downlinkMax,\r\n    effectiveType,\r\n    rtt,\r\n    type\r\n  };\r\n}\r\n\r\nvar __defProp$7 = Object.defineProperty;\r\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$7 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$7.call(b, prop))\r\n      __defNormalProp$7(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$7)\r\n    for (var prop of __getOwnPropSymbols$7(b)) {\r\n      if (__propIsEnum$7.call(b, prop))\r\n        __defNormalProp$7(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useNow(options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    interval = \"requestAnimationFrame\"\r\n  } = options;\r\n  const now = ref(new Date());\r\n  const update = () => now.value = new Date();\r\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\r\n  if (exposeControls) {\r\n    return __spreadValues$7({\r\n      now\r\n    }, controls);\r\n  } else {\r\n    return now;\r\n  }\r\n}\r\n\r\nfunction useObjectUrl(object) {\r\n  const url = ref();\r\n  const release = () => {\r\n    if (url.value)\r\n      URL.revokeObjectURL(url.value);\r\n    url.value = void 0;\r\n  };\r\n  watch(() => unref(object), (newObject) => {\r\n    release();\r\n    if (newObject)\r\n      url.value = URL.createObjectURL(newObject);\r\n  }, { immediate: true });\r\n  tryOnScopeDispose(release);\r\n  return readonly(url);\r\n}\r\n\r\nfunction useClamp(value, min, max) {\r\n  if (isFunction(value) || isReadonly(value))\r\n    return computed(() => clamp(resolveUnref(value), resolveUnref(min), resolveUnref(max)));\r\n  const _value = ref(value);\r\n  return computed({\r\n    get() {\r\n      return _value.value = clamp(_value.value, resolveUnref(min), resolveUnref(max));\r\n    },\r\n    set(value2) {\r\n      _value.value = clamp(value2, resolveUnref(min), resolveUnref(max));\r\n    }\r\n  });\r\n}\r\n\r\nfunction useOffsetPagination(options) {\r\n  const {\r\n    total = Infinity,\r\n    pageSize = 10,\r\n    page = 1,\r\n    onPageChange = noop,\r\n    onPageSizeChange = noop,\r\n    onPageCountChange = noop\r\n  } = options;\r\n  const currentPageSize = useClamp(pageSize, 1, Infinity);\r\n  const pageCount = computed(() => Math.max(1, Math.ceil(unref(total) / unref(currentPageSize))));\r\n  const currentPage = useClamp(page, 1, pageCount);\r\n  const isFirstPage = computed(() => currentPage.value === 1);\r\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\r\n  if (isRef(page))\r\n    syncRef(page, currentPage);\r\n  if (isRef(pageSize))\r\n    syncRef(pageSize, currentPageSize);\r\n  function prev() {\r\n    currentPage.value--;\r\n  }\r\n  function next() {\r\n    currentPage.value++;\r\n  }\r\n  const returnValue = {\r\n    currentPage,\r\n    currentPageSize,\r\n    pageCount,\r\n    isFirstPage,\r\n    isLastPage,\r\n    prev,\r\n    next\r\n  };\r\n  watch(currentPage, () => {\r\n    onPageChange(reactive(returnValue));\r\n  });\r\n  watch(currentPageSize, () => {\r\n    onPageSizeChange(reactive(returnValue));\r\n  });\r\n  watch(pageCount, () => {\r\n    onPageCountChange(reactive(returnValue));\r\n  });\r\n  return returnValue;\r\n}\r\n\r\nfunction useOnline(options = {}) {\r\n  const { isOnline } = useNetwork(options);\r\n  return isOnline;\r\n}\r\n\r\nfunction usePageLeave(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  const isLeft = ref(false);\r\n  const handler = (event) => {\r\n    if (!window)\r\n      return;\r\n    event = event || window.event;\r\n    const from = event.relatedTarget || event.toElement;\r\n    isLeft.value = !from;\r\n  };\r\n  if (window) {\r\n    useEventListener(window, \"mouseout\", handler, { passive: true });\r\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\r\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\r\n  }\r\n  return isLeft;\r\n}\r\n\r\nfunction useParallax(target, options = {}) {\r\n  const {\r\n    deviceOrientationTiltAdjust = (i) => i,\r\n    deviceOrientationRollAdjust = (i) => i,\r\n    mouseTiltAdjust = (i) => i,\r\n    mouseRollAdjust = (i) => i,\r\n    window = defaultWindow\r\n  } = options;\r\n  const orientation = reactive(useDeviceOrientation({ window }));\r\n  const {\r\n    elementX: x,\r\n    elementY: y,\r\n    elementWidth: width,\r\n    elementHeight: height\r\n  } = useMouseInElement(target, { handleOutside: false, window });\r\n  const source = computed(() => {\r\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\r\n      return \"deviceOrientation\";\r\n    return \"mouse\";\r\n  });\r\n  const roll = computed(() => {\r\n    if (source.value === \"deviceOrientation\") {\r\n      const value = -orientation.beta / 90;\r\n      return deviceOrientationRollAdjust(value);\r\n    } else {\r\n      const value = -(y.value - height.value / 2) / height.value;\r\n      return mouseRollAdjust(value);\r\n    }\r\n  });\r\n  const tilt = computed(() => {\r\n    if (source.value === \"deviceOrientation\") {\r\n      const value = orientation.gamma / 90;\r\n      return deviceOrientationTiltAdjust(value);\r\n    } else {\r\n      const value = (x.value - width.value / 2) / width.value;\r\n      return mouseTiltAdjust(value);\r\n    }\r\n  });\r\n  return { roll, tilt, source };\r\n}\r\n\r\nvar __defProp$6 = Object.defineProperty;\r\nvar __defProps$1 = Object.defineProperties;\r\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$6 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$6.call(b, prop))\r\n      __defNormalProp$6(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$6)\r\n    for (var prop of __getOwnPropSymbols$6(b)) {\r\n      if (__propIsEnum$6.call(b, prop))\r\n        __defNormalProp$6(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\r\nconst defaultState = {\r\n  x: 0,\r\n  y: 0,\r\n  pointerId: 0,\r\n  pressure: 0,\r\n  tiltX: 0,\r\n  tiltY: 0,\r\n  width: 0,\r\n  height: 0,\r\n  twist: 0,\r\n  pointerType: null\r\n};\r\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\r\nfunction usePointer(options = {}) {\r\n  const {\r\n    target = defaultWindow\r\n  } = options;\r\n  const isInside = ref(false);\r\n  const state = ref(options.initialValue || {});\r\n  Object.assign(state.value, defaultState, state.value);\r\n  const handler = (event) => {\r\n    isInside.value = true;\r\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\r\n      return;\r\n    state.value = objectPick(event, keys, false);\r\n  };\r\n  if (target) {\r\n    useEventListener(target, \"pointerdown\", handler, { passive: true });\r\n    useEventListener(target, \"pointermove\", handler, { passive: true });\r\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, { passive: true });\r\n  }\r\n  return __spreadProps$1(__spreadValues$6({}, toRefs(state)), {\r\n    isInside\r\n  });\r\n}\r\n\r\nfunction usePointerLock(target, options = {}) {\r\n  const { document = defaultDocument, pointerLockOptions } = options;\r\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\r\n  const element = ref();\r\n  const triggerElement = ref();\r\n  let targetElement;\r\n  if (isSupported.value) {\r\n    useEventListener(document, \"pointerlockchange\", () => {\r\n      var _a;\r\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\r\n      if (targetElement && currentElement === targetElement) {\r\n        element.value = document.pointerLockElement;\r\n        if (!element.value)\r\n          targetElement = triggerElement.value = null;\r\n      }\r\n    });\r\n    useEventListener(document, \"pointerlockerror\", () => {\r\n      var _a;\r\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\r\n      if (targetElement && currentElement === targetElement) {\r\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\r\n        throw new Error(`Failed to ${action} pointer lock.`);\r\n      }\r\n    });\r\n  }\r\n  async function lock(e, options2) {\r\n    var _a;\r\n    if (!isSupported.value)\r\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\r\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\r\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\r\n    if (!targetElement)\r\n      throw new Error(\"Target element undefined.\");\r\n    targetElement.requestPointerLock(options2 != null ? options2 : pointerLockOptions);\r\n    return await until(element).toBe(targetElement);\r\n  }\r\n  async function unlock() {\r\n    if (!element.value)\r\n      return false;\r\n    document.exitPointerLock();\r\n    await until(element).toBeNull();\r\n    return true;\r\n  }\r\n  return {\r\n    isSupported,\r\n    element,\r\n    triggerElement,\r\n    lock,\r\n    unlock\r\n  };\r\n}\r\n\r\nvar SwipeDirection;\r\n(function(SwipeDirection2) {\r\n  SwipeDirection2[\"UP\"] = \"UP\";\r\n  SwipeDirection2[\"RIGHT\"] = \"RIGHT\";\r\n  SwipeDirection2[\"DOWN\"] = \"DOWN\";\r\n  SwipeDirection2[\"LEFT\"] = \"LEFT\";\r\n  SwipeDirection2[\"NONE\"] = \"NONE\";\r\n})(SwipeDirection || (SwipeDirection = {}));\r\nfunction useSwipe(target, options = {}) {\r\n  const {\r\n    threshold = 50,\r\n    onSwipe,\r\n    onSwipeEnd,\r\n    onSwipeStart,\r\n    passive = true,\r\n    window = defaultWindow\r\n  } = options;\r\n  const coordsStart = reactive({ x: 0, y: 0 });\r\n  const coordsEnd = reactive({ x: 0, y: 0 });\r\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\r\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\r\n  const { max, abs } = Math;\r\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\r\n  const isSwiping = ref(false);\r\n  const direction = computed(() => {\r\n    if (!isThresholdExceeded.value)\r\n      return SwipeDirection.NONE;\r\n    if (abs(diffX.value) > abs(diffY.value)) {\r\n      return diffX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\r\n    } else {\r\n      return diffY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\r\n    }\r\n  });\r\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\r\n  const updateCoordsStart = (x, y) => {\r\n    coordsStart.x = x;\r\n    coordsStart.y = y;\r\n  };\r\n  const updateCoordsEnd = (x, y) => {\r\n    coordsEnd.x = x;\r\n    coordsEnd.y = y;\r\n  };\r\n  let listenerOptions;\r\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\r\n  if (!passive)\r\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\r\n  else\r\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\r\n  const onTouchEnd = (e) => {\r\n    if (isSwiping.value)\r\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\r\n    isSwiping.value = false;\r\n  };\r\n  const stops = [\r\n    useEventListener(target, \"touchstart\", (e) => {\r\n      if (listenerOptions.capture && !listenerOptions.passive)\r\n        e.preventDefault();\r\n      const [x, y] = getTouchEventCoords(e);\r\n      updateCoordsStart(x, y);\r\n      updateCoordsEnd(x, y);\r\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\r\n    }, listenerOptions),\r\n    useEventListener(target, \"touchmove\", (e) => {\r\n      const [x, y] = getTouchEventCoords(e);\r\n      updateCoordsEnd(x, y);\r\n      if (!isSwiping.value && isThresholdExceeded.value)\r\n        isSwiping.value = true;\r\n      if (isSwiping.value)\r\n        onSwipe == null ? void 0 : onSwipe(e);\r\n    }, listenerOptions),\r\n    useEventListener(target, \"touchend\", onTouchEnd, listenerOptions),\r\n    useEventListener(target, \"touchcancel\", onTouchEnd, listenerOptions)\r\n  ];\r\n  const stop = () => stops.forEach((s) => s());\r\n  return {\r\n    isPassiveEventSupported,\r\n    isSwiping,\r\n    direction,\r\n    coordsStart,\r\n    coordsEnd,\r\n    lengthX: diffX,\r\n    lengthY: diffY,\r\n    stop\r\n  };\r\n}\r\nfunction checkPassiveEventSupport(document) {\r\n  if (!document)\r\n    return false;\r\n  let supportsPassive = false;\r\n  const optionsBlock = {\r\n    get passive() {\r\n      supportsPassive = true;\r\n      return false;\r\n    }\r\n  };\r\n  document.addEventListener(\"x\", noop, optionsBlock);\r\n  document.removeEventListener(\"x\", noop);\r\n  return supportsPassive;\r\n}\r\n\r\nfunction usePointerSwipe(target, options = {}) {\r\n  const targetRef = resolveRef(target);\r\n  const {\r\n    threshold = 50,\r\n    onSwipe,\r\n    onSwipeEnd,\r\n    onSwipeStart\r\n  } = options;\r\n  const posStart = reactive({ x: 0, y: 0 });\r\n  const updatePosStart = (x, y) => {\r\n    posStart.x = x;\r\n    posStart.y = y;\r\n  };\r\n  const posEnd = reactive({ x: 0, y: 0 });\r\n  const updatePosEnd = (x, y) => {\r\n    posEnd.x = x;\r\n    posEnd.y = y;\r\n  };\r\n  const distanceX = computed(() => posStart.x - posEnd.x);\r\n  const distanceY = computed(() => posStart.y - posEnd.y);\r\n  const { max, abs } = Math;\r\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\r\n  const isSwiping = ref(false);\r\n  const isPointerDown = ref(false);\r\n  const direction = computed(() => {\r\n    if (!isThresholdExceeded.value)\r\n      return SwipeDirection.NONE;\r\n    if (abs(distanceX.value) > abs(distanceY.value)) {\r\n      return distanceX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\r\n    } else {\r\n      return distanceY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\r\n    }\r\n  });\r\n  const eventIsAllowed = (e) => {\r\n    var _a, _b, _c;\r\n    const isReleasingButton = e.buttons === 0;\r\n    const isPrimaryButton = e.buttons === 1;\r\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\r\n  };\r\n  const stops = [\r\n    useEventListener(target, \"pointerdown\", (e) => {\r\n      var _a, _b;\r\n      if (!eventIsAllowed(e))\r\n        return;\r\n      isPointerDown.value = true;\r\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\r\n      const eventTarget = e.target;\r\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\r\n      const { clientX: x, clientY: y } = e;\r\n      updatePosStart(x, y);\r\n      updatePosEnd(x, y);\r\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\r\n    }),\r\n    useEventListener(target, \"pointermove\", (e) => {\r\n      if (!eventIsAllowed(e))\r\n        return;\r\n      if (!isPointerDown.value)\r\n        return;\r\n      const { clientX: x, clientY: y } = e;\r\n      updatePosEnd(x, y);\r\n      if (!isSwiping.value && isThresholdExceeded.value)\r\n        isSwiping.value = true;\r\n      if (isSwiping.value)\r\n        onSwipe == null ? void 0 : onSwipe(e);\r\n    }),\r\n    useEventListener(target, \"pointerup\", (e) => {\r\n      var _a, _b;\r\n      if (!eventIsAllowed(e))\r\n        return;\r\n      if (isSwiping.value)\r\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\r\n      isPointerDown.value = false;\r\n      isSwiping.value = false;\r\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"initial\");\r\n    })\r\n  ];\r\n  const stop = () => stops.forEach((s) => s());\r\n  return {\r\n    isSwiping: readonly(isSwiping),\r\n    direction: readonly(direction),\r\n    posStart: readonly(posStart),\r\n    posEnd: readonly(posEnd),\r\n    distanceX,\r\n    distanceY,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction usePreferredColorScheme(options) {\r\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\r\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\r\n  return computed(() => {\r\n    if (isDark.value)\r\n      return \"dark\";\r\n    if (isLight.value)\r\n      return \"light\";\r\n    return \"no-preference\";\r\n  });\r\n}\r\n\r\nfunction usePreferredContrast(options) {\r\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\r\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\r\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\r\n  return computed(() => {\r\n    if (isMore.value)\r\n      return \"more\";\r\n    if (isLess.value)\r\n      return \"less\";\r\n    if (isCustom.value)\r\n      return \"custom\";\r\n    return \"no-preference\";\r\n  });\r\n}\r\n\r\nfunction usePreferredLanguages(options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  if (!window)\r\n    return ref([\"en\"]);\r\n  const navigator = window.navigator;\r\n  const value = ref(navigator.languages);\r\n  useEventListener(window, \"languagechange\", () => {\r\n    value.value = navigator.languages;\r\n  });\r\n  return value;\r\n}\r\n\r\nfunction usePreferredReducedMotion(options) {\r\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\r\n  return computed(() => {\r\n    if (isReduced.value)\r\n      return \"reduce\";\r\n    return \"no-preference\";\r\n  });\r\n}\r\n\r\nfunction usePrevious(value, initialValue) {\r\n  const previous = shallowRef(initialValue);\r\n  watch(resolveRef(value), (_, oldValue) => {\r\n    previous.value = oldValue;\r\n  }, { flush: \"sync\" });\r\n  return readonly(previous);\r\n}\r\n\r\nconst useScreenOrientation = (options = {}) => {\r\n  const {\r\n    window = defaultWindow\r\n  } = options;\r\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\r\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\r\n  const orientation = ref(screenOrientation.type);\r\n  const angle = ref(screenOrientation.angle || 0);\r\n  if (isSupported.value) {\r\n    useEventListener(window, \"orientationchange\", () => {\r\n      orientation.value = screenOrientation.type;\r\n      angle.value = screenOrientation.angle;\r\n    });\r\n  }\r\n  const lockOrientation = (type) => {\r\n    if (!isSupported.value)\r\n      return Promise.reject(new Error(\"Not supported\"));\r\n    return screenOrientation.lock(type);\r\n  };\r\n  const unlockOrientation = () => {\r\n    if (isSupported.value)\r\n      screenOrientation.unlock();\r\n  };\r\n  return {\r\n    isSupported,\r\n    orientation,\r\n    angle,\r\n    lockOrientation,\r\n    unlockOrientation\r\n  };\r\n};\r\n\r\nconst topVarName = \"--vueuse-safe-area-top\";\r\nconst rightVarName = \"--vueuse-safe-area-right\";\r\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\r\nconst leftVarName = \"--vueuse-safe-area-left\";\r\nfunction useScreenSafeArea() {\r\n  const top = ref(\"\");\r\n  const right = ref(\"\");\r\n  const bottom = ref(\"\");\r\n  const left = ref(\"\");\r\n  if (isClient) {\r\n    const topCssVar = useCssVar(topVarName);\r\n    const rightCssVar = useCssVar(rightVarName);\r\n    const bottomCssVar = useCssVar(bottomVarName);\r\n    const leftCssVar = useCssVar(leftVarName);\r\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\r\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\r\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\r\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\r\n    update();\r\n    useEventListener(\"resize\", useDebounceFn(update));\r\n  }\r\n  function update() {\r\n    top.value = getValue(topVarName);\r\n    right.value = getValue(rightVarName);\r\n    bottom.value = getValue(bottomVarName);\r\n    left.value = getValue(leftVarName);\r\n  }\r\n  return {\r\n    top,\r\n    right,\r\n    bottom,\r\n    left,\r\n    update\r\n  };\r\n}\r\nfunction getValue(position) {\r\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\r\n}\r\n\r\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\r\n  const {\r\n    immediate = true,\r\n    manual = false,\r\n    type = \"text/javascript\",\r\n    async = true,\r\n    crossOrigin,\r\n    referrerPolicy,\r\n    noModule,\r\n    defer,\r\n    document = defaultDocument,\r\n    attrs = {}\r\n  } = options;\r\n  const scriptTag = ref(null);\r\n  let _promise = null;\r\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\r\n    const resolveWithElement = (el2) => {\r\n      scriptTag.value = el2;\r\n      resolve(el2);\r\n      return el2;\r\n    };\r\n    if (!document) {\r\n      resolve(false);\r\n      return;\r\n    }\r\n    let shouldAppend = false;\r\n    let el = document.querySelector(`script[src=\"${resolveUnref(src)}\"]`);\r\n    if (!el) {\r\n      el = document.createElement(\"script\");\r\n      el.type = type;\r\n      el.async = async;\r\n      el.src = resolveUnref(src);\r\n      if (defer)\r\n        el.defer = defer;\r\n      if (crossOrigin)\r\n        el.crossOrigin = crossOrigin;\r\n      if (noModule)\r\n        el.noModule = noModule;\r\n      if (referrerPolicy)\r\n        el.referrerPolicy = referrerPolicy;\r\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\r\n      shouldAppend = true;\r\n    } else if (el.hasAttribute(\"data-loaded\")) {\r\n      resolveWithElement(el);\r\n    }\r\n    el.addEventListener(\"error\", (event) => reject(event));\r\n    el.addEventListener(\"abort\", (event) => reject(event));\r\n    el.addEventListener(\"load\", () => {\r\n      el.setAttribute(\"data-loaded\", \"true\");\r\n      onLoaded(el);\r\n      resolveWithElement(el);\r\n    });\r\n    if (shouldAppend)\r\n      el = document.head.appendChild(el);\r\n    if (!waitForScriptLoad)\r\n      resolveWithElement(el);\r\n  });\r\n  const load = (waitForScriptLoad = true) => {\r\n    if (!_promise)\r\n      _promise = loadScript(waitForScriptLoad);\r\n    return _promise;\r\n  };\r\n  const unload = () => {\r\n    if (!document)\r\n      return;\r\n    _promise = null;\r\n    if (scriptTag.value)\r\n      scriptTag.value = null;\r\n    const el = document.querySelector(`script[src=\"${resolveUnref(src)}\"]`);\r\n    if (el)\r\n      document.head.removeChild(el);\r\n  };\r\n  if (immediate && !manual)\r\n    tryOnMounted(load);\r\n  if (!manual)\r\n    tryOnUnmounted(unload);\r\n  return { scriptTag, load, unload };\r\n}\r\n\r\nfunction checkOverflowScroll(ele) {\r\n  const style = window.getComputedStyle(ele);\r\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientHeight < ele.scrollHeight || style.overflowY === \"auto\" && ele.clientWidth < ele.scrollWidth) {\r\n    return true;\r\n  } else {\r\n    const parent = ele.parentNode;\r\n    if (!parent || parent.tagName === \"BODY\")\r\n      return false;\r\n    return checkOverflowScroll(parent);\r\n  }\r\n}\r\nfunction preventDefault(rawEvent) {\r\n  const e = rawEvent || window.event;\r\n  const _target = e.target;\r\n  if (checkOverflowScroll(_target))\r\n    return false;\r\n  if (e.touches.length > 1)\r\n    return true;\r\n  if (e.preventDefault)\r\n    e.preventDefault();\r\n  return false;\r\n}\r\nfunction useScrollLock(element, initialState = false) {\r\n  const isLocked = ref(initialState);\r\n  let stopTouchMoveListener = null;\r\n  let initialOverflow;\r\n  watch(resolveRef(element), (el) => {\r\n    if (el) {\r\n      const ele = el;\r\n      initialOverflow = ele.style.overflow;\r\n      if (isLocked.value)\r\n        ele.style.overflow = \"hidden\";\r\n    }\r\n  }, {\r\n    immediate: true\r\n  });\r\n  const lock = () => {\r\n    const ele = resolveUnref(element);\r\n    if (!ele || isLocked.value)\r\n      return;\r\n    if (isIOS) {\r\n      stopTouchMoveListener = useEventListener(ele, \"touchmove\", (e) => {\r\n        preventDefault(e);\r\n      }, { passive: false });\r\n    }\r\n    ele.style.overflow = \"hidden\";\r\n    isLocked.value = true;\r\n  };\r\n  const unlock = () => {\r\n    const ele = resolveUnref(element);\r\n    if (!ele || !isLocked.value)\r\n      return;\r\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\r\n    ele.style.overflow = initialOverflow;\r\n    isLocked.value = false;\r\n  };\r\n  tryOnScopeDispose(unlock);\r\n  return computed({\r\n    get() {\r\n      return isLocked.value;\r\n    },\r\n    set(v) {\r\n      if (v)\r\n        lock();\r\n      else\r\n        unlock();\r\n    }\r\n  });\r\n}\r\n\r\nfunction useSessionStorage(key, initialValue, options = {}) {\r\n  const { window = defaultWindow } = options;\r\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\r\n}\r\n\r\nvar __defProp$5 = Object.defineProperty;\r\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$5 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$5.call(b, prop))\r\n      __defNormalProp$5(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$5)\r\n    for (var prop of __getOwnPropSymbols$5(b)) {\r\n      if (__propIsEnum$5.call(b, prop))\r\n        __defNormalProp$5(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useShare(shareOptions = {}, options = {}) {\r\n  const { navigator = defaultNavigator } = options;\r\n  const _navigator = navigator;\r\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\r\n  const share = async (overrideOptions = {}) => {\r\n    if (isSupported.value) {\r\n      const data = __spreadValues$5(__spreadValues$5({}, resolveUnref(shareOptions)), resolveUnref(overrideOptions));\r\n      let granted = true;\r\n      if (data.files && _navigator.canShare)\r\n        granted = _navigator.canShare({ files: data.files });\r\n      if (granted)\r\n        return _navigator.share(data);\r\n    }\r\n  };\r\n  return {\r\n    isSupported,\r\n    share\r\n  };\r\n}\r\n\r\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\r\nconst defaultCompare = (a, b) => a - b;\r\nfunction useSorted(...args) {\r\n  var _a, _b, _c, _d;\r\n  const [source] = args;\r\n  let compareFn = defaultCompare;\r\n  let options = {};\r\n  if (args.length === 2) {\r\n    if (typeof args[1] === \"object\") {\r\n      options = args[1];\r\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\r\n    } else {\r\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\r\n    }\r\n  } else if (args.length > 2) {\r\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\r\n    options = (_d = args[2]) != null ? _d : {};\r\n  }\r\n  const {\r\n    dirty = false,\r\n    sortFn = defaultSortFn\r\n  } = options;\r\n  if (!dirty)\r\n    return computed(() => sortFn([...unref(source)], compareFn));\r\n  watchEffect(() => {\r\n    const result = sortFn(unref(source), compareFn);\r\n    if (isRef(source))\r\n      source.value = result;\r\n    else\r\n      source.splice(0, source.length, ...result);\r\n  });\r\n  return source;\r\n}\r\n\r\nfunction useSpeechRecognition(options = {}) {\r\n  const {\r\n    interimResults = true,\r\n    continuous = true,\r\n    window = defaultWindow\r\n  } = options;\r\n  const lang = resolveRef(options.lang || \"en-US\");\r\n  const isListening = ref(false);\r\n  const isFinal = ref(false);\r\n  const result = ref(\"\");\r\n  const error = shallowRef(void 0);\r\n  const toggle = (value = !isListening.value) => {\r\n    isListening.value = value;\r\n  };\r\n  const start = () => {\r\n    isListening.value = true;\r\n  };\r\n  const stop = () => {\r\n    isListening.value = false;\r\n  };\r\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\r\n  const isSupported = useSupported(() => SpeechRecognition);\r\n  let recognition;\r\n  if (isSupported.value) {\r\n    recognition = new SpeechRecognition();\r\n    recognition.continuous = continuous;\r\n    recognition.interimResults = interimResults;\r\n    recognition.lang = unref(lang);\r\n    recognition.onstart = () => {\r\n      isFinal.value = false;\r\n    };\r\n    watch(lang, (lang2) => {\r\n      if (recognition && !isListening.value)\r\n        recognition.lang = lang2;\r\n    });\r\n    recognition.onresult = (event) => {\r\n      const transcript = Array.from(event.results).map((result2) => {\r\n        isFinal.value = result2.isFinal;\r\n        return result2[0];\r\n      }).map((result2) => result2.transcript).join(\"\");\r\n      result.value = transcript;\r\n      error.value = void 0;\r\n    };\r\n    recognition.onerror = (event) => {\r\n      error.value = event;\r\n    };\r\n    recognition.onend = () => {\r\n      isListening.value = false;\r\n      recognition.lang = unref(lang);\r\n    };\r\n    watch(isListening, () => {\r\n      if (isListening.value)\r\n        recognition.start();\r\n      else\r\n        recognition.stop();\r\n    });\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    isListening.value = false;\r\n  });\r\n  return {\r\n    isSupported,\r\n    isListening,\r\n    isFinal,\r\n    recognition,\r\n    result,\r\n    error,\r\n    toggle,\r\n    start,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useSpeechSynthesis(text, options = {}) {\r\n  const {\r\n    pitch = 1,\r\n    rate = 1,\r\n    volume = 1,\r\n    window = defaultWindow\r\n  } = options;\r\n  const synth = window && window.speechSynthesis;\r\n  const isSupported = useSupported(() => synth);\r\n  const isPlaying = ref(false);\r\n  const status = ref(\"init\");\r\n  const spokenText = resolveRef(text || \"\");\r\n  const lang = resolveRef(options.lang || \"en-US\");\r\n  const error = shallowRef(void 0);\r\n  const toggle = (value = !isPlaying.value) => {\r\n    isPlaying.value = value;\r\n  };\r\n  const bindEventsForUtterance = (utterance2) => {\r\n    utterance2.lang = unref(lang);\r\n    utterance2.voice = unref(options.voice) || null;\r\n    utterance2.pitch = pitch;\r\n    utterance2.rate = rate;\r\n    utterance2.volume = volume;\r\n    utterance2.onstart = () => {\r\n      isPlaying.value = true;\r\n      status.value = \"play\";\r\n    };\r\n    utterance2.onpause = () => {\r\n      isPlaying.value = false;\r\n      status.value = \"pause\";\r\n    };\r\n    utterance2.onresume = () => {\r\n      isPlaying.value = true;\r\n      status.value = \"play\";\r\n    };\r\n    utterance2.onend = () => {\r\n      isPlaying.value = false;\r\n      status.value = \"end\";\r\n    };\r\n    utterance2.onerror = (event) => {\r\n      error.value = event;\r\n    };\r\n  };\r\n  const utterance = computed(() => {\r\n    isPlaying.value = false;\r\n    status.value = \"init\";\r\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\r\n    bindEventsForUtterance(newUtterance);\r\n    return newUtterance;\r\n  });\r\n  const speak = () => {\r\n    synth.cancel();\r\n    utterance && synth.speak(utterance.value);\r\n  };\r\n  const stop = () => {\r\n    synth.cancel();\r\n    isPlaying.value = false;\r\n  };\r\n  if (isSupported.value) {\r\n    bindEventsForUtterance(utterance.value);\r\n    watch(lang, (lang2) => {\r\n      if (utterance.value && !isPlaying.value)\r\n        utterance.value.lang = lang2;\r\n    });\r\n    if (options.voice) {\r\n      watch(options.voice, () => {\r\n        synth.cancel();\r\n      });\r\n    }\r\n    watch(isPlaying, () => {\r\n      if (isPlaying.value)\r\n        synth.resume();\r\n      else\r\n        synth.pause();\r\n    });\r\n  }\r\n  tryOnScopeDispose(() => {\r\n    isPlaying.value = false;\r\n  });\r\n  return {\r\n    isSupported,\r\n    isPlaying,\r\n    status,\r\n    utterance,\r\n    error,\r\n    stop,\r\n    toggle,\r\n    speak\r\n  };\r\n}\r\n\r\nfunction useStepper(steps, initialStep) {\r\n  const stepsRef = ref(steps);\r\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\r\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\r\n  const current = computed(() => at(index.value));\r\n  const isFirst = computed(() => index.value === 0);\r\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\r\n  const next = computed(() => stepNames.value[index.value + 1]);\r\n  const previous = computed(() => stepNames.value[index.value - 1]);\r\n  function at(index2) {\r\n    if (Array.isArray(stepsRef.value))\r\n      return stepsRef.value[index2];\r\n    return stepsRef.value[stepNames.value[index2]];\r\n  }\r\n  function get(step) {\r\n    if (!stepNames.value.includes(step))\r\n      return;\r\n    return at(stepNames.value.indexOf(step));\r\n  }\r\n  function goTo(step) {\r\n    if (stepNames.value.includes(step))\r\n      index.value = stepNames.value.indexOf(step);\r\n  }\r\n  function goToNext() {\r\n    if (isLast.value)\r\n      return;\r\n    index.value++;\r\n  }\r\n  function goToPrevious() {\r\n    if (isFirst.value)\r\n      return;\r\n    index.value--;\r\n  }\r\n  function goBackTo(step) {\r\n    if (isAfter(step))\r\n      goTo(step);\r\n  }\r\n  function isNext(step) {\r\n    return stepNames.value.indexOf(step) === index.value + 1;\r\n  }\r\n  function isPrevious(step) {\r\n    return stepNames.value.indexOf(step) === index.value - 1;\r\n  }\r\n  function isCurrent(step) {\r\n    return stepNames.value.indexOf(step) === index.value;\r\n  }\r\n  function isBefore(step) {\r\n    return index.value < stepNames.value.indexOf(step);\r\n  }\r\n  function isAfter(step) {\r\n    return index.value > stepNames.value.indexOf(step);\r\n  }\r\n  return {\r\n    steps: stepsRef,\r\n    stepNames,\r\n    index,\r\n    current,\r\n    next,\r\n    previous,\r\n    isFirst,\r\n    isLast,\r\n    at,\r\n    get,\r\n    goTo,\r\n    goToNext,\r\n    goToPrevious,\r\n    goBackTo,\r\n    isNext,\r\n    isPrevious,\r\n    isCurrent,\r\n    isBefore,\r\n    isAfter\r\n  };\r\n}\r\n\r\nvar __defProp$4 = Object.defineProperty;\r\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$4 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$4.call(b, prop))\r\n      __defNormalProp$4(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$4)\r\n    for (var prop of __getOwnPropSymbols$4(b)) {\r\n      if (__propIsEnum$4.call(b, prop))\r\n        __defNormalProp$4(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\r\n  var _a;\r\n  const {\r\n    flush = \"pre\",\r\n    deep = true,\r\n    listenToStorageChanges = true,\r\n    writeDefaults = true,\r\n    mergeDefaults = false,\r\n    shallow,\r\n    window = defaultWindow,\r\n    eventFilter,\r\n    onError = (e) => {\r\n      console.error(e);\r\n    }\r\n  } = options;\r\n  const rawInit = resolveUnref(initialValue);\r\n  const type = guessSerializerType(rawInit);\r\n  const data = (shallow ? shallowRef : ref)(initialValue);\r\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\r\n  if (!storage) {\r\n    try {\r\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\r\n        var _a2;\r\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\r\n      })();\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  }\r\n  async function read(event) {\r\n    if (!storage || event && event.key !== key)\r\n      return;\r\n    try {\r\n      const rawValue = event ? event.newValue : await storage.getItem(key);\r\n      if (rawValue == null) {\r\n        data.value = rawInit;\r\n        if (writeDefaults && rawInit !== null)\r\n          await storage.setItem(key, await serializer.write(rawInit));\r\n      } else if (mergeDefaults) {\r\n        const value = await serializer.read(rawValue);\r\n        if (isFunction(mergeDefaults))\r\n          data.value = mergeDefaults(value, rawInit);\r\n        else if (type === \"object\" && !Array.isArray(value))\r\n          data.value = __spreadValues$4(__spreadValues$4({}, rawInit), value);\r\n        else\r\n          data.value = value;\r\n      } else {\r\n        data.value = await serializer.read(rawValue);\r\n      }\r\n    } catch (e) {\r\n      onError(e);\r\n    }\r\n  }\r\n  read();\r\n  if (window && listenToStorageChanges)\r\n    useEventListener(window, \"storage\", (e) => setTimeout(() => read(e), 0));\r\n  if (storage) {\r\n    watchWithFilter(data, async () => {\r\n      try {\r\n        if (data.value == null)\r\n          await storage.removeItem(key);\r\n        else\r\n          await storage.setItem(key, await serializer.write(data.value));\r\n      } catch (e) {\r\n        onError(e);\r\n      }\r\n    }, {\r\n      flush,\r\n      deep,\r\n      eventFilter\r\n    });\r\n  }\r\n  return data;\r\n}\r\n\r\nlet _id = 0;\r\nfunction useStyleTag(css, options = {}) {\r\n  const isLoaded = ref(false);\r\n  const {\r\n    document = defaultDocument,\r\n    immediate = true,\r\n    manual = false,\r\n    id = `vueuse_styletag_${++_id}`\r\n  } = options;\r\n  const cssRef = ref(css);\r\n  let stop = () => {\r\n  };\r\n  const load = () => {\r\n    if (!document)\r\n      return;\r\n    const el = document.getElementById(id) || document.createElement(\"style\");\r\n    if (!el.isConnected) {\r\n      el.type = \"text/css\";\r\n      el.id = id;\r\n      if (options.media)\r\n        el.media = options.media;\r\n      document.head.appendChild(el);\r\n    }\r\n    if (isLoaded.value)\r\n      return;\r\n    stop = watch(cssRef, (value) => {\r\n      el.textContent = value;\r\n    }, { immediate: true });\r\n    isLoaded.value = true;\r\n  };\r\n  const unload = () => {\r\n    if (!document || !isLoaded.value)\r\n      return;\r\n    stop();\r\n    document.head.removeChild(document.getElementById(id));\r\n    isLoaded.value = false;\r\n  };\r\n  if (immediate && !manual)\r\n    tryOnMounted(load);\r\n  if (!manual)\r\n    tryOnScopeDispose(unload);\r\n  return {\r\n    id,\r\n    css: cssRef,\r\n    unload,\r\n    load,\r\n    isLoaded: readonly(isLoaded)\r\n  };\r\n}\r\n\r\nfunction useTemplateRefsList() {\r\n  const refs = ref([]);\r\n  refs.value.set = (el) => {\r\n    if (el)\r\n      refs.value.push(el);\r\n  };\r\n  onBeforeUpdate(() => {\r\n    refs.value.length = 0;\r\n  });\r\n  return refs;\r\n}\r\n\r\nfunction useTextDirection(options = {}) {\r\n  const {\r\n    document = defaultDocument,\r\n    selector = \"html\",\r\n    observe = false,\r\n    initialValue = \"ltr\"\r\n  } = options;\r\n  function getValue() {\r\n    var _a, _b;\r\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\r\n  }\r\n  const dir = ref(getValue());\r\n  tryOnMounted(() => dir.value = getValue());\r\n  if (observe && document) {\r\n    useMutationObserver(document.querySelector(selector), () => dir.value = getValue(), { attributes: true });\r\n  }\r\n  return computed({\r\n    get() {\r\n      return dir.value;\r\n    },\r\n    set(v) {\r\n      var _a, _b;\r\n      dir.value = v;\r\n      if (!document)\r\n        return;\r\n      if (dir.value)\r\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\r\n      else\r\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\r\n    }\r\n  });\r\n}\r\n\r\nfunction getRangesFromSelection(selection) {\r\n  var _a;\r\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\r\n  const ranges = new Array(rangeCount);\r\n  for (let i = 0; i < rangeCount; i++) {\r\n    const range = selection.getRangeAt(i);\r\n    ranges[i] = range;\r\n  }\r\n  return ranges;\r\n}\r\nfunction useTextSelection(options = {}) {\r\n  const {\r\n    window = defaultWindow\r\n  } = options;\r\n  const selection = ref(null);\r\n  const text = computed(() => {\r\n    var _a, _b;\r\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\r\n  });\r\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\r\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\r\n  function onSelectionChange() {\r\n    selection.value = null;\r\n    if (window)\r\n      selection.value = window.getSelection();\r\n  }\r\n  if (window)\r\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\r\n  return {\r\n    text,\r\n    rects,\r\n    ranges,\r\n    selection\r\n  };\r\n}\r\n\r\nfunction useTextareaAutosize(options) {\r\n  const textarea = ref(options == null ? void 0 : options.element);\r\n  const input = ref(options == null ? void 0 : options.input);\r\n  function triggerResize() {\r\n    var _a, _b;\r\n    if (!textarea.value)\r\n      return;\r\n    textarea.value.style.height = \"1px\";\r\n    textarea.value.style.height = `${(_a = textarea.value) == null ? void 0 : _a.scrollHeight}px`;\r\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\r\n  }\r\n  watch([input, textarea], triggerResize, { immediate: true });\r\n  useResizeObserver(textarea, () => triggerResize());\r\n  if (options == null ? void 0 : options.watch)\r\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\r\n  return {\r\n    textarea,\r\n    input,\r\n    triggerResize\r\n  };\r\n}\r\n\r\nvar __defProp$3 = Object.defineProperty;\r\nvar __defProps = Object.defineProperties;\r\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$3 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$3.call(b, prop))\r\n      __defNormalProp$3(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$3)\r\n    for (var prop of __getOwnPropSymbols$3(b)) {\r\n      if (__propIsEnum$3.call(b, prop))\r\n        __defNormalProp$3(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\r\nfunction useThrottledRefHistory(source, options = {}) {\r\n  const { throttle = 200, trailing = true } = options;\r\n  const filter = throttleFilter(throttle, trailing);\r\n  const history = useRefHistory(source, __spreadProps(__spreadValues$3({}, options), { eventFilter: filter }));\r\n  return __spreadValues$3({}, history);\r\n}\r\n\r\nvar __defProp$2 = Object.defineProperty;\r\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$2 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$2.call(b, prop))\r\n      __defNormalProp$2(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$2)\r\n    for (var prop of __getOwnPropSymbols$2(b)) {\r\n      if (__propIsEnum$2.call(b, prop))\r\n        __defNormalProp$2(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nvar __objRest = (source, exclude) => {\r\n  var target = {};\r\n  for (var prop in source)\r\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\r\n      target[prop] = source[prop];\r\n  if (source != null && __getOwnPropSymbols$2)\r\n    for (var prop of __getOwnPropSymbols$2(source)) {\r\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\r\n        target[prop] = source[prop];\r\n    }\r\n  return target;\r\n};\r\nconst DEFAULT_UNITS = [\r\n  { max: 6e4, value: 1e3, name: \"second\" },\r\n  { max: 276e4, value: 6e4, name: \"minute\" },\r\n  { max: 72e6, value: 36e5, name: \"hour\" },\r\n  { max: 5184e5, value: 864e5, name: \"day\" },\r\n  { max: 24192e5, value: 6048e5, name: \"week\" },\r\n  { max: 28512e6, value: 2592e6, name: \"month\" },\r\n  { max: Infinity, value: 31536e6, name: \"year\" }\r\n];\r\nconst DEFAULT_MESSAGES = {\r\n  justNow: \"just now\",\r\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\r\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\r\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\r\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\r\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\r\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\r\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\r\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\r\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\r\n  invalid: \"\"\r\n};\r\nconst DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);\r\nfunction useTimeAgo(time, options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    updateInterval = 3e4\r\n  } = options;\r\n  const _a = useNow({ interval: updateInterval, controls: true }), { now } = _a, controls = __objRest(_a, [\"now\"]);\r\n  const timeAgo = computed(() => formatTimeAgo(new Date(resolveUnref(time)), options, unref(now.value)));\r\n  if (exposeControls) {\r\n    return __spreadValues$2({\r\n      timeAgo\r\n    }, controls);\r\n  } else {\r\n    return timeAgo;\r\n  }\r\n}\r\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\r\n  var _a;\r\n  const {\r\n    max,\r\n    messages = DEFAULT_MESSAGES,\r\n    fullDateFormatter = DEFAULT_FORMATTER,\r\n    units = DEFAULT_UNITS,\r\n    showSecond = false,\r\n    rounding = \"round\"\r\n  } = options;\r\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\r\n  const diff = +now - +from;\r\n  const absDiff = Math.abs(diff);\r\n  function getValue(diff2, unit) {\r\n    return roundFn(Math.abs(diff2) / unit.value);\r\n  }\r\n  function format(diff2, unit) {\r\n    const val = getValue(diff2, unit);\r\n    const past = diff2 > 0;\r\n    const str = applyFormat(unit.name, val, past);\r\n    return applyFormat(past ? \"past\" : \"future\", str, past);\r\n  }\r\n  function applyFormat(name, val, isPast) {\r\n    const formatter = messages[name];\r\n    if (typeof formatter === \"function\")\r\n      return formatter(val, isPast);\r\n    return formatter.replace(\"{0}\", val.toString());\r\n  }\r\n  if (absDiff < 6e4 && !showSecond)\r\n    return messages.justNow;\r\n  if (typeof max === \"number\" && absDiff > max)\r\n    return fullDateFormatter(new Date(from));\r\n  if (typeof max === \"string\") {\r\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\r\n    if (unitMax && absDiff > unitMax)\r\n      return fullDateFormatter(new Date(from));\r\n  }\r\n  for (const [idx, unit] of units.entries()) {\r\n    const val = getValue(diff, unit);\r\n    if (val <= 0 && units[idx - 1])\r\n      return format(diff, units[idx - 1]);\r\n    if (absDiff < unit.max)\r\n      return format(diff, unit);\r\n  }\r\n  return messages.invalid;\r\n}\r\n\r\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\r\n  const { start } = useTimeoutFn(loop, interval);\r\n  const isActive = ref(false);\r\n  async function loop() {\r\n    if (!isActive.value)\r\n      return;\r\n    await fn();\r\n    start();\r\n  }\r\n  function resume() {\r\n    if (!isActive.value) {\r\n      isActive.value = true;\r\n      loop();\r\n    }\r\n  }\r\n  function pause() {\r\n    isActive.value = false;\r\n  }\r\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\r\n    resume();\r\n  tryOnScopeDispose(pause);\r\n  return {\r\n    isActive,\r\n    pause,\r\n    resume\r\n  };\r\n}\r\n\r\nvar __defProp$1 = Object.defineProperty;\r\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues$1 = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp$1.call(b, prop))\r\n      __defNormalProp$1(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols$1)\r\n    for (var prop of __getOwnPropSymbols$1(b)) {\r\n      if (__propIsEnum$1.call(b, prop))\r\n        __defNormalProp$1(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nfunction useTimestamp(options = {}) {\r\n  const {\r\n    controls: exposeControls = false,\r\n    offset = 0,\r\n    immediate = true,\r\n    interval = \"requestAnimationFrame\",\r\n    callback\r\n  } = options;\r\n  const ts = ref(timestamp() + offset);\r\n  const update = () => ts.value = timestamp() + offset;\r\n  const cb = callback ? () => {\r\n    update();\r\n    callback(ts.value);\r\n  } : update;\r\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\r\n  if (exposeControls) {\r\n    return __spreadValues$1({\r\n      timestamp: ts\r\n    }, controls);\r\n  } else {\r\n    return ts;\r\n  }\r\n}\r\n\r\nfunction useTitle(newTitle = null, options = {}) {\r\n  var _a, _b;\r\n  const {\r\n    document = defaultDocument\r\n  } = options;\r\n  const title = resolveRef((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);\r\n  const isReadonly = newTitle && isFunction(newTitle);\r\n  function format(t) {\r\n    if (!(\"titleTemplate\" in options))\r\n      return t;\r\n    const template = options.titleTemplate || \"%s\";\r\n    return isFunction(template) ? template(t) : unref(template).replace(/%s/g, t);\r\n  }\r\n  watch(title, (t, o) => {\r\n    if (t !== o && document)\r\n      document.title = format(isString(t) ? t : \"\");\r\n  }, { immediate: true });\r\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\r\n    useMutationObserver((_b = document.head) == null ? void 0 : _b.querySelector(\"title\"), () => {\r\n      if (document && document.title !== title.value)\r\n        title.value = format(document.title);\r\n    }, { childList: true });\r\n  }\r\n  return title;\r\n}\r\n\r\nvar __defProp = Object.defineProperty;\r\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp.call(b, prop))\r\n      __defNormalProp(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols)\r\n    for (var prop of __getOwnPropSymbols(b)) {\r\n      if (__propIsEnum.call(b, prop))\r\n        __defNormalProp(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nconst _TransitionPresets = {\r\n  easeInSine: [0.12, 0, 0.39, 0],\r\n  easeOutSine: [0.61, 1, 0.88, 1],\r\n  easeInOutSine: [0.37, 0, 0.63, 1],\r\n  easeInQuad: [0.11, 0, 0.5, 0],\r\n  easeOutQuad: [0.5, 1, 0.89, 1],\r\n  easeInOutQuad: [0.45, 0, 0.55, 1],\r\n  easeInCubic: [0.32, 0, 0.67, 0],\r\n  easeOutCubic: [0.33, 1, 0.68, 1],\r\n  easeInOutCubic: [0.65, 0, 0.35, 1],\r\n  easeInQuart: [0.5, 0, 0.75, 0],\r\n  easeOutQuart: [0.25, 1, 0.5, 1],\r\n  easeInOutQuart: [0.76, 0, 0.24, 1],\r\n  easeInQuint: [0.64, 0, 0.78, 0],\r\n  easeOutQuint: [0.22, 1, 0.36, 1],\r\n  easeInOutQuint: [0.83, 0, 0.17, 1],\r\n  easeInExpo: [0.7, 0, 0.84, 0],\r\n  easeOutExpo: [0.16, 1, 0.3, 1],\r\n  easeInOutExpo: [0.87, 0, 0.13, 1],\r\n  easeInCirc: [0.55, 0, 1, 0.45],\r\n  easeOutCirc: [0, 0.55, 0.45, 1],\r\n  easeInOutCirc: [0.85, 0, 0.15, 1],\r\n  easeInBack: [0.36, 0, 0.66, -0.56],\r\n  easeOutBack: [0.34, 1.56, 0.64, 1],\r\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\r\n};\r\nconst TransitionPresets = __spreadValues({\r\n  linear: identity\r\n}, _TransitionPresets);\r\nfunction createEasingFunction([p0, p1, p2, p3]) {\r\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\r\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\r\n  const c = (a1) => 3 * a1;\r\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\r\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\r\n  const getTforX = (x) => {\r\n    let aGuessT = x;\r\n    for (let i = 0; i < 4; ++i) {\r\n      const currentSlope = getSlope(aGuessT, p0, p2);\r\n      if (currentSlope === 0)\r\n        return aGuessT;\r\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\r\n      aGuessT -= currentX / currentSlope;\r\n    }\r\n    return aGuessT;\r\n  };\r\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\r\n}\r\nfunction useTransition(source, options = {}) {\r\n  const {\r\n    delay = 0,\r\n    disabled = false,\r\n    duration = 1e3,\r\n    onFinished = noop,\r\n    onStarted = noop,\r\n    transition = identity\r\n  } = options;\r\n  const currentTransition = computed(() => {\r\n    const t = unref(transition);\r\n    return isFunction(t) ? t : createEasingFunction(t);\r\n  });\r\n  const sourceValue = computed(() => {\r\n    const s = unref(source);\r\n    return isNumber(s) ? s : s.map(unref);\r\n  });\r\n  const sourceVector = computed(() => isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value);\r\n  const outputVector = ref(sourceVector.value.slice(0));\r\n  let currentDuration;\r\n  let diffVector;\r\n  let endAt;\r\n  let startAt;\r\n  let startVector;\r\n  const { resume, pause } = useRafFn(() => {\r\n    const now = Date.now();\r\n    const progress = clamp(1 - (endAt - now) / currentDuration, 0, 1);\r\n    outputVector.value = startVector.map((val, i) => {\r\n      var _a;\r\n      return val + ((_a = diffVector[i]) != null ? _a : 0) * currentTransition.value(progress);\r\n    });\r\n    if (progress >= 1) {\r\n      pause();\r\n      onFinished();\r\n    }\r\n  }, { immediate: false });\r\n  const start = () => {\r\n    pause();\r\n    currentDuration = unref(duration);\r\n    diffVector = outputVector.value.map((n, i) => {\r\n      var _a, _b;\r\n      return ((_a = sourceVector.value[i]) != null ? _a : 0) - ((_b = outputVector.value[i]) != null ? _b : 0);\r\n    });\r\n    startVector = outputVector.value.slice(0);\r\n    startAt = Date.now();\r\n    endAt = startAt + currentDuration;\r\n    resume();\r\n    onStarted();\r\n  };\r\n  const timeout = useTimeoutFn(start, delay, { immediate: false });\r\n  watch(sourceVector, () => {\r\n    if (unref(disabled))\r\n      return;\r\n    if (unref(delay) <= 0)\r\n      start();\r\n    else\r\n      timeout.start();\r\n  }, { deep: true });\r\n  watch(() => unref(disabled), (v) => {\r\n    if (v) {\r\n      outputVector.value = sourceVector.value.slice(0);\r\n      pause();\r\n    }\r\n  });\r\n  return computed(() => {\r\n    const targetVector = unref(disabled) ? sourceVector : outputVector;\r\n    return isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value;\r\n  });\r\n}\r\n\r\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\r\n  const {\r\n    initialValue = {},\r\n    removeNullishValues = true,\r\n    removeFalsyValues = false,\r\n    write: enableWrite = true,\r\n    window = defaultWindow\r\n  } = options;\r\n  if (!window)\r\n    return reactive(initialValue);\r\n  const state = reactive({});\r\n  function getRawParams() {\r\n    if (mode === \"history\") {\r\n      return window.location.search || \"\";\r\n    } else if (mode === \"hash\") {\r\n      const hash = window.location.hash || \"\";\r\n      const index = hash.indexOf(\"?\");\r\n      return index > 0 ? hash.slice(index) : \"\";\r\n    } else {\r\n      return (window.location.hash || \"\").replace(/^#/, \"\");\r\n    }\r\n  }\r\n  function constructQuery(params) {\r\n    const stringified = params.toString();\r\n    if (mode === \"history\")\r\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\r\n    if (mode === \"hash-params\")\r\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\r\n    const hash = window.location.hash || \"#\";\r\n    const index = hash.indexOf(\"?\");\r\n    if (index > 0)\r\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\r\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\r\n  }\r\n  function read() {\r\n    return new URLSearchParams(getRawParams());\r\n  }\r\n  function updateState(params) {\r\n    const unusedKeys = new Set(Object.keys(state));\r\n    for (const key of params.keys()) {\r\n      const paramsForKey = params.getAll(key);\r\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\r\n      unusedKeys.delete(key);\r\n    }\r\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\r\n  }\r\n  const { pause, resume } = pausableWatch(state, () => {\r\n    const params = new URLSearchParams(\"\");\r\n    Object.keys(state).forEach((key) => {\r\n      const mapEntry = state[key];\r\n      if (Array.isArray(mapEntry))\r\n        mapEntry.forEach((value) => params.append(key, value));\r\n      else if (removeNullishValues && mapEntry == null)\r\n        params.delete(key);\r\n      else if (removeFalsyValues && !mapEntry)\r\n        params.delete(key);\r\n      else\r\n        params.set(key, mapEntry);\r\n    });\r\n    write(params);\r\n  }, { deep: true });\r\n  function write(params, shouldUpdate) {\r\n    pause();\r\n    if (shouldUpdate)\r\n      updateState(params);\r\n    window.history.replaceState(window.history.state, window.document.title, window.location.pathname + constructQuery(params));\r\n    resume();\r\n  }\r\n  function onChanged() {\r\n    if (!enableWrite)\r\n      return;\r\n    write(read(), true);\r\n  }\r\n  useEventListener(window, \"popstate\", onChanged, false);\r\n  if (mode !== \"history\")\r\n    useEventListener(window, \"hashchange\", onChanged, false);\r\n  const initial = read();\r\n  if (initial.keys().next().value)\r\n    updateState(initial);\r\n  else\r\n    Object.assign(state, initialValue);\r\n  return state;\r\n}\r\n\r\nfunction useUserMedia(options = {}) {\r\n  var _a, _b;\r\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\r\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\r\n  const videoDeviceId = ref(options.videoDeviceId);\r\n  const audioDeviceId = ref(options.audioDeviceId);\r\n  const { navigator = defaultNavigator } = options;\r\n  const isSupported = useSupported(() => {\r\n    var _a2;\r\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\r\n  });\r\n  const stream = shallowRef();\r\n  function getDeviceOptions(device) {\r\n    if (device.value === \"none\" || device.value === false)\r\n      return false;\r\n    if (device.value == null)\r\n      return true;\r\n    return {\r\n      deviceId: device.value\r\n    };\r\n  }\r\n  async function _start() {\r\n    if (!isSupported.value || stream.value)\r\n      return;\r\n    stream.value = await navigator.mediaDevices.getUserMedia({\r\n      video: getDeviceOptions(videoDeviceId),\r\n      audio: getDeviceOptions(audioDeviceId)\r\n    });\r\n    return stream.value;\r\n  }\r\n  async function _stop() {\r\n    var _a2;\r\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\r\n    stream.value = void 0;\r\n  }\r\n  function stop() {\r\n    _stop();\r\n    enabled.value = false;\r\n  }\r\n  async function start() {\r\n    await _start();\r\n    if (stream.value)\r\n      enabled.value = true;\r\n    return stream.value;\r\n  }\r\n  async function restart() {\r\n    _stop();\r\n    return await start();\r\n  }\r\n  watch(enabled, (v) => {\r\n    if (v)\r\n      _start();\r\n    else\r\n      _stop();\r\n  }, { immediate: true });\r\n  watch([videoDeviceId, audioDeviceId], () => {\r\n    if (autoSwitch.value && stream.value)\r\n      restart();\r\n  }, { immediate: true });\r\n  return {\r\n    isSupported,\r\n    stream,\r\n    start,\r\n    stop,\r\n    restart,\r\n    videoDeviceId,\r\n    audioDeviceId,\r\n    enabled,\r\n    autoSwitch\r\n  };\r\n}\r\n\r\nfunction useVModel(props, key, emit, options = {}) {\r\n  var _a, _b, _c, _d, _e;\r\n  const {\r\n    clone = false,\r\n    passive = false,\r\n    eventName,\r\n    deep = false,\r\n    defaultValue\r\n  } = options;\r\n  const vm = getCurrentInstance();\r\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\r\n  let event = eventName;\r\n  if (!key) {\r\n    if (isVue2) {\r\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\r\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\r\n      if (!eventName)\r\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\r\n    } else {\r\n      key = \"modelValue\";\r\n    }\r\n  }\r\n  event = eventName || event || `update:${key.toString()}`;\r\n  const cloneFn = (val) => !clone ? val : isFunction(clone) ? clone(val) : cloneFnJSON(val);\r\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\r\n  if (passive) {\r\n    const initialValue = getValue();\r\n    const proxy = ref(initialValue);\r\n    watch(() => props[key], (v) => proxy.value = cloneFn(v));\r\n    watch(proxy, (v) => {\r\n      if (v !== props[key] || deep)\r\n        _emit(event, v);\r\n    }, { deep });\r\n    return proxy;\r\n  } else {\r\n    return computed({\r\n      get() {\r\n        return getValue();\r\n      },\r\n      set(value) {\r\n        _emit(event, value);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction useVModels(props, emit, options = {}) {\r\n  const ret = {};\r\n  for (const key in props)\r\n    ret[key] = useVModel(props, key, emit, options);\r\n  return ret;\r\n}\r\n\r\nfunction useVibrate(options) {\r\n  const {\r\n    pattern = [],\r\n    interval = 0,\r\n    navigator = defaultNavigator\r\n  } = options || {};\r\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\r\n  const patternRef = resolveRef(pattern);\r\n  let intervalControls;\r\n  const vibrate = (pattern2 = patternRef.value) => {\r\n    if (isSupported.value)\r\n      navigator.vibrate(pattern2);\r\n  };\r\n  const stop = () => {\r\n    if (isSupported.value)\r\n      navigator.vibrate(0);\r\n    intervalControls == null ? void 0 : intervalControls.pause();\r\n  };\r\n  if (interval > 0) {\r\n    intervalControls = useIntervalFn(vibrate, interval, {\r\n      immediate: false,\r\n      immediateCallback: false\r\n    });\r\n  }\r\n  return {\r\n    isSupported,\r\n    pattern,\r\n    intervalControls,\r\n    vibrate,\r\n    stop\r\n  };\r\n}\r\n\r\nfunction useVirtualList(list, options) {\r\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\r\n  return {\r\n    list: currentList,\r\n    scrollTo,\r\n    containerProps: {\r\n      ref: containerRef,\r\n      onScroll: () => {\r\n        calculateRange();\r\n      },\r\n      style: containerStyle\r\n    },\r\n    wrapperProps\r\n  };\r\n}\r\nfunction useVirtualListResources(list) {\r\n  const containerRef = ref(null);\r\n  const size = useElementSize(containerRef);\r\n  const currentList = ref([]);\r\n  const source = shallowRef(list);\r\n  const state = ref({ start: 0, end: 10 });\r\n  return { state, source, currentList, size, containerRef };\r\n}\r\nfunction createGetViewCapacity(state, source, itemSize) {\r\n  return (containerSize) => {\r\n    if (typeof itemSize === \"number\")\r\n      return Math.ceil(containerSize / itemSize);\r\n    const { start = 0 } = state.value;\r\n    let sum = 0;\r\n    let capacity = 0;\r\n    for (let i = start; i < source.value.length; i++) {\r\n      const size = itemSize(i);\r\n      sum += size;\r\n      capacity = i;\r\n      if (sum > containerSize)\r\n        break;\r\n    }\r\n    return capacity - start;\r\n  };\r\n}\r\nfunction createGetOffset(source, itemSize) {\r\n  return (scrollDirection) => {\r\n    if (typeof itemSize === \"number\")\r\n      return Math.floor(scrollDirection / itemSize) + 1;\r\n    let sum = 0;\r\n    let offset = 0;\r\n    for (let i = 0; i < source.value.length; i++) {\r\n      const size = itemSize(i);\r\n      sum += size;\r\n      if (sum >= scrollDirection) {\r\n        offset = i;\r\n        break;\r\n      }\r\n    }\r\n    return offset + 1;\r\n  };\r\n}\r\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\r\n  return () => {\r\n    const element = containerRef.value;\r\n    if (element) {\r\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\r\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\r\n      const from = offset - overscan;\r\n      const to = offset + viewCapacity + overscan;\r\n      state.value = {\r\n        start: from < 0 ? 0 : from,\r\n        end: to > source.value.length ? source.value.length : to\r\n      };\r\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\r\n        data: ele,\r\n        index: index + state.value.start\r\n      }));\r\n    }\r\n  };\r\n}\r\nfunction createGetDistance(itemSize, source) {\r\n  return (index) => {\r\n    if (typeof itemSize === \"number\") {\r\n      const size2 = index * itemSize;\r\n      return size2;\r\n    }\r\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\r\n    return size;\r\n  };\r\n}\r\nfunction useWatchForSizes(size, list, calculateRange) {\r\n  watch([size.width, size.height, list], () => {\r\n    calculateRange();\r\n  });\r\n}\r\nfunction createComputedTotalSize(itemSize, source) {\r\n  return computed(() => {\r\n    if (typeof itemSize === \"number\")\r\n      return source.value.length * itemSize;\r\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\r\n  });\r\n}\r\nconst scrollToDictionaryForElementScrollKey = {\r\n  horizontal: \"scrollLeft\",\r\n  vertical: \"scrollTop\"\r\n};\r\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\r\n  return (index) => {\r\n    if (containerRef.value) {\r\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\r\n      calculateRange();\r\n    }\r\n  };\r\n}\r\nfunction useHorizontalVirtualList(options, list) {\r\n  const resources = useVirtualListResources(list);\r\n  const { state, source, currentList, size, containerRef } = resources;\r\n  const containerStyle = { overflowX: \"auto\" };\r\n  const { itemWidth, overscan = 5 } = options;\r\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\r\n  const getOffset = createGetOffset(source, itemWidth);\r\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\r\n  const getDistanceLeft = createGetDistance(itemWidth, source);\r\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\r\n  const totalWidth = createComputedTotalSize(itemWidth, source);\r\n  useWatchForSizes(size, list, calculateRange);\r\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\r\n  const wrapperProps = computed(() => {\r\n    return {\r\n      style: {\r\n        height: \"100%\",\r\n        width: `${totalWidth.value - offsetLeft.value}px`,\r\n        marginLeft: `${offsetLeft.value}px`,\r\n        display: \"flex\"\r\n      }\r\n    };\r\n  });\r\n  return {\r\n    scrollTo,\r\n    calculateRange,\r\n    wrapperProps,\r\n    containerStyle,\r\n    currentList,\r\n    containerRef\r\n  };\r\n}\r\nfunction useVerticalVirtualList(options, list) {\r\n  const resources = useVirtualListResources(list);\r\n  const { state, source, currentList, size, containerRef } = resources;\r\n  const containerStyle = { overflowY: \"auto\" };\r\n  const { itemHeight, overscan = 5 } = options;\r\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\r\n  const getOffset = createGetOffset(source, itemHeight);\r\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\r\n  const getDistanceTop = createGetDistance(itemHeight, source);\r\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\r\n  const totalHeight = createComputedTotalSize(itemHeight, source);\r\n  useWatchForSizes(size, list, calculateRange);\r\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\r\n  const wrapperProps = computed(() => {\r\n    return {\r\n      style: {\r\n        width: \"100%\",\r\n        height: `${totalHeight.value - offsetTop.value}px`,\r\n        marginTop: `${offsetTop.value}px`\r\n      }\r\n    };\r\n  });\r\n  return {\r\n    calculateRange,\r\n    scrollTo,\r\n    containerStyle,\r\n    wrapperProps,\r\n    currentList,\r\n    containerRef\r\n  };\r\n}\r\n\r\nconst useWakeLock = (options = {}) => {\r\n  const {\r\n    navigator = defaultNavigator,\r\n    document = defaultDocument\r\n  } = options;\r\n  let wakeLock;\r\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\r\n  const isActive = ref(false);\r\n  async function onVisibilityChange() {\r\n    if (!isSupported.value || !wakeLock)\r\n      return;\r\n    if (document && document.visibilityState === \"visible\")\r\n      wakeLock = await navigator.wakeLock.request(\"screen\");\r\n    isActive.value = !wakeLock.released;\r\n  }\r\n  if (document)\r\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\r\n  async function request(type) {\r\n    if (!isSupported.value)\r\n      return;\r\n    wakeLock = await navigator.wakeLock.request(type);\r\n    isActive.value = !wakeLock.released;\r\n  }\r\n  async function release() {\r\n    if (!isSupported.value || !wakeLock)\r\n      return;\r\n    await wakeLock.release();\r\n    isActive.value = !wakeLock.released;\r\n    wakeLock = null;\r\n  }\r\n  return {\r\n    isSupported,\r\n    isActive,\r\n    request,\r\n    release\r\n  };\r\n};\r\n\r\nconst useWebNotification = (defaultOptions = {}) => {\r\n  const {\r\n    window = defaultWindow\r\n  } = defaultOptions;\r\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\r\n  const notification = ref(null);\r\n  const requestPermission = async () => {\r\n    if (!isSupported.value)\r\n      return;\r\n    if (\"permission\" in Notification && Notification.permission !== \"denied\")\r\n      await Notification.requestPermission();\r\n  };\r\n  const onClick = createEventHook();\r\n  const onShow = createEventHook();\r\n  const onError = createEventHook();\r\n  const onClose = createEventHook();\r\n  const show = async (overrides) => {\r\n    if (!isSupported.value)\r\n      return;\r\n    await requestPermission();\r\n    const options = Object.assign({}, defaultOptions, overrides);\r\n    notification.value = new Notification(options.title || \"\", options);\r\n    notification.value.onclick = (event) => onClick.trigger(event);\r\n    notification.value.onshow = (event) => onShow.trigger(event);\r\n    notification.value.onerror = (event) => onError.trigger(event);\r\n    notification.value.onclose = (event) => onClose.trigger(event);\r\n    return notification.value;\r\n  };\r\n  const close = () => {\r\n    if (notification.value)\r\n      notification.value.close();\r\n    notification.value = null;\r\n  };\r\n  tryOnMounted(async () => {\r\n    if (isSupported.value)\r\n      await requestPermission();\r\n  });\r\n  tryOnScopeDispose(close);\r\n  if (isSupported.value && window) {\r\n    const document = window.document;\r\n    useEventListener(document, \"visibilitychange\", (e) => {\r\n      e.preventDefault();\r\n      if (document.visibilityState === \"visible\") {\r\n        close();\r\n      }\r\n    });\r\n  }\r\n  return {\r\n    isSupported,\r\n    notification,\r\n    show,\r\n    close,\r\n    onClick,\r\n    onShow,\r\n    onError,\r\n    onClose\r\n  };\r\n};\r\n\r\nconst DEFAULT_PING_MESSAGE = \"ping\";\r\nfunction resolveNestedOptions(options) {\r\n  if (options === true)\r\n    return {};\r\n  return options;\r\n}\r\nfunction useWebSocket(url, options = {}) {\r\n  const {\r\n    onConnected,\r\n    onDisconnected,\r\n    onError,\r\n    onMessage,\r\n    immediate = true,\r\n    autoClose = true,\r\n    protocols = []\r\n  } = options;\r\n  const data = ref(null);\r\n  const status = ref(\"CLOSED\");\r\n  const wsRef = ref();\r\n  const urlRef = resolveRef(url);\r\n  let heartbeatPause;\r\n  let heartbeatResume;\r\n  let explicitlyClosed = false;\r\n  let retried = 0;\r\n  let bufferedData = [];\r\n  let pongTimeoutWait;\r\n  const close = (code = 1e3, reason) => {\r\n    if (!wsRef.value)\r\n      return;\r\n    explicitlyClosed = true;\r\n    heartbeatPause == null ? void 0 : heartbeatPause();\r\n    wsRef.value.close(code, reason);\r\n  };\r\n  const _sendBuffer = () => {\r\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\r\n      for (const buffer of bufferedData)\r\n        wsRef.value.send(buffer);\r\n      bufferedData = [];\r\n    }\r\n  };\r\n  const resetHeartbeat = () => {\r\n    clearTimeout(pongTimeoutWait);\r\n    pongTimeoutWait = void 0;\r\n  };\r\n  const send = (data2, useBuffer = true) => {\r\n    if (!wsRef.value || status.value !== \"OPEN\") {\r\n      if (useBuffer)\r\n        bufferedData.push(data2);\r\n      return false;\r\n    }\r\n    _sendBuffer();\r\n    wsRef.value.send(data2);\r\n    return true;\r\n  };\r\n  const _init = () => {\r\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\r\n      return;\r\n    const ws = new WebSocket(urlRef.value, protocols);\r\n    wsRef.value = ws;\r\n    status.value = \"CONNECTING\";\r\n    ws.onopen = () => {\r\n      status.value = \"OPEN\";\r\n      onConnected == null ? void 0 : onConnected(ws);\r\n      heartbeatResume == null ? void 0 : heartbeatResume();\r\n      _sendBuffer();\r\n    };\r\n    ws.onclose = (ev) => {\r\n      status.value = \"CLOSED\";\r\n      wsRef.value = void 0;\r\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\r\n      if (!explicitlyClosed && options.autoReconnect) {\r\n        const {\r\n          retries = -1,\r\n          delay = 1e3,\r\n          onFailed\r\n        } = resolveNestedOptions(options.autoReconnect);\r\n        retried += 1;\r\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\r\n          setTimeout(_init, delay);\r\n        else if (typeof retries === \"function\" && retries())\r\n          setTimeout(_init, delay);\r\n        else\r\n          onFailed == null ? void 0 : onFailed();\r\n      }\r\n    };\r\n    ws.onerror = (e) => {\r\n      onError == null ? void 0 : onError(ws, e);\r\n    };\r\n    ws.onmessage = (e) => {\r\n      if (options.heartbeat) {\r\n        resetHeartbeat();\r\n        const {\r\n          message = DEFAULT_PING_MESSAGE\r\n        } = resolveNestedOptions(options.heartbeat);\r\n        if (e.data === message)\r\n          return;\r\n      }\r\n      data.value = e.data;\r\n      onMessage == null ? void 0 : onMessage(ws, e);\r\n    };\r\n  };\r\n  if (options.heartbeat) {\r\n    const {\r\n      message = DEFAULT_PING_MESSAGE,\r\n      interval = 1e3,\r\n      pongTimeout = 1e3\r\n    } = resolveNestedOptions(options.heartbeat);\r\n    const { pause, resume } = useIntervalFn(() => {\r\n      send(message, false);\r\n      if (pongTimeoutWait != null)\r\n        return;\r\n      pongTimeoutWait = setTimeout(() => {\r\n        close();\r\n      }, pongTimeout);\r\n    }, interval, { immediate: false });\r\n    heartbeatPause = pause;\r\n    heartbeatResume = resume;\r\n  }\r\n  if (autoClose) {\r\n    useEventListener(window, \"beforeunload\", () => close());\r\n    tryOnScopeDispose(close);\r\n  }\r\n  const open = () => {\r\n    close();\r\n    explicitlyClosed = false;\r\n    retried = 0;\r\n    _init();\r\n  };\r\n  if (immediate)\r\n    watch(urlRef, open, { immediate: true });\r\n  return {\r\n    data,\r\n    status,\r\n    close,\r\n    send,\r\n    open,\r\n    ws: wsRef\r\n  };\r\n}\r\n\r\nfunction useWebWorker(arg0, workerOptions, options) {\r\n  const {\r\n    window = defaultWindow\r\n  } = options != null ? options : {};\r\n  const data = ref(null);\r\n  const worker = shallowRef();\r\n  const post = function post2(val) {\r\n    if (!worker.value)\r\n      return;\r\n    worker.value.postMessage(val);\r\n  };\r\n  const terminate = function terminate2() {\r\n    if (!worker.value)\r\n      return;\r\n    worker.value.terminate();\r\n  };\r\n  if (window) {\r\n    if (isString(arg0))\r\n      worker.value = new Worker(arg0, workerOptions);\r\n    else if (isFunction(arg0))\r\n      worker.value = arg0();\r\n    else\r\n      worker.value = arg0;\r\n    worker.value.onmessage = (e) => {\r\n      data.value = e.data;\r\n    };\r\n    tryOnScopeDispose(() => {\r\n      if (worker.value)\r\n        worker.value.terminate();\r\n    });\r\n  }\r\n  return {\r\n    data,\r\n    post,\r\n    terminate,\r\n    worker\r\n  };\r\n}\r\n\r\nconst jobRunner = (userFunc) => (e) => {\r\n  const userFuncArgs = e.data[0];\r\n  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\r\n    postMessage([\"SUCCESS\", result]);\r\n  }).catch((error) => {\r\n    postMessage([\"ERROR\", error]);\r\n  });\r\n};\r\n\r\nconst depsParser = (deps) => {\r\n  if (deps.length === 0)\r\n    return \"\";\r\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\r\n  return `importScripts(${depsString})`;\r\n};\r\n\r\nconst createWorkerBlobUrl = (fn, deps) => {\r\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\r\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\r\n  const url = URL.createObjectURL(blob);\r\n  return url;\r\n};\r\n\r\nconst useWebWorkerFn = (fn, options = {}) => {\r\n  const {\r\n    dependencies = [],\r\n    timeout,\r\n    window = defaultWindow\r\n  } = options;\r\n  const worker = ref();\r\n  const workerStatus = ref(\"PENDING\");\r\n  const promise = ref({});\r\n  const timeoutId = ref();\r\n  const workerTerminate = (status = \"PENDING\") => {\r\n    if (worker.value && worker.value._url && window) {\r\n      worker.value.terminate();\r\n      URL.revokeObjectURL(worker.value._url);\r\n      promise.value = {};\r\n      worker.value = void 0;\r\n      window.clearTimeout(timeoutId.value);\r\n      workerStatus.value = status;\r\n    }\r\n  };\r\n  workerTerminate();\r\n  tryOnScopeDispose(workerTerminate);\r\n  const generateWorker = () => {\r\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\r\n    const newWorker = new Worker(blobUrl);\r\n    newWorker._url = blobUrl;\r\n    newWorker.onmessage = (e) => {\r\n      const { resolve = () => {\r\n      }, reject = () => {\r\n      } } = promise.value;\r\n      const [status, result] = e.data;\r\n      switch (status) {\r\n        case \"SUCCESS\":\r\n          resolve(result);\r\n          workerTerminate(status);\r\n          break;\r\n        default:\r\n          reject(result);\r\n          workerTerminate(\"ERROR\");\r\n          break;\r\n      }\r\n    };\r\n    newWorker.onerror = (e) => {\r\n      const { reject = () => {\r\n      } } = promise.value;\r\n      reject(e);\r\n      workerTerminate(\"ERROR\");\r\n    };\r\n    if (timeout) {\r\n      timeoutId.value = setTimeout(() => workerTerminate(\"TIMEOUT_EXPIRED\"), timeout);\r\n    }\r\n    return newWorker;\r\n  };\r\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\r\n    promise.value = {\r\n      resolve,\r\n      reject\r\n    };\r\n    worker.value && worker.value.postMessage([[...fnArgs]]);\r\n    workerStatus.value = \"RUNNING\";\r\n  });\r\n  const workerFn = (...fnArgs) => {\r\n    if (workerStatus.value === \"RUNNING\") {\r\n      console.error(\"[useWebWorkerFn] You can only run one instance of the worker at a time.\");\r\n      return Promise.reject();\r\n    }\r\n    worker.value = generateWorker();\r\n    return callWorker(...fnArgs);\r\n  };\r\n  return {\r\n    workerFn,\r\n    workerStatus,\r\n    workerTerminate\r\n  };\r\n};\r\n\r\nfunction useWindowFocus({ window = defaultWindow } = {}) {\r\n  if (!window)\r\n    return ref(false);\r\n  const focused = ref(window.document.hasFocus());\r\n  useEventListener(window, \"blur\", () => {\r\n    focused.value = false;\r\n  });\r\n  useEventListener(window, \"focus\", () => {\r\n    focused.value = true;\r\n  });\r\n  return focused;\r\n}\r\n\r\nfunction useWindowScroll({ window = defaultWindow } = {}) {\r\n  if (!window) {\r\n    return {\r\n      x: ref(0),\r\n      y: ref(0)\r\n    };\r\n  }\r\n  const x = ref(window.scrollX);\r\n  const y = ref(window.scrollY);\r\n  useEventListener(window, \"scroll\", () => {\r\n    x.value = window.scrollX;\r\n    y.value = window.scrollY;\r\n  }, {\r\n    capture: false,\r\n    passive: true\r\n  });\r\n  return { x, y };\r\n}\r\n\r\nfunction useWindowSize(options = {}) {\r\n  const {\r\n    window = defaultWindow,\r\n    initialWidth = Infinity,\r\n    initialHeight = Infinity,\r\n    listenOrientation = true,\r\n    includeScrollbar = true\r\n  } = options;\r\n  const width = ref(initialWidth);\r\n  const height = ref(initialHeight);\r\n  const update = () => {\r\n    if (window) {\r\n      if (includeScrollbar) {\r\n        width.value = window.innerWidth;\r\n        height.value = window.innerHeight;\r\n      } else {\r\n        width.value = window.document.documentElement.clientWidth;\r\n        height.value = window.document.documentElement.clientHeight;\r\n      }\r\n    }\r\n  };\r\n  update();\r\n  tryOnMounted(update);\r\n  useEventListener(\"resize\", update, { passive: true });\r\n  if (listenOrientation)\r\n    useEventListener(\"orientationchange\", update, { passive: true });\r\n  return { width, height };\r\n}\r\n\r\nexport { DefaultMagicKeysAliasMap, StorageSerializers, SwipeDirection, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, cloneFnJSON, computedAsync, computedInject, createFetch, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\r\n", "import { isClient, isIOS } from '@vueuse/core'\n\nexport const isFirefox = (): boolean =>\n  isClient && /firefox/i.test(window.navigator.userAgent)\n\nexport { isClient, isIOS }\n", "import { isClient } from '../browser'\n\nexport const isInContainer = (\n  el?: Element,\n  container?: Element | Window\n): boolean => {\n  if (!isClient || !el || !container) return false\n\n  const elRect = el.getBoundingClientRect()\n\n  let containerRect: Pick<DOMRect, 'top' | 'bottom' | 'left' | 'right'>\n  if (container instanceof Element) {\n    containerRect = container.getBoundingClientRect()\n  } else {\n    containerRect = {\n      top: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight,\n      left: 0,\n    }\n  }\n  return (\n    elRect.top < containerRect.bottom &&\n    elRect.bottom > containerRect.top &&\n    elRect.right > containerRect.left &&\n    elRect.left < containerRect.right\n  )\n}\n\nexport const getOffsetTop = (el: HTMLElement) => {\n  let offset = 0\n  let parent = el\n\n  while (parent) {\n    offset += parent.offsetTop\n    parent = parent.offsetParent as HTMLElement\n  }\n\n  return offset\n}\n\nexport const getOffsetTopDistance = (\n  el: HTMLElement,\n  containerEl: HTMLElement\n) => {\n  return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl))\n}\n\nexport const getClientXY = (event: MouseEvent | TouchEvent) => {\n  let clientX: number\n  let clientY: number\n  if (event.type === 'touchend') {\n    clientY = (event as TouchEvent).changedTouches[0].clientY\n    clientX = (event as TouchEvent).changedTouches[0].clientX\n  } else if (event.type.startsWith('touch')) {\n    clientY = (event as TouchEvent).touches[0].clientY\n    clientX = (event as TouchEvent).touches[0].clientX\n  } else {\n    clientY = (event as MouseEvent).clientY\n    clientX = (event as MouseEvent).clientX\n  }\n  return {\n    clientX,\n    clientY,\n  }\n}\n", "import { isArray, isObject, isString } from '@vue/shared'\nimport { isNil } from 'lodash-unified'\n\nexport {\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  isDate,\n  isPromise,\n  isSymbol,\n} from '@vue/shared'\nexport { isVNode } from 'vue'\n\nexport const isUndefined = (val: any): val is undefined => val === undefined\nexport const isBoolean = (val: any): val is boolean => typeof val === 'boolean'\nexport const isNumber = (val: any): val is number => typeof val === 'number'\n\nexport const isEmpty = (val: unknown) =>\n  (!val && val !== 0) ||\n  (isArray(val) && val.length === 0) ||\n  (isObject(val) && !Object.keys(val).length)\n\nexport const isElement = (e: unknown): e is Element => {\n  if (typeof Element === 'undefined') return false\n  return e instanceof Element\n}\n\nexport const isPropAbsent = (prop: unknown): prop is null | undefined => {\n  return isNil(prop)\n}\n\nexport const isStringNumber = (val: string): boolean => {\n  if (!isString(val)) {\n    return false\n  }\n  return !Number.isNaN(Number(val))\n}\n", "import { capitalize as toCapitalize } from '@vue/shared'\nexport {\n  camelize,\n  hyphenate,\n  hyphenate as kebabCase, // alias\n} from '@vue/shared'\n\n/**\n * fork from {@link https://github.com/sindresorhus/escape-string-regexp}\n */\nexport const escapeStringRegexp = (string = '') =>\n  string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d')\n\n// NOTE: improve capitalize types. Restore previous code after the [PR](https://github.com/vuejs/core/pull/6212) merge\nexport const capitalize = <T extends string>(str: T) =>\n  toCapitalize(str) as Capitalize<T>\n", "import { get, set } from 'lodash-unified'\nimport type { Entries } from 'type-fest'\nimport type { Arrayable } from '.'\n\nexport const keysOf = <T>(arr: T) => Object.keys(arr) as Array<keyof T>\nexport const entriesOf = <T>(arr: T) => Object.entries(arr) as Entries<T>\nexport { hasOwn } from '@vue/shared'\n\nexport const getProp = <T = any>(\n  obj: Record<string, any>,\n  path: Arrayable<string>,\n  defaultValue?: any\n): { value: T } => {\n  return {\n    get value() {\n      return get(obj, path, defaultValue)\n    },\n    set value(val: any) {\n      set(obj, path, val)\n    },\n  }\n}\n", "import { isString } from './types'\n\nclass ElementPlusError extends Error {\n  constructor(m: string) {\n    super(m)\n    this.name = 'ElementPlusError'\n  }\n}\n\nexport function throwError(scope: string, m: string): never {\n  throw new ElementPlusError(`[${scope}] ${m}`)\n}\n\nexport function debugWarn(err: Error): void\nexport function debugWarn(scope: string, message: string): void\nexport function debugWarn(scope: string | Error, message?: string): void {\n  if (process.env.NODE_ENV !== 'production') {\n    const error: Error = isString(scope)\n      ? new ElementPlusError(`[${scope}] ${message}`)\n      : scope\n    // eslint-disable-next-line no-console\n    console.warn(error)\n  }\n}\n", "import { isNumber, isObject, isString, isStringNumber } from '../types'\nimport { isClient } from '../browser'\nimport { camelize } from '../strings'\nimport { entriesOf, keysOf } from '../objects'\nimport { debugWarn } from '../error'\nimport type { CSSProperties } from 'vue'\n\nconst SCOPE = 'utils/dom/style'\n\nexport const classNameToArray = (cls = '') =>\n  cls.split(' ').filter((item) => !!item.trim())\n\nexport const hasClass = (el: Element, cls: string): boolean => {\n  if (!el || !cls) return false\n  if (cls.includes(' ')) throw new Error('className should not contain space.')\n  return el.classList.contains(cls)\n}\n\nexport const addClass = (el: Element, cls: string) => {\n  if (!el || !cls.trim()) return\n  el.classList.add(...classNameToArray(cls))\n}\n\nexport const removeClass = (el: Element, cls: string) => {\n  if (!el || !cls.trim()) return\n  el.classList.remove(...classNameToArray(cls))\n}\n\nexport const getStyle = (\n  element: HTMLElement,\n  styleName: keyof CSSProperties\n): string => {\n  if (!isClient || !element || !styleName) return ''\n\n  let key = camelize(styleName)\n  if (key === 'float') key = 'cssFloat'\n  try {\n    const style = (element.style as any)[key]\n    if (style) return style\n    const computed: any = document.defaultView?.getComputedStyle(element, '')\n    return computed ? computed[key] : ''\n  } catch {\n    return (element.style as any)[key]\n  }\n}\n\nexport const setStyle = (\n  element: HTMLElement,\n  styleName: CSSProperties | keyof CSSProperties,\n  value?: string | number\n) => {\n  if (!element || !styleName) return\n\n  if (isObject(styleName)) {\n    entriesOf(styleName).forEach(([prop, value]) =>\n      setStyle(element, prop, value)\n    )\n  } else {\n    const key: any = camelize(styleName)\n    element.style[key] = value as any\n  }\n}\n\nexport const removeStyle = (\n  element: HTMLElement,\n  style: CSSProperties | keyof CSSProperties\n) => {\n  if (!element || !style) return\n\n  if (isObject(style)) {\n    keysOf(style).forEach((prop) => removeStyle(element, prop))\n  } else {\n    setStyle(element, style, '')\n  }\n}\n\nexport function addUnit(value?: string | number, defaultUnit = 'px') {\n  if (!value) return ''\n  if (isNumber(value) || isStringNumber(value)) {\n    return `${value}${defaultUnit}`\n  } else if (isString(value)) {\n    return value\n  }\n  debugWarn(SCOPE, 'binding value must be a string or number')\n}\n", "import { isClient } from '../browser'\nimport { getStyle } from './style'\n\nexport const isScroll = (el: HTMLElement, isVertical?: boolean): boolean => {\n  if (!isClient) return false\n\n  const key = (\n    {\n      undefined: 'overflow',\n      true: 'overflow-y',\n      false: 'overflow-x',\n    } as const\n  )[String(isVertical)]!\n  const overflow = getStyle(el, key)\n  return ['scroll', 'auto', 'overlay'].some((s) => overflow.includes(s))\n}\n\nexport const getScrollContainer = (\n  el: HTMLElement,\n  isVertical?: boolean\n): Window | HTMLElement | undefined => {\n  if (!isClient) return\n\n  let parent: HTMLElement = el\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent))\n      return window\n\n    if (isScroll(parent, isVertical)) return parent\n\n    parent = parent.parentNode as HTMLElement\n  }\n\n  return parent\n}\n\nlet scrollBarWidth: number\nexport const getScrollBarWidth = (namespace: string): number => {\n  if (!isClient) return 0\n  if (scrollBarWidth !== undefined) return scrollBarWidth\n\n  const outer = document.createElement('div')\n  outer.className = `${namespace}-scrollbar__wrap`\n  outer.style.visibility = 'hidden'\n  outer.style.width = '100px'\n  outer.style.position = 'absolute'\n  outer.style.top = '-9999px'\n  document.body.appendChild(outer)\n\n  const widthNoScroll = outer.offsetWidth\n  outer.style.overflow = 'scroll'\n\n  const inner = document.createElement('div')\n  inner.style.width = '100%'\n  outer.appendChild(inner)\n\n  const widthWithScroll = inner.offsetWidth\n  outer.parentNode?.removeChild(outer)\n  scrollBarWidth = widthNoScroll - widthWithScroll\n\n  return scrollBarWidth\n}\n\n/**\n * Scroll with in the container element, positioning the **selected** element at the top\n * of the container\n */\nexport function scrollIntoView(\n  container: HTMLElement,\n  selected: HTMLElement\n): void {\n  if (!isClient) return\n\n  if (!selected) {\n    container.scrollTop = 0\n    return\n  }\n\n  const offsetParents: HTMLElement[] = []\n  let pointer = selected.offsetParent\n  while (\n    pointer !== null &&\n    container !== pointer &&\n    container.contains(pointer)\n  ) {\n    offsetParents.push(pointer as HTMLElement)\n    pointer = (pointer as HTMLElement).offsetParent\n  }\n  const top =\n    selected.offsetTop +\n    offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0)\n  const bottom = top + selected.offsetHeight\n  const viewRectTop = container.scrollTop\n  const viewRectBottom = viewRectTop + container.clientHeight\n\n  if (top < viewRectTop) {\n    container.scrollTop = top\n  } else if (bottom > viewRectBottom) {\n    container.scrollTop = bottom - container.clientHeight\n  }\n}\n", "import { isClient } from '../browser'\n\nconst globalNodes: HTMLElement[] = []\nlet target: HTMLElement = !isClient ? (undefined as any) : document.body\n\nexport function createGlobalNode(id?: string) {\n  const el = document.createElement('div')\n  if (id !== undefined) {\n    el.setAttribute('id', id)\n  }\n\n  target.appendChild(el)\n  globalNodes.push(el)\n\n  return el\n}\n\nexport function removeGlobalNode(el: HTMLElement) {\n  globalNodes.splice(globalNodes.indexOf(el), 1)\n  el.remove()\n}\n\nexport function changeGlobalNodesTarget(el: HTMLElement) {\n  if (el === target) return\n\n  target = el\n  globalNodes.forEach((el) => {\n    if (el.contains(target) === false) {\n      target.appendChild(el)\n    }\n  })\n}\n", "import { warn } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { isObject } from '../../types'\nimport { hasOwn } from '../../objects'\n\nimport type { PropType } from 'vue'\nimport type {\n  EpProp,\n  EpPropConvert,\n  EpPropFinalized,\n  EpPropInput,\n  EpPropMergeType,\n  IfEpProp,\n  IfNativePropType,\n  NativePropType,\n} from './types'\n\nexport const epPropKey = '__epPropKey'\n\nexport const definePropType = <T>(val: any): PropType<T> => val\n\nexport const isEpProp = (val: unknown): val is EpProp<any, any, any> =>\n  isObject(val) && !!(val as any)[epPropKey]\n\n/**\n * @description Build prop. It can better optimize prop types\n * @description 生成 prop，能更好地优化类型\n * @example\n  // limited options\n  // the type will be PropType<'light' | 'dark'>\n  buildProp({\n    type: String,\n    values: ['light', 'dark'],\n  } as const)\n  * @example\n  // limited options and other types\n  // the type will be PropType<'small' | 'large' | number>\n  buildProp({\n    type: [String, Number],\n    values: ['small', 'large'],\n    validator: (val: unknown): val is number => typeof val === 'number',\n  } as const)\n  @link see more: https://github.com/element-plus/element-plus/pull/3341\n */\nexport const buildProp = <\n  Type = never,\n  Value = never,\n  Validator = never,\n  Default extends EpPropMergeType<Type, Value, Validator> = never,\n  Required extends boolean = false\n>(\n  prop: EpPropInput<Type, Value, Validator, Default, Required>,\n  key?: string\n): EpPropFinalized<Type, Value, Validator, Default, Required> => {\n  // filter native prop type and nested prop, e.g `null`, `undefined` (from `buildProps`)\n  if (!isObject(prop) || isEpProp(prop)) return prop as any\n\n  const { values, required, default: defaultValue, type, validator } = prop\n\n  const _validator =\n    values || validator\n      ? (val: unknown) => {\n          let valid = false\n          let allowedValues: unknown[] = []\n\n          if (values) {\n            allowedValues = Array.from(values)\n            if (hasOwn(prop, 'default')) {\n              allowedValues.push(defaultValue)\n            }\n            valid ||= allowedValues.includes(val)\n          }\n          if (validator) valid ||= validator(val)\n\n          if (!valid && allowedValues.length > 0) {\n            const allowValuesText = [...new Set(allowedValues)]\n              .map((value) => JSON.stringify(value))\n              .join(', ')\n            warn(\n              `Invalid prop: validation failed${\n                key ? ` for prop \"${key}\"` : ''\n              }. Expected one of [${allowValuesText}], got value ${JSON.stringify(\n                val\n              )}.`\n            )\n          }\n          return valid\n        }\n      : undefined\n\n  const epProp: any = {\n    type,\n    required: !!required,\n    validator: _validator,\n    [epPropKey]: true,\n  }\n  if (hasOwn(prop, 'default')) epProp.default = defaultValue\n  return epProp\n}\n\nexport const buildProps = <\n  Props extends Record<\n    string,\n    | { [epPropKey]: true }\n    | NativePropType\n    | EpPropInput<any, any, any, any, any>\n  >\n>(\n  props: Props\n): {\n  [K in keyof Props]: IfEpProp<\n    Props[K],\n    Props[K],\n    IfNativePropType<Props[K], Props[K], EpPropConvert<Props[K]>>\n  >\n} =>\n  fromPairs(\n    Object.entries(props).map(([key, option]) => [\n      key,\n      buildProp(option as any, key),\n    ])\n  ) as any\n", "import {\n  CircleCheck,\n  CircleClose,\n  CircleCloseFilled,\n  Close,\n  InfoFilled,\n  Loading,\n  SuccessFilled,\n  WarningFilled,\n} from '@element-plus/icons-vue'\nimport { definePropType } from './props'\n\nimport type { Component } from 'vue'\n\nexport const iconPropType = definePropType<string | Component>([\n  String,\n  Object,\n  Function,\n])\n\nexport const CloseComponents = {\n  Close,\n}\n\nexport const TypeComponents = {\n  Close,\n  SuccessFilled,\n  InfoFilled,\n  WarningFilled,\n  CircleCloseFilled,\n}\n\nexport const TypeComponentsMap = {\n  success: SuccessFilled,\n  warning: WarningFilled,\n  error: CircleCloseFilled,\n  info: InfoFilled,\n}\n\nexport const ValidateComponentsMap = {\n  validating: Loading,\n  success: CircleCheck,\n  error: CircleClose,\n}\n", "import { isFunction } from '../types'\n\nimport type { ComponentPublicInstance, Ref } from 'vue'\n\nexport type RefSetter = (\n  el: Element | ComponentPublicInstance | undefined\n) => void\n\nexport const composeRefs = (\n  ...refs: (Ref<HTMLElement | undefined> | RefSetter)[]\n) => {\n  return (el: Element | ComponentPublicInstance | null) => {\n    refs.forEach((ref) => {\n      if (isFunction(ref)) {\n        ref(el as Element | ComponentPublicInstance)\n      } else {\n        ref.value = el as HTMLElement | undefined\n      }\n    })\n  }\n}\n", "import { componentSizeMap } from '@element-plus/constants'\n\nimport type { ComponentSize } from '@element-plus/constants'\n\nexport const getComponentSize = (size?: ComponentSize) => {\n  return componentSizeMap[size || 'default']\n}\n", "import { componentSizes, datePickTypes } from '@element-plus/constants'\nimport type { ComponentSize, DatePickType } from '@element-plus/constants'\n\nexport const isValidComponentSize = (val: string): val is ComponentSize | '' =>\n  ['', ...componentSizes].includes(val)\n\nexport const isValidDatePickType = (val: string): val is DatePickType =>\n  ([...datePickTypes] as string[]).includes(val)\n", "import {\n  Comment,\n  Fragment,\n  Text,\n  createBlock,\n  createCommentVNode,\n  isVNode,\n  openBlock,\n} from 'vue'\nimport { camelize, isArray } from '@vue/shared'\nimport { hasOwn } from '../objects'\nimport { debugWarn } from '../error'\nimport type {\n  VNode,\n  VNodeArrayChildren,\n  VNodeChild,\n  VNodeNormalizedChildren,\n} from 'vue'\n\nconst SCOPE = 'utils/vue/vnode'\n\nexport enum PatchFlags {\n  TEXT = 1,\n  CLASS = 2,\n  STYLE = 4,\n  PROPS = 8,\n  FULL_PROPS = 16,\n  HYDRATE_EVENTS = 32,\n  STABLE_FRAGMENT = 64,\n  KEYED_FRAGMENT = 128,\n  UNKEYED_FRAGMENT = 256,\n  NEED_PATCH = 512,\n  DYNAMIC_SLOTS = 1024,\n  HOISTED = -1,\n  BAIL = -2,\n}\n\nexport type VNodeChildAtom = Exclude<VNodeChild, Array<any>>\nexport type RawSlots = Exclude<\n  VNodeNormalizedChildren,\n  Array<any> | null | string\n>\n\nexport function isFragment(node: VNode): boolean\nexport function isFragment(node: unknown): node is VNode\nexport function isFragment(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Fragment\n}\n\nexport function isText(node: VNode): boolean\nexport function isText(node: unknown): node is VNode\nexport function isText(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Text\n}\n\nexport function isComment(node: VNode): boolean\nexport function isComment(node: unknown): node is VNode\nexport function isComment(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Comment\n}\n\nconst TEMPLATE = 'template'\nexport function isTemplate(node: VNode): boolean\nexport function isTemplate(node: unknown): node is VNode\nexport function isTemplate(node: unknown): node is VNode {\n  return isVNode(node) && node.type === TEMPLATE\n}\n\n/**\n * determine if the element is a valid element type rather than fragments and comment e.g. <template> v-if\n * @param node {VNode} node to be tested\n */\nexport function isValidElementNode(node: VNode): boolean\nexport function isValidElementNode(node: unknown): node is VNode\nexport function isValidElementNode(node: unknown): node is VNode {\n  return isVNode(node) && !isFragment(node) && !isComment(node)\n}\n\n/**\n * get a valid child node (not fragment nor comment)\n * @param node {VNode} node to be searched\n * @param depth {number} depth to be searched\n */\nfunction getChildren(\n  node: VNodeNormalizedChildren | VNodeChild,\n  depth: number\n): VNodeNormalizedChildren | VNodeChild {\n  if (isComment(node)) return\n  if (isFragment(node) || isTemplate(node)) {\n    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : undefined\n  }\n  return node\n}\n\nexport const getFirstValidNode = (\n  nodes: VNodeNormalizedChildren,\n  maxDepth = 3\n) => {\n  if (Array.isArray(nodes)) {\n    return getChildren(nodes[0], maxDepth)\n  } else {\n    return getChildren(nodes, maxDepth)\n  }\n}\n\nexport function renderIf(\n  condition: boolean,\n  ...args: Parameters<typeof createBlock>\n) {\n  return condition ? renderBlock(...args) : createCommentVNode('v-if', true)\n}\n\nexport function renderBlock(...args: Parameters<typeof createBlock>) {\n  return openBlock(), createBlock(...args)\n}\n\nexport const getNormalizedProps = (node: VNode) => {\n  if (!isVNode(node)) {\n    debugWarn(SCOPE, '[getNormalizedProps] must be a VNode')\n    return {}\n  }\n\n  const raw = node.props || {}\n  const type = (isVNode(node.type) ? node.type.props : undefined) || {}\n  const props: Record<string, any> = {}\n\n  Object.keys(type).forEach((key) => {\n    if (hasOwn(type[key], 'default')) {\n      props[key] = type[key].default\n    }\n  })\n\n  Object.keys(raw).forEach((key) => {\n    props[camelize(key)] = raw[key]\n  })\n\n  return props\n}\n\nexport const ensureOnlyChild = (children: VNodeArrayChildren | undefined) => {\n  if (!isArray(children) || children.length > 1) {\n    throw new Error('expect to receive a single Vue element child')\n  }\n  return children[0]\n}\n\nexport type FlattenVNodes = Array<VNodeChildAtom | RawSlots>\n\nexport const flattedChildren = (\n  children: FlattenVNodes | VNode | VNodeNormalizedChildren\n): FlattenVNodes => {\n  const vNodes = isArray(children) ? children : [children]\n  const result: FlattenVNodes = []\n\n  vNodes.forEach((child) => {\n    if (isArray(child)) {\n      result.push(...flattedChildren(child))\n    } else if (isVNode(child) && isArray(child.children)) {\n      result.push(...flattedChildren(child.children))\n    } else {\n      result.push(child)\n      if (isVNode(child) && child.component?.subTree) {\n        result.push(...flattedChildren(child.component.subTree))\n      }\n    }\n  })\n  return result\n}\n", "export const unique = <T>(arr: T[]) => [...new Set(arr)]\n\ntype Many<T> = T | ReadonlyArray<T>\n// TODO: rename to `ensureArray`\n/** like `_.castArray`, except falsy value returns empty array. */\nexport const castArray = <T>(arr: Many<T>): T[] => {\n  if (!arr && (arr as any) !== 0) return []\n  return Array.isArray(arr) ? arr : [arr]\n}\n\n// TODO: remove import alias\n// avoid naming conflicts\nexport { castArray as ensureArray } from 'lodash-unified'\n", "export const isKorean = (text: string) =>\n  /([\\uAC00-\\uD7AF\\u3130-\\u318F])+/gi.test(text)\n", "import { isClient } from './browser'\n\nexport const rAF = (fn: () => void) =>\n  isClient\n    ? window.requestAnimationFrame(fn)\n    : (setTimeout(fn, 16) as unknown as number)\n\nexport const cAF = (handle: number) =>\n  isClient ? window.cancelAnimationFrame(handle) : clearTimeout(handle)\n", "/**\n * Generate random number in range [0, 1000]\n * Maybe replace with [uuid](https://www.npmjs.com/package/uuid)\n */\nexport const generateId = (): number => Math.floor(Math.random() * 10000)\n\n/**\n * Generating a random int in range (0, max - 1)\n * @param max {number}\n */\nexport const getRandomInt = (max: number) =>\n  Math.floor(Math.random() * Math.floor(max))\n", "export const mutable = <T extends readonly any[] | Record<string, unknown>>(\n  val: T\n) => val as Mutable<typeof val>\nexport type Mutable<T> = { -readonly [P in keyof T]: T[P] }\n\nexport type HTMLElementCustomized<T> = HTMLElement & T\n\n/**\n * @deprecated stop to use null\n * @see {@link https://github.com/sindresorhus/meta/discussions/7}\n */\nexport type Nullable<T> = T | null\n\nexport type Arrayable<T> = T | T[]\nexport type Awaitable<T> = Promise<T> | T\n", "import { computed, getCurrentInstance } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { debugWarn } from '@element-plus/utils'\n\nimport type { ComputedRef } from 'vue'\n\ninterface Params {\n  excludeListeners?: boolean\n  excludeKeys?: ComputedRef<string[]>\n}\n\nconst DEFAULT_EXCLUDE_KEYS = ['class', 'style']\nconst LISTENER_PREFIX = /^on[A-Z]/\n\nexport const useAttrs = (\n  params: Params = {}\n): ComputedRef<Record<string, unknown>> => {\n  const { excludeListeners = false, excludeKeys } = params\n  const allExcludeKeys = computed<string[]>(() => {\n    return (excludeKeys?.value || []).concat(DEFAULT_EXCLUDE_KEYS)\n  })\n\n  const instance = getCurrentInstance()\n  if (!instance) {\n    debugWarn(\n      'use-attrs',\n      'getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function'\n    )\n    return computed(() => ({}))\n  }\n\n  return computed(() =>\n    fromPairs(\n      Object.entries(instance.proxy?.$attrs!).filter(\n        ([key]) =>\n          !allExcludeKeys.value.includes(key) &&\n          !(excludeListeners && LISTENER_PREFIX.test(key))\n      )\n    )\n  )\n}\n", "import { unref, watch } from 'vue'\nimport { debugWarn } from '@element-plus/utils'\n\nimport type { MaybeRef } from '@vueuse/core'\n\ntype DeprecationParam = {\n  from: string\n  replacement: string\n  scope: string\n  version: string\n  ref: string\n  type?: 'API' | 'Attribute' | 'Event' | 'Slot'\n}\n\nexport const useDeprecated = (\n  { from, replacement, scope, version, ref, type = 'API' }: DeprecationParam,\n  condition: MaybeRef<boolean>\n) => {\n  watch(\n    () => unref(condition),\n    (val) => {\n      if (val) {\n        debugWarn(\n          scope,\n          `[${type}] ${from} is about to be deprecated in version ${version}, please use ${replacement} instead.\nFor more detail, please visit: ${ref}\n`\n        )\n      }\n    },\n    {\n      immediate: true,\n    }\n  )\n}\n", "import { onBeforeUnmount, onMounted, watchEffect } from 'vue'\nimport { addUnit } from '@element-plus/utils'\nimport type { ComputedRef, Ref } from 'vue'\n\nexport const useDraggable = (\n  targetRef: Ref<HTMLElement | undefined>,\n  dragRef: Ref<HTMLElement | undefined>,\n  draggable: ComputedRef<boolean>\n) => {\n  let transform = {\n    offsetX: 0,\n    offsetY: 0,\n  }\n\n  const onMousedown = (e: MouseEvent) => {\n    const downX = e.clientX\n    const downY = e.clientY\n    const { offsetX, offsetY } = transform\n\n    const targetRect = targetRef.value!.getBoundingClientRect()\n    const targetLeft = targetRect.left\n    const targetTop = targetRect.top\n    const targetWidth = targetRect.width\n    const targetHeight = targetRect.height\n\n    const clientWidth = document.documentElement.clientWidth\n    const clientHeight = document.documentElement.clientHeight\n\n    const minLeft = -targetLeft + offsetX\n    const minTop = -targetTop + offsetY\n    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX\n    const maxTop = clientHeight - targetTop - targetHeight + offsetY\n\n    const onMousemove = (e: MouseEvent) => {\n      const moveX = Math.min(\n        Math.max(offsetX + e.clientX - downX, minLeft),\n        maxLeft\n      )\n      const moveY = Math.min(\n        Math.max(offsetY + e.clientY - downY, minTop),\n        maxTop\n      )\n\n      transform = {\n        offsetX: moveX,\n        offsetY: moveY,\n      }\n\n      if (targetRef.value) {\n        targetRef.value.style.transform = `translate(${addUnit(\n          moveX\n        )}, ${addUnit(moveY)})`\n      }\n    }\n\n    const onMouseup = () => {\n      document.removeEventListener('mousemove', onMousemove)\n      document.removeEventListener('mouseup', onMouseup)\n    }\n\n    document.addEventListener('mousemove', onMousemove)\n    document.addEventListener('mouseup', onMouseup)\n  }\n\n  const onDraggable = () => {\n    if (dragRef.value && targetRef.value) {\n      dragRef.value.addEventListener('mousedown', onMousedown)\n    }\n  }\n\n  const offDraggable = () => {\n    if (dragRef.value && targetRef.value) {\n      dragRef.value.removeEventListener('mousedown', onMousedown)\n    }\n  }\n\n  onMounted(() => {\n    watchEffect(() => {\n      if (draggable.value) {\n        onDraggable()\n      } else {\n        offDraggable()\n      }\n    })\n  })\n\n  onBeforeUnmount(() => {\n    offDraggable()\n  })\n}\n", "import type { Ref } from 'vue'\n\nexport const useFocus = (\n  el: Ref<{\n    focus: () => void\n  } | null>\n) => {\n  return {\n    focus: () => {\n      el.value?.focus?.()\n    },\n  }\n}\n", "export default {\n  name: 'en',\n  el: {\n    colorpicker: {\n      confirm: 'OK',\n      clear: 'Clear',\n      defaultLabel: 'color picker',\n      description:\n        'current color is {color}. press enter to select a new color.',\n    },\n    datepicker: {\n      now: 'Now',\n      today: 'Today',\n      cancel: 'Cancel',\n      clear: 'Clear',\n      confirm: 'OK',\n      dateTablePrompt:\n        'Use the arrow keys and enter to select the day of the month',\n      monthTablePrompt: 'Use the arrow keys and enter to select the month',\n      yearTablePrompt: 'Use the arrow keys and enter to select the year',\n      selectedDate: 'Selected date',\n      selectDate: 'Select date',\n      selectTime: 'Select time',\n      startDate: 'Start Date',\n      startTime: 'Start Time',\n      endDate: 'End Date',\n      endTime: 'End Time',\n      prevYear: 'Previous Year',\n      nextYear: 'Next Year',\n      prevMonth: 'Previous Month',\n      nextMonth: 'Next Month',\n      year: '',\n      month1: 'January',\n      month2: 'February',\n      month3: 'March',\n      month4: 'April',\n      month5: 'May',\n      month6: 'June',\n      month7: 'July',\n      month8: 'August',\n      month9: 'September',\n      month10: 'October',\n      month11: 'November',\n      month12: 'December',\n      week: 'week',\n      weeks: {\n        sun: 'Sun',\n        mon: 'Mon',\n        tue: 'Tue',\n        wed: 'Wed',\n        thu: 'Thu',\n        fri: 'Fri',\n        sat: 'Sat',\n      },\n      weeksFull: {\n        sun: 'Sunday',\n        mon: 'Monday',\n        tue: 'Tuesday',\n        wed: 'Wednesday',\n        thu: 'Thursday',\n        fri: 'Friday',\n        sat: 'Saturday',\n      },\n      months: {\n        jan: 'Jan',\n        feb: 'Feb',\n        mar: 'Mar',\n        apr: 'Apr',\n        may: 'May',\n        jun: 'Jun',\n        jul: 'Jul',\n        aug: 'Aug',\n        sep: 'Sep',\n        oct: 'Oct',\n        nov: 'Nov',\n        dec: 'Dec',\n      },\n    },\n    inputNumber: {\n      decrease: 'decrease number',\n      increase: 'increase number',\n    },\n    select: {\n      loading: 'Loading',\n      noMatch: 'No matching data',\n      noData: 'No data',\n      placeholder: 'Select',\n    },\n    dropdown: {\n      toggleDropdown: 'Toggle Dropdown',\n    },\n    cascader: {\n      noMatch: 'No matching data',\n      loading: 'Loading',\n      placeholder: 'Select',\n      noData: 'No data',\n    },\n    pagination: {\n      goto: 'Go to',\n      pagesize: '/page',\n      total: 'Total {total}',\n      pageClassifier: '',\n      page: 'Page',\n      prev: 'Go to previous page',\n      next: 'Go to next page',\n      currentPage: 'page {pager}',\n      prevPages: 'Previous {pager} pages',\n      nextPages: 'Next {pager} pages',\n      deprecationWarning:\n        'Deprecated usages detected, please refer to the el-pagination documentation for more details',\n    },\n    dialog: {\n      close: 'Close this dialog',\n    },\n    drawer: {\n      close: 'Close this dialog',\n    },\n    messagebox: {\n      title: 'Message',\n      confirm: 'OK',\n      cancel: 'Cancel',\n      error: 'Illegal input',\n      close: 'Close this dialog',\n    },\n    upload: {\n      deleteTip: 'press delete to remove',\n      delete: 'Delete',\n      preview: 'Preview',\n      continue: 'Continue',\n    },\n    slider: {\n      defaultLabel: 'slider between {min} and {max}',\n      defaultRangeStartLabel: 'pick start value',\n      defaultRangeEndLabel: 'pick end value',\n    },\n    table: {\n      emptyText: 'No Data',\n      confirmFilter: 'Confirm',\n      resetFilter: 'Reset',\n      clearFilter: 'All',\n      sumText: 'Sum',\n    },\n    tree: {\n      emptyText: 'No Data',\n    },\n    transfer: {\n      noMatch: 'No matching data',\n      noData: 'No data',\n      titles: ['List 1', 'List 2'], // to be translated\n      filterPlaceholder: 'Enter keyword', // to be translated\n      noCheckedFormat: '{total} items', // to be translated\n      hasCheckedFormat: '{checked}/{total} checked', // to be translated\n    },\n    image: {\n      error: 'FAILED',\n    },\n    pageHeader: {\n      title: 'Back', // to be translated\n    },\n    popconfirm: {\n      confirmButtonText: 'Yes',\n      cancelButtonText: 'No',\n    },\n  },\n}\n", "import { computed, inject, isRef, ref, unref } from 'vue'\nimport { get } from 'lodash-unified'\nimport English from '@element-plus/locale/lang/en'\n\nimport type { MaybeRef } from '@vueuse/core'\nimport type { InjectionKey, Ref } from 'vue'\nimport type { Language } from '@element-plus/locale'\n\nexport type TranslatorOption = Record<string, string | number>\nexport type Translator = (path: string, option?: TranslatorOption) => string\nexport type LocaleContext = {\n  locale: Ref<Language>\n  lang: Ref<string>\n  t: Translator\n}\n\nexport const buildTranslator =\n  (locale: MaybeRef<Language>): Translator =>\n  (path, option) =>\n    translate(path, option, unref(locale))\n\nexport const translate = (\n  path: string,\n  option: undefined | TranslatorOption,\n  locale: Language\n): string =>\n  (get(locale, path, path) as string).replace(\n    /\\{(\\w+)\\}/g,\n    (_, key) => `${option?.[key] ?? `{${key}}`}`\n  )\n\nexport const buildLocaleContext = (\n  locale: MaybeRef<Language>\n): LocaleContext => {\n  const lang = computed(() => unref(locale).name)\n  const localeRef = isRef(locale) ? locale : ref(locale)\n  return {\n    lang,\n    locale: localeRef,\n    t: buildTranslator(locale),\n  }\n}\n\nexport const localeContextKey: InjectionKey<Ref<Language | undefined>> =\n  Symbol('localeContextKey')\n\nexport const useLocale = (localeOverrides?: Ref<Language | undefined>) => {\n  const locale = localeOverrides || inject(localeContextKey, ref())!\n  return buildLocaleContext(computed(() => locale.value || English))\n}\n", "import { computed, getCurrentInstance, inject, ref, unref } from 'vue'\n\nimport type { InjectionKey, Ref } from 'vue'\n\nexport const defaultNamespace = 'el'\nconst statePrefix = 'is-'\n\nconst _bem = (\n  namespace: string,\n  block: string,\n  blockSuffix: string,\n  element: string,\n  modifier: string\n) => {\n  let cls = `${namespace}-${block}`\n  if (blockSuffix) {\n    cls += `-${blockSuffix}`\n  }\n  if (element) {\n    cls += `__${element}`\n  }\n  if (modifier) {\n    cls += `--${modifier}`\n  }\n  return cls\n}\n\nexport const namespaceContextKey: InjectionKey<Ref<string | undefined>> =\n  Symbol('namespaceContextKey')\n\nexport const useGetDerivedNamespace = (\n  namespaceOverrides?: Ref<string | undefined>\n) => {\n  const derivedNamespace =\n    namespaceOverrides ||\n    (getCurrentInstance()\n      ? inject(namespaceContextKey, ref(defaultNamespace))\n      : ref(defaultNamespace))\n  const namespace = computed(() => {\n    return unref(derivedNamespace) || defaultNamespace\n  })\n  return namespace\n}\n\nexport const useNamespace = (\n  block: string,\n  namespaceOverrides?: Ref<string | undefined>\n) => {\n  const namespace = useGetDerivedNamespace(namespaceOverrides)\n  const b = (blockSuffix = '') =>\n    _bem(namespace.value, block, blockSuffix, '', '')\n  const e = (element?: string) =>\n    element ? _bem(namespace.value, block, '', element, '') : ''\n  const m = (modifier?: string) =>\n    modifier ? _bem(namespace.value, block, '', '', modifier) : ''\n  const be = (blockSuffix?: string, element?: string) =>\n    blockSuffix && element\n      ? _bem(namespace.value, block, blockSuffix, element, '')\n      : ''\n  const em = (element?: string, modifier?: string) =>\n    element && modifier\n      ? _bem(namespace.value, block, '', element, modifier)\n      : ''\n  const bm = (blockSuffix?: string, modifier?: string) =>\n    blockSuffix && modifier\n      ? _bem(namespace.value, block, blockSuffix, '', modifier)\n      : ''\n  const bem = (blockSuffix?: string, element?: string, modifier?: string) =>\n    blockSuffix && element && modifier\n      ? _bem(namespace.value, block, blockSuffix, element, modifier)\n      : ''\n  const is: {\n    (name: string, state: boolean | undefined): string\n    (name: string): string\n  } = (name: string, ...args: [boolean | undefined] | []) => {\n    const state = args.length >= 1 ? args[0]! : true\n    return name && state ? `${statePrefix}${name}` : ''\n  }\n\n  // for css var\n  // --el-xxx: value;\n  const cssVar = (object: Record<string, string>) => {\n    const styles: Record<string, string> = {}\n    for (const key in object) {\n      if (object[key]) {\n        styles[`--${namespace.value}-${key}`] = object[key]\n      }\n    }\n    return styles\n  }\n  // with block\n  const cssVarBlock = (object: Record<string, string>) => {\n    const styles: Record<string, string> = {}\n    for (const key in object) {\n      if (object[key]) {\n        styles[`--${namespace.value}-${block}-${key}`] = object[key]\n      }\n    }\n    return styles\n  }\n\n  const cssVarName = (name: string) => `--${namespace.value}-${name}`\n  const cssVarBlockName = (name: string) =>\n    `--${namespace.value}-${block}-${name}`\n\n  return {\n    namespace,\n    b,\n    e,\n    m,\n    be,\n    em,\n    bm,\n    bem,\n    is,\n    // css\n    cssVar,\n    cssVarName,\n    cssVarBlock,\n    cssVarBlockName,\n  }\n}\n\nexport type UseNamespaceReturn = ReturnType<typeof useNamespace>\n", "import { isRef, onScopeDispose, watch } from 'vue'\nimport { computed } from '@vue/reactivity'\nimport {\n  addClass,\n  getScrollBarWidth,\n  getStyle,\n  hasClass,\n  isClient,\n  removeClass,\n  throwError,\n} from '@element-plus/utils'\nimport { useNamespace } from '../use-namespace'\n\nimport type { Ref } from 'vue'\nimport type { UseNamespaceReturn } from '../use-namespace'\n\nexport type UseLockScreenOptions = {\n  ns?: UseNamespaceReturn\n  // shouldLock?: MaybeRef<boolean>\n}\n\n/**\n * Hook that monitoring the ref value to lock or unlock the screen.\n * When the trigger became true, it assumes modal is now opened and vice versa.\n * @param trigger {Ref<boolean>}\n */\nexport const useLockscreen = (\n  trigger: Ref<boolean>,\n  options: UseLockScreenOptions = {}\n) => {\n  if (!isRef(trigger)) {\n    throwError(\n      '[useLockscreen]',\n      'You need to pass a ref param to this function'\n    )\n  }\n\n  const ns = options.ns || useNamespace('popup')\n\n  const hiddenCls = computed(() => ns.bm('parent', 'hidden'))\n\n  if (!isClient || hasClass(document.body, hiddenCls.value)) {\n    return\n  }\n\n  let scrollBarWidth = 0\n  let withoutHiddenClass = false\n  let bodyWidth = '0'\n\n  const cleanup = () => {\n    setTimeout(() => {\n      removeClass(document?.body, hiddenCls.value)\n      if (withoutHiddenClass && document) {\n        document.body.style.width = bodyWidth\n      }\n    }, 200)\n  }\n  watch(trigger, (val) => {\n    if (!val) {\n      cleanup()\n      return\n    }\n\n    withoutHiddenClass = !hasClass(document.body, hiddenCls.value)\n    if (withoutHiddenClass) {\n      bodyWidth = document.body.style.width\n    }\n    scrollBarWidth = getScrollBarWidth(ns.namespace.value)\n    const bodyHasOverflow =\n      document.documentElement.clientHeight < document.body.scrollHeight\n    const bodyOverflowY = getStyle(document.body, 'overflowY')\n    if (\n      scrollBarWidth > 0 &&\n      (bodyHasOverflow || bodyOverflowY === 'scroll') &&\n      withoutHiddenClass\n    ) {\n      document.body.style.width = `calc(100% - ${scrollBarWidth}px)`\n    }\n    addClass(document.body, hiddenCls.value)\n  })\n  onScopeDispose(() => cleanup())\n}\n", "import { watch } from 'vue'\nimport { isClient, useEventListener } from '@vueuse/core'\nimport { EVENT_CODE } from '@element-plus/constants'\n\nimport type { Ref } from 'vue'\n\ntype ModalInstance = {\n  handleClose: () => void\n}\n\nconst modalStack: ModalInstance[] = []\n\nconst closeModal = (e: KeyboardEvent) => {\n  if (modalStack.length === 0) return\n  if (e.code === EVENT_CODE.esc) {\n    e.stopPropagation()\n    const topModal = modalStack[modalStack.length - 1]\n    topModal.handleClose()\n  }\n}\n\nexport const useModal = (instance: ModalInstance, visibleRef: Ref<boolean>) => {\n  watch(visibleRef, (val) => {\n    if (val) {\n      modalStack.push(instance)\n    } else {\n      modalStack.splice(modalStack.indexOf(instance), 1)\n    }\n  })\n}\n\nif (isClient) useEventListener(document, 'keydown', closeModal)\n", "import { computed, getCurrentInstance, onMounted, watch } from 'vue'\nimport { isFunction } from '@vue/shared'\nimport {\n  buildProp,\n  definePropType,\n  isBoolean,\n  isClient,\n} from '@element-plus/utils'\nimport type { ExtractPropType } from '@element-plus/utils'\nimport type { RouteLocationNormalizedLoaded } from 'vue-router'\n\nimport type { ComponentPublicInstance, ExtractPropTypes, Ref } from 'vue'\n\nconst _prop = buildProp({\n  type: definePropType<boolean | null>(Boolean),\n  default: null,\n} as const)\nconst _event = buildProp({\n  type: definePropType<(val: boolean) => void>(Function),\n} as const)\n\nexport type UseModelTogglePropsRaw<T extends string> = {\n  [K in T]: typeof _prop\n} & {\n  [K in `onUpdate:${T}`]: typeof _event\n}\n\nexport type UseModelTogglePropsGeneric<T extends string> = {\n  [K in T]: ExtractPropType<typeof _prop>\n} & {\n  [K in `onUpdate:${T}`]: ExtractPropType<typeof _event>\n}\n\nexport const createModelToggleComposable = <T extends string>(name: T) => {\n  const updateEventKey = `update:${name}` as const\n  const updateEventKeyRaw = `onUpdate:${name}` as const\n  const useModelToggleEmits = [updateEventKey]\n\n  const useModelToggleProps = {\n    [name]: _prop,\n    [updateEventKeyRaw]: _event,\n  } as UseModelTogglePropsRaw<T>\n\n  const useModelToggle = ({\n    indicator,\n    toggleReason,\n    shouldHideWhenRouteChanges,\n    shouldProceed,\n    onShow,\n    onHide,\n  }: ModelToggleParams) => {\n    const instance = getCurrentInstance()!\n    const { emit } = instance\n    const props = instance.props as UseModelTogglePropsGeneric<T> & {\n      disabled: boolean\n    }\n    const hasUpdateHandler = computed(() =>\n      isFunction(props[updateEventKeyRaw])\n    )\n    // when it matches the default value we say this is absent\n    // though this could be mistakenly passed from the user but we need to rule out that\n    // condition\n    const isModelBindingAbsent = computed(() => props[name] === null)\n\n    const doShow = (event?: Event) => {\n      if (indicator.value === true) {\n        return\n      }\n\n      indicator.value = true\n      if (toggleReason) {\n        toggleReason.value = event\n      }\n      if (isFunction(onShow)) {\n        onShow(event)\n      }\n    }\n\n    const doHide = (event?: Event) => {\n      if (indicator.value === false) {\n        return\n      }\n\n      indicator.value = false\n      if (toggleReason) {\n        toggleReason.value = event\n      }\n      if (isFunction(onHide)) {\n        onHide(event)\n      }\n    }\n\n    const show = (event?: Event) => {\n      if (\n        props.disabled === true ||\n        (isFunction(shouldProceed) && !shouldProceed())\n      )\n        return\n\n      const shouldEmit = hasUpdateHandler.value && isClient\n\n      if (shouldEmit) {\n        emit(updateEventKey, true)\n      }\n\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doShow(event)\n      }\n    }\n\n    const hide = (event?: Event) => {\n      if (props.disabled === true || !isClient) return\n\n      const shouldEmit = hasUpdateHandler.value && isClient\n\n      if (shouldEmit) {\n        emit(updateEventKey, false)\n      }\n\n      if (isModelBindingAbsent.value || !shouldEmit) {\n        doHide(event)\n      }\n    }\n\n    const onChange = (val: boolean) => {\n      if (!isBoolean(val)) return\n      if (props.disabled && val) {\n        if (hasUpdateHandler.value) {\n          emit(updateEventKey, false)\n        }\n      } else if (indicator.value !== val) {\n        if (val) {\n          doShow()\n        } else {\n          doHide()\n        }\n      }\n    }\n\n    const toggle = () => {\n      if (indicator.value) {\n        hide()\n      } else {\n        show()\n      }\n    }\n\n    watch(() => props[name], onChange)\n\n    if (\n      shouldHideWhenRouteChanges &&\n      instance.appContext.config.globalProperties.$route !== undefined\n    ) {\n      watch(\n        () => ({\n          ...(\n            instance.proxy as ComponentPublicInstance<{\n              $route: RouteLocationNormalizedLoaded\n            }>\n          ).$route,\n        }),\n        () => {\n          if (shouldHideWhenRouteChanges.value && indicator.value) {\n            hide()\n          }\n        }\n      )\n    }\n\n    onMounted(() => {\n      onChange(props[name])\n    })\n\n    return {\n      hide,\n      show,\n      toggle,\n      hasUpdateHandler,\n    }\n  }\n\n  return {\n    useModelToggle,\n    useModelToggleProps,\n    useModelToggleEmits,\n  }\n}\n\nconst { useModelToggle, useModelToggleProps, useModelToggleEmits } =\n  createModelToggleComposable('modelValue')\n\nexport { useModelToggle, useModelToggleEmits, useModelToggleProps }\n\nexport type UseModelToggleProps = ExtractPropTypes<typeof useModelToggleProps>\n\nexport type ModelToggleParams = {\n  indicator: Ref<boolean>\n  toggleReason?: Ref<Event | undefined>\n  shouldHideWhenRouteChanges?: Ref<boolean>\n  shouldProceed?: () => boolean\n  onShow?: (event?: Event) => void\n  onHide?: (event?: Event) => void\n}\n", "import { watch } from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport type { Ref } from 'vue'\n\nexport const usePreventGlobal = <E extends keyof DocumentEventMap>(\n  indicator: Ref<boolean>,\n  evt: E,\n  cb: (e: DocumentEventMap[E]) => boolean\n) => {\n  const prevent = (e: DocumentEventMap[E]) => {\n    if (cb(e)) e.stopImmediatePropagation()\n  }\n  let stop: (() => void) | undefined = undefined\n  watch(\n    () => indicator.value,\n    (val) => {\n      if (val) {\n        stop = useEventListener(document, evt, prevent, true)\n      } else {\n        stop?.()\n      }\n    },\n    { immediate: true }\n  )\n}\n", "import { computed, getCurrentInstance } from 'vue'\nimport type { ComputedRef } from 'vue'\n\nexport const useProp = <T>(name: string): ComputedRef<T | undefined> => {\n  const vm = getCurrentInstance()\n  return computed(() => (vm?.proxy?.$props as any)?.[name])\n}\n", "import { computed, onBeforeUnmount, ref, shallowRef, unref, watch } from 'vue'\nimport { createPopper } from '@popperjs/core'\nimport { fromPairs } from 'lodash-unified'\n\nimport type { Ref } from 'vue'\nimport type {\n  Instance,\n  Modifier,\n  Options,\n  State,\n  VirtualElement,\n} from '@popperjs/core'\n\ntype ElementType = HTMLElement | undefined\ntype ReferenceElement = ElementType | VirtualElement\nexport type PartialOptions = Partial<Options>\n\nexport const usePopper = (\n  referenceElementRef: Ref<ReferenceElement>,\n  popperElementRef: Ref<ElementType>,\n  opts: Ref<PartialOptions> | PartialOptions = {} as PartialOptions\n) => {\n  const stateUpdater = {\n    name: 'updateState',\n    enabled: true,\n    phase: 'write',\n    fn: ({ state }) => {\n      const derivedState = deriveState(state)\n\n      Object.assign(states.value, derivedState)\n    },\n    requires: ['computeStyles'],\n  } as Modifier<'updateState', any>\n\n  const options = computed<Options>(() => {\n    const { onFirstUpdate, placement, strategy, modifiers } = unref(opts)\n\n    return {\n      onFirstUpdate,\n      placement: placement || 'bottom',\n      strategy: strategy || 'absolute',\n      modifiers: [\n        ...(modifiers || []),\n        stateUpdater,\n        { name: 'applyStyles', enabled: false },\n      ],\n    }\n  })\n\n  const instanceRef = shallowRef<Instance | undefined>()\n  const states = ref<Pick<State, 'styles' | 'attributes'>>({\n    styles: {\n      popper: {\n        position: unref(options).strategy,\n        left: '0',\n        top: '0',\n      },\n      arrow: {\n        position: 'absolute',\n      },\n    },\n    attributes: {},\n  })\n\n  const destroy = () => {\n    if (!instanceRef.value) return\n\n    instanceRef.value.destroy()\n    instanceRef.value = undefined\n  }\n\n  watch(\n    options,\n    (newOptions) => {\n      const instance = unref(instanceRef)\n      if (instance) {\n        instance.setOptions(newOptions)\n      }\n    },\n    {\n      deep: true,\n    }\n  )\n\n  watch(\n    [referenceElementRef, popperElementRef],\n    ([referenceElement, popperElement]) => {\n      destroy()\n      if (!referenceElement || !popperElement) return\n\n      instanceRef.value = createPopper(\n        referenceElement,\n        popperElement,\n        unref(options)\n      )\n    }\n  )\n\n  onBeforeUnmount(() => {\n    destroy()\n  })\n\n  return {\n    state: computed(() => ({ ...(unref(instanceRef)?.state || {}) })),\n    styles: computed(() => unref(states).styles),\n    attributes: computed(() => unref(states).attributes),\n    update: () => unref(instanceRef)?.update(),\n    forceUpdate: () => unref(instanceRef)?.forceUpdate(),\n    // Preventing end users from modifying the instance.\n    instanceRef: computed(() => unref(instanceRef)),\n  }\n}\n\nfunction deriveState(state: State) {\n  const elements = Object.keys(state.elements) as unknown as Array<\n    keyof State['elements']\n  >\n\n  const styles = fromPairs(\n    elements.map(\n      (element) =>\n        [element, state.styles[element] || {}] as [\n          string,\n          State['styles'][keyof State['styles']]\n        ]\n    )\n  )\n\n  const attributes = fromPairs(\n    elements.map(\n      (element) =>\n        [element, state.attributes[element]] as [\n          string,\n          State['attributes'][keyof State['attributes']]\n        ]\n    )\n  )\n\n  return {\n    styles,\n    attributes,\n  }\n}\n\nexport type UsePopperReturn = ReturnType<typeof usePopper>\n", "import { NOOP } from '@vue/shared'\n\nexport const useSameTarget = (handleClick?: (e: MouseEvent) => void) => {\n  if (!handleClick) {\n    return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP }\n  }\n\n  let mousedownTarget = false\n  let mouseupTarget = false\n  // refer to this https://javascript.info/mouse-events-basics\n  // events fired in the order: mousedown -> mouseup -> click\n  // we need to set the mousedown handle to false after click fired.\n  const onClick = (e: MouseEvent) => {\n    // if and only if\n    if (mousedownTarget && mouseupTarget) {\n      handleClick(e)\n    }\n    mousedownTarget = mouseupTarget = false\n  }\n\n  const onMousedown = (e: MouseEvent) => {\n    // marking current mousedown target.\n    mousedownTarget = e.target === e.currentTarget\n  }\n  const onMouseup = (e: MouseEvent) => {\n    // marking current mouseup target.\n    mouseupTarget = e.target === e.currentTarget\n  }\n\n  return { onClick, onMousedown, onMouseup }\n}\n", "import { Teleport, h, onUnmounted, ref } from 'vue'\nimport { NOOP } from '@vue/shared'\nimport {\n  createGlobalNode,\n  isClient,\n  removeGlobalNode,\n} from '@element-plus/utils'\n\nimport type { Ref, VNode } from 'vue'\n\nexport const useTeleport = (\n  contentRenderer: () => VNode,\n  appendToBody: Ref<boolean>\n) => {\n  const isTeleportVisible = ref(false)\n\n  if (!isClient) {\n    return {\n      isTeleportVisible,\n      showTeleport: NOOP,\n      hideTeleport: NOOP,\n      renderTeleport: NOOP,\n    }\n  }\n\n  let $el: HTMLElement | null = null\n\n  const showTeleport = () => {\n    isTeleportVisible.value = true\n    // this allows the delayed showing strategy since the the content itself could be enterable\n    // e.g. el-popper\n    if ($el !== null) return\n\n    $el = createGlobalNode()\n  }\n\n  const hideTeleport = () => {\n    isTeleportVisible.value = false\n    if ($el !== null) {\n      removeGlobalNode($el)\n      $el = null\n    }\n  }\n\n  const renderTeleport = () => {\n    return appendToBody.value !== true\n      ? contentRenderer()\n      : isTeleportVisible.value\n      ? [h(Teleport, { to: $el }, contentRenderer())]\n      : undefined\n  }\n\n  onUnmounted(hideTeleport)\n\n  return {\n    isTeleportVisible,\n    showTeleport,\n    hideTeleport,\n    renderTeleport,\n  }\n}\n", "import { onMounted, ref, watch } from 'vue'\n\nimport type { Ref } from 'vue'\n\nexport const useThrottleRender = (loading: Ref<boolean>, throttle = 0) => {\n  if (throttle === 0) return loading\n  const throttled = ref(false)\n  let timeoutHandle = 0\n\n  const dispatchThrottling = () => {\n    if (timeoutHandle) {\n      clearTimeout(timeoutHandle)\n    }\n    timeoutHandle = window.setTimeout(() => {\n      throttled.value = loading.value\n    }, throttle)\n  }\n  onMounted(dispatchThrottling)\n\n  watch(\n    () => loading.value,\n    (val) => {\n      if (val) {\n        dispatchThrottling()\n      } else {\n        throttled.value = val\n      }\n    }\n  )\n  return throttled\n}\n", "import { tryOnScopeDispose } from '@vueuse/core'\n\nexport function useTimeout() {\n  let timeoutHandle: number\n\n  const registerTimeout = (fn: (...args: any[]) => any, delay: number) => {\n    cancelTimeout()\n    timeoutHandle = window.setTimeout(fn, delay)\n  }\n  const cancelTimeout = () => window.clearTimeout(timeoutHandle)\n\n  tryOnScopeDispose(() => cancelTimeout())\n\n  return {\n    registerTimeout,\n    cancelTimeout,\n  }\n}\n", "/* istanbul ignore file */\nimport { getCurrentInstance } from 'vue'\n\nconst AFTER_APPEAR = 'after-appear'\nconst AFTER_ENTER = 'after-enter'\nconst AFTER_LEAVE = 'after-leave'\nconst APPEAR = 'appear'\nconst APPEAR_CANCELLED = 'appear-cancelled'\nconst BEFORE_ENTER = 'before-enter'\nconst BEFORE_LEAVE = 'before-leave'\nconst ENTER = 'enter'\nconst ENTER_CANCELLED = 'enter-cancelled'\nconst LEAVE = 'leave'\nconst LEAVE_CANCELLED = 'leave-cancelled'\n\nexport const useTransitionFallthroughEmits = [\n  AFTER_APPEAR,\n  AFTER_ENTER,\n  AFTER_LEAVE,\n  APPEAR,\n  APPEAR_CANCELLED,\n  BEFORE_ENTER,\n  BEFORE_LEAVE,\n  ENTER,\n  ENTER_CANCELLED,\n  LEAVE,\n  LEAVE_CANCELLED,\n] as const\n\n// Sometimes we want to delegate the transition emitted event\n// we have to right the function locally, which is not a good\n// approach to this, so we created this hook for the event\n// fallthrough\n\n/**\n * NOTE:\n * This is only a delegator for delegating transition callbacks.\n * Use this at your need.\n */\n\n/**\n * Simple usage\n *\n * In your setups:\n *\n * setup() {\n *   const fallthroughMethods = useTransitionFallthrough()\n *   return fallthrough\n * }\n *\n * In your template:\n *\n * <template>\n *  <transition name=\"whatever\" v-bind=\"fallthrough\">\n *    <slot />\n *  </transition>\n * </template>\n *\n */\n\nexport const useTransitionFallthrough = () => {\n  const { emit } = getCurrentInstance()!\n\n  return {\n    onAfterAppear: () => {\n      emit(AFTER_APPEAR)\n    },\n    onAfterEnter: () => {\n      emit(AFTER_ENTER)\n    },\n    onAfterLeave: () => {\n      emit(AFTER_LEAVE)\n    },\n    onAppearCancelled: () => {\n      emit(APPEAR_CANCELLED)\n    },\n    onBeforeEnter: () => {\n      emit(BEFORE_ENTER)\n    },\n    onBeforeLeave: () => {\n      emit(BEFORE_LEAVE)\n    },\n    onEnter: () => {\n      emit(ENTER)\n    },\n    onEnterCancelled: () => {\n      emit(ENTER_CANCELLED)\n    },\n    onLeave: () => {\n      emit(LEAVE)\n    },\n    onLeaveCancelled: () => {\n      emit(LEAVE_CANCELLED)\n    },\n  }\n}\n", "import { computed, getCurrentInstance, inject, unref } from 'vue'\nimport { debugWarn, isClient } from '@element-plus/utils'\nimport { useGetDerivedNamespace } from '../use-namespace'\n\nimport type { InjectionKey, Ref } from 'vue'\nimport type { MaybeRef } from '@vueuse/core'\n\nexport type ElIdInjectionContext = {\n  prefix: number\n  current: number\n}\n\nconst defaultIdInjection = {\n  prefix: Math.floor(Math.random() * 10000),\n  current: 0,\n}\n\nexport const ID_INJECTION_KEY: InjectionKey<ElIdInjectionContext> =\n  Symbol('elIdInjection')\n\nexport const useIdInjection = (): ElIdInjectionContext => {\n  return getCurrentInstance()\n    ? inject(ID_INJECTION_KEY, defaultIdInjection)\n    : defaultIdInjection\n}\n\nexport const useId = (deterministicId?: MaybeRef<string>): Ref<string> => {\n  const idInjection = useIdInjection()\n  if (!isClient && idInjection === defaultIdInjection) {\n    debugWarn(\n      'IdInjection',\n      `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed\nusage: app.provide(ID_INJECTION_KEY, {\n  prefix: number,\n  current: number,\n})`\n    )\n  }\n\n  const namespace = useGetDerivedNamespace()\n  const idRef = computed(\n    () =>\n      unref(deterministicId) ||\n      `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`\n  )\n\n  return idRef\n}\n", "import { onBeforeUnmount, onMounted } from 'vue'\nimport { isClient } from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\n\nlet registeredEscapeHandlers: ((e: KeyboardEvent) => void)[] = []\n\nconst cachedHandler = (e: Event) => {\n  const event = e as KeyboardEvent\n  if (event.key === EVENT_CODE.esc) {\n    registeredEscapeHandlers.forEach((registeredHandler) =>\n      registeredHandler(event)\n    )\n  }\n}\n\nexport const useEscapeKeydown = (handler: (e: KeyboardEvent) => void) => {\n  onMounted(() => {\n    if (registeredEscapeHandlers.length === 0) {\n      document.addEventListener('keydown', cachedHandler)\n    }\n    if (isClient) registeredEscapeHandlers.push(handler)\n  })\n\n  onBeforeUnmount(() => {\n    registeredEscapeHandlers = registeredEscapeHandlers.filter(\n      (registeredHandler) => registeredHandler !== handler\n    )\n    if (registeredEscapeHandlers.length === 0) {\n      if (isClient) document.removeEventListener('keydown', cachedHandler)\n    }\n  })\n}\n", "import { computed, onBeforeMount } from 'vue'\nimport { isClient } from '@element-plus/utils'\nimport { useGetDerivedNamespace } from '../use-namespace'\nimport { useIdInjection } from '../use-id'\n\nlet cachedContainer: HTMLElement\n\nexport const usePopperContainerId = () => {\n  const namespace = useGetDerivedNamespace()\n  const idInjection = useIdInjection()\n\n  const id = computed(() => {\n    return `${namespace.value}-popper-container-${idInjection.prefix}`\n  })\n  const selector = computed(() => `#${id.value}`)\n\n  return {\n    id,\n    selector,\n  }\n}\n\nconst createContainer = (id: string) => {\n  const container = document.createElement('div')\n  container.id = id\n  document.body.appendChild(container)\n  return container\n}\n\nexport const usePopperContainer = () => {\n  const { id, selector } = usePopperContainerId()\n  onBeforeMount(() => {\n    if (!isClient) return\n\n    // This is for bypassing the error that when under testing env, we often encounter\n    // document.body.innerHTML = '' situation\n    // for this we need to disable the caching since it's not really needed\n    if (\n      process.env.NODE_ENV === 'test' ||\n      (!cachedContainer && !document.body.querySelector(selector.value))\n    ) {\n      cachedContainer = createContainer(id.value)\n    }\n  })\n\n  return {\n    id,\n    selector,\n  }\n}\n", "import { nextTick, unref, watch } from 'vue'\n\nimport type { Ref } from 'vue'\n\nexport type UseDelayedRenderProps = {\n  indicator: Ref<boolean>\n  intermediateIndicator: Ref<boolean>\n  shouldSetIntermediate?: (step: 'show' | 'hide') => boolean\n  beforeShow?: () => void\n  beforeHide?: () => void\n  afterShow?: () => void\n  afterHide?: () => void\n}\n\nexport const useDelayedRender = ({\n  indicator,\n  intermediateIndicator,\n  shouldSetIntermediate = () => true,\n  beforeShow,\n  afterShow,\n  afterHide,\n  beforeHide,\n}: UseDelayedRenderProps) => {\n  watch(\n    () => unref(indicator),\n    (val) => {\n      if (val) {\n        beforeShow?.()\n        nextTick(() => {\n          if (!unref(indicator)) return\n          if (shouldSetIntermediate('show')) {\n            intermediateIndicator.value = true\n          }\n        })\n      } else {\n        beforeHide?.()\n        nextTick(() => {\n          if (unref(indicator)) return\n\n          if (shouldSetIntermediate('hide')) {\n            intermediateIndicator.value = false\n          }\n        })\n      }\n    }\n  )\n\n  // because we don't always set the value ourselves, so that we\n  // simply watch the value's state, then invoke the corresponding hook.\n  watch(\n    () => intermediateIndicator.value,\n    (val) => {\n      if (val) {\n        afterShow?.()\n      } else {\n        afterHide?.()\n      }\n    }\n  )\n}\n", "import { unref } from 'vue'\nimport { buildProps, isNumber } from '@element-plus/utils'\nimport { useTimeout } from '../use-timeout'\n\nimport type { ExtractPropTypes, ToRefs } from 'vue'\n\nexport const useDelayedToggleProps = buildProps({\n  /**\n   * @description delay of appearance, in millisecond\n   */\n  showAfter: {\n    type: Number,\n    default: 0,\n  },\n  /**\n   * @description delay of disappear, in millisecond\n   */\n  hideAfter: {\n    type: Number,\n    default: 200,\n  },\n  /**\n   * @description disappear automatically, in millisecond\n   */\n  autoClose: {\n    type: Number,\n    default: 0,\n  },\n} as const)\n\nexport type UseDelayedToggleProps = {\n  open: (event?: Event) => void\n  close: (event?: Event) => void\n} & ToRefs<ExtractPropTypes<typeof useDelayedToggleProps>>\n\nexport const useDelayedToggle = ({\n  showAfter,\n  hideAfter,\n  autoClose,\n  open,\n  close,\n}: UseDelayedToggleProps) => {\n  const { registerTimeout } = useTimeout()\n  const {\n    registerTimeout: registerTimeoutForAutoClose,\n    cancelTimeout: cancelTimeoutForAutoClose,\n  } = useTimeout()\n\n  const onOpen = (event?: Event) => {\n    registerTimeout(() => {\n      open(event)\n\n      const _autoClose = unref(autoClose)\n      if (isNumber(_autoClose) && _autoClose > 0) {\n        registerTimeoutForAutoClose(() => {\n          close(event)\n        }, _autoClose)\n      }\n    }, unref(showAfter))\n  }\n\n  const onClose = (event?: Event) => {\n    cancelTimeoutForAutoClose()\n\n    registerTimeout(() => {\n      close(event)\n    }, unref(hideAfter))\n  }\n\n  return {\n    onOpen,\n    onClose,\n  }\n}\n", "import { provide } from 'vue'\n\nimport type { InjectionKey, ObjectDirective, Ref } from 'vue'\n\ntype ForwardRefSetter = <T>(el: T) => void\n\nexport type ForwardRefInjectionContext = {\n  setForwardRef: ForwardRefSetter\n}\n\nexport const FORWARD_REF_INJECTION_KEY: InjectionKey<ForwardRefInjectionContext> =\n  Symbol('elForwardRef')\n\nexport const useForwardRef = <T>(forwardRef: Ref<T | null>) => {\n  const setForwardRef = (el: T) => {\n    forwardRef.value = el\n  }\n\n  provide(FORWARD_REF_INJECTION_KEY, {\n    setForwardRef,\n  })\n}\n\nexport const useForwardRefDirective = (\n  setForwardRef: ForwardRefSetter\n): ObjectDirective => {\n  return {\n    mounted(el) {\n      setForwardRef(el)\n    },\n    updated(el) {\n      setForwardRef(el)\n    },\n    unmounted() {\n      setForwardRef(null)\n    },\n  }\n}\n", "import { computed, getCurrentInstance, inject, ref, unref } from 'vue'\nimport { isNumber } from '@element-plus/utils'\n\nimport type { InjectionKey, Ref } from 'vue'\n\nconst zIndex = ref(0)\nexport const defaultInitialZIndex = 2000\n\nexport const zIndexContextKey: InjectionKey<Ref<number | undefined>> =\n  Symbol('zIndexContextKey')\n\nexport const useZIndex = (zIndexOverrides?: Ref<number>) => {\n  const zIndexInjection =\n    zIndexOverrides ||\n    (getCurrentInstance() ? inject(zIndexContextKey, undefined) : undefined)\n  const initialZIndex = computed(() => {\n    const zIndexFromInjection = unref(zIndexInjection)\n    return isNumber(zIndexFromInjection)\n      ? zIndexFromInjection\n      : defaultInitialZIndex\n  })\n  const currentZIndex = computed(() => initialZIndex.value + zIndex.value)\n\n  const nextZIndex = () => {\n    zIndex.value++\n    return currentZIndex.value\n  }\n\n  return {\n    initialZIndex,\n    currentZIndex,\n    nextZIndex,\n  }\n}\n\nexport type UseZIndexReturn = ReturnType<typeof useZIndex>\n", "const sides = ['top', 'right', 'bottom', 'left'];\r\nconst alignments = ['start', 'end'];\r\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\r\nconst min = Math.min;\r\nconst max = Math.max;\r\nconst round = Math.round;\r\nconst floor = Math.floor;\r\nconst createCoords = v => ({\r\n  x: v,\r\n  y: v\r\n});\r\nconst oppositeSideMap = {\r\n  left: 'right',\r\n  right: 'left',\r\n  bottom: 'top',\r\n  top: 'bottom'\r\n};\r\nconst oppositeAlignmentMap = {\r\n  start: 'end',\r\n  end: 'start'\r\n};\r\nfunction clamp(start, value, end) {\r\n  return max(start, min(value, end));\r\n}\r\nfunction evaluate(value, param) {\r\n  return typeof value === 'function' ? value(param) : value;\r\n}\r\nfunction getSide(placement) {\r\n  return placement.split('-')[0];\r\n}\r\nfunction getAlignment(placement) {\r\n  return placement.split('-')[1];\r\n}\r\nfunction getOppositeAxis(axis) {\r\n  return axis === 'x' ? 'y' : 'x';\r\n}\r\nfunction getAxisLength(axis) {\r\n  return axis === 'y' ? 'height' : 'width';\r\n}\r\nfunction getSideAxis(placement) {\r\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\r\n}\r\nfunction getAlignmentAxis(placement) {\r\n  return getOppositeAxis(getSideAxis(placement));\r\n}\r\nfunction getAlignmentSides(placement, rects, rtl) {\r\n  if (rtl === void 0) {\r\n    rtl = false;\r\n  }\r\n  const alignment = getAlignment(placement);\r\n  const alignmentAxis = getAlignmentAxis(placement);\r\n  const length = getAxisLength(alignmentAxis);\r\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\r\n  if (rects.reference[length] > rects.floating[length]) {\r\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\r\n  }\r\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\r\n}\r\nfunction getExpandedPlacements(placement) {\r\n  const oppositePlacement = getOppositePlacement(placement);\r\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\r\n}\r\nfunction getOppositeAlignmentPlacement(placement) {\r\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\r\n}\r\nfunction getSideList(side, isStart, rtl) {\r\n  const lr = ['left', 'right'];\r\n  const rl = ['right', 'left'];\r\n  const tb = ['top', 'bottom'];\r\n  const bt = ['bottom', 'top'];\r\n  switch (side) {\r\n    case 'top':\r\n    case 'bottom':\r\n      if (rtl) return isStart ? rl : lr;\r\n      return isStart ? lr : rl;\r\n    case 'left':\r\n    case 'right':\r\n      return isStart ? tb : bt;\r\n    default:\r\n      return [];\r\n  }\r\n}\r\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\r\n  const alignment = getAlignment(placement);\r\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\r\n  if (alignment) {\r\n    list = list.map(side => side + \"-\" + alignment);\r\n    if (flipAlignment) {\r\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\r\n    }\r\n  }\r\n  return list;\r\n}\r\nfunction getOppositePlacement(placement) {\r\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\r\n}\r\nfunction expandPaddingObject(padding) {\r\n  return {\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0,\r\n    ...padding\r\n  };\r\n}\r\nfunction getPaddingObject(padding) {\r\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\r\n    top: padding,\r\n    right: padding,\r\n    bottom: padding,\r\n    left: padding\r\n  };\r\n}\r\nfunction rectToClientRect(rect) {\r\n  return {\r\n    ...rect,\r\n    top: rect.y,\r\n    left: rect.x,\r\n    right: rect.x + rect.width,\r\n    bottom: rect.y + rect.height\r\n  };\r\n}\r\n\r\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\r\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\r\nexport { rectToClientRect } from '@floating-ui/utils';\r\n\r\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\r\n  let {\r\n    reference,\r\n    floating\r\n  } = _ref;\r\n  const sideAxis = getSideAxis(placement);\r\n  const alignmentAxis = getAlignmentAxis(placement);\r\n  const alignLength = getAxisLength(alignmentAxis);\r\n  const side = getSide(placement);\r\n  const isVertical = sideAxis === 'y';\r\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\r\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\r\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\r\n  let coords;\r\n  switch (side) {\r\n    case 'top':\r\n      coords = {\r\n        x: commonX,\r\n        y: reference.y - floating.height\r\n      };\r\n      break;\r\n    case 'bottom':\r\n      coords = {\r\n        x: commonX,\r\n        y: reference.y + reference.height\r\n      };\r\n      break;\r\n    case 'right':\r\n      coords = {\r\n        x: reference.x + reference.width,\r\n        y: commonY\r\n      };\r\n      break;\r\n    case 'left':\r\n      coords = {\r\n        x: reference.x - floating.width,\r\n        y: commonY\r\n      };\r\n      break;\r\n    default:\r\n      coords = {\r\n        x: reference.x,\r\n        y: reference.y\r\n      };\r\n  }\r\n  switch (getAlignment(placement)) {\r\n    case 'start':\r\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\r\n      break;\r\n    case 'end':\r\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\r\n      break;\r\n  }\r\n  return coords;\r\n}\r\n\r\n/**\r\n * Computes the `x` and `y` coordinates that will place the floating element\r\n * next to a reference element when it is given a certain positioning strategy.\r\n *\r\n * This export does not have any `platform` interface logic. You will need to\r\n * write one for the platform you are using Floating UI with.\r\n */\r\nconst computePosition = async (reference, floating, config) => {\r\n  const {\r\n    placement = 'bottom',\r\n    strategy = 'absolute',\r\n    middleware = [],\r\n    platform\r\n  } = config;\r\n  const validMiddleware = middleware.filter(Boolean);\r\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\r\n  let rects = await platform.getElementRects({\r\n    reference,\r\n    floating,\r\n    strategy\r\n  });\r\n  let {\r\n    x,\r\n    y\r\n  } = computeCoordsFromPlacement(rects, placement, rtl);\r\n  let statefulPlacement = placement;\r\n  let middlewareData = {};\r\n  let resetCount = 0;\r\n  for (let i = 0; i < validMiddleware.length; i++) {\r\n    const {\r\n      name,\r\n      fn\r\n    } = validMiddleware[i];\r\n    const {\r\n      x: nextX,\r\n      y: nextY,\r\n      data,\r\n      reset\r\n    } = await fn({\r\n      x,\r\n      y,\r\n      initialPlacement: placement,\r\n      placement: statefulPlacement,\r\n      strategy,\r\n      middlewareData,\r\n      rects,\r\n      platform,\r\n      elements: {\r\n        reference,\r\n        floating\r\n      }\r\n    });\r\n    x = nextX != null ? nextX : x;\r\n    y = nextY != null ? nextY : y;\r\n    middlewareData = {\r\n      ...middlewareData,\r\n      [name]: {\r\n        ...middlewareData[name],\r\n        ...data\r\n      }\r\n    };\r\n    if (reset && resetCount <= 50) {\r\n      resetCount++;\r\n      if (typeof reset === 'object') {\r\n        if (reset.placement) {\r\n          statefulPlacement = reset.placement;\r\n        }\r\n        if (reset.rects) {\r\n          rects = reset.rects === true ? await platform.getElementRects({\r\n            reference,\r\n            floating,\r\n            strategy\r\n          }) : reset.rects;\r\n        }\r\n        ({\r\n          x,\r\n          y\r\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\r\n      }\r\n      i = -1;\r\n      continue;\r\n    }\r\n  }\r\n  return {\r\n    x,\r\n    y,\r\n    placement: statefulPlacement,\r\n    strategy,\r\n    middlewareData\r\n  };\r\n};\r\n\r\n/**\r\n * Resolves with an object of overflow side offsets that determine how much the\r\n * element is overflowing a given clipping boundary on each side.\r\n * - positive = overflowing the boundary by that number of pixels\r\n * - negative = how many pixels left before it will overflow\r\n * - 0 = lies flush with the boundary\r\n * @see https://floating-ui.com/docs/detectOverflow\r\n */\r\nasync function detectOverflow(state, options) {\r\n  var _await$platform$isEle;\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  const {\r\n    x,\r\n    y,\r\n    platform,\r\n    rects,\r\n    elements,\r\n    strategy\r\n  } = state;\r\n  const {\r\n    boundary = 'clippingAncestors',\r\n    rootBoundary = 'viewport',\r\n    elementContext = 'floating',\r\n    altBoundary = false,\r\n    padding = 0\r\n  } = evaluate(options, state);\r\n  const paddingObject = getPaddingObject(padding);\r\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\r\n  const element = elements[altBoundary ? altContext : elementContext];\r\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\r\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\r\n    boundary,\r\n    rootBoundary,\r\n    strategy\r\n  }));\r\n  const rect = elementContext === 'floating' ? {\r\n    ...rects.floating,\r\n    x,\r\n    y\r\n  } : rects.reference;\r\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\r\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\r\n    x: 1,\r\n    y: 1\r\n  } : {\r\n    x: 1,\r\n    y: 1\r\n  };\r\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\r\n    rect,\r\n    offsetParent,\r\n    strategy\r\n  }) : rect);\r\n  return {\r\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\r\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\r\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\r\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\r\n  };\r\n}\r\n\r\n/**\r\n * Provides data to position an inner element of the floating element so that it\r\n * appears centered to the reference element.\r\n * @see https://floating-ui.com/docs/arrow\r\n */\r\nconst arrow = options => ({\r\n  name: 'arrow',\r\n  options,\r\n  async fn(state) {\r\n    const {\r\n      x,\r\n      y,\r\n      placement,\r\n      rects,\r\n      platform,\r\n      elements,\r\n      middlewareData\r\n    } = state;\r\n    // Since `element` is required, we don't Partial<> the type.\r\n    const {\r\n      element,\r\n      padding = 0\r\n    } = evaluate(options, state) || {};\r\n    if (element == null) {\r\n      return {};\r\n    }\r\n    const paddingObject = getPaddingObject(padding);\r\n    const coords = {\r\n      x,\r\n      y\r\n    };\r\n    const axis = getAlignmentAxis(placement);\r\n    const length = getAxisLength(axis);\r\n    const arrowDimensions = await platform.getDimensions(element);\r\n    const isYAxis = axis === 'y';\r\n    const minProp = isYAxis ? 'top' : 'left';\r\n    const maxProp = isYAxis ? 'bottom' : 'right';\r\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\r\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\r\n    const startDiff = coords[axis] - rects.reference[axis];\r\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\r\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\r\n\r\n    // DOM platform can return `window` as the `offsetParent`.\r\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\r\n      clientSize = elements.floating[clientProp] || rects.floating[length];\r\n    }\r\n    const centerToReference = endDiff / 2 - startDiff / 2;\r\n\r\n    // If the padding is large enough that it causes the arrow to no longer be\r\n    // centered, modify the padding so that it is centered.\r\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\r\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\r\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\r\n\r\n    // Make sure the arrow doesn't overflow the floating element if the center\r\n    // point is outside the floating element's bounds.\r\n    const min$1 = minPadding;\r\n    const max = clientSize - arrowDimensions[length] - maxPadding;\r\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\r\n    const offset = clamp(min$1, center, max);\r\n\r\n    // If the reference is small enough that the arrow's padding causes it to\r\n    // to point to nothing for an aligned placement, adjust the offset of the\r\n    // floating element itself. To ensure `shift()` continues to take action,\r\n    // a single reset is performed when this is true.\r\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\r\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\r\n    return {\r\n      [axis]: coords[axis] + alignmentOffset,\r\n      data: {\r\n        [axis]: offset,\r\n        centerOffset: center - offset - alignmentOffset,\r\n        ...(shouldAddOffset && {\r\n          alignmentOffset\r\n        })\r\n      },\r\n      reset: shouldAddOffset\r\n    };\r\n  }\r\n});\r\n\r\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\r\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\r\n  return allowedPlacementsSortedByAlignment.filter(placement => {\r\n    if (alignment) {\r\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\r\n    }\r\n    return true;\r\n  });\r\n}\r\n/**\r\n * Optimizes the visibility of the floating element by choosing the placement\r\n * that has the most space available automatically, without needing to specify a\r\n * preferred placement. Alternative to `flip`.\r\n * @see https://floating-ui.com/docs/autoPlacement\r\n */\r\nconst autoPlacement = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'autoPlacement',\r\n    options,\r\n    async fn(state) {\r\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\r\n      const {\r\n        rects,\r\n        middlewareData,\r\n        placement,\r\n        platform,\r\n        elements\r\n      } = state;\r\n      const {\r\n        crossAxis = false,\r\n        alignment,\r\n        allowedPlacements = placements,\r\n        autoAlignment = true,\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\r\n      const overflow = await detectOverflow(state, detectOverflowOptions);\r\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\r\n      const currentPlacement = placements$1[currentIndex];\r\n      if (currentPlacement == null) {\r\n        return {};\r\n      }\r\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\r\n\r\n      // Make `computeCoords` start from the right place.\r\n      if (placement !== currentPlacement) {\r\n        return {\r\n          reset: {\r\n            placement: placements$1[0]\r\n          }\r\n        };\r\n      }\r\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\r\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\r\n        placement: currentPlacement,\r\n        overflows: currentOverflows\r\n      }];\r\n      const nextPlacement = placements$1[currentIndex + 1];\r\n\r\n      // There are more placements to check.\r\n      if (nextPlacement) {\r\n        return {\r\n          data: {\r\n            index: currentIndex + 1,\r\n            overflows: allOverflows\r\n          },\r\n          reset: {\r\n            placement: nextPlacement\r\n          }\r\n        };\r\n      }\r\n      const placementsSortedByMostSpace = allOverflows.map(d => {\r\n        const alignment = getAlignment(d.placement);\r\n        return [d.placement, alignment && crossAxis ?\r\n        // Check along the mainAxis and main crossAxis side.\r\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\r\n        // Check only the mainAxis.\r\n        d.overflows[0], d.overflows];\r\n      }).sort((a, b) => a[1] - b[1]);\r\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\r\n      // Aligned placements should not check their opposite crossAxis\r\n      // side.\r\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\r\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\r\n      if (resetPlacement !== placement) {\r\n        return {\r\n          data: {\r\n            index: currentIndex + 1,\r\n            overflows: allOverflows\r\n          },\r\n          reset: {\r\n            placement: resetPlacement\r\n          }\r\n        };\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by flipping the `placement`\r\n * in order to keep it in view when the preferred placement(s) will overflow the\r\n * clipping boundary. Alternative to `autoPlacement`.\r\n * @see https://floating-ui.com/docs/flip\r\n */\r\nconst flip = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'flip',\r\n    options,\r\n    async fn(state) {\r\n      var _middlewareData$arrow, _middlewareData$flip;\r\n      const {\r\n        placement,\r\n        middlewareData,\r\n        rects,\r\n        initialPlacement,\r\n        platform,\r\n        elements\r\n      } = state;\r\n      const {\r\n        mainAxis: checkMainAxis = true,\r\n        crossAxis: checkCrossAxis = true,\r\n        fallbackPlacements: specifiedFallbackPlacements,\r\n        fallbackStrategy = 'bestFit',\r\n        fallbackAxisSideDirection = 'none',\r\n        flipAlignment = true,\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n\r\n      // If a reset by the arrow was caused due to an alignment offset being\r\n      // added, we should skip any logic now since `flip()` has already done its\r\n      // work.\r\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\r\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\r\n        return {};\r\n      }\r\n      const side = getSide(placement);\r\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\r\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\r\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\r\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\r\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\r\n      }\r\n      const placements = [initialPlacement, ...fallbackPlacements];\r\n      const overflow = await detectOverflow(state, detectOverflowOptions);\r\n      const overflows = [];\r\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\r\n      if (checkMainAxis) {\r\n        overflows.push(overflow[side]);\r\n      }\r\n      if (checkCrossAxis) {\r\n        const sides = getAlignmentSides(placement, rects, rtl);\r\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\r\n      }\r\n      overflowsData = [...overflowsData, {\r\n        placement,\r\n        overflows\r\n      }];\r\n\r\n      // One or more sides is overflowing.\r\n      if (!overflows.every(side => side <= 0)) {\r\n        var _middlewareData$flip2, _overflowsData$filter;\r\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\r\n        const nextPlacement = placements[nextIndex];\r\n        if (nextPlacement) {\r\n          // Try next placement and re-run the lifecycle.\r\n          return {\r\n            data: {\r\n              index: nextIndex,\r\n              overflows: overflowsData\r\n            },\r\n            reset: {\r\n              placement: nextPlacement\r\n            }\r\n          };\r\n        }\r\n\r\n        // First, find the candidates that fit on the mainAxis side of overflow,\r\n        // then find the placement that fits the best on the main crossAxis side.\r\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\r\n\r\n        // Otherwise fallback.\r\n        if (!resetPlacement) {\r\n          switch (fallbackStrategy) {\r\n            case 'bestFit':\r\n              {\r\n                var _overflowsData$map$so;\r\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\r\n                if (placement) {\r\n                  resetPlacement = placement;\r\n                }\r\n                break;\r\n              }\r\n            case 'initialPlacement':\r\n              resetPlacement = initialPlacement;\r\n              break;\r\n          }\r\n        }\r\n        if (placement !== resetPlacement) {\r\n          return {\r\n            reset: {\r\n              placement: resetPlacement\r\n            }\r\n          };\r\n        }\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\n\r\nfunction getSideOffsets(overflow, rect) {\r\n  return {\r\n    top: overflow.top - rect.height,\r\n    right: overflow.right - rect.width,\r\n    bottom: overflow.bottom - rect.height,\r\n    left: overflow.left - rect.width\r\n  };\r\n}\r\nfunction isAnySideFullyClipped(overflow) {\r\n  return sides.some(side => overflow[side] >= 0);\r\n}\r\n/**\r\n * Provides data to hide the floating element in applicable situations, such as\r\n * when it is not in the same clipping context as the reference element.\r\n * @see https://floating-ui.com/docs/hide\r\n */\r\nconst hide = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'hide',\r\n    options,\r\n    async fn(state) {\r\n      const {\r\n        rects\r\n      } = state;\r\n      const {\r\n        strategy = 'referenceHidden',\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n      switch (strategy) {\r\n        case 'referenceHidden':\r\n          {\r\n            const overflow = await detectOverflow(state, {\r\n              ...detectOverflowOptions,\r\n              elementContext: 'reference'\r\n            });\r\n            const offsets = getSideOffsets(overflow, rects.reference);\r\n            return {\r\n              data: {\r\n                referenceHiddenOffsets: offsets,\r\n                referenceHidden: isAnySideFullyClipped(offsets)\r\n              }\r\n            };\r\n          }\r\n        case 'escaped':\r\n          {\r\n            const overflow = await detectOverflow(state, {\r\n              ...detectOverflowOptions,\r\n              altBoundary: true\r\n            });\r\n            const offsets = getSideOffsets(overflow, rects.floating);\r\n            return {\r\n              data: {\r\n                escapedOffsets: offsets,\r\n                escaped: isAnySideFullyClipped(offsets)\r\n              }\r\n            };\r\n          }\r\n        default:\r\n          {\r\n            return {};\r\n          }\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nfunction getBoundingRect(rects) {\r\n  const minX = min(...rects.map(rect => rect.left));\r\n  const minY = min(...rects.map(rect => rect.top));\r\n  const maxX = max(...rects.map(rect => rect.right));\r\n  const maxY = max(...rects.map(rect => rect.bottom));\r\n  return {\r\n    x: minX,\r\n    y: minY,\r\n    width: maxX - minX,\r\n    height: maxY - minY\r\n  };\r\n}\r\nfunction getRectsByLine(rects) {\r\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\r\n  const groups = [];\r\n  let prevRect = null;\r\n  for (let i = 0; i < sortedRects.length; i++) {\r\n    const rect = sortedRects[i];\r\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\r\n      groups.push([rect]);\r\n    } else {\r\n      groups[groups.length - 1].push(rect);\r\n    }\r\n    prevRect = rect;\r\n  }\r\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\r\n}\r\n/**\r\n * Provides improved positioning for inline reference elements that can span\r\n * over multiple lines, such as hyperlinks or range selections.\r\n * @see https://floating-ui.com/docs/inline\r\n */\r\nconst inline = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'inline',\r\n    options,\r\n    async fn(state) {\r\n      const {\r\n        placement,\r\n        elements,\r\n        rects,\r\n        platform,\r\n        strategy\r\n      } = state;\r\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\r\n      // ClientRect's bounds, despite the event listener being triggered. A\r\n      // padding of 2 seems to handle this issue.\r\n      const {\r\n        padding = 2,\r\n        x,\r\n        y\r\n      } = evaluate(options, state);\r\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\r\n      const clientRects = getRectsByLine(nativeClientRects);\r\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\r\n      const paddingObject = getPaddingObject(padding);\r\n      function getBoundingClientRect() {\r\n        // There are two rects and they are disjoined.\r\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\r\n          // Find the first rect in which the point is fully inside.\r\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\r\n        }\r\n\r\n        // There are 2 or more connected rects.\r\n        if (clientRects.length >= 2) {\r\n          if (getSideAxis(placement) === 'y') {\r\n            const firstRect = clientRects[0];\r\n            const lastRect = clientRects[clientRects.length - 1];\r\n            const isTop = getSide(placement) === 'top';\r\n            const top = firstRect.top;\r\n            const bottom = lastRect.bottom;\r\n            const left = isTop ? firstRect.left : lastRect.left;\r\n            const right = isTop ? firstRect.right : lastRect.right;\r\n            const width = right - left;\r\n            const height = bottom - top;\r\n            return {\r\n              top,\r\n              bottom,\r\n              left,\r\n              right,\r\n              width,\r\n              height,\r\n              x: left,\r\n              y: top\r\n            };\r\n          }\r\n          const isLeftSide = getSide(placement) === 'left';\r\n          const maxRight = max(...clientRects.map(rect => rect.right));\r\n          const minLeft = min(...clientRects.map(rect => rect.left));\r\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\r\n          const top = measureRects[0].top;\r\n          const bottom = measureRects[measureRects.length - 1].bottom;\r\n          const left = minLeft;\r\n          const right = maxRight;\r\n          const width = right - left;\r\n          const height = bottom - top;\r\n          return {\r\n            top,\r\n            bottom,\r\n            left,\r\n            right,\r\n            width,\r\n            height,\r\n            x: left,\r\n            y: top\r\n          };\r\n        }\r\n        return fallback;\r\n      }\r\n      const resetRects = await platform.getElementRects({\r\n        reference: {\r\n          getBoundingClientRect\r\n        },\r\n        floating: elements.floating,\r\n        strategy\r\n      });\r\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\r\n        return {\r\n          reset: {\r\n            rects: resetRects\r\n          }\r\n        };\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\n\r\n// For type backwards-compatibility, the `OffsetOptions` type was also\r\n// Derivable.\r\nasync function convertValueToCoords(state, options) {\r\n  const {\r\n    placement,\r\n    platform,\r\n    elements\r\n  } = state;\r\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\r\n  const side = getSide(placement);\r\n  const alignment = getAlignment(placement);\r\n  const isVertical = getSideAxis(placement) === 'y';\r\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\r\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\r\n  const rawValue = evaluate(options, state);\r\n\r\n  // eslint-disable-next-line prefer-const\r\n  let {\r\n    mainAxis,\r\n    crossAxis,\r\n    alignmentAxis\r\n  } = typeof rawValue === 'number' ? {\r\n    mainAxis: rawValue,\r\n    crossAxis: 0,\r\n    alignmentAxis: null\r\n  } : {\r\n    mainAxis: 0,\r\n    crossAxis: 0,\r\n    alignmentAxis: null,\r\n    ...rawValue\r\n  };\r\n  if (alignment && typeof alignmentAxis === 'number') {\r\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\r\n  }\r\n  return isVertical ? {\r\n    x: crossAxis * crossAxisMulti,\r\n    y: mainAxis * mainAxisMulti\r\n  } : {\r\n    x: mainAxis * mainAxisMulti,\r\n    y: crossAxis * crossAxisMulti\r\n  };\r\n}\r\n\r\n/**\r\n * Modifies the placement by translating the floating element along the\r\n * specified axes.\r\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\r\n * object may be passed.\r\n * @see https://floating-ui.com/docs/offset\r\n */\r\nconst offset = function (options) {\r\n  if (options === void 0) {\r\n    options = 0;\r\n  }\r\n  return {\r\n    name: 'offset',\r\n    options,\r\n    async fn(state) {\r\n      var _middlewareData$offse, _middlewareData$arrow;\r\n      const {\r\n        x,\r\n        y,\r\n        placement,\r\n        middlewareData\r\n      } = state;\r\n      const diffCoords = await convertValueToCoords(state, options);\r\n\r\n      // If the placement is the same and the arrow caused an alignment offset\r\n      // then we don't need to change the positioning coordinates.\r\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\r\n        return {};\r\n      }\r\n      return {\r\n        x: x + diffCoords.x,\r\n        y: y + diffCoords.y,\r\n        data: {\r\n          ...diffCoords,\r\n          placement\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by shifting it in order to\r\n * keep it in view when it will overflow the clipping boundary.\r\n * @see https://floating-ui.com/docs/shift\r\n */\r\nconst shift = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'shift',\r\n    options,\r\n    async fn(state) {\r\n      const {\r\n        x,\r\n        y,\r\n        placement\r\n      } = state;\r\n      const {\r\n        mainAxis: checkMainAxis = true,\r\n        crossAxis: checkCrossAxis = false,\r\n        limiter = {\r\n          fn: _ref => {\r\n            let {\r\n              x,\r\n              y\r\n            } = _ref;\r\n            return {\r\n              x,\r\n              y\r\n            };\r\n          }\r\n        },\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n      const coords = {\r\n        x,\r\n        y\r\n      };\r\n      const overflow = await detectOverflow(state, detectOverflowOptions);\r\n      const crossAxis = getSideAxis(getSide(placement));\r\n      const mainAxis = getOppositeAxis(crossAxis);\r\n      let mainAxisCoord = coords[mainAxis];\r\n      let crossAxisCoord = coords[crossAxis];\r\n      if (checkMainAxis) {\r\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\r\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\r\n        const min = mainAxisCoord + overflow[minSide];\r\n        const max = mainAxisCoord - overflow[maxSide];\r\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\r\n      }\r\n      if (checkCrossAxis) {\r\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\r\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\r\n        const min = crossAxisCoord + overflow[minSide];\r\n        const max = crossAxisCoord - overflow[maxSide];\r\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\r\n      }\r\n      const limitedCoords = limiter.fn({\r\n        ...state,\r\n        [mainAxis]: mainAxisCoord,\r\n        [crossAxis]: crossAxisCoord\r\n      });\r\n      return {\r\n        ...limitedCoords,\r\n        data: {\r\n          x: limitedCoords.x - x,\r\n          y: limitedCoords.y - y\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\n/**\r\n * Built-in `limiter` that will stop `shift()` at a certain point.\r\n */\r\nconst limitShift = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    options,\r\n    fn(state) {\r\n      const {\r\n        x,\r\n        y,\r\n        placement,\r\n        rects,\r\n        middlewareData\r\n      } = state;\r\n      const {\r\n        offset = 0,\r\n        mainAxis: checkMainAxis = true,\r\n        crossAxis: checkCrossAxis = true\r\n      } = evaluate(options, state);\r\n      const coords = {\r\n        x,\r\n        y\r\n      };\r\n      const crossAxis = getSideAxis(placement);\r\n      const mainAxis = getOppositeAxis(crossAxis);\r\n      let mainAxisCoord = coords[mainAxis];\r\n      let crossAxisCoord = coords[crossAxis];\r\n      const rawOffset = evaluate(offset, state);\r\n      const computedOffset = typeof rawOffset === 'number' ? {\r\n        mainAxis: rawOffset,\r\n        crossAxis: 0\r\n      } : {\r\n        mainAxis: 0,\r\n        crossAxis: 0,\r\n        ...rawOffset\r\n      };\r\n      if (checkMainAxis) {\r\n        const len = mainAxis === 'y' ? 'height' : 'width';\r\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\r\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\r\n        if (mainAxisCoord < limitMin) {\r\n          mainAxisCoord = limitMin;\r\n        } else if (mainAxisCoord > limitMax) {\r\n          mainAxisCoord = limitMax;\r\n        }\r\n      }\r\n      if (checkCrossAxis) {\r\n        var _middlewareData$offse, _middlewareData$offse2;\r\n        const len = mainAxis === 'y' ? 'width' : 'height';\r\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\r\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\r\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\r\n        if (crossAxisCoord < limitMin) {\r\n          crossAxisCoord = limitMin;\r\n        } else if (crossAxisCoord > limitMax) {\r\n          crossAxisCoord = limitMax;\r\n        }\r\n      }\r\n      return {\r\n        [mainAxis]: mainAxisCoord,\r\n        [crossAxis]: crossAxisCoord\r\n      };\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Provides data that allows you to change the size of the floating element —\r\n * for instance, prevent it from overflowing the clipping boundary or match the\r\n * width of the reference element.\r\n * @see https://floating-ui.com/docs/size\r\n */\r\nconst size = function (options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  return {\r\n    name: 'size',\r\n    options,\r\n    async fn(state) {\r\n      const {\r\n        placement,\r\n        rects,\r\n        platform,\r\n        elements\r\n      } = state;\r\n      const {\r\n        apply = () => {},\r\n        ...detectOverflowOptions\r\n      } = evaluate(options, state);\r\n      const overflow = await detectOverflow(state, detectOverflowOptions);\r\n      const side = getSide(placement);\r\n      const alignment = getAlignment(placement);\r\n      const isYAxis = getSideAxis(placement) === 'y';\r\n      const {\r\n        width,\r\n        height\r\n      } = rects.floating;\r\n      let heightSide;\r\n      let widthSide;\r\n      if (side === 'top' || side === 'bottom') {\r\n        heightSide = side;\r\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\r\n      } else {\r\n        widthSide = side;\r\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\r\n      }\r\n      const overflowAvailableHeight = height - overflow[heightSide];\r\n      const overflowAvailableWidth = width - overflow[widthSide];\r\n      const noShift = !state.middlewareData.shift;\r\n      let availableHeight = overflowAvailableHeight;\r\n      let availableWidth = overflowAvailableWidth;\r\n      if (isYAxis) {\r\n        const maximumClippingWidth = width - overflow.left - overflow.right;\r\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\r\n      } else {\r\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\r\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\r\n      }\r\n      if (noShift && !alignment) {\r\n        const xMin = max(overflow.left, 0);\r\n        const xMax = max(overflow.right, 0);\r\n        const yMin = max(overflow.top, 0);\r\n        const yMax = max(overflow.bottom, 0);\r\n        if (isYAxis) {\r\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\r\n        } else {\r\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\r\n        }\r\n      }\r\n      await apply({\r\n        ...state,\r\n        availableWidth,\r\n        availableHeight\r\n      });\r\n      const nextDimensions = await platform.getDimensions(elements.floating);\r\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\r\n        return {\r\n          reset: {\r\n            rects: true\r\n          }\r\n        };\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\n\r\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\r\n", "function getNodeName(node) {\r\n  if (isNode(node)) {\r\n    return (node.nodeName || '').toLowerCase();\r\n  }\r\n  // Mocked nodes in testing environments may not be instances of Node. By\r\n  // returning `#document` an infinite loop won't occur.\r\n  // https://github.com/floating-ui/floating-ui/issues/2317\r\n  return '#document';\r\n}\r\nfunction getWindow(node) {\r\n  var _node$ownerDocument;\r\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\r\n}\r\nfunction getDocumentElement(node) {\r\n  var _ref;\r\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\r\n}\r\nfunction isNode(value) {\r\n  return value instanceof Node || value instanceof getWindow(value).Node;\r\n}\r\nfunction isElement(value) {\r\n  return value instanceof Element || value instanceof getWindow(value).Element;\r\n}\r\nfunction isHTMLElement(value) {\r\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\r\n}\r\nfunction isShadowRoot(value) {\r\n  // Browsers without `ShadowRoot` support.\r\n  if (typeof ShadowRoot === 'undefined') {\r\n    return false;\r\n  }\r\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\r\n}\r\nfunction isOverflowElement(element) {\r\n  const {\r\n    overflow,\r\n    overflowX,\r\n    overflowY,\r\n    display\r\n  } = getComputedStyle(element);\r\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\r\n}\r\nfunction isTableElement(element) {\r\n  return ['table', 'td', 'th'].includes(getNodeName(element));\r\n}\r\nfunction isContainingBlock(element) {\r\n  const webkit = isWebKit();\r\n  const css = getComputedStyle(element);\r\n\r\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\r\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\r\n}\r\nfunction getContainingBlock(element) {\r\n  let currentNode = getParentNode(element);\r\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\r\n    if (isContainingBlock(currentNode)) {\r\n      return currentNode;\r\n    } else {\r\n      currentNode = getParentNode(currentNode);\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction isWebKit() {\r\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\r\n  return CSS.supports('-webkit-backdrop-filter', 'none');\r\n}\r\nfunction isLastTraversableNode(node) {\r\n  return ['html', 'body', '#document'].includes(getNodeName(node));\r\n}\r\nfunction getComputedStyle(element) {\r\n  return getWindow(element).getComputedStyle(element);\r\n}\r\nfunction getNodeScroll(element) {\r\n  if (isElement(element)) {\r\n    return {\r\n      scrollLeft: element.scrollLeft,\r\n      scrollTop: element.scrollTop\r\n    };\r\n  }\r\n  return {\r\n    scrollLeft: element.pageXOffset,\r\n    scrollTop: element.pageYOffset\r\n  };\r\n}\r\nfunction getParentNode(node) {\r\n  if (getNodeName(node) === 'html') {\r\n    return node;\r\n  }\r\n  const result =\r\n  // Step into the shadow DOM of the parent of a slotted node.\r\n  node.assignedSlot ||\r\n  // DOM Element detected.\r\n  node.parentNode ||\r\n  // ShadowRoot detected.\r\n  isShadowRoot(node) && node.host ||\r\n  // Fallback.\r\n  getDocumentElement(node);\r\n  return isShadowRoot(result) ? result.host : result;\r\n}\r\nfunction getNearestOverflowAncestor(node) {\r\n  const parentNode = getParentNode(node);\r\n  if (isLastTraversableNode(parentNode)) {\r\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\r\n  }\r\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\r\n    return parentNode;\r\n  }\r\n  return getNearestOverflowAncestor(parentNode);\r\n}\r\nfunction getOverflowAncestors(node, list, traverseIframes) {\r\n  var _node$ownerDocument2;\r\n  if (list === void 0) {\r\n    list = [];\r\n  }\r\n  if (traverseIframes === void 0) {\r\n    traverseIframes = true;\r\n  }\r\n  const scrollableAncestor = getNearestOverflowAncestor(node);\r\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\r\n  const win = getWindow(scrollableAncestor);\r\n  if (isBody) {\r\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\r\n  }\r\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\r\n}\r\n\r\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\r\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\r\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\r\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\r\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\r\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\r\n\r\nfunction getCssDimensions(element) {\r\n  const css = getComputedStyle(element);\r\n  // In testing environments, the `width` and `height` properties are empty\r\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\r\n  let width = parseFloat(css.width) || 0;\r\n  let height = parseFloat(css.height) || 0;\r\n  const hasOffset = isHTMLElement(element);\r\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\r\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\r\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\r\n  if (shouldFallback) {\r\n    width = offsetWidth;\r\n    height = offsetHeight;\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    $: shouldFallback\r\n  };\r\n}\r\n\r\nfunction unwrapElement(element) {\r\n  return !isElement(element) ? element.contextElement : element;\r\n}\r\n\r\nfunction getScale(element) {\r\n  const domElement = unwrapElement(element);\r\n  if (!isHTMLElement(domElement)) {\r\n    return createCoords(1);\r\n  }\r\n  const rect = domElement.getBoundingClientRect();\r\n  const {\r\n    width,\r\n    height,\r\n    $\r\n  } = getCssDimensions(domElement);\r\n  let x = ($ ? round(rect.width) : rect.width) / width;\r\n  let y = ($ ? round(rect.height) : rect.height) / height;\r\n\r\n  // 0, NaN, or Infinity should always fallback to 1.\r\n\r\n  if (!x || !Number.isFinite(x)) {\r\n    x = 1;\r\n  }\r\n  if (!y || !Number.isFinite(y)) {\r\n    y = 1;\r\n  }\r\n  return {\r\n    x,\r\n    y\r\n  };\r\n}\r\n\r\nconst noOffsets = /*#__PURE__*/createCoords(0);\r\nfunction getVisualOffsets(element) {\r\n  const win = getWindow(element);\r\n  if (!isWebKit() || !win.visualViewport) {\r\n    return noOffsets;\r\n  }\r\n  return {\r\n    x: win.visualViewport.offsetLeft,\r\n    y: win.visualViewport.offsetTop\r\n  };\r\n}\r\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\r\n  if (isFixed === void 0) {\r\n    isFixed = false;\r\n  }\r\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\r\n    return false;\r\n  }\r\n  return isFixed;\r\n}\r\n\r\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\r\n  if (includeScale === void 0) {\r\n    includeScale = false;\r\n  }\r\n  if (isFixedStrategy === void 0) {\r\n    isFixedStrategy = false;\r\n  }\r\n  const clientRect = element.getBoundingClientRect();\r\n  const domElement = unwrapElement(element);\r\n  let scale = createCoords(1);\r\n  if (includeScale) {\r\n    if (offsetParent) {\r\n      if (isElement(offsetParent)) {\r\n        scale = getScale(offsetParent);\r\n      }\r\n    } else {\r\n      scale = getScale(element);\r\n    }\r\n  }\r\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\r\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\r\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\r\n  let width = clientRect.width / scale.x;\r\n  let height = clientRect.height / scale.y;\r\n  if (domElement) {\r\n    const win = getWindow(domElement);\r\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\r\n    let currentIFrame = win.frameElement;\r\n    while (currentIFrame && offsetParent && offsetWin !== win) {\r\n      const iframeScale = getScale(currentIFrame);\r\n      const iframeRect = currentIFrame.getBoundingClientRect();\r\n      const css = getComputedStyle(currentIFrame);\r\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\r\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\r\n      x *= iframeScale.x;\r\n      y *= iframeScale.y;\r\n      width *= iframeScale.x;\r\n      height *= iframeScale.y;\r\n      x += left;\r\n      y += top;\r\n      currentIFrame = getWindow(currentIFrame).frameElement;\r\n    }\r\n  }\r\n  return rectToClientRect({\r\n    width,\r\n    height,\r\n    x,\r\n    y\r\n  });\r\n}\r\n\r\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\r\n  let {\r\n    rect,\r\n    offsetParent,\r\n    strategy\r\n  } = _ref;\r\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\r\n  const documentElement = getDocumentElement(offsetParent);\r\n  if (offsetParent === documentElement) {\r\n    return rect;\r\n  }\r\n  let scroll = {\r\n    scrollLeft: 0,\r\n    scrollTop: 0\r\n  };\r\n  let scale = createCoords(1);\r\n  const offsets = createCoords(0);\r\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\r\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\r\n      scroll = getNodeScroll(offsetParent);\r\n    }\r\n    if (isHTMLElement(offsetParent)) {\r\n      const offsetRect = getBoundingClientRect(offsetParent);\r\n      scale = getScale(offsetParent);\r\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\r\n      offsets.y = offsetRect.y + offsetParent.clientTop;\r\n    }\r\n  }\r\n  return {\r\n    width: rect.width * scale.x,\r\n    height: rect.height * scale.y,\r\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\r\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\r\n  };\r\n}\r\n\r\nfunction getClientRects(element) {\r\n  return Array.from(element.getClientRects());\r\n}\r\n\r\nfunction getWindowScrollBarX(element) {\r\n  // If <html> has a CSS width greater than the viewport, then this will be\r\n  // incorrect for RTL.\r\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\r\n}\r\n\r\n// Gets the entire size of the scrollable document area, even extending outside\r\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\r\nfunction getDocumentRect(element) {\r\n  const html = getDocumentElement(element);\r\n  const scroll = getNodeScroll(element);\r\n  const body = element.ownerDocument.body;\r\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\r\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\r\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\r\n  const y = -scroll.scrollTop;\r\n  if (getComputedStyle(body).direction === 'rtl') {\r\n    x += max(html.clientWidth, body.clientWidth) - width;\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    x,\r\n    y\r\n  };\r\n}\r\n\r\nfunction getViewportRect(element, strategy) {\r\n  const win = getWindow(element);\r\n  const html = getDocumentElement(element);\r\n  const visualViewport = win.visualViewport;\r\n  let width = html.clientWidth;\r\n  let height = html.clientHeight;\r\n  let x = 0;\r\n  let y = 0;\r\n  if (visualViewport) {\r\n    width = visualViewport.width;\r\n    height = visualViewport.height;\r\n    const visualViewportBased = isWebKit();\r\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\r\n      x = visualViewport.offsetLeft;\r\n      y = visualViewport.offsetTop;\r\n    }\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    x,\r\n    y\r\n  };\r\n}\r\n\r\n// Returns the inner client rect, subtracting scrollbars if present.\r\nfunction getInnerBoundingClientRect(element, strategy) {\r\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\r\n  const top = clientRect.top + element.clientTop;\r\n  const left = clientRect.left + element.clientLeft;\r\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\r\n  const width = element.clientWidth * scale.x;\r\n  const height = element.clientHeight * scale.y;\r\n  const x = left * scale.x;\r\n  const y = top * scale.y;\r\n  return {\r\n    width,\r\n    height,\r\n    x,\r\n    y\r\n  };\r\n}\r\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\r\n  let rect;\r\n  if (clippingAncestor === 'viewport') {\r\n    rect = getViewportRect(element, strategy);\r\n  } else if (clippingAncestor === 'document') {\r\n    rect = getDocumentRect(getDocumentElement(element));\r\n  } else if (isElement(clippingAncestor)) {\r\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\r\n  } else {\r\n    const visualOffsets = getVisualOffsets(element);\r\n    rect = {\r\n      ...clippingAncestor,\r\n      x: clippingAncestor.x - visualOffsets.x,\r\n      y: clippingAncestor.y - visualOffsets.y\r\n    };\r\n  }\r\n  return rectToClientRect(rect);\r\n}\r\nfunction hasFixedPositionAncestor(element, stopNode) {\r\n  const parentNode = getParentNode(element);\r\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\r\n    return false;\r\n  }\r\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\r\n}\r\n\r\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\r\n// clipping (or hiding) child elements. This returns all clipping ancestors\r\n// of the given element up the tree.\r\nfunction getClippingElementAncestors(element, cache) {\r\n  const cachedResult = cache.get(element);\r\n  if (cachedResult) {\r\n    return cachedResult;\r\n  }\r\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\r\n  let currentContainingBlockComputedStyle = null;\r\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\r\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\r\n\r\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\r\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\r\n    const computedStyle = getComputedStyle(currentNode);\r\n    const currentNodeIsContaining = isContainingBlock(currentNode);\r\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\r\n      currentContainingBlockComputedStyle = null;\r\n    }\r\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\r\n    if (shouldDropCurrentNode) {\r\n      // Drop non-containing blocks.\r\n      result = result.filter(ancestor => ancestor !== currentNode);\r\n    } else {\r\n      // Record last containing block for next iteration.\r\n      currentContainingBlockComputedStyle = computedStyle;\r\n    }\r\n    currentNode = getParentNode(currentNode);\r\n  }\r\n  cache.set(element, result);\r\n  return result;\r\n}\r\n\r\n// Gets the maximum area that the element is visible in due to any number of\r\n// clipping ancestors.\r\nfunction getClippingRect(_ref) {\r\n  let {\r\n    element,\r\n    boundary,\r\n    rootBoundary,\r\n    strategy\r\n  } = _ref;\r\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\r\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\r\n  const firstClippingAncestor = clippingAncestors[0];\r\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\r\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\r\n    accRect.top = max(rect.top, accRect.top);\r\n    accRect.right = min(rect.right, accRect.right);\r\n    accRect.bottom = min(rect.bottom, accRect.bottom);\r\n    accRect.left = max(rect.left, accRect.left);\r\n    return accRect;\r\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\r\n  return {\r\n    width: clippingRect.right - clippingRect.left,\r\n    height: clippingRect.bottom - clippingRect.top,\r\n    x: clippingRect.left,\r\n    y: clippingRect.top\r\n  };\r\n}\r\n\r\nfunction getDimensions(element) {\r\n  return getCssDimensions(element);\r\n}\r\n\r\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\r\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\r\n  const documentElement = getDocumentElement(offsetParent);\r\n  const isFixed = strategy === 'fixed';\r\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\r\n  let scroll = {\r\n    scrollLeft: 0,\r\n    scrollTop: 0\r\n  };\r\n  const offsets = createCoords(0);\r\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\r\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\r\n      scroll = getNodeScroll(offsetParent);\r\n    }\r\n    if (isOffsetParentAnElement) {\r\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\r\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\r\n      offsets.y = offsetRect.y + offsetParent.clientTop;\r\n    } else if (documentElement) {\r\n      offsets.x = getWindowScrollBarX(documentElement);\r\n    }\r\n  }\r\n  return {\r\n    x: rect.left + scroll.scrollLeft - offsets.x,\r\n    y: rect.top + scroll.scrollTop - offsets.y,\r\n    width: rect.width,\r\n    height: rect.height\r\n  };\r\n}\r\n\r\nfunction getTrueOffsetParent(element, polyfill) {\r\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\r\n    return null;\r\n  }\r\n  if (polyfill) {\r\n    return polyfill(element);\r\n  }\r\n  return element.offsetParent;\r\n}\r\n\r\n// Gets the closest ancestor positioned element. Handles some edge cases,\r\n// such as table ancestors and cross browser bugs.\r\nfunction getOffsetParent(element, polyfill) {\r\n  const window = getWindow(element);\r\n  if (!isHTMLElement(element)) {\r\n    return window;\r\n  }\r\n  let offsetParent = getTrueOffsetParent(element, polyfill);\r\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\r\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\r\n  }\r\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\r\n    return window;\r\n  }\r\n  return offsetParent || getContainingBlock(element) || window;\r\n}\r\n\r\nconst getElementRects = async function (_ref) {\r\n  let {\r\n    reference,\r\n    floating,\r\n    strategy\r\n  } = _ref;\r\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\r\n  const getDimensionsFn = this.getDimensions;\r\n  return {\r\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\r\n    floating: {\r\n      x: 0,\r\n      y: 0,\r\n      ...(await getDimensionsFn(floating))\r\n    }\r\n  };\r\n};\r\n\r\nfunction isRTL(element) {\r\n  return getComputedStyle(element).direction === 'rtl';\r\n}\r\n\r\nconst platform = {\r\n  convertOffsetParentRelativeRectToViewportRelativeRect,\r\n  getDocumentElement,\r\n  getClippingRect,\r\n  getOffsetParent,\r\n  getElementRects,\r\n  getClientRects,\r\n  getDimensions,\r\n  getScale,\r\n  isElement,\r\n  isRTL\r\n};\r\n\r\n// https://samthor.au/2021/observing-dom/\r\nfunction observeMove(element, onMove) {\r\n  let io = null;\r\n  let timeoutId;\r\n  const root = getDocumentElement(element);\r\n  function cleanup() {\r\n    clearTimeout(timeoutId);\r\n    io && io.disconnect();\r\n    io = null;\r\n  }\r\n  function refresh(skip, threshold) {\r\n    if (skip === void 0) {\r\n      skip = false;\r\n    }\r\n    if (threshold === void 0) {\r\n      threshold = 1;\r\n    }\r\n    cleanup();\r\n    const {\r\n      left,\r\n      top,\r\n      width,\r\n      height\r\n    } = element.getBoundingClientRect();\r\n    if (!skip) {\r\n      onMove();\r\n    }\r\n    if (!width || !height) {\r\n      return;\r\n    }\r\n    const insetTop = floor(top);\r\n    const insetRight = floor(root.clientWidth - (left + width));\r\n    const insetBottom = floor(root.clientHeight - (top + height));\r\n    const insetLeft = floor(left);\r\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\r\n    const options = {\r\n      rootMargin,\r\n      threshold: max(0, min(1, threshold)) || 1\r\n    };\r\n    let isFirstUpdate = true;\r\n    function handleObserve(entries) {\r\n      const ratio = entries[0].intersectionRatio;\r\n      if (ratio !== threshold) {\r\n        if (!isFirstUpdate) {\r\n          return refresh();\r\n        }\r\n        if (!ratio) {\r\n          timeoutId = setTimeout(() => {\r\n            refresh(false, 1e-7);\r\n          }, 100);\r\n        } else {\r\n          refresh(false, ratio);\r\n        }\r\n      }\r\n      isFirstUpdate = false;\r\n    }\r\n\r\n    // Older browsers don't support a `document` as the root and will throw an\r\n    // error.\r\n    try {\r\n      io = new IntersectionObserver(handleObserve, {\r\n        ...options,\r\n        // Handle <iframe>s\r\n        root: root.ownerDocument\r\n      });\r\n    } catch (e) {\r\n      io = new IntersectionObserver(handleObserve, options);\r\n    }\r\n    io.observe(element);\r\n  }\r\n  refresh(true);\r\n  return cleanup;\r\n}\r\n\r\n/**\r\n * Automatically updates the position of the floating element when necessary.\r\n * Should only be called when the floating element is mounted on the DOM or\r\n * visible on the screen.\r\n * @returns cleanup function that should be invoked when the floating element is\r\n * removed from the DOM or hidden from the screen.\r\n * @see https://floating-ui.com/docs/autoUpdate\r\n */\r\nfunction autoUpdate(reference, floating, update, options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  const {\r\n    ancestorScroll = true,\r\n    ancestorResize = true,\r\n    elementResize = typeof ResizeObserver === 'function',\r\n    layoutShift = typeof IntersectionObserver === 'function',\r\n    animationFrame = false\r\n  } = options;\r\n  const referenceEl = unwrapElement(reference);\r\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\r\n  ancestors.forEach(ancestor => {\r\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\r\n      passive: true\r\n    });\r\n    ancestorResize && ancestor.addEventListener('resize', update);\r\n  });\r\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\r\n  let reobserveFrame = -1;\r\n  let resizeObserver = null;\r\n  if (elementResize) {\r\n    resizeObserver = new ResizeObserver(_ref => {\r\n      let [firstEntry] = _ref;\r\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\r\n        // Prevent update loops when using the `size` middleware.\r\n        // https://github.com/floating-ui/floating-ui/issues/1740\r\n        resizeObserver.unobserve(floating);\r\n        cancelAnimationFrame(reobserveFrame);\r\n        reobserveFrame = requestAnimationFrame(() => {\r\n          resizeObserver && resizeObserver.observe(floating);\r\n        });\r\n      }\r\n      update();\r\n    });\r\n    if (referenceEl && !animationFrame) {\r\n      resizeObserver.observe(referenceEl);\r\n    }\r\n    resizeObserver.observe(floating);\r\n  }\r\n  let frameId;\r\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\r\n  if (animationFrame) {\r\n    frameLoop();\r\n  }\r\n  function frameLoop() {\r\n    const nextRefRect = getBoundingClientRect(reference);\r\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\r\n      update();\r\n    }\r\n    prevRefRect = nextRefRect;\r\n    frameId = requestAnimationFrame(frameLoop);\r\n  }\r\n  update();\r\n  return () => {\r\n    ancestors.forEach(ancestor => {\r\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\r\n      ancestorResize && ancestor.removeEventListener('resize', update);\r\n    });\r\n    cleanupIo && cleanupIo();\r\n    resizeObserver && resizeObserver.disconnect();\r\n    resizeObserver = null;\r\n    if (animationFrame) {\r\n      cancelAnimationFrame(frameId);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Computes the `x` and `y` coordinates that will place the floating element\r\n * next to a reference element when it is given a certain CSS positioning\r\n * strategy.\r\n */\r\nconst computePosition = (reference, floating, options) => {\r\n  // This caches the expensive `getClippingElementAncestors` function so that\r\n  // multiple lifecycle resets re-use the same result. It only lives for a\r\n  // single call. If other functions become expensive, we can add them as well.\r\n  const cache = new Map();\r\n  const mergedOptions = {\r\n    platform,\r\n    ...options\r\n  };\r\n  const platformWithCache = {\r\n    ...mergedOptions.platform,\r\n    _c: cache\r\n  };\r\n  return computePosition$1(reference, floating, {\r\n    ...mergedOptions,\r\n    platform: platformWithCache\r\n  });\r\n};\r\n\r\nexport { autoUpdate, computePosition, platform };\r\n", "import { isRef, onMounted, ref, unref, watchEffect } from 'vue'\nimport { unrefElement } from '@vueuse/core'\nimport { isNil } from 'lodash-unified'\nimport { arrow as arrowCore, computePosition } from '@floating-ui/dom'\nimport { buildProps, isClient, keysOf } from '@element-plus/utils'\n\nimport type { Ref, ToRefs } from 'vue'\nimport type {\n  ComputePositionReturn,\n  Middleware,\n  Placement,\n  SideObject,\n  Strategy,\n  VirtualElement,\n} from '@floating-ui/dom'\n\nexport const useFloatingProps = buildProps({} as const)\n\nexport type UseFloatingProps = ToRefs<{\n  middleware: Array<Middleware>\n  placement: Placement\n  strategy: Strategy\n}>\n\ntype ElementRef = Parameters<typeof unrefElement>['0']\n\nconst unrefReference = (\n  elRef: ElementRef | Ref<VirtualElement | undefined>\n) => {\n  if (!isClient) return\n  if (!elRef) return elRef\n  const unrefEl = unrefElement(elRef as ElementRef)\n  if (unrefEl) return unrefEl\n  return isRef(elRef) ? unrefEl : (elRef as VirtualElement)\n}\n\nexport const getPositionDataWithUnit = <T extends Record<string, number>>(\n  record: T | undefined,\n  key: keyof T\n) => {\n  const value = record?.[key]\n  return isNil(value) ? '' : `${value}px`\n}\n\nexport const useFloating = ({\n  middleware,\n  placement,\n  strategy,\n}: UseFloatingProps) => {\n  const referenceRef = ref<HTMLElement | VirtualElement>()\n  const contentRef = ref<HTMLElement>()\n  const x = ref<number>()\n  const y = ref<number>()\n  const middlewareData = ref<ComputePositionReturn['middlewareData']>({})\n\n  const states = {\n    x,\n    y,\n    placement,\n    strategy,\n    middlewareData,\n  } as const\n\n  const update = async () => {\n    if (!isClient) return\n\n    const referenceEl = unrefReference(referenceRef)\n    const contentEl = unrefElement(contentRef)\n    if (!referenceEl || !contentEl) return\n\n    const data = await computePosition(referenceEl, contentEl, {\n      placement: unref(placement),\n      strategy: unref(strategy),\n      middleware: unref(middleware),\n    })\n\n    keysOf(states).forEach((key) => {\n      states[key].value = data[key]\n    })\n  }\n\n  onMounted(() => {\n    watchEffect(() => {\n      update()\n    })\n  })\n\n  return {\n    ...states,\n    update,\n    referenceRef,\n    contentRef,\n  }\n}\n\nexport type ArrowMiddlewareProps = {\n  arrowRef: Ref<HTMLElement | null | undefined>\n  padding?: number | SideObject\n}\n\nexport const arrowMiddleware = ({\n  arrowRef,\n  padding,\n}: ArrowMiddlewareProps): Middleware => {\n  return {\n    name: 'arrow',\n    options: {\n      element: arrowRef,\n      padding,\n    },\n\n    fn(args) {\n      const arrowEl = unref(arrowRef)\n      if (!arrowEl) return {}\n\n      return arrowCore({\n        element: arrowEl,\n        padding,\n      }).fn(args)\n    },\n  }\n}\n", "import { ref } from 'vue'\n\nimport type { ShallowRef } from 'vue'\n\n// Keep input cursor in the correct position when we use formatter.\nexport function useCursor(\n  input: ShallowRef<HTMLInputElement | undefined>\n): [() => void, () => void] {\n  const selectionRef = ref<{\n    selectionStart?: number\n    selectionEnd?: number\n    value?: string\n    beforeTxt?: string\n    afterTxt?: string\n  }>()\n\n  function recordCursor() {\n    if (input.value == undefined) return\n\n    const { selectionStart, selectionEnd, value } = input.value\n\n    if (selectionStart == null || selectionEnd == null) return\n\n    const beforeTxt = value.slice(0, Math.max(0, selectionStart))\n    const afterTxt = value.slice(Math.max(0, selectionEnd))\n\n    selectionRef.value = {\n      selectionStart,\n      selectionEnd,\n      value,\n      beforeTxt,\n      afterTxt,\n    }\n  }\n  function setCursor() {\n    if (input.value == undefined || selectionRef.value == undefined) return\n\n    const { value } = input.value\n    const { beforeTxt, afterTxt, selectionStart } = selectionRef.value\n\n    if (\n      beforeTxt == undefined ||\n      afterTxt == undefined ||\n      selectionStart == undefined\n    )\n      return\n\n    let startPos = value.length\n\n    if (value.endsWith(afterTxt)) {\n      startPos = value.length - afterTxt.length\n    } else if (value.startsWith(beforeTxt)) {\n      startPos = beforeTxt.length\n    } else {\n      const beforeLastChar = beforeTxt[selectionStart - 1]\n      const newIndex = value.indexOf(beforeLastChar, selectionStart - 1)\n      if (newIndex !== -1) {\n        startPos = newIndex + 1\n      }\n    }\n\n    input.value.setSelectionRange(startPos, startPos)\n  }\n\n  return [recordCursor, setCursor]\n}\n", "import { shallowRef } from 'vue'\nimport { flattedChildren, isVNode } from '@element-plus/utils'\n\nimport type { ComponentInternalInstance, VNode } from 'vue'\n\nconst getOrderedChildren = <T>(\n  vm: ComponentInternalInstance,\n  childComponentName: string,\n  children: Record<number, T>\n): T[] => {\n  const nodes = flattedChildren(vm.subTree).filter(\n    (n): n is VNode =>\n      isVNode(n) &&\n      (n.type as any)?.name === childComponentName &&\n      !!n.component\n  )\n  const uids = nodes.map((n) => n.component!.uid)\n  return uids.map((uid) => children[uid]).filter((p) => !!p)\n}\n\nexport const useOrderedChildren = <T extends { uid: number }>(\n  vm: ComponentInternalInstance,\n  childComponentName: string\n) => {\n  const children: Record<number, T> = {}\n  const orderedChildren = shallowRef<T[]>([])\n\n  const addChild = (child: T) => {\n    children[child.uid] = child\n    orderedChildren.value = getOrderedChildren(vm, childComponentName, children)\n  }\n  const removeChild = (uid: number) => {\n    delete children[uid]\n    orderedChildren.value = orderedChildren.value.filter(\n      (children) => children.uid !== uid\n    )\n  }\n\n  return {\n    children: orderedChildren,\n    addChild,\n    removeChild,\n  }\n}\n", "import { computed, inject, unref } from 'vue'\nimport { buildProp } from '@element-plus/utils'\nimport { componentSizes } from '@element-plus/constants'\n\nimport type { InjectionKey, Ref } from 'vue'\nimport type { ComponentSize } from '@element-plus/constants'\n\nexport const useSizeProp = buildProp({\n  type: String,\n  values: componentSizes,\n  required: false,\n} as const)\n\nexport const useSizeProps = {\n  size: useSizeProp,\n}\n\nexport interface SizeContext {\n  size: Ref<ComponentSize>\n}\n\nexport const SIZE_INJECTION_KEY: InjectionKey<SizeContext> = Symbol('size')\n\nexport const useGlobalSize = () => {\n  const injectedSize = inject(SIZE_INJECTION_KEY, {} as SizeContext)\n\n  return computed<ComponentSize>(() => {\n    return unref(injectedSize.size) || ''\n  })\n}\n", "import { getCurrentInstance, ref, shallowRef, watch } from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport { isFunction } from '@element-plus/utils'\nimport type { ShallowRef } from 'vue'\n\ninterface UseFocusControllerOptions {\n  afterFocus?: () => void\n  /**\n   * return true to cancel blur\n   * @param event FocusEvent\n   */\n  beforeBlur?: (event: FocusEvent) => boolean | undefined\n  afterBlur?: () => void\n}\n\nexport function useFocusController<T extends HTMLElement>(\n  target: ShallowRef<T | undefined>,\n  { afterFocus, beforeBlur, afterBlur }: UseFocusControllerOptions = {}\n) {\n  const instance = getCurrentInstance()!\n  const { emit } = instance\n  const wrapperRef = shallowRef<HTMLElement>()\n  const isFocused = ref(false)\n\n  const handleFocus = (event: FocusEvent) => {\n    if (isFocused.value) return\n    isFocused.value = true\n    emit('focus', event)\n    afterFocus?.()\n  }\n\n  const handleBlur = (event: FocusEvent) => {\n    const cancelBlur = isFunction(beforeBlur) ? beforeBlur(event) : false\n    if (\n      cancelBlur ||\n      (event.relatedTarget &&\n        wrapperRef.value?.contains(event.relatedTarget as Node))\n    )\n      return\n\n    isFocused.value = false\n    emit('blur', event)\n    afterBlur?.()\n  }\n\n  const handleClick = () => {\n    target.value?.focus()\n  }\n\n  watch(wrapperRef, (el) => {\n    if (el) {\n      el.setAttribute('tabindex', '-1')\n    }\n  })\n\n  // TODO: using useEventListener will fail the test\n  // useEventListener(target, 'focus', handleFocus)\n  // useEventListener(target, 'blur', handleBlur)\n  useEventListener(wrapperRef, 'click', handleClick)\n\n  return {\n    wrapperRef,\n    isFocused,\n    handleFocus,\n    handleBlur,\n  }\n}\n", "\nexport default (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACY,IAAC,cAAc,CAAC,MAAM,UAAU;AAC1C;AACA,OAAK,UAAU,CAAC,QAAQ;AACtB,eAAW,QAAQ,CAAC,MAAM,GAAG,OAAO,OAAO,SAAS,OAAO,QAAQ,CAAA,CAAE,CAAC,GAAG;AACvE,UAAI,UAAU,KAAK,MAAM,IAAI;IACnC;EACA;AACE,MAAI,OAAO;AACT,eAAW,CAAC,KAAK,IAAI,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC/C;AACA,WAAK,GAAG,IAAI;IAClB;EACA;AACE,SAAO;AACT;AACY,IAAC,sBAAsB,CAAC,IAAI,SAAS;AAC/C;AACA,KAAG,UAAU,CAAC,QAAQ;AACpB;AACA,OAAG,WAAW,IAAI;AAClB,QAAI,OAAO,iBAAiB,IAAI,IAAI;EACxC;AACE,SAAO;AACT;AACY,IAAC,uBAAuB,CAAC,WAAW,SAAS;AACvD;AACA,YAAU,UAAU,CAAC,QAAQ;AAC3B,QAAI,UAAU,MAAM,SAAS;EACjC;AACE,SAAO;AACT;AACY,IAAC,kBAAkB,CAAC,cAAc;AAC5C;AACA,YAAU,UAAU;AACpB,SAAO;AACT;;;ACpCY,IAAC,aAAa;EACxB,KAAK;EACL,OAAO;EACP,OAAO;EACP,MAAM;EACN,IAAI;EACJ,OAAO;EACP,MAAM;EACN,KAAK;EACL,QAAQ;EACR,WAAW;EACX,aAAa;EACb,QAAQ;EACR,UAAU;EACV,MAAM;EACN,KAAK;AACP;;;AChBY,IAAC,gBAAgB;EAC3B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACF;AACY,IAAC,YAAY;EACvB;EACA;EACA;EACA;EACA;EACA;EACA;AACF;;;ACnBY,IAAC,qBAAqB;AACtB,IAAC,eAAe;AAChB,IAAC,cAAc;;;ACFf,IAAC,gBAAgB,OAAO,eAAe;;;ACAvC,IAAC,iBAAiB,CAAC,IAAI,WAAW,SAAS,OAAO;AAClD,IAAC,mBAAmB;EAC9B,OAAO;EACP,SAAS;EACT,OAAO;AACT;;;ACLA,IAAM,8BAA8B;AACxB,IAAC,YAAY,CAAC,YAAY;AACpC,MAAI;AACF,WAAO;AACT,QAAMA,YAAW,iBAAiB,OAAO;AACzC,SAAOA,UAAS,aAAa,UAAU,QAAQ,QAAQ,iBAAiB;AAC1E;AACY,IAAC,6BAA6B,CAAC,YAAY;AACrD,SAAO,MAAM,KAAK,QAAQ,iBAAiB,2BAA2B,CAAC,EAAE,OAAO,CAAC,SAAS,YAAY,IAAI,KAAK,UAAU,IAAI,CAAC;AAChI;AACY,IAAC,cAAc,CAAC,YAAY;AACtC,MAAI,QAAQ,WAAW,KAAK,QAAQ,aAAa,KAAK,QAAQ,aAAa,UAAU,MAAM,MAAM;AAC/F,WAAO;EACX;AACE,MAAI,QAAQ,UAAU;AACpB,WAAO;EACX;AACE,UAAQ,QAAQ,UAAQ;IACtB,KAAK,KAAK;AACR,aAAO,CAAC,CAAC,QAAQ,QAAQ,QAAQ,QAAQ;IAC/C;IACI,KAAK,SAAS;AACZ,aAAO,EAAE,QAAQ,SAAS,YAAY,QAAQ,SAAS;IAC7D;IACI,KAAK;IACL,KAAK;IACL,KAAK,YAAY;AACf,aAAO;IACb;IACI,SAAS;AACP,aAAO;IACb;EACA;AACA;AASY,IAAC,eAAe,SAAS,KAAK,SAAS,MAAM;AACvD,MAAI;AACJ,MAAI,KAAK,SAAS,OAAO,KAAK,KAAK,SAAS,OAAO,GAAG;AACpD,gBAAY;EAChB,WAAa,KAAK,SAAS,KAAK,GAAG;AAC/B,gBAAY;EAChB,OAAS;AACL,gBAAY;EAChB;AACE,QAAM,MAAM,SAAS,YAAY,SAAS;AAC1C,MAAI,UAAU,MAAM,GAAG,IAAI;AAC3B,MAAI,cAAc,GAAG;AACrB,SAAO;AACT;AACY,IAAC,SAAS,CAAC,OAAO,CAAC,GAAG,aAAa,WAAW;AAC9C,IAAC,aAAa,CAAC,IAAI,UAAU,YAAY;AACnD,QAAM,EAAE,WAAU,IAAK;AACvB,MAAI,CAAC;AACH,WAAO;AACT,QAAM,WAAW,WAAW,iBAAiB,OAAO;AACpD,QAAM,QAAQ,MAAM,UAAU,QAAQ,KAAK,UAAU,EAAE;AACvD,SAAO,SAAS,QAAQ,QAAQ,KAAK;AACvC;AACY,IAAC,YAAY,CAAC,OAAO;AAC/B,MAAI,CAAC;AACH;AACF,KAAG,MAAK;AACR,GAAC,OAAO,EAAE,KAAK,GAAG,MAAK;AACzB;;;ACtEY,IAAC,uBAAuB,CAAC,eAAe,aAAa,EAAE,2BAA2B,KAAI,IAAK,CAAA,MAAO;AAC5G,QAAM,cAAc,CAAC,UAAU;AAC7B,UAAM,gBAAgB,iBAAiB,OAAO,SAAS,cAAc,KAAK;AAC1E,QAAI,6BAA6B,SAAS,CAAC,eAAe;AACxD,aAAO,eAAe,OAAO,SAAS,YAAY,KAAK;IAC7D;EACA;AACE,SAAO;AACT;AACY,IAAC,YAAY,CAAC,YAAY;AACpC,SAAO,CAAC,MAAM,EAAE,gBAAgB,UAAU,QAAQ,CAAC,IAAI;AACzD;;;ACXA,SAAS,cAAAC,aAAY,eAAAC,cAAa,UAAU,SAAAC,QAAO,OAAAC,MAAK,QAAQ,SAAS,SAAAC,QAAO,WAAW,iBAAiB,kBAAAC,iBAAgB,aAAa,WAAAC,UAAS,UAAAC,SAAQ,SAAAC,QAAO,YAAAC,WAAU,UAAU,UAAU,UAAU,OAAO,QAAQ,OAAO,OAAO,sBAAAC,qBAAoB,iBAAAC,gBAAe,YAAAC,WAAU,mBAAAC,kBAAiB,aAAAC,YAAW,eAAAC,cAAa,kBAAkB;AAE9U,IAAI,cAAc,OAAO;AACzB,IAAI,eAAe,OAAO;AAC1B,IAAI,sBAAsB,OAAO;AACjC,IAAI,wBAAwB,OAAO;AACnC,IAAI,iBAAiB,OAAO,UAAU;AACtC,IAAI,iBAAiB,OAAO,UAAU;AACtC,IAAI,oBAAoB,CAAC,KAAK,KAAK,UAAU,OAAO,MAAM,YAAY,KAAK,KAAK,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,MAAM,CAAC,IAAI,IAAI,GAAG,IAAI;AAC9J,IAAI,mBAAmB,CAAC,GAAG,MAAM;AAC/B,WAAS,QAAQ,MAAM,IAAI,CAAC;AAC1B,QAAI,eAAe,KAAK,GAAG,IAAI;AAC7B,wBAAkB,GAAG,MAAM,EAAE,IAAI,CAAC;AACtC,MAAI;AACF,aAAS,QAAQ,sBAAsB,CAAC,GAAG;AACzC,UAAI,eAAe,KAAK,GAAG,IAAI;AAC7B,0BAAkB,GAAG,MAAM,EAAE,IAAI,CAAC;AAAA,IACtC;AACF,SAAO;AACT;AACA,IAAI,kBAAkB,CAAC,GAAG,MAAM,aAAa,GAAG,oBAAoB,CAAC,CAAC;AACtE,SAAS,cAAc,IAAI,SAAS;AAClC,MAAIC;AACJ,QAAM,SAAShB,YAAW;AAC1B,EAAAC,aAAY,MAAM;AAChB,WAAO,QAAQ,GAAG;AAAA,EACpB,GAAG,gBAAgB,iBAAiB,CAAC,GAAG,OAAO,GAAG;AAAA,IAChD,QAAQe,MAAK,WAAW,OAAO,SAAS,QAAQ,UAAU,OAAOA,MAAK;AAAA,EACxE,CAAC,CAAC;AACF,SAAO,SAAS,MAAM;AACxB;AAEA,IAAI;AACJ,IAAM,WAAW,OAAO,WAAW;AACnC,IAAM,QAAQ,CAAC,QAAQ,OAAO,QAAQ;AAOtC,IAAMC,cAAa,CAAC,QAAQ,OAAO,QAAQ;AAE3C,IAAMC,YAAW,CAAC,QAAQ,OAAO,QAAQ;AAMzC,IAAM,OAAO,MAAM;AACnB;AAMA,IAAM,QAAQ,cAAc,KAAK,UAAU,OAAO,SAAS,OAAO,cAAc,OAAO,SAAS,GAAG,cAAc,iBAAiB,KAAK,OAAO,UAAU,SAAS;AAGjK,SAAS,aAAa,GAAG;AACvB,SAAO,OAAO,MAAM,aAAa,EAAE,IAAIC,OAAM,CAAC;AAChD;AAEA,SAAS,oBAAoB,QAAQ,IAAI;AACvC,WAAS,WAAW,MAAM;AACxB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,cAAQ,QAAQ,OAAO,MAAM,GAAG,MAAM,MAAM,IAAI,GAAG,EAAE,IAAI,SAAS,MAAM,KAAK,CAAC,CAAC,EAAE,KAAK,OAAO,EAAE,MAAM,MAAM;AAAA,IAC7G,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAIA,SAAS,eAAe,IAAI,UAAU,CAAC,GAAG;AACxC,MAAI;AACJ,MAAI;AACJ,MAAI,eAAe;AACnB,QAAM,gBAAgB,CAAC,WAAW;AAChC,iBAAa,MAAM;AACnB,iBAAa;AACb,mBAAe;AAAA,EACjB;AACA,QAAM,SAAS,CAAC,WAAW;AACzB,UAAM,WAAW,aAAa,EAAE;AAChC,UAAM,cAAc,aAAa,QAAQ,OAAO;AAChD,QAAI;AACF,oBAAc,KAAK;AACrB,QAAI,YAAY,KAAK,gBAAgB,UAAU,eAAe,GAAG;AAC/D,UAAI,UAAU;AACZ,sBAAc,QAAQ;AACtB,mBAAW;AAAA,MACb;AACA,aAAO,QAAQ,QAAQ,OAAO,CAAC;AAAA,IACjC;AACA,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,qBAAe,QAAQ,iBAAiB,SAAS;AACjD,UAAI,eAAe,CAAC,UAAU;AAC5B,mBAAW,WAAW,MAAM;AAC1B,cAAI;AACF,0BAAc,KAAK;AACrB,qBAAW;AACX,kBAAQ,OAAO,CAAC;AAAA,QAClB,GAAG,WAAW;AAAA,MAChB;AACA,cAAQ,WAAW,MAAM;AACvB,YAAI;AACF,wBAAc,QAAQ;AACxB,mBAAW;AACX,gBAAQ,OAAO,CAAC;AAAA,MAClB,GAAG,QAAQ;AAAA,IACb,CAAC;AAAA,EACH;AACA,SAAO;AACT;AACA,SAAS,eAAe,IAAI,WAAW,MAAM,UAAU,MAAM,iBAAiB,OAAO;AACnF,MAAI,WAAW;AACf,MAAI;AACJ,MAAI,YAAY;AAChB,MAAI,eAAe;AACnB,MAAI;AACJ,QAAM,QAAQ,MAAM;AAClB,QAAI,OAAO;AACT,mBAAa,KAAK;AAClB,cAAQ;AACR,mBAAa;AACb,qBAAe;AAAA,IACjB;AAAA,EACF;AACA,QAAM,SAAS,CAAC,YAAY;AAC1B,UAAM,WAAW,aAAa,EAAE;AAChC,UAAM,UAAU,KAAK,IAAI,IAAI;AAC7B,UAAM,SAAS,MAAM;AACnB,aAAO,YAAY,QAAQ;AAAA,IAC7B;AACA,UAAM;AACN,QAAI,YAAY,GAAG;AACjB,iBAAW,KAAK,IAAI;AACpB,aAAO,OAAO;AAAA,IAChB;AACA,QAAI,UAAU,aAAa,WAAW,CAAC,YAAY;AACjD,iBAAW,KAAK,IAAI;AACpB,aAAO;AAAA,IACT,WAAW,UAAU;AACnB,kBAAY,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC3C,uBAAe,iBAAiB,SAAS;AACzC,gBAAQ,WAAW,MAAM;AACvB,qBAAW,KAAK,IAAI;AACpB,sBAAY;AACZ,kBAAQ,OAAO,CAAC;AAChB,gBAAM;AAAA,QACR,GAAG,KAAK,IAAI,GAAG,WAAW,OAAO,CAAC;AAAA,MACpC,CAAC;AAAA,IACH;AACA,QAAI,CAAC,WAAW,CAAC;AACf,cAAQ,WAAW,MAAM,YAAY,MAAM,QAAQ;AACrD,gBAAY;AACZ,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAwCA,SAAS,SAAS,KAAK;AACrB,SAAO;AACT;AA6EA,SAAS,kBAAkB,IAAI;AAC7B,MAAI,gBAAgB,GAAG;AACrB,IAAAC,gBAAe,EAAE;AACjB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAoPA,SAAS,cAAc,IAAI,KAAK,KAAK,UAAU,CAAC,GAAG;AACjD,SAAO,oBAAoB,eAAe,IAAI,OAAO,GAAG,EAAE;AAC5D;AAEA,SAAS,aAAa,OAAO,KAAK,KAAK,UAAU,CAAC,GAAG;AACnD,QAAM,YAAYC,KAAI,MAAM,KAAK;AACjC,QAAM,UAAU,cAAc,MAAM;AAClC,cAAU,QAAQ,MAAM;AAAA,EAC1B,GAAG,IAAI,OAAO;AACd,EAAAC,OAAM,OAAO,MAAM,QAAQ,CAAC;AAC5B,SAAO;AACT;AAcA,SAAS,cAAc,IAAI,KAAK,KAAK,WAAW,OAAO,UAAU,MAAM,iBAAiB,OAAO;AAC7F,SAAO,oBAAoB,eAAe,IAAI,UAAU,SAAS,cAAc,GAAG,EAAE;AACtF;AA8KA,SAAS,aAAa,IAAI,OAAO,MAAM;AACrC,MAAIC,oBAAmB;AACrB,IAAAC,WAAU,EAAE;AAAA,WACL;AACP,OAAG;AAAA;AAEH,IAAAC,UAAS,EAAE;AACf;AAwVA,SAAS,aAAa,IAAI,UAAU,UAAU,CAAC,GAAG;AAChD,QAAM;AAAA,IACJ,YAAY;AAAA,EACd,IAAI;AACJ,QAAM,YAAYC,KAAI,KAAK;AAC3B,MAAI,QAAQ;AACZ,WAAS,QAAQ;AACf,QAAI,OAAO;AACT,mBAAa,KAAK;AAClB,cAAQ;AAAA,IACV;AAAA,EACF;AACA,WAAS,OAAO;AACd,cAAU,QAAQ;AAClB,UAAM;AAAA,EACR;AACA,WAAS,SAAS,MAAM;AACtB,UAAM;AACN,cAAU,QAAQ;AAClB,YAAQ,WAAW,MAAM;AACvB,gBAAU,QAAQ;AAClB,cAAQ;AACR,SAAG,GAAG,IAAI;AAAA,IACZ,GAAG,aAAa,QAAQ,CAAC;AAAA,EAC3B;AACA,MAAI,WAAW;AACb,cAAU,QAAQ;AAClB,QAAI;AACF,YAAM;AAAA,EACV;AACA,oBAAkB,IAAI;AACtB,SAAO;AAAA,IACL,WAAW,SAAS,SAAS;AAAA,IAC7B;AAAA,IACA;AAAA,EACF;AACF;;;AC3lCA,SAAS,SAAAC,QAAO,OAAAC,MAAK,cAAAC,aAAY,eAAAC,cAAa,YAAAC,WAAU,UAAAC,SAAQ,SAAAC,QAAO,SAAAC,QAAO,sBAAAC,qBAAoB,aAAAC,YAAW,WAAW,YAAAC,WAAU,YAAAC,WAAU,aAAAC,YAAW,SAAS,YAAAC,WAAU,mBAAAC,kBAAiB,UAAAC,SAAQ,KAAK,KAAK,YAAY,sBAAsB;AAkF/O,SAAS,aAAa,OAAO;AAC3B,MAAIC;AACJ,QAAM,QAAQ,aAAa,KAAK;AAChC,UAAQA,MAAK,SAAS,OAAO,SAAS,MAAM,QAAQ,OAAOA,MAAK;AAClE;AAEA,IAAM,gBAAgB,WAAW,SAAS;AAC1C,IAAM,kBAAkB,WAAW,OAAO,WAAW;AACrD,IAAM,mBAAmB,WAAW,OAAO,YAAY;AACvD,IAAM,kBAAkB,WAAW,OAAO,WAAW;AAErD,SAAS,oBAAoB,MAAM;AACjC,MAAIC;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAIC,UAAS,KAAK,CAAC,CAAC,KAAK,MAAM,QAAQ,KAAK,CAAC,CAAC,GAAG;AAC/C,KAAC,QAAQ,WAAW,OAAO,IAAI;AAC/B,IAAAD,UAAS;AAAA,EACX,OAAO;AACL,KAACA,SAAQ,QAAQ,WAAW,OAAO,IAAI;AAAA,EACzC;AACA,MAAI,CAACA;AACH,WAAO;AACT,MAAI,CAAC,MAAM,QAAQ,MAAM;AACvB,aAAS,CAAC,MAAM;AAClB,MAAI,CAAC,MAAM,QAAQ,SAAS;AAC1B,gBAAY,CAAC,SAAS;AACxB,QAAM,WAAW,CAAC;AAClB,QAAM,UAAU,MAAM;AACpB,aAAS,QAAQ,CAAC,OAAO,GAAG,CAAC;AAC7B,aAAS,SAAS;AAAA,EACpB;AACA,QAAM,WAAW,CAAC,IAAI,OAAO,UAAU,aAAa;AAClD,OAAG,iBAAiB,OAAO,UAAU,QAAQ;AAC7C,WAAO,MAAM,GAAG,oBAAoB,OAAO,UAAU,QAAQ;AAAA,EAC/D;AACA,QAAM,YAAYE,OAAM,MAAM,CAAC,aAAaF,OAAM,GAAG,aAAa,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,QAAQ,MAAM;AAC/F,YAAQ;AACR,QAAI,CAAC;AACH;AACF,aAAS,KAAK,GAAG,OAAO,QAAQ,CAAC,UAAU;AACzC,aAAO,UAAU,IAAI,CAAC,aAAa,SAAS,IAAI,OAAO,UAAU,QAAQ,CAAC;AAAA,IAC5E,CAAC,CAAC;AAAA,EACJ,GAAG,EAAE,WAAW,MAAM,OAAO,OAAO,CAAC;AACrC,QAAM,OAAO,MAAM;AACjB,cAAU;AACV,YAAQ;AAAA,EACV;AACA,oBAAkB,IAAI;AACtB,SAAO;AACT;AAEA,IAAI,iBAAiB;AACrB,SAAS,eAAeA,SAAQ,SAAS,UAAU,CAAC,GAAG;AACrD,QAAM,EAAE,QAAAG,UAAS,eAAe,SAAS,CAAC,GAAG,UAAU,MAAM,eAAe,MAAM,IAAI;AACtF,MAAI,CAACA;AACH;AACF,MAAI,SAAS,CAAC,gBAAgB;AAC5B,qBAAiB;AACjB,UAAM,KAAKA,QAAO,SAAS,KAAK,QAAQ,EAAE,QAAQ,CAAC,OAAO,GAAG,iBAAiB,SAAS,IAAI,CAAC;AAAA,EAC9F;AACA,MAAI,eAAe;AACnB,QAAM,eAAe,CAAC,UAAU;AAC9B,WAAO,OAAO,KAAK,CAACC,aAAY;AAC9B,UAAI,OAAOA,aAAY,UAAU;AAC/B,eAAO,MAAM,KAAKD,QAAO,SAAS,iBAAiBC,QAAO,CAAC,EAAE,KAAK,CAAC,OAAO,OAAO,MAAM,UAAU,MAAM,aAAa,EAAE,SAAS,EAAE,CAAC;AAAA,MACpI,OAAO;AACL,cAAM,KAAK,aAAaA,QAAO;AAC/B,eAAO,OAAO,MAAM,WAAW,MAAM,MAAM,aAAa,EAAE,SAAS,EAAE;AAAA,MACvE;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,WAAW,CAAC,UAAU;AAC1B,UAAM,KAAK,aAAaJ,OAAM;AAC9B,QAAI,CAAC,MAAM,OAAO,MAAM,UAAU,MAAM,aAAa,EAAE,SAAS,EAAE;AAChE;AACF,QAAI,MAAM,WAAW;AACnB,qBAAe,CAAC,aAAa,KAAK;AACpC,QAAI,CAAC,cAAc;AACjB,qBAAe;AACf;AAAA,IACF;AACA,YAAQ,KAAK;AAAA,EACf;AACA,QAAM,UAAU;AAAA,IACd,iBAAiBG,SAAQ,SAAS,UAAU,EAAE,SAAS,MAAM,QAAQ,CAAC;AAAA,IACtE,iBAAiBA,SAAQ,eAAe,CAAC,MAAM;AAC7C,YAAM,KAAK,aAAaH,OAAM;AAC9B,UAAI;AACF,uBAAe,CAAC,EAAE,aAAa,EAAE,SAAS,EAAE,KAAK,CAAC,aAAa,CAAC;AAAA,IACpE,GAAG,EAAE,SAAS,KAAK,CAAC;AAAA,IACpB,gBAAgB,iBAAiBG,SAAQ,QAAQ,CAAC,UAAU;AAC1D,UAAIJ;AACJ,YAAM,KAAK,aAAaC,OAAM;AAC9B,YAAMD,MAAKI,QAAO,SAAS,kBAAkB,OAAO,SAASJ,IAAG,aAAa,YAAY,EAAE,MAAM,OAAO,SAAS,GAAG,SAASI,QAAO,SAAS,aAAa;AACxJ,gBAAQ,KAAK;AAAA,IACjB,CAAC;AAAA,EACH,EAAE,OAAO,OAAO;AAChB,QAAM,OAAO,MAAM,QAAQ,QAAQ,CAAC,OAAO,GAAG,CAAC;AAC/C,SAAO;AACT;AAiXA,SAAS,aAAa,UAAU,OAAO,OAAO;AAC5C,QAAM,cAAcE,KAAI;AACxB,QAAM,SAAS,MAAM,YAAY,QAAQ,QAAQ,SAAS,CAAC;AAC3D,SAAO;AACP,eAAa,QAAQ,IAAI;AACzB,SAAO;AACT;AAuaA,SAAS,YAAY,QAAQ;AAC3B,SAAO,KAAK,MAAM,KAAK,UAAU,MAAM,CAAC;AAC1C;AAuBA,IAAM,UAAU,OAAO,eAAe,cAAc,aAAa,OAAO,WAAW,cAAc,SAAS,OAAO,WAAW,cAAc,SAAS,OAAO,SAAS,cAAc,OAAO,CAAC;AACzL,IAAM,YAAY;AAClB,QAAQ,SAAS,IAAI,QAAQ,SAAS,KAAK,CAAC;AAC5C,IAAM,WAAW,QAAQ,SAAS;AA8RlC,SAAS,UAAU,MAAMC,SAAQ,EAAE,QAAAC,UAAS,eAAe,eAAe,GAAG,IAAI,CAAC,GAAG;AACnF,QAAM,WAAWC,KAAI,YAAY;AACjC,QAAM,QAAQC,UAAS,MAAM;AAC3B,QAAIC;AACJ,WAAO,aAAaJ,OAAM,OAAOI,MAAKH,WAAU,OAAO,SAASA,QAAO,aAAa,OAAO,SAASG,IAAG;AAAA,EACzG,CAAC;AACD,EAAAC,OAAM,CAAC,OAAO,MAAM,aAAa,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,MAAM;AACxD,QAAID;AACJ,QAAI,MAAMH,SAAQ;AAChB,YAAM,SAASG,MAAKH,QAAO,iBAAiB,EAAE,EAAE,iBAAiB,KAAK,MAAM,OAAO,SAASG,IAAG,KAAK;AACpG,eAAS,QAAQ,SAAS;AAAA,IAC5B;AAAA,EACF,GAAG,EAAE,WAAW,KAAK,CAAC;AACtB,EAAAC,OAAM,UAAU,CAAC,QAAQ;AACvB,QAAID;AACJ,SAAKA,MAAK,MAAM,UAAU,OAAO,SAASA,IAAG;AAC3C,YAAM,MAAM,MAAM,YAAY,aAAa,IAAI,GAAG,GAAG;AAAA,EACzD,CAAC;AACD,SAAO;AACT;AA6eA,SAAS,sBAAsB,EAAE,UAAAE,YAAW,gBAAgB,IAAI,CAAC,GAAG;AAClE,MAAI,CAACA;AACH,WAAOC,KAAI,SAAS;AACtB,QAAM,aAAaA,KAAID,UAAS,eAAe;AAC/C,mBAAiBA,WAAU,oBAAoB,MAAM;AACnD,eAAW,QAAQA,UAAS;AAAA,EAC9B,CAAC;AACD,SAAO;AACT;AAyHA,IAAI,wBAAwB,OAAO;AACnC,IAAI,iBAAiB,OAAO,UAAU;AACtC,IAAI,iBAAiB,OAAO,UAAU;AACtC,IAAI,cAAc,CAAC,QAAQ,YAAY;AACrC,MAAIE,UAAS,CAAC;AACd,WAAS,QAAQ;AACf,QAAI,eAAe,KAAK,QAAQ,IAAI,KAAK,QAAQ,QAAQ,IAAI,IAAI;AAC/D,MAAAA,QAAO,IAAI,IAAI,OAAO,IAAI;AAC9B,MAAI,UAAU,QAAQ;AACpB,aAAS,QAAQ,sBAAsB,MAAM,GAAG;AAC9C,UAAI,QAAQ,QAAQ,IAAI,IAAI,KAAK,eAAe,KAAK,QAAQ,IAAI;AAC/D,QAAAA,QAAO,IAAI,IAAI,OAAO,IAAI;AAAA,IAC9B;AACF,SAAOA;AACT;AACA,SAAS,kBAAkBA,SAAQ,UAAU,UAAU,CAAC,GAAG;AACzD,QAAMC,MAAK,SAAS,EAAE,QAAAC,UAAS,cAAc,IAAID,KAAI,kBAAkB,YAAYA,KAAI,CAAC,QAAQ,CAAC;AACjG,MAAI;AACJ,QAAM,cAAc,aAAa,MAAMC,WAAU,oBAAoBA,OAAM;AAC3E,QAAM,UAAU,MAAM;AACpB,QAAI,UAAU;AACZ,eAAS,WAAW;AACpB,iBAAW;AAAA,IACb;AAAA,EACF;AACA,QAAM,YAAYC,OAAM,MAAM,aAAaH,OAAM,GAAG,CAAC,OAAO;AAC1D,YAAQ;AACR,QAAI,YAAY,SAASE,WAAU,IAAI;AACrC,iBAAW,IAAI,eAAe,QAAQ;AACtC,eAAS,QAAQ,IAAI,eAAe;AAAA,IACtC;AAAA,EACF,GAAG,EAAE,WAAW,MAAM,OAAO,OAAO,CAAC;AACrC,QAAM,OAAO,MAAM;AACjB,YAAQ;AACR,cAAU;AAAA,EACZ;AACA,oBAAkB,IAAI;AACtB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,mBAAmBF,SAAQ,UAAU,CAAC,GAAG;AAChD,QAAM;AAAA,IACJ,QAAQ;AAAA,IACR,eAAe;AAAA,IACf,eAAe;AAAA,IACf,YAAY;AAAA,EACd,IAAI;AACJ,QAAM,SAASI,KAAI,CAAC;AACpB,QAAM,SAASA,KAAI,CAAC;AACpB,QAAM,OAAOA,KAAI,CAAC;AAClB,QAAM,QAAQA,KAAI,CAAC;AACnB,QAAM,MAAMA,KAAI,CAAC;AACjB,QAAM,QAAQA,KAAI,CAAC;AACnB,QAAM,IAAIA,KAAI,CAAC;AACf,QAAM,IAAIA,KAAI,CAAC;AACf,WAAS,SAAS;AAChB,UAAM,KAAK,aAAaJ,OAAM;AAC9B,QAAI,CAAC,IAAI;AACP,UAAI,OAAO;AACT,eAAO,QAAQ;AACf,eAAO,QAAQ;AACf,aAAK,QAAQ;AACb,cAAM,QAAQ;AACd,YAAI,QAAQ;AACZ,cAAM,QAAQ;AACd,UAAE,QAAQ;AACV,UAAE,QAAQ;AAAA,MACZ;AACA;AAAA,IACF;AACA,UAAM,OAAO,GAAG,sBAAsB;AACtC,WAAO,QAAQ,KAAK;AACpB,WAAO,QAAQ,KAAK;AACpB,SAAK,QAAQ,KAAK;AAClB,UAAM,QAAQ,KAAK;AACnB,QAAI,QAAQ,KAAK;AACjB,UAAM,QAAQ,KAAK;AACnB,MAAE,QAAQ,KAAK;AACf,MAAE,QAAQ,KAAK;AAAA,EACjB;AACA,oBAAkBA,SAAQ,MAAM;AAChC,EAAAG,OAAM,MAAM,aAAaH,OAAM,GAAG,CAAC,QAAQ,CAAC,OAAO,OAAO,CAAC;AAC3D,MAAI;AACF,qBAAiB,UAAU,QAAQ,EAAE,SAAS,MAAM,SAAS,KAAK,CAAC;AACrE,MAAI;AACF,qBAAiB,UAAU,QAAQ,EAAE,SAAS,KAAK,CAAC;AACtD,eAAa,MAAM;AACjB,QAAI;AACF,aAAO;AAAA,EACX,CAAC;AACD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAu3DA,IAAI,wBAAwB,OAAO;AACnC,IAAI,iBAAiB,OAAO,UAAU;AACtC,IAAI,iBAAiB,OAAO,UAAU;AACtC,IAAI,cAAc,CAAC,QAAQ,YAAY;AACrC,MAAIK,UAAS,CAAC;AACd,WAAS,QAAQ;AACf,QAAI,eAAe,KAAK,QAAQ,IAAI,KAAK,QAAQ,QAAQ,IAAI,IAAI;AAC/D,MAAAA,QAAO,IAAI,IAAI,OAAO,IAAI;AAC9B,MAAI,UAAU,QAAQ;AACpB,aAAS,QAAQ,sBAAsB,MAAM,GAAG;AAC9C,UAAI,QAAQ,QAAQ,IAAI,IAAI,KAAK,eAAe,KAAK,QAAQ,IAAI;AAC/D,QAAAA,QAAO,IAAI,IAAI,OAAO,IAAI;AAAA,IAC9B;AACF,SAAOA;AACT;AACA,SAAS,oBAAoBA,SAAQ,UAAU,UAAU,CAAC,GAAG;AAC3D,QAAMC,MAAK,SAAS,EAAE,QAAAC,UAAS,cAAc,IAAID,KAAI,kBAAkB,YAAYA,KAAI,CAAC,QAAQ,CAAC;AACjG,MAAI;AACJ,QAAM,cAAc,aAAa,MAAMC,WAAU,sBAAsBA,OAAM;AAC7E,QAAM,UAAU,MAAM;AACpB,QAAI,UAAU;AACZ,eAAS,WAAW;AACpB,iBAAW;AAAA,IACb;AAAA,EACF;AACA,QAAM,YAAYC,OAAM,MAAM,aAAaH,OAAM,GAAG,CAAC,OAAO;AAC1D,YAAQ;AACR,QAAI,YAAY,SAASE,WAAU,IAAI;AACrC,iBAAW,IAAI,iBAAiB,QAAQ;AACxC,eAAS,QAAQ,IAAI,eAAe;AAAA,IACtC;AAAA,EACF,GAAG,EAAE,WAAW,KAAK,CAAC;AACtB,QAAM,OAAO,MAAM;AACjB,YAAQ;AACR,cAAU;AAAA,EACZ;AACA,oBAAkB,IAAI;AACtB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAwQA,IAAM,eAAe;AAAA,EACnB,GAAG;AAAA,EACH,GAAG;AAAA,EACH,WAAW;AAAA,EACX,UAAU;AAAA,EACV,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,aAAa;AACf;AACA,IAAM,OAAuB,OAAO,KAAK,YAAY;AA4ErD,IAAI;AAAA,CACH,SAAS,iBAAiB;AACzB,kBAAgB,IAAI,IAAI;AACxB,kBAAgB,OAAO,IAAI;AAC3B,kBAAgB,MAAM,IAAI;AAC1B,kBAAgB,MAAM,IAAI;AAC1B,kBAAgB,MAAM,IAAI;AAC5B,GAAG,mBAAmB,iBAAiB,CAAC,EAAE;AAguC1C,IAAI,YAAY,OAAO;AACvB,IAAI,sBAAsB,OAAO;AACjC,IAAI,eAAe,OAAO,UAAU;AACpC,IAAI,eAAe,OAAO,UAAU;AACpC,IAAI,kBAAkB,CAAC,KAAK,KAAK,UAAU,OAAO,MAAM,UAAU,KAAK,KAAK,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,MAAM,CAAC,IAAI,IAAI,GAAG,IAAI;AAC1J,IAAI,iBAAiB,CAAC,GAAG,MAAM;AAC7B,WAAS,QAAQ,MAAM,IAAI,CAAC;AAC1B,QAAI,aAAa,KAAK,GAAG,IAAI;AAC3B,sBAAgB,GAAG,MAAM,EAAE,IAAI,CAAC;AACpC,MAAI;AACF,aAAS,QAAQ,oBAAoB,CAAC,GAAG;AACvC,UAAI,aAAa,KAAK,GAAG,IAAI;AAC3B,wBAAgB,GAAG,MAAM,EAAE,IAAI,CAAC;AAAA,IACpC;AACF,SAAO;AACT;AACA,IAAM,qBAAqB;AAAA,EACzB,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAC7B,aAAa,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAC9B,eAAe,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAChC,YAAY,CAAC,MAAM,GAAG,KAAK,CAAC;AAAA,EAC5B,aAAa,CAAC,KAAK,GAAG,MAAM,CAAC;AAAA,EAC7B,eAAe,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAChC,aAAa,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAC9B,cAAc,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAC/B,gBAAgB,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EACjC,aAAa,CAAC,KAAK,GAAG,MAAM,CAAC;AAAA,EAC7B,cAAc,CAAC,MAAM,GAAG,KAAK,CAAC;AAAA,EAC9B,gBAAgB,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EACjC,aAAa,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAC9B,cAAc,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAC/B,gBAAgB,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EACjC,YAAY,CAAC,KAAK,GAAG,MAAM,CAAC;AAAA,EAC5B,aAAa,CAAC,MAAM,GAAG,KAAK,CAAC;AAAA,EAC7B,eAAe,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAChC,YAAY,CAAC,MAAM,GAAG,GAAG,IAAI;AAAA,EAC7B,aAAa,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,EAC9B,eAAe,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,EAChC,YAAY,CAAC,MAAM,GAAG,MAAM,KAAK;AAAA,EACjC,aAAa,CAAC,MAAM,MAAM,MAAM,CAAC;AAAA,EACjC,eAAe,CAAC,MAAM,MAAM,MAAM,GAAG;AACvC;AACA,IAAM,oBAAoB,eAAe;AAAA,EACvC,QAAQ;AACV,GAAG,kBAAkB;AAsPrB,SAAS,UAAU,OAAO,KAAK,MAAM,UAAU,CAAC,GAAG;AACjD,MAAIE,KAAI,IAAI,IAAI,IAAI;AACpB,QAAM;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU;AAAA,IACV;AAAA,IACA,OAAO;AAAA,IACP;AAAA,EACF,IAAI;AACJ,QAAM,KAAKC,oBAAmB;AAC9B,QAAM,QAAQ,SAAS,MAAM,OAAO,SAAS,GAAG,WAAWD,MAAK,MAAM,OAAO,SAAS,GAAG,UAAU,OAAO,SAASA,IAAG,KAAK,EAAE,QAAQ,MAAM,KAAK,MAAM,OAAO,SAAS,GAAG,UAAU,OAAO,SAAS,GAAG,UAAU,OAAO,SAAS,GAAG,KAAK,MAAM,OAAO,SAAS,GAAG,KAAK;AACtQ,MAAI,QAAQ;AACZ,MAAI,CAAC,KAAK;AACR,QAAIE,SAAQ;AACV,YAAM,gBAAgB,MAAM,KAAK,MAAM,OAAO,SAAS,GAAG,UAAU,OAAO,SAAS,GAAG,aAAa,OAAO,SAAS,GAAG;AACvH,aAAO,gBAAgB,OAAO,SAAS,aAAa,UAAU;AAC9D,UAAI,CAAC;AACH,iBAAS,gBAAgB,OAAO,SAAS,aAAa,UAAU;AAAA,IACpE,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AACA,UAAQ,aAAa,SAAS,UAAU,IAAI,SAAS;AACrD,QAAM,UAAU,CAAC,QAAQ,CAAC,QAAQ,MAAMC,YAAW,KAAK,IAAI,MAAM,GAAG,IAAI,YAAY,GAAG;AACxF,QAAM,WAAW,MAAM,MAAM,MAAM,GAAG,CAAC,IAAI,QAAQ,MAAM,GAAG,CAAC,IAAI;AACjE,MAAI,SAAS;AACX,UAAM,eAAe,SAAS;AAC9B,UAAM,QAAQC,KAAI,YAAY;AAC9B,IAAAC,OAAM,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,MAAM,QAAQ,QAAQ,CAAC,CAAC;AACvD,IAAAA,OAAM,OAAO,CAAC,MAAM;AAClB,UAAI,MAAM,MAAM,GAAG,KAAK;AACtB,cAAM,OAAO,CAAC;AAAA,IAClB,GAAG,EAAE,KAAK,CAAC;AACX,WAAO;AAAA,EACT,OAAO;AACL,WAAOC,UAAS;AAAA,MACd,MAAM;AACJ,eAAO,SAAS;AAAA,MAClB;AAAA,MACA,IAAI,OAAO;AACT,cAAM,OAAO,KAAK;AAAA,MACpB;AAAA,IACF,CAAC;AAAA,EACH;AACF;AA+kBA,SAAS,eAAe,EAAE,QAAAC,UAAS,cAAc,IAAI,CAAC,GAAG;AACvD,MAAI,CAACA;AACH,WAAOC,KAAI,KAAK;AAClB,QAAM,UAAUA,KAAID,QAAO,SAAS,SAAS,CAAC;AAC9C,mBAAiBA,SAAQ,QAAQ,MAAM;AACrC,YAAQ,QAAQ;AAAA,EAClB,CAAC;AACD,mBAAiBA,SAAQ,SAAS,MAAM;AACtC,YAAQ,QAAQ;AAAA,EAClB,CAAC;AACD,SAAO;AACT;AAqBA,SAAS,cAAc,UAAU,CAAC,GAAG;AACnC,QAAM;AAAA,IACJ,QAAAE,UAAS;AAAA,IACT,eAAe;AAAA,IACf,gBAAgB;AAAA,IAChB,oBAAoB;AAAA,IACpB,mBAAmB;AAAA,EACrB,IAAI;AACJ,QAAM,QAAQC,KAAI,YAAY;AAC9B,QAAM,SAASA,KAAI,aAAa;AAChC,QAAM,SAAS,MAAM;AACnB,QAAID,SAAQ;AACV,UAAI,kBAAkB;AACpB,cAAM,QAAQA,QAAO;AACrB,eAAO,QAAQA,QAAO;AAAA,MACxB,OAAO;AACL,cAAM,QAAQA,QAAO,SAAS,gBAAgB;AAC9C,eAAO,QAAQA,QAAO,SAAS,gBAAgB;AAAA,MACjD;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACP,eAAa,MAAM;AACnB,mBAAiB,UAAU,QAAQ,EAAE,SAAS,KAAK,CAAC;AACpD,MAAI;AACF,qBAAiB,qBAAqB,QAAQ,EAAE,SAAS,KAAK,CAAC;AACjE,SAAO,EAAE,OAAO,OAAO;AACzB;;;ACx7MY,IAAC,YAAY,MAAM,YAAY,WAAW,KAAK,OAAO,UAAU,SAAS;;;ACAzE,IAAC,gBAAgB,CAAC,IAAI,cAAc;AAC9C,MAAI,CAAC,YAAY,CAAC,MAAM,CAAC;AACvB,WAAO;AACT,QAAM,SAAS,GAAG,sBAAqB;AACvC,MAAI;AACJ,MAAI,qBAAqB,SAAS;AAChC,oBAAgB,UAAU,sBAAqB;EACnD,OAAS;AACL,oBAAgB;MACd,KAAK;MACL,OAAO,OAAO;MACd,QAAQ,OAAO;MACf,MAAM;IACZ;EACA;AACE,SAAO,OAAO,MAAM,cAAc,UAAU,OAAO,SAAS,cAAc,OAAO,OAAO,QAAQ,cAAc,QAAQ,OAAO,OAAO,cAAc;AACpJ;AACY,IAAC,eAAe,CAAC,OAAO;AAClC,MAAIE,UAAS;AACb,MAAI,SAAS;AACb,SAAO,QAAQ;AACb,IAAAA,WAAU,OAAO;AACjB,aAAS,OAAO;EACpB;AACE,SAAOA;AACT;AACY,IAAC,uBAAuB,CAAC,IAAI,gBAAgB;AACvD,SAAO,KAAK,IAAI,aAAa,EAAE,IAAI,aAAa,WAAW,CAAC;AAC9D;AACY,IAAC,cAAc,CAAC,UAAU;AACpC,MAAI;AACJ,MAAI;AACJ,MAAI,MAAM,SAAS,YAAY;AAC7B,cAAU,MAAM,eAAe,CAAC,EAAE;AAClC,cAAU,MAAM,eAAe,CAAC,EAAE;EACtC,WAAa,MAAM,KAAK,WAAW,OAAO,GAAG;AACzC,cAAU,MAAM,QAAQ,CAAC,EAAE;AAC3B,cAAU,MAAM,QAAQ,CAAC,EAAE;EAC/B,OAAS;AACL,cAAU,MAAM;AAChB,cAAU,MAAM;EACpB;AACE,SAAO;IACL;IACA;EACJ;AACA;;;ACnCY,IAAC,cAAc,CAAC,QAAQ,QAAQ;AAChC,IAAC,YAAY,CAAC,QAAQ,OAAO,QAAQ;AACrC,IAACC,YAAW,CAAC,QAAQ,OAAO,QAAQ;AACpC,IAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,QAAQ,KAAK,QAAQ,GAAG,KAAK,IAAI,WAAW,KAAK,SAAS,GAAG,KAAK,CAAC,OAAO,KAAK,GAAG,EAAE;AAChH,IAAC,YAAY,CAAC,MAAM;AAC9B,MAAI,OAAO,YAAY;AACrB,WAAO;AACT,SAAO,aAAa;AACtB;AACY,IAAC,eAAe,CAAC,SAAS;AACpC,SAAO,cAAM,IAAI;AACnB;AACY,IAAC,iBAAiB,CAAC,QAAQ;AACrC,MAAI,CAAC,SAAS,GAAG,GAAG;AAClB,WAAO;EACX;AACE,SAAO,CAAC,OAAO,MAAM,OAAO,GAAG,CAAC;AAClC;;;ACvBY,IAAC,qBAAqB,CAAC,SAAS,OAAO,OAAO,QAAQ,uBAAuB,MAAM,EAAE,QAAQ,MAAM,OAAO;AAC1G,IAACC,cAAa,CAAC,QAAQC,WAAa,GAAG;;;ACNvC,IAAC,SAAS,CAAC,QAAQ,OAAO,KAAK,GAAG;AAClC,IAAC,YAAY,CAAC,QAAQ,OAAO,QAAQ,GAAG;AAExC,IAAC,UAAU,CAAC,KAAK,MAAM,iBAAiB;AAClD,SAAO;IACL,IAAI,QAAQ;AACV,aAAO,YAAI,KAAK,MAAM,YAAY;IACxC;IACI,IAAI,MAAM,KAAK;AACb,kBAAI,KAAK,MAAM,GAAG;IACxB;EACA;AACA;;;ACZA,IAAM,mBAAN,cAA+B,MAAM;EACnC,YAAY,GAAG;AACb,UAAM,CAAC;AACP,SAAK,OAAO;EAChB;AACA;AACO,SAAS,WAAW,OAAO,GAAG;AACnC,QAAM,IAAI,iBAAiB,IAAI,UAAU,GAAG;AAC9C;AACO,SAAS,UAAU,OAAO,SAAS;AACxC,MAAI,MAAuC;AACzC,UAAM,QAAQ,SAAS,KAAK,IAAI,IAAI,iBAAiB,IAAI,UAAU,SAAS,IAAI;AAChF,YAAQ,KAAK,KAAK;EACtB;AACA;;;ACVA,IAAM,QAAQ;AACF,IAAC,mBAAmB,CAAC,MAAM,OAAO,IAAI,MAAM,GAAG,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC,KAAK,KAAI,CAAE;AAC/E,IAAC,WAAW,CAAC,IAAI,QAAQ;AACnC,MAAI,CAAC,MAAM,CAAC;AACV,WAAO;AACT,MAAI,IAAI,SAAS,GAAG;AAClB,UAAM,IAAI,MAAM,qCAAqC;AACvD,SAAO,GAAG,UAAU,SAAS,GAAG;AAClC;AACY,IAAC,WAAW,CAAC,IAAI,QAAQ;AACnC,MAAI,CAAC,MAAM,CAAC,IAAI,KAAI;AAClB;AACF,KAAG,UAAU,IAAI,GAAG,iBAAiB,GAAG,CAAC;AAC3C;AACY,IAAC,cAAc,CAAC,IAAI,QAAQ;AACtC,MAAI,CAAC,MAAM,CAAC,IAAI,KAAI;AAClB;AACF,KAAG,UAAU,OAAO,GAAG,iBAAiB,GAAG,CAAC;AAC9C;AACY,IAAC,WAAW,CAAC,SAAS,cAAc;AAC9C,MAAIC;AACJ,MAAI,CAAC,YAAY,CAAC,WAAW,CAAC;AAC5B,WAAO;AACT,MAAI,MAAM,SAAS,SAAS;AAC5B,MAAI,QAAQ;AACV,UAAM;AACR,MAAI;AACF,UAAM,QAAQ,QAAQ,MAAM,GAAG;AAC/B,QAAI;AACF,aAAO;AACT,UAAMC,aAAYD,MAAK,SAAS,gBAAgB,OAAO,SAASA,IAAG,iBAAiB,SAAS,EAAE;AAC/F,WAAOC,YAAWA,UAAS,GAAG,IAAI;EACtC,SAAW,GAAP;AACA,WAAO,QAAQ,MAAM,GAAG;EAC5B;AACA;AAoBO,SAAS,QAAQ,OAAO,cAAc,MAAM;AACjD,MAAI,CAAC;AACH,WAAO;AACT,MAAIC,UAAS,KAAK,KAAK,eAAe,KAAK,GAAG;AAC5C,WAAO,GAAG,QAAQ;EACtB,WAAa,SAAS,KAAK,GAAG;AAC1B,WAAO;EACX;AACE,YAAU,OAAO,0CAA0C;AAC7D;;;ACnEY,IAAC,WAAW,CAAC,IAAI,eAAe;AAC1C,MAAI,CAAC;AACH,WAAO;AACT,QAAM,MAAM;IACV,WAAW;IACX,MAAM;IACN,OAAO;EACX,EAAI,OAAO,UAAU,CAAC;AACpB,QAAM,WAAW,SAAS,IAAI,GAAG;AACjC,SAAO,CAAC,UAAU,QAAQ,SAAS,EAAE,KAAK,CAAC,MAAM,SAAS,SAAS,CAAC,CAAC;AACvE;AACY,IAAC,qBAAqB,CAAC,IAAI,eAAe;AACpD,MAAI,CAAC;AACH;AACF,MAAI,SAAS;AACb,SAAO,QAAQ;AACb,QAAI,CAAC,QAAQ,UAAU,SAAS,eAAe,EAAE,SAAS,MAAM;AAC9D,aAAO;AACT,QAAI,SAAS,QAAQ,UAAU;AAC7B,aAAO;AACT,aAAS,OAAO;EACpB;AACE,SAAO;AACT;AACA,IAAI;AACQ,IAAC,oBAAoB,CAAC,cAAc;AAC9C,MAAIC;AACJ,MAAI,CAAC;AACH,WAAO;AACT,MAAI,mBAAmB;AACrB,WAAO;AACT,QAAM,QAAQ,SAAS,cAAc,KAAK;AAC1C,QAAM,YAAY,GAAG;AACrB,QAAM,MAAM,aAAa;AACzB,QAAM,MAAM,QAAQ;AACpB,QAAM,MAAM,WAAW;AACvB,QAAM,MAAM,MAAM;AAClB,WAAS,KAAK,YAAY,KAAK;AAC/B,QAAM,gBAAgB,MAAM;AAC5B,QAAM,MAAM,WAAW;AACvB,QAAM,QAAQ,SAAS,cAAc,KAAK;AAC1C,QAAM,MAAM,QAAQ;AACpB,QAAM,YAAY,KAAK;AACvB,QAAM,kBAAkB,MAAM;AAC9B,GAACA,MAAK,MAAM,eAAe,OAAO,SAASA,IAAG,YAAY,KAAK;AAC/D,mBAAiB,gBAAgB;AACjC,SAAO;AACT;AACO,SAAS,eAAe,WAAW,UAAU;AAClD,MAAI,CAAC;AACH;AACF,MAAI,CAAC,UAAU;AACb,cAAU,YAAY;AACtB;EACJ;AACE,QAAM,gBAAgB,CAAA;AACtB,MAAI,UAAU,SAAS;AACvB,SAAO,YAAY,QAAQ,cAAc,WAAW,UAAU,SAAS,OAAO,GAAG;AAC/E,kBAAc,KAAK,OAAO;AAC1B,cAAU,QAAQ;EACtB;AACE,QAAM,MAAM,SAAS,YAAY,cAAc,OAAO,CAAC,MAAM,SAAS,OAAO,KAAK,WAAW,CAAC;AAC9F,QAAM,SAAS,MAAM,SAAS;AAC9B,QAAM,cAAc,UAAU;AAC9B,QAAM,iBAAiB,cAAc,UAAU;AAC/C,MAAI,MAAM,aAAa;AACrB,cAAU,YAAY;EAC1B,WAAa,SAAS,gBAAgB;AAClC,cAAU,YAAY,SAAS,UAAU;EAC7C;AACA;;;ACvEA,IAAM,cAAc,CAAA;AACpB,IAAI,SAAS,CAAC,WAAW,SAAS,SAAS;AACpC,SAAS,iBAAiB,IAAI;AACnC,QAAM,KAAK,SAAS,cAAc,KAAK;AACvC,MAAI,OAAO,QAAQ;AACjB,OAAG,aAAa,MAAM,EAAE;EAC5B;AACE,SAAO,YAAY,EAAE;AACrB,cAAY,KAAK,EAAE;AACnB,SAAO;AACT;AACO,SAAS,iBAAiB,IAAI;AACnC,cAAY,OAAO,YAAY,QAAQ,EAAE,GAAG,CAAC;AAC7C,KAAG,OAAM;AACX;;;ACXY,IAAC,YAAY;AACb,IAAC,iBAAiB,CAAC,QAAQ;AAC3B,IAAC,WAAW,CAAC,QAAQ,SAAS,GAAG,KAAK,CAAC,CAAC,IAAI,SAAS;AACrD,IAAC,YAAY,CAAC,MAAM,QAAQ;AACtC,MAAI,CAAC,SAAS,IAAI,KAAK,SAAS,IAAI;AAClC,WAAO;AACT,QAAM,EAAE,QAAQ,UAAU,SAAS,cAAc,MAAM,UAAS,IAAK;AACrE,QAAM,aAAa,UAAU,YAAY,CAAC,QAAQ;AAChD,QAAI,QAAQ;AACZ,QAAI,gBAAgB,CAAA;AACpB,QAAI,QAAQ;AACV,sBAAgB,MAAM,KAAK,MAAM;AACjC,UAAI,OAAO,MAAM,SAAS,GAAG;AAC3B,sBAAc,KAAK,YAAY;MACvC;AACM,gBAAU,QAAQ,cAAc,SAAS,GAAG;IAClD;AACI,QAAI;AACF,gBAAU,QAAQ,UAAU,GAAG;AACjC,QAAI,CAAC,SAAS,cAAc,SAAS,GAAG;AACtC,YAAM,kBAAkB,CAAC,GAAG,IAAI,IAAI,aAAa,CAAC,EAAE,IAAI,CAAC,UAAU,KAAK,UAAU,KAAK,CAAC,EAAE,KAAK,IAAI;AACnG,WAAK,kCAAkC,MAAM,cAAc,SAAS,wBAAwB,+BAA+B,KAAK,UAAU,GAAG,IAAI;IACvJ;AACI,WAAO;EACX,IAAM;AACJ,QAAM,SAAS;IACb;IACA,UAAU,CAAC,CAAC;IACZ,WAAW;IACX,CAAC,SAAS,GAAG;EACjB;AACE,MAAI,OAAO,MAAM,SAAS;AACxB,WAAO,UAAU;AACnB,SAAO;AACT;AACY,IAAC,aAAa,CAAC,UAAU,kBAAU,OAAO,QAAQ,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,MAAM,MAAM;EAC1F;EACA,UAAU,QAAQ,GAAG;AACvB,CAAC,CAAC;;;AC/BU,IAAC,eAAe,eAAe;EACzC;EACA;EACA;AACF,CAAC;AACW,IAAC,kBAAkB;EAC7B;AACF;AACY,IAAC,iBAAiB;EAC5B;EACA;EACA;EACA;EACA;AACF;AACY,IAAC,oBAAoB;EAC/B,SAAS;EACT,SAAS;EACT,OAAO;EACP,MAAM;AACR;AACY,IAAC,wBAAwB;EACnC,YAAY;EACZ,SAAS;EACT,OAAO;AACT;;;ACnCY,IAAC,cAAc,IAAI,SAAS;AACtC,SAAO,CAAC,OAAO;AACb,SAAK,QAAQ,CAACC,SAAQ;AACpB,UAAI,WAAWA,IAAG,GAAG;AACnB,QAAAA,KAAI,EAAE;MACd,OAAa;AACL,QAAAA,KAAI,QAAQ;MACpB;IACA,CAAK;EACL;AACA;;;ACVY,IAAC,mBAAmB,CAACC,UAAS;AACxC,SAAO,iBAAiBA,SAAQ,SAAS;AAC3C;;;ACFY,IAAC,uBAAuB,CAAC,QAAQ,CAAC,IAAI,GAAG,cAAc,EAAE,SAAS,GAAG;;;ACWjF,IAAMC,SAAQ;AACJ,IAAC,cAA8B,CAAC,gBAAgB;AACxD,cAAY,YAAY,MAAM,IAAI,CAAC,IAAI;AACvC,cAAY,YAAY,OAAO,IAAI,CAAC,IAAI;AACxC,cAAY,YAAY,OAAO,IAAI,CAAC,IAAI;AACxC,cAAY,YAAY,OAAO,IAAI,CAAC,IAAI;AACxC,cAAY,YAAY,YAAY,IAAI,EAAE,IAAI;AAC9C,cAAY,YAAY,gBAAgB,IAAI,EAAE,IAAI;AAClD,cAAY,YAAY,iBAAiB,IAAI,EAAE,IAAI;AACnD,cAAY,YAAY,gBAAgB,IAAI,GAAG,IAAI;AACnD,cAAY,YAAY,kBAAkB,IAAI,GAAG,IAAI;AACrD,cAAY,YAAY,YAAY,IAAI,GAAG,IAAI;AAC/C,cAAY,YAAY,eAAe,IAAI,IAAI,IAAI;AACnD,cAAY,YAAY,SAAS,IAAI,EAAE,IAAI;AAC3C,cAAY,YAAY,MAAM,IAAI,EAAE,IAAI;AACxC,SAAO;AACT,GAAG,cAAc,CAAA,CAAE;AACZ,SAAS,WAAW,MAAM;AAC/B,SAAO,QAAQ,IAAI,KAAK,KAAK,SAAS;AACxC;AAIO,SAAS,UAAU,MAAM;AAC9B,SAAO,QAAQ,IAAI,KAAK,KAAK,SAAS;AACxC;AAKO,SAAS,mBAAmB,MAAM;AACvC,SAAO,QAAQ,IAAI,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC,UAAU,IAAI;AAC9D;AAsBY,IAAC,qBAAqB,CAAC,SAAS;AAC1C,MAAI,CAAC,QAAQ,IAAI,GAAG;AAClB,cAAUC,QAAO,sCAAsC;AACvD,WAAO,CAAA;EACX;AACE,QAAM,MAAM,KAAK,SAAS,CAAA;AAC1B,QAAM,QAAQ,QAAQ,KAAK,IAAI,IAAI,KAAK,KAAK,QAAQ,WAAW,CAAA;AAChE,QAAM,QAAQ,CAAA;AACd,SAAO,KAAK,IAAI,EAAE,QAAQ,CAAC,QAAQ;AACjC,QAAI,OAAO,KAAK,GAAG,GAAG,SAAS,GAAG;AAChC,YAAM,GAAG,IAAI,KAAK,GAAG,EAAE;IAC7B;EACA,CAAG;AACD,SAAO,KAAK,GAAG,EAAE,QAAQ,CAAC,QAAQ;AAChC,UAAM,SAAS,GAAG,CAAC,IAAI,IAAI,GAAG;EAClC,CAAG;AACD,SAAO;AACT;AACY,IAAC,kBAAkB,CAAC,aAAa;AAC3C,MAAI,CAAC,QAAQ,QAAQ,KAAK,SAAS,SAAS,GAAG;AAC7C,UAAM,IAAI,MAAM,8CAA8C;EAClE;AACE,SAAO,SAAS,CAAC;AACnB;AACY,IAAC,kBAAkB,CAAC,aAAa;AAC3C,QAAM,SAAS,QAAQ,QAAQ,IAAI,WAAW,CAAC,QAAQ;AACvD,QAAM,SAAS,CAAA;AACf,SAAO,QAAQ,CAAC,UAAU;AACxB,QAAIC;AACJ,QAAI,QAAQ,KAAK,GAAG;AAClB,aAAO,KAAK,GAAG,gBAAgB,KAAK,CAAC;IAC3C,WAAe,QAAQ,KAAK,KAAK,QAAQ,MAAM,QAAQ,GAAG;AACpD,aAAO,KAAK,GAAG,gBAAgB,MAAM,QAAQ,CAAC;IACpD,OAAW;AACL,aAAO,KAAK,KAAK;AACjB,UAAI,QAAQ,KAAK,OAAOA,MAAK,MAAM,cAAc,OAAO,SAASA,IAAG,UAAU;AAC5E,eAAO,KAAK,GAAG,gBAAgB,MAAM,UAAU,OAAO,CAAC;MAC/D;IACA;EACA,CAAG;AACD,SAAO;AACT;;;AC3GY,IAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,IAAI,IAAI,GAAG,CAAC;AACnC,IAAC,YAAY,CAAC,QAAQ;AAChC,MAAI,CAAC,OAAO,QAAQ;AAClB,WAAO,CAAA;AACT,SAAO,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG;AACxC;;;ACLY,IAAC,WAAW,CAAC,SAAS,oCAAoC,KAAK,IAAI;;;ACCnE,IAAC,MAAM,CAAC,OAAO,WAAW,OAAO,sBAAsB,EAAE,IAAI,WAAW,IAAI,EAAE;AAC9E,IAAC,MAAM,CAAC,WAAW,WAAW,OAAO,qBAAqB,MAAM,IAAI,aAAa,MAAM;;;ACFvF,IAAC,aAAa,MAAM,KAAK,MAAM,KAAK,OAAM,IAAK,GAAG;;;ACAlD,IAAC,UAAU,CAAC,QAAQ;;;ACGhC,IAAM,uBAAuB,CAAC,SAAS,OAAO;AAC9C,IAAM,kBAAkB;AACZ,IAAC,WAAW,CAAC,SAAS,CAAA,MAAO;AACvC,QAAM,EAAE,mBAAmB,OAAO,YAAW,IAAK;AAClD,QAAM,iBAAiBC,UAAS,MAAM;AACpC,aAAS,eAAe,OAAO,SAAS,YAAY,UAAU,CAAA,GAAI,OAAO,oBAAoB;EACjG,CAAG;AACD,QAAM,WAAW,mBAAkB;AACnC,MAAI,CAAC,UAAU;AACb,cAAU,aAAa,8FAA8F;AACrH,WAAOA,UAAS,OAAO,CAAA,EAAG;EAC9B;AACE,SAAOA,UAAS,MAAM;AACpB,QAAIC;AACJ,WAAO,kBAAU,OAAO,SAASA,MAAK,SAAS,UAAU,OAAO,SAASA,IAAG,MAAM,EAAE,OAAO,CAAC,CAAC,GAAG,MAAM,CAAC,eAAe,MAAM,SAAS,GAAG,KAAK,EAAE,oBAAoB,gBAAgB,KAAK,GAAG,EAAE,CAAC;EAClM,CAAG;AACH;;;ACjBY,IAAC,gBAAgB,CAAC,EAAE,MAAM,aAAa,OAAO,SAAAC,UAAS,KAAAC,MAAK,OAAO,MAAK,GAAI,cAAc;AACpG,QAAM,MAAM,MAAM,SAAS,GAAG,CAAC,QAAQ;AACrC,QAAI,KAAK;AACP,gBAAU,OAAO,IAAI,SAAS,6CAA6CD,wBAAuB;iCACvEC;CAChC;IACD;EACA,GAAK;IACD,WAAW;EACf,CAAG;AACH;;;ACVY,IAAC,eAAe,CAAC,WAAW,SAAS,cAAc;AAC7D,MAAI,YAAY;IACd,SAAS;IACT,SAAS;EACb;AACE,QAAM,cAAc,CAAC,MAAM;AACzB,UAAM,QAAQ,EAAE;AAChB,UAAM,QAAQ,EAAE;AAChB,UAAM,EAAE,SAAS,QAAO,IAAK;AAC7B,UAAM,aAAa,UAAU,MAAM,sBAAqB;AACxD,UAAM,aAAa,WAAW;AAC9B,UAAM,YAAY,WAAW;AAC7B,UAAM,cAAc,WAAW;AAC/B,UAAM,eAAe,WAAW;AAChC,UAAM,cAAc,SAAS,gBAAgB;AAC7C,UAAM,eAAe,SAAS,gBAAgB;AAC9C,UAAM,UAAU,CAAC,aAAa;AAC9B,UAAM,SAAS,CAAC,YAAY;AAC5B,UAAM,UAAU,cAAc,aAAa,cAAc;AACzD,UAAM,SAAS,eAAe,YAAY,eAAe;AACzD,UAAM,cAAc,CAAC,OAAO;AAC1B,YAAM,QAAQ,KAAK,IAAI,KAAK,IAAI,UAAU,GAAG,UAAU,OAAO,OAAO,GAAG,OAAO;AAC/E,YAAM,QAAQ,KAAK,IAAI,KAAK,IAAI,UAAU,GAAG,UAAU,OAAO,MAAM,GAAG,MAAM;AAC7E,kBAAY;QACV,SAAS;QACT,SAAS;MACjB;AACM,UAAI,UAAU,OAAO;AACnB,kBAAU,MAAM,MAAM,YAAY,aAAa,QAAQ,KAAK,MAAM,QAAQ,KAAK;MACvF;IACA;AACI,UAAM,YAAY,MAAM;AACtB,eAAS,oBAAoB,aAAa,WAAW;AACrD,eAAS,oBAAoB,WAAW,SAAS;IACvD;AACI,aAAS,iBAAiB,aAAa,WAAW;AAClD,aAAS,iBAAiB,WAAW,SAAS;EAClD;AACE,QAAM,cAAc,MAAM;AACxB,QAAI,QAAQ,SAAS,UAAU,OAAO;AACpC,cAAQ,MAAM,iBAAiB,aAAa,WAAW;IAC7D;EACA;AACE,QAAM,eAAe,MAAM;AACzB,QAAI,QAAQ,SAAS,UAAU,OAAO;AACpC,cAAQ,MAAM,oBAAoB,aAAa,WAAW;IAChE;EACA;AACE,YAAU,MAAM;AACd,gBAAY,MAAM;AAChB,UAAI,UAAU,OAAO;AACnB,oBAAW;MACnB,OAAa;AACL,qBAAY;MACpB;IACA,CAAK;EACL,CAAG;AACD,kBAAgB,MAAM;AACpB,iBAAY;EAChB,CAAG;AACH;;;AC9DY,IAAC,WAAW,CAAC,OAAO;AAC9B,SAAO;IACL,OAAO,MAAM;AACX,UAAIC,KAAI;AACR,OAAC,MAAMA,MAAK,GAAG,UAAU,OAAO,SAASA,IAAG,UAAU,OAAO,SAAS,GAAG,KAAKA,GAAE;IACtF;EACA;AACA;;;ACPA,IAAA,UAAe;EACb,MAAM;EACN,IAAI;IACF,aAAa;MACX,SAAS;MACT,OAAO;MACP,cAAc;MACd,aAAa;IACnB;IACI,YAAY;MACV,KAAK;MACL,OAAO;MACP,QAAQ;MACR,OAAO;MACP,SAAS;MACT,iBAAiB;MACjB,kBAAkB;MAClB,iBAAiB;MACjB,cAAc;MACd,YAAY;MACZ,YAAY;MACZ,WAAW;MACX,WAAW;MACX,SAAS;MACT,SAAS;MACT,UAAU;MACV,UAAU;MACV,WAAW;MACX,WAAW;MACX,MAAM;MACN,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,QAAQ;MACR,SAAS;MACT,SAAS;MACT,SAAS;MACT,MAAM;MACN,OAAO;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;MACb;MACM,WAAW;QACT,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;MACb;MACM,QAAQ;QACN,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;MACb;IACA;IACI,aAAa;MACX,UAAU;MACV,UAAU;IAChB;IACI,QAAQ;MACN,SAAS;MACT,SAAS;MACT,QAAQ;MACR,aAAa;IACnB;IACI,UAAU;MACR,gBAAgB;IACtB;IACI,UAAU;MACR,SAAS;MACT,SAAS;MACT,aAAa;MACb,QAAQ;IACd;IACI,YAAY;MACV,MAAM;MACN,UAAU;MACV,OAAO;MACP,gBAAgB;MAChB,MAAM;MACN,MAAM;MACN,MAAM;MACN,aAAa;MACb,WAAW;MACX,WAAW;MACX,oBAAoB;IAC1B;IACI,QAAQ;MACN,OAAO;IACb;IACI,QAAQ;MACN,OAAO;IACb;IACI,YAAY;MACV,OAAO;MACP,SAAS;MACT,QAAQ;MACR,OAAO;MACP,OAAO;IACb;IACI,QAAQ;MACN,WAAW;MACX,QAAQ;MACR,SAAS;MACT,UAAU;IAChB;IACI,QAAQ;MACN,cAAc;MACd,wBAAwB;MACxB,sBAAsB;IAC5B;IACI,OAAO;MACL,WAAW;MACX,eAAe;MACf,aAAa;MACb,aAAa;MACb,SAAS;IACf;IACI,MAAM;MACJ,WAAW;IACjB;IACI,UAAU;MACR,SAAS;MACT,QAAQ;MACR,QAAQ,CAAC,UAAU,QAAQ;MAC3B,mBAAmB;MACnB,iBAAiB;MACjB,kBAAkB;IACxB;IACI,OAAO;MACL,OAAO;IACb;IACI,YAAY;MACV,OAAO;IACb;IACI,YAAY;MACV,mBAAmB;MACnB,kBAAkB;IACxB;EACA;AACA;;;AC9JY,IAAC,kBAAkB,CAAC,WAAW,CAAC,MAAM,WAAW,UAAU,MAAM,QAAQ,MAAM,MAAM,CAAC;AACtF,IAAC,YAAY,CAAC,MAAM,QAAQ,WAAW,YAAI,QAAQ,MAAM,IAAI,EAAE,QAAQ,cAAc,CAAC,GAAG,QAAQ;AAC3G,MAAIC;AACJ,SAAO,IAAIA,MAAK,UAAU,OAAO,SAAS,OAAO,GAAG,MAAM,OAAOA,MAAK,IAAI;AAC5E,CAAC;AACW,IAAC,qBAAqB,CAAC,WAAW;AAC5C,QAAM,OAAOC,UAAS,MAAM,MAAM,MAAM,EAAE,IAAI;AAC9C,QAAM,YAAY,MAAM,MAAM,IAAI,SAAS,IAAI,MAAM;AACrD,SAAO;IACL;IACA,QAAQ;IACR,GAAG,gBAAgB,MAAM;EAC7B;AACA;AACY,IAAC,mBAAmB,OAAO,kBAAkB;AAC7C,IAAC,YAAY,CAAC,oBAAoB;AAC5C,QAAM,SAAS,mBAAmB,OAAO,kBAAkB,IAAG,CAAE;AAChE,SAAO,mBAAmBA,UAAS,MAAM,OAAO,SAAS,OAAO,CAAC;AACnE;;;ACpBY,IAAC,mBAAmB;AAChC,IAAM,cAAc;AACpB,IAAM,OAAO,CAAC,WAAW,OAAO,aAAa,SAAS,aAAa;AACjE,MAAI,MAAM,GAAG,aAAa;AAC1B,MAAI,aAAa;AACf,WAAO,IAAI;EACf;AACE,MAAI,SAAS;AACX,WAAO,KAAK;EAChB;AACE,MAAI,UAAU;AACZ,WAAO,KAAK;EAChB;AACE,SAAO;AACT;AACY,IAAC,sBAAsB,OAAO,qBAAqB;AACnD,IAAC,yBAAyB,CAAC,uBAAuB;AAC5D,QAAM,mBAAmB,uBAAuB,mBAAkB,IAAK,OAAO,qBAAqB,IAAI,gBAAgB,CAAC,IAAI,IAAI,gBAAgB;AAChJ,QAAM,YAAYC,UAAS,MAAM;AAC/B,WAAO,MAAM,gBAAgB,KAAK;EACtC,CAAG;AACD,SAAO;AACT;AACY,IAAC,eAAe,CAAC,OAAO,uBAAuB;AACzD,QAAM,YAAY,uBAAuB,kBAAkB;AAC3D,QAAM,IAAI,CAAC,cAAc,OAAO,KAAK,UAAU,OAAO,OAAO,aAAa,IAAI,EAAE;AAChF,QAAM,IAAI,CAAC,YAAY,UAAU,KAAK,UAAU,OAAO,OAAO,IAAI,SAAS,EAAE,IAAI;AACjF,QAAM,IAAI,CAAC,aAAa,WAAW,KAAK,UAAU,OAAO,OAAO,IAAI,IAAI,QAAQ,IAAI;AACpF,QAAM,KAAK,CAAC,aAAa,YAAY,eAAe,UAAU,KAAK,UAAU,OAAO,OAAO,aAAa,SAAS,EAAE,IAAI;AACvH,QAAM,KAAK,CAAC,SAAS,aAAa,WAAW,WAAW,KAAK,UAAU,OAAO,OAAO,IAAI,SAAS,QAAQ,IAAI;AAC9G,QAAM,KAAK,CAAC,aAAa,aAAa,eAAe,WAAW,KAAK,UAAU,OAAO,OAAO,aAAa,IAAI,QAAQ,IAAI;AAC1H,QAAM,MAAM,CAAC,aAAa,SAAS,aAAa,eAAe,WAAW,WAAW,KAAK,UAAU,OAAO,OAAO,aAAa,SAAS,QAAQ,IAAI;AACpJ,QAAM,KAAK,CAAC,SAAS,SAAS;AAC5B,UAAM,QAAQ,KAAK,UAAU,IAAI,KAAK,CAAC,IAAI;AAC3C,WAAO,QAAQ,QAAQ,GAAG,cAAc,SAAS;EACrD;AACE,QAAM,SAAS,CAAC,WAAW;AACzB,UAAM,SAAS,CAAA;AACf,eAAW,OAAO,QAAQ;AACxB,UAAI,OAAO,GAAG,GAAG;AACf,eAAO,KAAK,UAAU,SAAS,KAAK,IAAI,OAAO,GAAG;MAC1D;IACA;AACI,WAAO;EACX;AACE,QAAM,cAAc,CAAC,WAAW;AAC9B,UAAM,SAAS,CAAA;AACf,eAAW,OAAO,QAAQ;AACxB,UAAI,OAAO,GAAG,GAAG;AACf,eAAO,KAAK,UAAU,SAAS,SAAS,KAAK,IAAI,OAAO,GAAG;MACnE;IACA;AACI,WAAO;EACX;AACE,QAAM,aAAa,CAAC,SAAS,KAAK,UAAU,SAAS;AACrD,QAAM,kBAAkB,CAAC,SAAS,KAAK,UAAU,SAAS,SAAS;AACnE,SAAO;IACL;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACJ;AACA;;;AC5DY,IAAC,gBAAgB,CAAC,SAAS,UAAU,CAAA,MAAO;AACtD,MAAI,CAAC,MAAM,OAAO,GAAG;AACnB,eAAW,mBAAmB,+CAA+C;EACjF;AACE,QAAM,KAAK,QAAQ,MAAM,aAAa,OAAO;AAC7C,QAAM,YAAY,SAAS,MAAM,GAAG,GAAG,UAAU,QAAQ,CAAC;AAC1D,MAAI,CAAC,YAAY,SAAS,SAAS,MAAM,UAAU,KAAK,GAAG;AACzD;EACJ;AACE,MAAIC,kBAAiB;AACrB,MAAI,qBAAqB;AACzB,MAAI,YAAY;AAChB,QAAM,UAAU,MAAM;AACpB,eAAW,MAAM;AACf,kBAAY,YAAY,OAAO,SAAS,SAAS,MAAM,UAAU,KAAK;AACtE,UAAI,sBAAsB,UAAU;AAClC,iBAAS,KAAK,MAAM,QAAQ;MACpC;IACA,GAAO,GAAG;EACV;AACE,QAAM,SAAS,CAAC,QAAQ;AACtB,QAAI,CAAC,KAAK;AACR,cAAO;AACP;IACN;AACI,yBAAqB,CAAC,SAAS,SAAS,MAAM,UAAU,KAAK;AAC7D,QAAI,oBAAoB;AACtB,kBAAY,SAAS,KAAK,MAAM;IACtC;AACI,IAAAA,kBAAiB,kBAAkB,GAAG,UAAU,KAAK;AACrD,UAAM,kBAAkB,SAAS,gBAAgB,eAAe,SAAS,KAAK;AAC9E,UAAM,gBAAgB,SAAS,SAAS,MAAM,WAAW;AACzD,QAAIA,kBAAiB,MAAM,mBAAmB,kBAAkB,aAAa,oBAAoB;AAC/F,eAAS,KAAK,MAAM,QAAQ,eAAeA;IACjD;AACI,aAAS,SAAS,MAAM,UAAU,KAAK;EAC3C,CAAG;AACD,iBAAe,MAAM,QAAO,CAAE;AAChC;;;AC/CA,IAAM,aAAa,CAAA;AACnB,IAAM,aAAa,CAAC,MAAM;AACxB,MAAI,WAAW,WAAW;AACxB;AACF,MAAI,EAAE,SAAS,WAAW,KAAK;AAC7B,MAAE,gBAAe;AACjB,UAAM,WAAW,WAAW,WAAW,SAAS,CAAC;AACjD,aAAS,YAAW;EACxB;AACA;AACY,IAAC,WAAW,CAAC,UAAU,eAAe;AAChD,QAAM,YAAY,CAAC,QAAQ;AACzB,QAAI,KAAK;AACP,iBAAW,KAAK,QAAQ;IAC9B,OAAW;AACL,iBAAW,OAAO,WAAW,QAAQ,QAAQ,GAAG,CAAC;IACvD;EACA,CAAG;AACH;AACA,IAAI;AACF,mBAAiB,UAAU,WAAW,UAAU;;;ACflD,IAAM,QAAQ,UAAU;EACtB,MAAM,eAAe,OAAO;EAC5B,SAAS;AACX,CAAC;AACD,IAAM,SAAS,UAAU;EACvB,MAAM,eAAe,QAAQ;AAC/B,CAAC;AACW,IAAC,8BAA8B,CAAC,SAAS;AACnD,QAAM,iBAAiB,UAAU;AACjC,QAAM,oBAAoB,YAAY;AACtC,QAAM,uBAAuB,CAAC,cAAc;AAC5C,QAAM,uBAAuB;IAC3B,CAAC,IAAI,GAAG;IACR,CAAC,iBAAiB,GAAG;EACzB;AACE,QAAM,kBAAkB,CAAC;IACvB;IACA;IACA;IACA;IACA;IACA;EACJ,MAAQ;AACJ,UAAM,WAAW,mBAAkB;AACnC,UAAM,EAAE,KAAI,IAAK;AACjB,UAAM,QAAQ,SAAS;AACvB,UAAM,mBAAmBC,UAAS,MAAM,WAAW,MAAM,iBAAiB,CAAC,CAAC;AAC5E,UAAM,uBAAuBA,UAAS,MAAM,MAAM,IAAI,MAAM,IAAI;AAChE,UAAM,SAAS,CAAC,UAAU;AACxB,UAAI,UAAU,UAAU,MAAM;AAC5B;MACR;AACM,gBAAU,QAAQ;AAClB,UAAI,cAAc;AAChB,qBAAa,QAAQ;MAC7B;AACM,UAAI,WAAW,MAAM,GAAG;AACtB,eAAO,KAAK;MACpB;IACA;AACI,UAAM,SAAS,CAAC,UAAU;AACxB,UAAI,UAAU,UAAU,OAAO;AAC7B;MACR;AACM,gBAAU,QAAQ;AAClB,UAAI,cAAc;AAChB,qBAAa,QAAQ;MAC7B;AACM,UAAI,WAAW,MAAM,GAAG;AACtB,eAAO,KAAK;MACpB;IACA;AACI,UAAM,OAAO,CAAC,UAAU;AACtB,UAAI,MAAM,aAAa,QAAQ,WAAW,aAAa,KAAK,CAAC,cAAa;AACxE;AACF,YAAM,aAAa,iBAAiB,SAAS;AAC7C,UAAI,YAAY;AACd,aAAK,gBAAgB,IAAI;MACjC;AACM,UAAI,qBAAqB,SAAS,CAAC,YAAY;AAC7C,eAAO,KAAK;MACpB;IACA;AACI,UAAMC,QAAO,CAAC,UAAU;AACtB,UAAI,MAAM,aAAa,QAAQ,CAAC;AAC9B;AACF,YAAM,aAAa,iBAAiB,SAAS;AAC7C,UAAI,YAAY;AACd,aAAK,gBAAgB,KAAK;MAClC;AACM,UAAI,qBAAqB,SAAS,CAAC,YAAY;AAC7C,eAAO,KAAK;MACpB;IACA;AACI,UAAM,WAAW,CAAC,QAAQ;AACxB,UAAI,CAAC,UAAU,GAAG;AAChB;AACF,UAAI,MAAM,YAAY,KAAK;AACzB,YAAI,iBAAiB,OAAO;AAC1B,eAAK,gBAAgB,KAAK;QACpC;MACA,WAAiB,UAAU,UAAU,KAAK;AAClC,YAAI,KAAK;AACP,iBAAM;QAChB,OAAe;AACL,iBAAM;QAChB;MACA;IACA;AACI,UAAM,SAAS,MAAM;AACnB,UAAI,UAAU,OAAO;AACnB,QAAAA,MAAI;MACZ,OAAa;AACL,aAAI;MACZ;IACA;AACI,UAAM,MAAM,MAAM,IAAI,GAAG,QAAQ;AACjC,QAAI,8BAA8B,SAAS,WAAW,OAAO,iBAAiB,WAAW,QAAQ;AAC/F,YAAM,OAAO;QACX,GAAG,SAAS,MAAM;MAC1B,IAAU,MAAM;AACR,YAAI,2BAA2B,SAAS,UAAU,OAAO;AACvD,UAAAA,MAAI;QACd;MACA,CAAO;IACP;AACI,cAAU,MAAM;AACd,eAAS,MAAM,IAAI,CAAC;IAC1B,CAAK;AACD,WAAO;MACL,MAAAA;MACA;MACA;MACA;IACN;EACA;AACE,SAAO;IACL,gBAAgB;IAChB,qBAAqB;IACrB,qBAAqB;EACzB;AACA;AACK,IAAC,EAAE,gBAAgB,qBAAqB,oBAAmB,IAAK,4BAA4B,YAAY;;;AChIjG,IAAC,mBAAmB,CAAC,WAAW,KAAK,OAAO;AACtD,QAAM,UAAU,CAAC,MAAM;AACrB,QAAI,GAAG,CAAC;AACN,QAAE,yBAAwB;EAChC;AACE,MAAI,OAAO;AACX,QAAM,MAAM,UAAU,OAAO,CAAC,QAAQ;AACpC,QAAI,KAAK;AACP,aAAO,iBAAiB,UAAU,KAAK,SAAS,IAAI;IAC1D,OAAW;AACL,cAAQ,OAAO,SAAS,KAAI;IAClC;EACA,GAAK,EAAE,WAAW,KAAI,CAAE;AACxB;;;ACdY,IAAC,UAAU,CAAC,SAAS;AAC/B,QAAM,KAAK,mBAAkB;AAC7B,SAAOC,UAAS,MAAM;AACpB,QAAIC,KAAI;AACR,YAAQ,MAAMA,MAAK,MAAM,OAAO,SAAS,GAAG,UAAU,OAAO,SAASA,IAAG,WAAW,OAAO,SAAS,GAAG,IAAI;EAC/G,CAAG;AACH;;;ACJY,IAAC,YAAY,CAAC,qBAAqB,kBAAkB,OAAO,CAAA,MAAO;AAC7E,QAAM,eAAe;IACnB,MAAM;IACN,SAAS;IACT,OAAO;IACP,IAAI,CAAC,EAAE,MAAK,MAAO;AACjB,YAAM,eAAe,YAAY,KAAK;AACtC,aAAO,OAAO,OAAO,OAAO,YAAY;IAC9C;IACI,UAAU,CAAC,eAAe;EAC9B;AACE,QAAM,UAAUC,UAAS,MAAM;AAC7B,UAAM,EAAE,eAAe,WAAW,UAAU,UAAS,IAAK,MAAM,IAAI;AACpE,WAAO;MACL;MACA,WAAW,aAAa;MACxB,UAAU,YAAY;MACtB,WAAW;QACT,GAAG,aAAa,CAAA;QAChB;QACA,EAAE,MAAM,eAAe,SAAS,MAAK;MAC7C;IACA;EACA,CAAG;AACD,QAAM,cAAc,WAAU;AAC9B,QAAM,SAAS,IAAI;IACjB,QAAQ;MACN,QAAQ;QACN,UAAU,MAAM,OAAO,EAAE;QACzB,MAAM;QACN,KAAK;MACb;MACM,OAAO;QACL,UAAU;MAClB;IACA;IACI,YAAY,CAAA;EAChB,CAAG;AACD,QAAM,UAAU,MAAM;AACpB,QAAI,CAAC,YAAY;AACf;AACF,gBAAY,MAAM,QAAO;AACzB,gBAAY,QAAQ;EACxB;AACE,QAAM,SAAS,CAAC,eAAe;AAC7B,UAAM,WAAW,MAAM,WAAW;AAClC,QAAI,UAAU;AACZ,eAAS,WAAW,UAAU;IACpC;EACA,GAAK;IACD,MAAM;EACV,CAAG;AACD,QAAM,CAAC,qBAAqB,gBAAgB,GAAG,CAAC,CAAC,kBAAkB,aAAa,MAAM;AACpF,YAAO;AACP,QAAI,CAAC,oBAAoB,CAAC;AACxB;AACF,gBAAY,QAAQ,aAAa,kBAAkB,eAAe,MAAM,OAAO,CAAC;EACpF,CAAG;AACD,kBAAgB,MAAM;AACpB,YAAO;EACX,CAAG;AACD,SAAO;IACL,OAAOA,UAAS,MAAM;AACpB,UAAIC;AACJ,aAAO,EAAE,KAAKA,MAAK,MAAM,WAAW,MAAM,OAAO,SAASA,IAAG,UAAU,CAAA,EAAE;IAC/E,CAAK;IACD,QAAQD,UAAS,MAAM,MAAM,MAAM,EAAE,MAAM;IAC3C,YAAYA,UAAS,MAAM,MAAM,MAAM,EAAE,UAAU;IACnD,QAAQ,MAAM;AACZ,UAAIC;AACJ,cAAQA,MAAK,MAAM,WAAW,MAAM,OAAO,SAASA,IAAG,OAAM;IACnE;IACI,aAAa,MAAM;AACjB,UAAIA;AACJ,cAAQA,MAAK,MAAM,WAAW,MAAM,OAAO,SAASA,IAAG,YAAW;IACxE;IACI,aAAaD,UAAS,MAAM,MAAM,WAAW,CAAC;EAClD;AACA;AACA,SAAS,YAAY,OAAO;AAC1B,QAAM,WAAW,OAAO,KAAK,MAAM,QAAQ;AAC3C,QAAM,SAAS,kBAAU,SAAS,IAAI,CAAC,YAAY,CAAC,SAAS,MAAM,OAAO,OAAO,KAAK,CAAA,CAAE,CAAC,CAAC;AAC1F,QAAM,aAAa,kBAAU,SAAS,IAAI,CAAC,YAAY,CAAC,SAAS,MAAM,WAAW,OAAO,CAAC,CAAC,CAAC;AAC5F,SAAO;IACL;IACA;EACJ;AACA;;;ACzFY,IAAC,gBAAgB,CAAC,gBAAgB;AAC5C,MAAI,CAAC,aAAa;AAChB,WAAO,EAAE,SAAS,MAAM,aAAa,MAAM,WAAW,KAAI;EAC9D;AACE,MAAI,kBAAkB;AACtB,MAAI,gBAAgB;AACpB,QAAM,UAAU,CAAC,MAAM;AACrB,QAAI,mBAAmB,eAAe;AACpC,kBAAY,CAAC;IACnB;AACI,sBAAkB,gBAAgB;EACtC;AACE,QAAM,cAAc,CAAC,MAAM;AACzB,sBAAkB,EAAE,WAAW,EAAE;EACrC;AACE,QAAM,YAAY,CAAC,MAAM;AACvB,oBAAgB,EAAE,WAAW,EAAE;EACnC;AACE,SAAO,EAAE,SAAS,aAAa,UAAS;AAC1C;;;ACbY,IAAC,cAAc,CAAC,iBAAiB,iBAAiB;AAC5D,QAAM,oBAAoB,IAAI,KAAK;AACnC,MAAI,CAAC,UAAU;AACb,WAAO;MACL;MACA,cAAc;MACd,cAAc;MACd,gBAAgB;IACtB;EACA;AACE,MAAI,MAAM;AACV,QAAM,eAAe,MAAM;AACzB,sBAAkB,QAAQ;AAC1B,QAAI,QAAQ;AACV;AACF,UAAM,iBAAgB;EAC1B;AACE,QAAM,eAAe,MAAM;AACzB,sBAAkB,QAAQ;AAC1B,QAAI,QAAQ,MAAM;AAChB,uBAAiB,GAAG;AACpB,YAAM;IACZ;EACA;AACE,QAAM,iBAAiB,MAAM;AAC3B,WAAO,aAAa,UAAU,OAAO,gBAAe,IAAK,kBAAkB,QAAQ,CAAC,EAAE,UAAU,EAAE,IAAI,IAAG,GAAI,gBAAe,CAAE,CAAC,IAAI;EACvI;AACE,cAAY,YAAY;AACxB,SAAO;IACL;IACA;IACA;IACA;EACJ;AACA;;;ACxCY,IAAC,oBAAoB,CAAC,SAAS,WAAW,MAAM;AAC1D,MAAI,aAAa;AACf,WAAO;AACT,QAAM,YAAY,IAAI,KAAK;AAC3B,MAAI,gBAAgB;AACpB,QAAM,qBAAqB,MAAM;AAC/B,QAAI,eAAe;AACjB,mBAAa,aAAa;IAChC;AACI,oBAAgB,OAAO,WAAW,MAAM;AACtC,gBAAU,QAAQ,QAAQ;IAChC,GAAO,QAAQ;EACf;AACE,YAAU,kBAAkB;AAC5B,QAAM,MAAM,QAAQ,OAAO,CAAC,QAAQ;AAClC,QAAI,KAAK;AACP,yBAAkB;IACxB,OAAW;AACL,gBAAU,QAAQ;IACxB;EACA,CAAG;AACD,SAAO;AACT;;;ACtBO,SAAS,aAAa;AAC3B,MAAI;AACJ,QAAM,kBAAkB,CAAC,IAAI,UAAU;AACrC,kBAAa;AACb,oBAAgB,OAAO,WAAW,IAAI,KAAK;EAC/C;AACE,QAAM,gBAAgB,MAAM,OAAO,aAAa,aAAa;AAC7D,oBAAkB,MAAM,cAAa,CAAE;AACvC,SAAO;IACL;IACA;EACJ;AACA;;;ACZA,IAAM,eAAe;AACrB,IAAM,cAAc;AACpB,IAAM,cAAc;AACpB,IAAM,SAAS;AACf,IAAM,mBAAmB;AACzB,IAAM,eAAe;AACrB,IAAM,eAAe;AACrB,IAAM,QAAQ;AACd,IAAM,kBAAkB;AACxB,IAAM,QAAQ;AACd,IAAM,kBAAkB;AACZ,IAAC,gCAAgC;EAC3C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACF;AACY,IAAC,2BAA2B,MAAM;AAC5C,QAAM,EAAE,KAAI,IAAK,mBAAkB;AACnC,SAAO;IACL,eAAe,MAAM;AACnB,WAAK,YAAY;IACvB;IACI,cAAc,MAAM;AAClB,WAAK,WAAW;IACtB;IACI,cAAc,MAAM;AAClB,WAAK,WAAW;IACtB;IACI,mBAAmB,MAAM;AACvB,WAAK,gBAAgB;IAC3B;IACI,eAAe,MAAM;AACnB,WAAK,YAAY;IACvB;IACI,eAAe,MAAM;AACnB,WAAK,YAAY;IACvB;IACI,SAAS,MAAM;AACb,WAAK,KAAK;IAChB;IACI,kBAAkB,MAAM;AACtB,WAAK,eAAe;IAC1B;IACI,SAAS,MAAM;AACb,WAAK,KAAK;IAChB;IACI,kBAAkB,MAAM;AACtB,WAAK,eAAe;IAC1B;EACA;AACA;;;ACxDA,IAAM,qBAAqB;EACzB,QAAQ,KAAK,MAAM,KAAK,OAAM,IAAK,GAAG;EACtC,SAAS;AACX;AACY,IAAC,mBAAmB,OAAO,eAAe;AAC1C,IAAC,iBAAiB,MAAM;AAClC,SAAO,mBAAkB,IAAK,OAAO,kBAAkB,kBAAkB,IAAI;AAC/E;AACY,IAAC,QAAQ,CAAC,oBAAoB;AACxC,QAAM,cAAc,eAAc;AAClC,MAAI,CAAC,YAAY,gBAAgB,oBAAoB;AACnD,cAAU,eAAe;;;;GAI1B;EACH;AACE,QAAM,YAAY,uBAAsB;AACxC,QAAM,QAAQE,UAAS,MAAM,MAAM,eAAe,KAAK,GAAG,UAAU,YAAY,YAAY,UAAU,YAAY,WAAW;AAC7H,SAAO;AACT;;;ACpBA,IAAI,2BAA2B,CAAA;AAC/B,IAAM,gBAAgB,CAAC,MAAM;AAC3B,QAAM,QAAQ;AACd,MAAI,MAAM,QAAQ,WAAW,KAAK;AAChC,6BAAyB,QAAQ,CAAC,sBAAsB,kBAAkB,KAAK,CAAC;EACpF;AACA;AACY,IAAC,mBAAmB,CAAC,YAAY;AAC3C,YAAU,MAAM;AACd,QAAI,yBAAyB,WAAW,GAAG;AACzC,eAAS,iBAAiB,WAAW,aAAa;IACxD;AACI,QAAI;AACF,+BAAyB,KAAK,OAAO;EAC3C,CAAG;AACD,kBAAgB,MAAM;AACpB,+BAA2B,yBAAyB,OAAO,CAAC,sBAAsB,sBAAsB,OAAO;AAC/G,QAAI,yBAAyB,WAAW,GAAG;AACzC,UAAI;AACF,iBAAS,oBAAoB,WAAW,aAAa;IAC7D;EACA,CAAG;AACH;;;ACrBA,IAAI;AACQ,IAAC,uBAAuB,MAAM;AACxC,QAAM,YAAY,uBAAsB;AACxC,QAAM,cAAc,eAAc;AAClC,QAAM,KAAKC,UAAS,MAAM;AACxB,WAAO,GAAG,UAAU,0BAA0B,YAAY;EAC9D,CAAG;AACD,QAAM,WAAWA,UAAS,MAAM,IAAI,GAAG,OAAO;AAC9C,SAAO;IACL;IACA;EACJ;AACA;AACA,IAAM,kBAAkB,CAAC,OAAO;AAC9B,QAAM,YAAY,SAAS,cAAc,KAAK;AAC9C,YAAU,KAAK;AACf,WAAS,KAAK,YAAY,SAAS;AACnC,SAAO;AACT;AACY,IAAC,qBAAqB,MAAM;AACtC,QAAM,EAAE,IAAI,SAAQ,IAAK,qBAAoB;AAC7C,gBAAc,MAAM;AAClB,QAAI,CAAC;AACH;AACF,QAAuC,CAAC,mBAAmB,CAAC,SAAS,KAAK,cAAc,SAAS,KAAK,GAAG;AACvG,wBAAkB,gBAAgB,GAAG,KAAK;IAChD;EACA,CAAG;AACD,SAAO;IACL;IACA;EACJ;AACA;;;ACnCY,IAAC,mBAAmB,CAAC;EAC/B;EACA;EACA,wBAAwB,MAAM;EAC9B;EACA;EACA;EACA;AACF,MAAM;AACJ,QAAM,MAAM,MAAM,SAAS,GAAG,CAAC,QAAQ;AACrC,QAAI,KAAK;AACP,oBAAc,OAAO,SAAS,WAAU;AACxC,eAAS,MAAM;AACb,YAAI,CAAC,MAAM,SAAS;AAClB;AACF,YAAI,sBAAsB,MAAM,GAAG;AACjC,gCAAsB,QAAQ;QACxC;MACA,CAAO;IACP,OAAW;AACL,oBAAc,OAAO,SAAS,WAAU;AACxC,eAAS,MAAM;AACb,YAAI,MAAM,SAAS;AACjB;AACF,YAAI,sBAAsB,MAAM,GAAG;AACjC,gCAAsB,QAAQ;QACxC;MACA,CAAO;IACP;EACA,CAAG;AACD,QAAM,MAAM,sBAAsB,OAAO,CAAC,QAAQ;AAChD,QAAI,KAAK;AACP,mBAAa,OAAO,SAAS,UAAS;IAC5C,OAAW;AACL,mBAAa,OAAO,SAAS,UAAS;IAC5C;EACA,CAAG;AACH;;;ACnCY,IAAC,wBAAwB,WAAW;EAC9C,WAAW;IACT,MAAM;IACN,SAAS;EACb;EACE,WAAW;IACT,MAAM;IACN,SAAS;EACb;EACE,WAAW;IACT,MAAM;IACN,SAAS;EACb;AACA,CAAC;AACW,IAAC,mBAAmB,CAAC;EAC/B;EACA;EACA;EACA;EACA;AACF,MAAM;AACJ,QAAM,EAAE,gBAAe,IAAK,WAAU;AACtC,QAAM;IACJ,iBAAiB;IACjB,eAAe;EACnB,IAAM,WAAU;AACd,QAAM,SAAS,CAAC,UAAU;AACxB,oBAAgB,MAAM;AACpB,WAAK,KAAK;AACV,YAAM,aAAa,MAAM,SAAS;AAClC,UAAIC,UAAS,UAAU,KAAK,aAAa,GAAG;AAC1C,oCAA4B,MAAM;AAChC,gBAAM,KAAK;QACrB,GAAW,UAAU;MACrB;IACA,GAAO,MAAM,SAAS,CAAC;EACvB;AACE,QAAM,UAAU,CAAC,UAAU;AACzB,8BAAyB;AACzB,oBAAgB,MAAM;AACpB,YAAM,KAAK;IACjB,GAAO,MAAM,SAAS,CAAC;EACvB;AACE,SAAO;IACL;IACA;EACJ;AACA;;;ACjDY,IAAC,4BAA4B,OAAO,cAAc;AAClD,IAAC,gBAAgB,CAAC,eAAe;AAC3C,QAAM,gBAAgB,CAAC,OAAO;AAC5B,eAAW,QAAQ;EACvB;AACE,UAAQ,2BAA2B;IACjC;EACJ,CAAG;AACH;AACY,IAAC,yBAAyB,CAAC,kBAAkB;AACvD,SAAO;IACL,QAAQ,IAAI;AACV,oBAAc,EAAE;IACtB;IACI,QAAQ,IAAI;AACV,oBAAc,EAAE;IACtB;IACI,YAAY;AACV,oBAAc,IAAI;IACxB;EACA;AACA;;;ACpBA,IAAM,SAAS,IAAI,CAAC;AACR,IAAC,uBAAuB;AACxB,IAAC,mBAAmB,OAAO,kBAAkB;AAC7C,IAAC,YAAY,CAAC,oBAAoB;AAC5C,QAAM,kBAAkB,oBAAoB,mBAAkB,IAAK,OAAO,kBAAkB,MAAM,IAAI;AACtG,QAAM,gBAAgBC,UAAS,MAAM;AACnC,UAAM,sBAAsB,MAAM,eAAe;AACjD,WAAOC,UAAS,mBAAmB,IAAI,sBAAsB;EACjE,CAAG;AACD,QAAM,gBAAgBD,UAAS,MAAM,cAAc,QAAQ,OAAO,KAAK;AACvE,QAAM,aAAa,MAAM;AACvB,WAAO;AACP,WAAO,cAAc;EACzB;AACE,SAAO;IACL;IACA;IACA;EACJ;AACA;;;ACrBA,IAAM,QAAQ,CAAC,OAAO,SAAS,UAAU,MAAM;AAC/C,IAAM,aAAa,CAAC,SAAS,KAAK;AAClC,IAAM,aAA0B,MAAM,OAAO,CAAC,KAAK,SAAS,IAAI,OAAO,MAAM,OAAO,MAAM,WAAW,CAAC,GAAG,OAAO,MAAM,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC;AACxI,IAAM,MAAM,KAAK;AACjB,IAAM,MAAM,KAAK;AACjB,IAAM,QAAQ,KAAK;AAEnB,IAAM,eAAe,QAAM;AAAA,EACzB,GAAG;AAAA,EACH,GAAG;AACL;AAWA,SAASE,OAAM,OAAO,OAAO,KAAK;AAChC,SAAO,IAAI,OAAO,IAAI,OAAO,GAAG,CAAC;AACnC;AACA,SAAS,SAAS,OAAO,OAAO;AAC9B,SAAO,OAAO,UAAU,aAAa,MAAM,KAAK,IAAI;AACtD;AACA,SAAS,QAAQ,WAAW;AAC1B,SAAO,UAAU,MAAM,GAAG,EAAE,CAAC;AAC/B;AACA,SAAS,aAAa,WAAW;AAC/B,SAAO,UAAU,MAAM,GAAG,EAAE,CAAC;AAC/B;AACA,SAAS,gBAAgB,MAAM;AAC7B,SAAO,SAAS,MAAM,MAAM;AAC9B;AACA,SAAS,cAAc,MAAM;AAC3B,SAAO,SAAS,MAAM,WAAW;AACnC;AACA,SAAS,YAAY,WAAW;AAC9B,SAAO,CAAC,OAAO,QAAQ,EAAE,SAAS,QAAQ,SAAS,CAAC,IAAI,MAAM;AAChE;AACA,SAAS,iBAAiB,WAAW;AACnC,SAAO,gBAAgB,YAAY,SAAS,CAAC;AAC/C;AAoDA,SAAS,oBAAoB,SAAS;AACpC,SAAO;AAAA,IACL,KAAK;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,GAAG;AAAA,EACL;AACF;AACA,SAAS,iBAAiB,SAAS;AACjC,SAAO,OAAO,YAAY,WAAW,oBAAoB,OAAO,IAAI;AAAA,IAClE,KAAK;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,EACR;AACF;AACA,SAAS,iBAAiB,MAAM;AAC9B,SAAO;AAAA,IACL,GAAG;AAAA,IACH,KAAK,KAAK;AAAA,IACV,MAAM,KAAK;AAAA,IACX,OAAO,KAAK,IAAI,KAAK;AAAA,IACrB,QAAQ,KAAK,IAAI,KAAK;AAAA,EACxB;AACF;;;ACtHA,SAAS,2BAA2B,MAAM,WAAW,KAAK;AACxD,MAAI;AAAA,IACF;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,WAAW,YAAY,SAAS;AACtC,QAAM,gBAAgB,iBAAiB,SAAS;AAChD,QAAM,cAAc,cAAc,aAAa;AAC/C,QAAM,OAAO,QAAQ,SAAS;AAC9B,QAAM,aAAa,aAAa;AAChC,QAAM,UAAU,UAAU,IAAI,UAAU,QAAQ,IAAI,SAAS,QAAQ;AACrE,QAAM,UAAU,UAAU,IAAI,UAAU,SAAS,IAAI,SAAS,SAAS;AACvE,QAAM,cAAc,UAAU,WAAW,IAAI,IAAI,SAAS,WAAW,IAAI;AACzE,MAAI;AACJ,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,eAAS;AAAA,QACP,GAAG;AAAA,QACH,GAAG,UAAU,IAAI,SAAS;AAAA,MAC5B;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,GAAG;AAAA,QACH,GAAG,UAAU,IAAI,UAAU;AAAA,MAC7B;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,GAAG,UAAU,IAAI,UAAU;AAAA,QAC3B,GAAG;AAAA,MACL;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,GAAG,UAAU,IAAI,SAAS;AAAA,QAC1B,GAAG;AAAA,MACL;AACA;AAAA,IACF;AACE,eAAS;AAAA,QACP,GAAG,UAAU;AAAA,QACb,GAAG,UAAU;AAAA,MACf;AAAA,EACJ;AACA,UAAQ,aAAa,SAAS,GAAG;AAAA,IAC/B,KAAK;AACH,aAAO,aAAa,KAAK,eAAe,OAAO,aAAa,KAAK;AACjE;AAAA,IACF,KAAK;AACH,aAAO,aAAa,KAAK,eAAe,OAAO,aAAa,KAAK;AACjE;AAAA,EACJ;AACA,SAAO;AACT;AASA,IAAM,kBAAkB,OAAO,WAAW,UAAU,WAAW;AAC7D,QAAM;AAAA,IACJ,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,aAAa,CAAC;AAAA,IACd,UAAAC;AAAA,EACF,IAAI;AACJ,QAAM,kBAAkB,WAAW,OAAO,OAAO;AACjD,QAAM,MAAM,OAAOA,UAAS,SAAS,OAAO,SAASA,UAAS,MAAM,QAAQ;AAC5E,MAAI,QAAQ,MAAMA,UAAS,gBAAgB;AAAA,IACzC;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,MAAI;AAAA,IACF;AAAA,IACA;AAAA,EACF,IAAI,2BAA2B,OAAO,WAAW,GAAG;AACpD,MAAI,oBAAoB;AACxB,MAAI,iBAAiB,CAAC;AACtB,MAAI,aAAa;AACjB,WAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAC/C,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI,gBAAgB,CAAC;AACrB,UAAM;AAAA,MACJ,GAAG;AAAA,MACH,GAAG;AAAA,MACH;AAAA,MACA;AAAA,IACF,IAAI,MAAM,GAAG;AAAA,MACX;AAAA,MACA;AAAA,MACA,kBAAkB;AAAA,MAClB,WAAW;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAAA;AAAA,MACA,UAAU;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AACD,QAAI,SAAS,OAAO,QAAQ;AAC5B,QAAI,SAAS,OAAO,QAAQ;AAC5B,qBAAiB;AAAA,MACf,GAAG;AAAA,MACH,CAAC,IAAI,GAAG;AAAA,QACN,GAAG,eAAe,IAAI;AAAA,QACtB,GAAG;AAAA,MACL;AAAA,IACF;AACA,QAAI,SAAS,cAAc,IAAI;AAC7B;AACA,UAAI,OAAO,UAAU,UAAU;AAC7B,YAAI,MAAM,WAAW;AACnB,8BAAoB,MAAM;AAAA,QAC5B;AACA,YAAI,MAAM,OAAO;AACf,kBAAQ,MAAM,UAAU,OAAO,MAAMA,UAAS,gBAAgB;AAAA,YAC5D;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC,IAAI,MAAM;AAAA,QACb;AACA,SAAC;AAAA,UACC;AAAA,UACA;AAAA,QACF,IAAI,2BAA2B,OAAO,mBAAmB,GAAG;AAAA,MAC9D;AACA,UAAI;AACJ;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,WAAW;AAAA,IACX;AAAA,IACA;AAAA,EACF;AACF;AAsEA,IAAM,QAAQ,cAAY;AAAA,EACxB,MAAM;AAAA,EACN;AAAA,EACA,MAAM,GAAG,OAAO;AACd,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAAC;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AAEJ,UAAM;AAAA,MACJ;AAAA,MACA,UAAU;AAAA,IACZ,IAAI,SAAS,SAAS,KAAK,KAAK,CAAC;AACjC,QAAI,WAAW,MAAM;AACnB,aAAO,CAAC;AAAA,IACV;AACA,UAAM,gBAAgB,iBAAiB,OAAO;AAC9C,UAAM,SAAS;AAAA,MACb;AAAA,MACA;AAAA,IACF;AACA,UAAM,OAAO,iBAAiB,SAAS;AACvC,UAAM,SAAS,cAAc,IAAI;AACjC,UAAM,kBAAkB,MAAMA,UAAS,cAAc,OAAO;AAC5D,UAAM,UAAU,SAAS;AACzB,UAAM,UAAU,UAAU,QAAQ;AAClC,UAAM,UAAU,UAAU,WAAW;AACrC,UAAM,aAAa,UAAU,iBAAiB;AAC9C,UAAM,UAAU,MAAM,UAAU,MAAM,IAAI,MAAM,UAAU,IAAI,IAAI,OAAO,IAAI,IAAI,MAAM,SAAS,MAAM;AACtG,UAAM,YAAY,OAAO,IAAI,IAAI,MAAM,UAAU,IAAI;AACrD,UAAM,oBAAoB,OAAOA,UAAS,mBAAmB,OAAO,SAASA,UAAS,gBAAgB,OAAO;AAC7G,QAAI,aAAa,oBAAoB,kBAAkB,UAAU,IAAI;AAGrE,QAAI,CAAC,cAAc,CAAE,OAAOA,UAAS,aAAa,OAAO,SAASA,UAAS,UAAU,iBAAiB,IAAK;AACzG,mBAAa,SAAS,SAAS,UAAU,KAAK,MAAM,SAAS,MAAM;AAAA,IACrE;AACA,UAAM,oBAAoB,UAAU,IAAI,YAAY;AAIpD,UAAM,yBAAyB,aAAa,IAAI,gBAAgB,MAAM,IAAI,IAAI;AAC9E,UAAM,aAAa,IAAI,cAAc,OAAO,GAAG,sBAAsB;AACrE,UAAM,aAAa,IAAI,cAAc,OAAO,GAAG,sBAAsB;AAIrE,UAAM,QAAQ;AACd,UAAMC,OAAM,aAAa,gBAAgB,MAAM,IAAI;AACnD,UAAM,SAAS,aAAa,IAAI,gBAAgB,MAAM,IAAI,IAAI;AAC9D,UAAMC,UAASC,OAAM,OAAO,QAAQF,IAAG;AAMvC,UAAM,kBAAkB,CAAC,eAAe,SAAS,aAAa,SAAS,KAAK,QAAQ,UAAUC,WAAU,MAAM,UAAU,MAAM,IAAI,KAAK,SAAS,QAAQ,aAAa,cAAc,gBAAgB,MAAM,IAAI,IAAI;AACjN,UAAM,kBAAkB,kBAAkB,SAAS,QAAQ,SAAS,QAAQ,SAASD,OAAM;AAC3F,WAAO;AAAA,MACL,CAAC,IAAI,GAAG,OAAO,IAAI,IAAI;AAAA,MACvB,MAAM;AAAA,QACJ,CAAC,IAAI,GAAGC;AAAA,QACR,cAAc,SAASA,UAAS;AAAA,QAChC,GAAI,mBAAmB;AAAA,UACrB;AAAA,QACF;AAAA,MACF;AAAA,MACA,OAAO;AAAA,IACT;AAAA,EACF;AACF;AAsaA,eAAe,qBAAqB,OAAO,SAAS;AAClD,QAAM;AAAA,IACJ;AAAA,IACA,UAAAE;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,MAAM,OAAOA,UAAS,SAAS,OAAO,SAASA,UAAS,MAAM,SAAS,QAAQ;AACrF,QAAM,OAAO,QAAQ,SAAS;AAC9B,QAAM,YAAY,aAAa,SAAS;AACxC,QAAM,aAAa,YAAY,SAAS,MAAM;AAC9C,QAAM,gBAAgB,CAAC,QAAQ,KAAK,EAAE,SAAS,IAAI,IAAI,KAAK;AAC5D,QAAM,iBAAiB,OAAO,aAAa,KAAK;AAChD,QAAM,WAAW,SAAS,SAAS,KAAK;AAGxC,MAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,OAAO,aAAa,WAAW;AAAA,IACjC,UAAU;AAAA,IACV,WAAW;AAAA,IACX,eAAe;AAAA,EACjB,IAAI;AAAA,IACF,UAAU;AAAA,IACV,WAAW;AAAA,IACX,eAAe;AAAA,IACf,GAAG;AAAA,EACL;AACA,MAAI,aAAa,OAAO,kBAAkB,UAAU;AAClD,gBAAY,cAAc,QAAQ,gBAAgB,KAAK;AAAA,EACzD;AACA,SAAO,aAAa;AAAA,IAClB,GAAG,YAAY;AAAA,IACf,GAAG,WAAW;AAAA,EAChB,IAAI;AAAA,IACF,GAAG,WAAW;AAAA,IACd,GAAG,YAAY;AAAA,EACjB;AACF;AASA,IAAM,SAAS,SAAU,SAAS;AAChC,MAAI,YAAY,QAAQ;AACtB,cAAU;AAAA,EACZ;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA,MAAM,GAAG,OAAO;AACd,UAAI,uBAAuB;AAC3B,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI;AACJ,YAAM,aAAa,MAAM,qBAAqB,OAAO,OAAO;AAI5D,UAAI,gBAAgB,wBAAwB,eAAe,WAAW,OAAO,SAAS,sBAAsB,eAAe,wBAAwB,eAAe,UAAU,QAAQ,sBAAsB,iBAAiB;AACzN,eAAO,CAAC;AAAA,MACV;AACA,aAAO;AAAA,QACL,GAAG,IAAI,WAAW;AAAA,QAClB,GAAG,IAAI,WAAW;AAAA,QAClB,MAAM;AAAA,UACJ,GAAG;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AC5xBA,SAAS,YAAY,MAAM;AACzB,MAAI,OAAO,IAAI,GAAG;AAChB,YAAQ,KAAK,YAAY,IAAI,YAAY;AAAA,EAC3C;AAIA,SAAO;AACT;AACA,SAAS,UAAU,MAAM;AACvB,MAAI;AACJ,UAAQ,QAAQ,OAAO,UAAU,sBAAsB,KAAK,kBAAkB,OAAO,SAAS,oBAAoB,gBAAgB;AACpI;AACA,SAAS,mBAAmB,MAAM;AAChC,MAAI;AACJ,UAAQ,QAAQ,OAAO,IAAI,IAAI,KAAK,gBAAgB,KAAK,aAAa,OAAO,aAAa,OAAO,SAAS,KAAK;AACjH;AACA,SAAS,OAAO,OAAO;AACrB,SAAO,iBAAiB,QAAQ,iBAAiB,UAAU,KAAK,EAAE;AACpE;AACA,SAASC,WAAU,OAAO;AACxB,SAAO,iBAAiB,WAAW,iBAAiB,UAAU,KAAK,EAAE;AACvE;AACA,SAAS,cAAc,OAAO;AAC5B,SAAO,iBAAiB,eAAe,iBAAiB,UAAU,KAAK,EAAE;AAC3E;AACA,SAAS,aAAa,OAAO;AAE3B,MAAI,OAAO,eAAe,aAAa;AACrC,WAAO;AAAA,EACT;AACA,SAAO,iBAAiB,cAAc,iBAAiB,UAAU,KAAK,EAAE;AAC1E;AACA,SAAS,kBAAkB,SAAS;AAClC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAIC,kBAAiB,OAAO;AAC5B,SAAO,kCAAkC,KAAK,WAAW,YAAY,SAAS,KAAK,CAAC,CAAC,UAAU,UAAU,EAAE,SAAS,OAAO;AAC7H;AACA,SAAS,eAAe,SAAS;AAC/B,SAAO,CAAC,SAAS,MAAM,IAAI,EAAE,SAAS,YAAY,OAAO,CAAC;AAC5D;AACA,SAAS,kBAAkB,SAAS;AAClC,QAAM,SAAS,SAAS;AACxB,QAAM,MAAMA,kBAAiB,OAAO;AAGpC,SAAO,IAAI,cAAc,UAAU,IAAI,gBAAgB,WAAW,IAAI,gBAAgB,IAAI,kBAAkB,WAAW,UAAU,CAAC,WAAW,IAAI,iBAAiB,IAAI,mBAAmB,SAAS,UAAU,CAAC,WAAW,IAAI,SAAS,IAAI,WAAW,SAAS,UAAU,CAAC,aAAa,eAAe,QAAQ,EAAE,KAAK,YAAU,IAAI,cAAc,IAAI,SAAS,KAAK,CAAC,KAAK,CAAC,SAAS,UAAU,UAAU,SAAS,EAAE,KAAK,YAAU,IAAI,WAAW,IAAI,SAAS,KAAK,CAAC;AACnc;AACA,SAAS,mBAAmB,SAAS;AACnC,MAAI,cAAc,cAAc,OAAO;AACvC,SAAO,cAAc,WAAW,KAAK,CAAC,sBAAsB,WAAW,GAAG;AACxE,QAAI,kBAAkB,WAAW,GAAG;AAClC,aAAO;AAAA,IACT,OAAO;AACL,oBAAc,cAAc,WAAW;AAAA,IACzC;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,WAAW;AAClB,MAAI,OAAO,QAAQ,eAAe,CAAC,IAAI;AAAU,WAAO;AACxD,SAAO,IAAI,SAAS,2BAA2B,MAAM;AACvD;AACA,SAAS,sBAAsB,MAAM;AACnC,SAAO,CAAC,QAAQ,QAAQ,WAAW,EAAE,SAAS,YAAY,IAAI,CAAC;AACjE;AACA,SAASA,kBAAiB,SAAS;AACjC,SAAO,UAAU,OAAO,EAAE,iBAAiB,OAAO;AACpD;AACA,SAAS,cAAc,SAAS;AAC9B,MAAID,WAAU,OAAO,GAAG;AACtB,WAAO;AAAA,MACL,YAAY,QAAQ;AAAA,MACpB,WAAW,QAAQ;AAAA,IACrB;AAAA,EACF;AACA,SAAO;AAAA,IACL,YAAY,QAAQ;AAAA,IACpB,WAAW,QAAQ;AAAA,EACrB;AACF;AACA,SAAS,cAAc,MAAM;AAC3B,MAAI,YAAY,IAAI,MAAM,QAAQ;AAChC,WAAO;AAAA,EACT;AACA,QAAM;AAAA;AAAA,IAEN,KAAK;AAAA,IAEL,KAAK;AAAA,IAEL,aAAa,IAAI,KAAK,KAAK;AAAA,IAE3B,mBAAmB,IAAI;AAAA;AACvB,SAAO,aAAa,MAAM,IAAI,OAAO,OAAO;AAC9C;AACA,SAAS,2BAA2B,MAAM;AACxC,QAAM,aAAa,cAAc,IAAI;AACrC,MAAI,sBAAsB,UAAU,GAAG;AACrC,WAAO,KAAK,gBAAgB,KAAK,cAAc,OAAO,KAAK;AAAA,EAC7D;AACA,MAAI,cAAc,UAAU,KAAK,kBAAkB,UAAU,GAAG;AAC9D,WAAO;AAAA,EACT;AACA,SAAO,2BAA2B,UAAU;AAC9C;AACA,SAAS,qBAAqB,MAAM,MAAM,iBAAiB;AACzD,MAAI;AACJ,MAAI,SAAS,QAAQ;AACnB,WAAO,CAAC;AAAA,EACV;AACA,MAAI,oBAAoB,QAAQ;AAC9B,sBAAkB;AAAA,EACpB;AACA,QAAM,qBAAqB,2BAA2B,IAAI;AAC1D,QAAM,SAAS,yBAAyB,uBAAuB,KAAK,kBAAkB,OAAO,SAAS,qBAAqB;AAC3H,QAAM,MAAM,UAAU,kBAAkB;AACxC,MAAI,QAAQ;AACV,WAAO,KAAK,OAAO,KAAK,IAAI,kBAAkB,CAAC,GAAG,kBAAkB,kBAAkB,IAAI,qBAAqB,CAAC,GAAG,IAAI,gBAAgB,kBAAkB,qBAAqB,IAAI,YAAY,IAAI,CAAC,CAAC;AAAA,EACtM;AACA,SAAO,KAAK,OAAO,oBAAoB,qBAAqB,oBAAoB,CAAC,GAAG,eAAe,CAAC;AACtG;;;ACvHA,SAAS,iBAAiB,SAAS;AACjC,QAAM,MAAME,kBAAiB,OAAO;AAGpC,MAAI,QAAQ,WAAW,IAAI,KAAK,KAAK;AACrC,MAAI,SAAS,WAAW,IAAI,MAAM,KAAK;AACvC,QAAM,YAAY,cAAc,OAAO;AACvC,QAAM,cAAc,YAAY,QAAQ,cAAc;AACtD,QAAM,eAAe,YAAY,QAAQ,eAAe;AACxD,QAAM,iBAAiB,MAAM,KAAK,MAAM,eAAe,MAAM,MAAM,MAAM;AACzE,MAAI,gBAAgB;AAClB,YAAQ;AACR,aAAS;AAAA,EACX;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EACL;AACF;AAEA,SAAS,cAAc,SAAS;AAC9B,SAAO,CAACC,WAAU,OAAO,IAAI,QAAQ,iBAAiB;AACxD;AAEA,SAAS,SAAS,SAAS;AACzB,QAAM,aAAa,cAAc,OAAO;AACxC,MAAI,CAAC,cAAc,UAAU,GAAG;AAC9B,WAAO,aAAa,CAAC;AAAA,EACvB;AACA,QAAM,OAAO,WAAW,sBAAsB;AAC9C,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,iBAAiB,UAAU;AAC/B,MAAI,KAAK,IAAI,MAAM,KAAK,KAAK,IAAI,KAAK,SAAS;AAC/C,MAAI,KAAK,IAAI,MAAM,KAAK,MAAM,IAAI,KAAK,UAAU;AAIjD,MAAI,CAAC,KAAK,CAAC,OAAO,SAAS,CAAC,GAAG;AAC7B,QAAI;AAAA,EACN;AACA,MAAI,CAAC,KAAK,CAAC,OAAO,SAAS,CAAC,GAAG;AAC7B,QAAI;AAAA,EACN;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,YAAyB,aAAa,CAAC;AAC7C,SAAS,iBAAiB,SAAS;AACjC,QAAM,MAAM,UAAU,OAAO;AAC7B,MAAI,CAAC,SAAS,KAAK,CAAC,IAAI,gBAAgB;AACtC,WAAO;AAAA,EACT;AACA,SAAO;AAAA,IACL,GAAG,IAAI,eAAe;AAAA,IACtB,GAAG,IAAI,eAAe;AAAA,EACxB;AACF;AACA,SAAS,uBAAuB,SAAS,SAAS,sBAAsB;AACtE,MAAI,YAAY,QAAQ;AACtB,cAAU;AAAA,EACZ;AACA,MAAI,CAAC,wBAAwB,WAAW,yBAAyB,UAAU,OAAO,GAAG;AACnF,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEA,SAAS,sBAAsB,SAAS,cAAc,iBAAiB,cAAc;AACnF,MAAI,iBAAiB,QAAQ;AAC3B,mBAAe;AAAA,EACjB;AACA,MAAI,oBAAoB,QAAQ;AAC9B,sBAAkB;AAAA,EACpB;AACA,QAAM,aAAa,QAAQ,sBAAsB;AACjD,QAAM,aAAa,cAAc,OAAO;AACxC,MAAI,QAAQ,aAAa,CAAC;AAC1B,MAAI,cAAc;AAChB,QAAI,cAAc;AAChB,UAAIA,WAAU,YAAY,GAAG;AAC3B,gBAAQ,SAAS,YAAY;AAAA,MAC/B;AAAA,IACF,OAAO;AACL,cAAQ,SAAS,OAAO;AAAA,IAC1B;AAAA,EACF;AACA,QAAM,gBAAgB,uBAAuB,YAAY,iBAAiB,YAAY,IAAI,iBAAiB,UAAU,IAAI,aAAa,CAAC;AACvI,MAAI,KAAK,WAAW,OAAO,cAAc,KAAK,MAAM;AACpD,MAAI,KAAK,WAAW,MAAM,cAAc,KAAK,MAAM;AACnD,MAAI,QAAQ,WAAW,QAAQ,MAAM;AACrC,MAAI,SAAS,WAAW,SAAS,MAAM;AACvC,MAAI,YAAY;AACd,UAAM,MAAM,UAAU,UAAU;AAChC,UAAM,YAAY,gBAAgBA,WAAU,YAAY,IAAI,UAAU,YAAY,IAAI;AACtF,QAAI,gBAAgB,IAAI;AACxB,WAAO,iBAAiB,gBAAgB,cAAc,KAAK;AACzD,YAAM,cAAc,SAAS,aAAa;AAC1C,YAAM,aAAa,cAAc,sBAAsB;AACvD,YAAM,MAAMD,kBAAiB,aAAa;AAC1C,YAAM,OAAO,WAAW,QAAQ,cAAc,aAAa,WAAW,IAAI,WAAW,KAAK,YAAY;AACtG,YAAM,MAAM,WAAW,OAAO,cAAc,YAAY,WAAW,IAAI,UAAU,KAAK,YAAY;AAClG,WAAK,YAAY;AACjB,WAAK,YAAY;AACjB,eAAS,YAAY;AACrB,gBAAU,YAAY;AACtB,WAAK;AACL,WAAK;AACL,sBAAgB,UAAU,aAAa,EAAE;AAAA,IAC3C;AAAA,EACF;AACA,SAAO,iBAAiB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACH;AAEA,SAAS,sDAAsD,MAAM;AACnE,MAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,0BAA0B,cAAc,YAAY;AAC1D,QAAM,kBAAkB,mBAAmB,YAAY;AACvD,MAAI,iBAAiB,iBAAiB;AACpC,WAAO;AAAA,EACT;AACA,MAAI,SAAS;AAAA,IACX,YAAY;AAAA,IACZ,WAAW;AAAA,EACb;AACA,MAAI,QAAQ,aAAa,CAAC;AAC1B,QAAM,UAAU,aAAa,CAAC;AAC9B,MAAI,2BAA2B,CAAC,2BAA2B,aAAa,SAAS;AAC/E,QAAI,YAAY,YAAY,MAAM,UAAU,kBAAkB,eAAe,GAAG;AAC9E,eAAS,cAAc,YAAY;AAAA,IACrC;AACA,QAAI,cAAc,YAAY,GAAG;AAC/B,YAAM,aAAa,sBAAsB,YAAY;AACrD,cAAQ,SAAS,YAAY;AAC7B,cAAQ,IAAI,WAAW,IAAI,aAAa;AACxC,cAAQ,IAAI,WAAW,IAAI,aAAa;AAAA,IAC1C;AAAA,EACF;AACA,SAAO;AAAA,IACL,OAAO,KAAK,QAAQ,MAAM;AAAA,IAC1B,QAAQ,KAAK,SAAS,MAAM;AAAA,IAC5B,GAAG,KAAK,IAAI,MAAM,IAAI,OAAO,aAAa,MAAM,IAAI,QAAQ;AAAA,IAC5D,GAAG,KAAK,IAAI,MAAM,IAAI,OAAO,YAAY,MAAM,IAAI,QAAQ;AAAA,EAC7D;AACF;AAEA,SAAS,eAAe,SAAS;AAC/B,SAAO,MAAM,KAAK,QAAQ,eAAe,CAAC;AAC5C;AAEA,SAAS,oBAAoB,SAAS;AAGpC,SAAO,sBAAsB,mBAAmB,OAAO,CAAC,EAAE,OAAO,cAAc,OAAO,EAAE;AAC1F;AAIA,SAAS,gBAAgB,SAAS;AAChC,QAAM,OAAO,mBAAmB,OAAO;AACvC,QAAM,SAAS,cAAc,OAAO;AACpC,QAAM,OAAO,QAAQ,cAAc;AACnC,QAAM,QAAQ,IAAI,KAAK,aAAa,KAAK,aAAa,KAAK,aAAa,KAAK,WAAW;AACxF,QAAM,SAAS,IAAI,KAAK,cAAc,KAAK,cAAc,KAAK,cAAc,KAAK,YAAY;AAC7F,MAAI,IAAI,CAAC,OAAO,aAAa,oBAAoB,OAAO;AACxD,QAAM,IAAI,CAAC,OAAO;AAClB,MAAIA,kBAAiB,IAAI,EAAE,cAAc,OAAO;AAC9C,SAAK,IAAI,KAAK,aAAa,KAAK,WAAW,IAAI;AAAA,EACjD;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,SAAS,gBAAgB,SAAS,UAAU;AAC1C,QAAM,MAAM,UAAU,OAAO;AAC7B,QAAM,OAAO,mBAAmB,OAAO;AACvC,QAAM,iBAAiB,IAAI;AAC3B,MAAI,QAAQ,KAAK;AACjB,MAAI,SAAS,KAAK;AAClB,MAAI,IAAI;AACR,MAAI,IAAI;AACR,MAAI,gBAAgB;AAClB,YAAQ,eAAe;AACvB,aAAS,eAAe;AACxB,UAAM,sBAAsB,SAAS;AACrC,QAAI,CAAC,uBAAuB,uBAAuB,aAAa,SAAS;AACvE,UAAI,eAAe;AACnB,UAAI,eAAe;AAAA,IACrB;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAGA,SAAS,2BAA2B,SAAS,UAAU;AACrD,QAAM,aAAa,sBAAsB,SAAS,MAAM,aAAa,OAAO;AAC5E,QAAM,MAAM,WAAW,MAAM,QAAQ;AACrC,QAAM,OAAO,WAAW,OAAO,QAAQ;AACvC,QAAM,QAAQ,cAAc,OAAO,IAAI,SAAS,OAAO,IAAI,aAAa,CAAC;AACzE,QAAM,QAAQ,QAAQ,cAAc,MAAM;AAC1C,QAAM,SAAS,QAAQ,eAAe,MAAM;AAC5C,QAAM,IAAI,OAAO,MAAM;AACvB,QAAM,IAAI,MAAM,MAAM;AACtB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AACA,SAAS,kCAAkC,SAAS,kBAAkB,UAAU;AAC9E,MAAI;AACJ,MAAI,qBAAqB,YAAY;AACnC,WAAO,gBAAgB,SAAS,QAAQ;AAAA,EAC1C,WAAW,qBAAqB,YAAY;AAC1C,WAAO,gBAAgB,mBAAmB,OAAO,CAAC;AAAA,EACpD,WAAWC,WAAU,gBAAgB,GAAG;AACtC,WAAO,2BAA2B,kBAAkB,QAAQ;AAAA,EAC9D,OAAO;AACL,UAAM,gBAAgB,iBAAiB,OAAO;AAC9C,WAAO;AAAA,MACL,GAAG;AAAA,MACH,GAAG,iBAAiB,IAAI,cAAc;AAAA,MACtC,GAAG,iBAAiB,IAAI,cAAc;AAAA,IACxC;AAAA,EACF;AACA,SAAO,iBAAiB,IAAI;AAC9B;AACA,SAAS,yBAAyB,SAAS,UAAU;AACnD,QAAM,aAAa,cAAc,OAAO;AACxC,MAAI,eAAe,YAAY,CAACA,WAAU,UAAU,KAAK,sBAAsB,UAAU,GAAG;AAC1F,WAAO;AAAA,EACT;AACA,SAAOD,kBAAiB,UAAU,EAAE,aAAa,WAAW,yBAAyB,YAAY,QAAQ;AAC3G;AAKA,SAAS,4BAA4B,SAAS,OAAO;AACnD,QAAM,eAAe,MAAM,IAAI,OAAO;AACtC,MAAI,cAAc;AAChB,WAAO;AAAA,EACT;AACA,MAAI,SAAS,qBAAqB,SAAS,CAAC,GAAG,KAAK,EAAE,OAAO,QAAMC,WAAU,EAAE,KAAK,YAAY,EAAE,MAAM,MAAM;AAC9G,MAAI,sCAAsC;AAC1C,QAAM,iBAAiBD,kBAAiB,OAAO,EAAE,aAAa;AAC9D,MAAI,cAAc,iBAAiB,cAAc,OAAO,IAAI;AAG5D,SAAOC,WAAU,WAAW,KAAK,CAAC,sBAAsB,WAAW,GAAG;AACpE,UAAM,gBAAgBD,kBAAiB,WAAW;AAClD,UAAM,0BAA0B,kBAAkB,WAAW;AAC7D,QAAI,CAAC,2BAA2B,cAAc,aAAa,SAAS;AAClE,4CAAsC;AAAA,IACxC;AACA,UAAM,wBAAwB,iBAAiB,CAAC,2BAA2B,CAAC,sCAAsC,CAAC,2BAA2B,cAAc,aAAa,YAAY,CAAC,CAAC,uCAAuC,CAAC,YAAY,OAAO,EAAE,SAAS,oCAAoC,QAAQ,KAAK,kBAAkB,WAAW,KAAK,CAAC,2BAA2B,yBAAyB,SAAS,WAAW;AACzZ,QAAI,uBAAuB;AAEzB,eAAS,OAAO,OAAO,cAAY,aAAa,WAAW;AAAA,IAC7D,OAAO;AAEL,4CAAsC;AAAA,IACxC;AACA,kBAAc,cAAc,WAAW;AAAA,EACzC;AACA,QAAM,IAAI,SAAS,MAAM;AACzB,SAAO;AACT;AAIA,SAAS,gBAAgB,MAAM;AAC7B,MAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,2BAA2B,aAAa,sBAAsB,4BAA4B,SAAS,KAAK,EAAE,IAAI,CAAC,EAAE,OAAO,QAAQ;AACtI,QAAM,oBAAoB,CAAC,GAAG,0BAA0B,YAAY;AACpE,QAAM,wBAAwB,kBAAkB,CAAC;AACjD,QAAM,eAAe,kBAAkB,OAAO,CAAC,SAAS,qBAAqB;AAC3E,UAAM,OAAO,kCAAkC,SAAS,kBAAkB,QAAQ;AAClF,YAAQ,MAAM,IAAI,KAAK,KAAK,QAAQ,GAAG;AACvC,YAAQ,QAAQ,IAAI,KAAK,OAAO,QAAQ,KAAK;AAC7C,YAAQ,SAAS,IAAI,KAAK,QAAQ,QAAQ,MAAM;AAChD,YAAQ,OAAO,IAAI,KAAK,MAAM,QAAQ,IAAI;AAC1C,WAAO;AAAA,EACT,GAAG,kCAAkC,SAAS,uBAAuB,QAAQ,CAAC;AAC9E,SAAO;AAAA,IACL,OAAO,aAAa,QAAQ,aAAa;AAAA,IACzC,QAAQ,aAAa,SAAS,aAAa;AAAA,IAC3C,GAAG,aAAa;AAAA,IAChB,GAAG,aAAa;AAAA,EAClB;AACF;AAEA,SAAS,cAAc,SAAS;AAC9B,SAAO,iBAAiB,OAAO;AACjC;AAEA,SAAS,8BAA8B,SAAS,cAAc,UAAU;AACtE,QAAM,0BAA0B,cAAc,YAAY;AAC1D,QAAM,kBAAkB,mBAAmB,YAAY;AACvD,QAAM,UAAU,aAAa;AAC7B,QAAM,OAAO,sBAAsB,SAAS,MAAM,SAAS,YAAY;AACvE,MAAI,SAAS;AAAA,IACX,YAAY;AAAA,IACZ,WAAW;AAAA,EACb;AACA,QAAM,UAAU,aAAa,CAAC;AAC9B,MAAI,2BAA2B,CAAC,2BAA2B,CAAC,SAAS;AACnE,QAAI,YAAY,YAAY,MAAM,UAAU,kBAAkB,eAAe,GAAG;AAC9E,eAAS,cAAc,YAAY;AAAA,IACrC;AACA,QAAI,yBAAyB;AAC3B,YAAM,aAAa,sBAAsB,cAAc,MAAM,SAAS,YAAY;AAClF,cAAQ,IAAI,WAAW,IAAI,aAAa;AACxC,cAAQ,IAAI,WAAW,IAAI,aAAa;AAAA,IAC1C,WAAW,iBAAiB;AAC1B,cAAQ,IAAI,oBAAoB,eAAe;AAAA,IACjD;AAAA,EACF;AACA,SAAO;AAAA,IACL,GAAG,KAAK,OAAO,OAAO,aAAa,QAAQ;AAAA,IAC3C,GAAG,KAAK,MAAM,OAAO,YAAY,QAAQ;AAAA,IACzC,OAAO,KAAK;AAAA,IACZ,QAAQ,KAAK;AAAA,EACf;AACF;AAEA,SAAS,oBAAoB,SAAS,UAAU;AAC9C,MAAI,CAAC,cAAc,OAAO,KAAKA,kBAAiB,OAAO,EAAE,aAAa,SAAS;AAC7E,WAAO;AAAA,EACT;AACA,MAAI,UAAU;AACZ,WAAO,SAAS,OAAO;AAAA,EACzB;AACA,SAAO,QAAQ;AACjB;AAIA,SAAS,gBAAgB,SAAS,UAAU;AAC1C,QAAME,UAAS,UAAU,OAAO;AAChC,MAAI,CAAC,cAAc,OAAO,GAAG;AAC3B,WAAOA;AAAA,EACT;AACA,MAAI,eAAe,oBAAoB,SAAS,QAAQ;AACxD,SAAO,gBAAgB,eAAe,YAAY,KAAKF,kBAAiB,YAAY,EAAE,aAAa,UAAU;AAC3G,mBAAe,oBAAoB,cAAc,QAAQ;AAAA,EAC3D;AACA,MAAI,iBAAiB,YAAY,YAAY,MAAM,UAAU,YAAY,YAAY,MAAM,UAAUA,kBAAiB,YAAY,EAAE,aAAa,YAAY,CAAC,kBAAkB,YAAY,IAAI;AAC9L,WAAOE;AAAA,EACT;AACA,SAAO,gBAAgB,mBAAmB,OAAO,KAAKA;AACxD;AAEA,IAAM,kBAAkB,eAAgB,MAAM;AAC5C,MAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,oBAAoB,KAAK,mBAAmB;AAClD,QAAM,kBAAkB,KAAK;AAC7B,SAAO;AAAA,IACL,WAAW,8BAA8B,WAAW,MAAM,kBAAkB,QAAQ,GAAG,QAAQ;AAAA,IAC/F,UAAU;AAAA,MACR,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAI,MAAM,gBAAgB,QAAQ;AAAA,IACpC;AAAA,EACF;AACF;AAEA,SAAS,MAAM,SAAS;AACtB,SAAOF,kBAAiB,OAAO,EAAE,cAAc;AACjD;AAEA,IAAM,WAAW;AAAA,EACf;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAAC;AAAA,EACA;AACF;AA8JA,IAAME,mBAAkB,CAAC,WAAW,UAAU,YAAY;AAIxD,QAAM,QAAQ,oBAAI,IAAI;AACtB,QAAM,gBAAgB;AAAA,IACpB;AAAA,IACA,GAAG;AAAA,EACL;AACA,QAAM,oBAAoB;AAAA,IACxB,GAAG,cAAc;AAAA,IACjB,IAAI;AAAA,EACN;AACA,SAAO,gBAAkB,WAAW,UAAU;AAAA,IAC5C,GAAG;AAAA,IACH,UAAU;AAAA,EACZ,CAAC;AACH;;;AChlBY,IAAC,mBAAmB,WAAW,CAAA,CAAE;AAC7C,IAAM,iBAAiB,CAAC,UAAU;AAChC,MAAI,CAAC;AACH;AACF,MAAI,CAAC;AACH,WAAO;AACT,QAAM,UAAU,aAAa,KAAK;AAClC,MAAI;AACF,WAAO;AACT,SAAO,MAAM,KAAK,IAAI,UAAU;AAClC;AACY,IAAC,0BAA0B,CAAC,QAAQ,QAAQ;AACtD,QAAM,QAAQ,UAAU,OAAO,SAAS,OAAO,GAAG;AAClD,SAAO,cAAM,KAAK,IAAI,KAAK,GAAG;AAChC;AACY,IAAC,cAAc,CAAC;EAC1B;EACA;EACA;AACF,MAAM;AACJ,QAAM,eAAe,IAAG;AACxB,QAAM,aAAa,IAAG;AACtB,QAAM,IAAI,IAAG;AACb,QAAM,IAAI,IAAG;AACb,QAAM,iBAAiB,IAAI,CAAA,CAAE;AAC7B,QAAM,SAAS;IACb;IACA;IACA;IACA;IACA;EACJ;AACE,QAAM,SAAS,YAAY;AACzB,QAAI,CAAC;AACH;AACF,UAAM,cAAc,eAAe,YAAY;AAC/C,UAAM,YAAY,aAAa,UAAU;AACzC,QAAI,CAAC,eAAe,CAAC;AACnB;AACF,UAAM,OAAO,MAAMC,iBAAgB,aAAa,WAAW;MACzD,WAAW,MAAM,SAAS;MAC1B,UAAU,MAAM,QAAQ;MACxB,YAAY,MAAM,UAAU;IAClC,CAAK;AACD,WAAO,MAAM,EAAE,QAAQ,CAAC,QAAQ;AAC9B,aAAO,GAAG,EAAE,QAAQ,KAAK,GAAG;IAClC,CAAK;EACL;AACE,YAAU,MAAM;AACd,gBAAY,MAAM;AAChB,aAAM;IACZ,CAAK;EACL,CAAG;AACD,SAAO;IACL,GAAG;IACH;IACA;IACA;EACJ;AACA;AACY,IAAC,kBAAkB,CAAC;EAC9B;EACA;AACF,MAAM;AACJ,SAAO;IACL,MAAM;IACN,SAAS;MACP,SAAS;MACT;IACN;IACI,GAAG,MAAM;AACP,YAAM,UAAU,MAAM,QAAQ;AAC9B,UAAI,CAAC;AACH,eAAO,CAAA;AACT,aAAOC,MAAU;QACf,SAAS;QACT;MACR,CAAO,EAAE,GAAG,IAAI;IAChB;EACA;AACA;;;ACpFO,SAAS,UAAU,OAAO;AAC/B,QAAM,eAAe,IAAG;AACxB,WAAS,eAAe;AACtB,QAAI,MAAM,SAAS;AACjB;AACF,UAAM,EAAE,gBAAgB,cAAc,MAAK,IAAK,MAAM;AACtD,QAAI,kBAAkB,QAAQ,gBAAgB;AAC5C;AACF,UAAM,YAAY,MAAM,MAAM,GAAG,KAAK,IAAI,GAAG,cAAc,CAAC;AAC5D,UAAM,WAAW,MAAM,MAAM,KAAK,IAAI,GAAG,YAAY,CAAC;AACtD,iBAAa,QAAQ;MACnB;MACA;MACA;MACA;MACA;IACN;EACA;AACE,WAAS,YAAY;AACnB,QAAI,MAAM,SAAS,UAAU,aAAa,SAAS;AACjD;AACF,UAAM,EAAE,MAAK,IAAK,MAAM;AACxB,UAAM,EAAE,WAAW,UAAU,eAAc,IAAK,aAAa;AAC7D,QAAI,aAAa,UAAU,YAAY,UAAU,kBAAkB;AACjE;AACF,QAAI,WAAW,MAAM;AACrB,QAAI,MAAM,SAAS,QAAQ,GAAG;AAC5B,iBAAW,MAAM,SAAS,SAAS;IACzC,WAAe,MAAM,WAAW,SAAS,GAAG;AACtC,iBAAW,UAAU;IAC3B,OAAW;AACL,YAAM,iBAAiB,UAAU,iBAAiB,CAAC;AACnD,YAAM,WAAW,MAAM,QAAQ,gBAAgB,iBAAiB,CAAC;AACjE,UAAI,aAAa,IAAI;AACnB,mBAAW,WAAW;MAC9B;IACA;AACI,UAAM,MAAM,kBAAkB,UAAU,QAAQ;EACpD;AACE,SAAO,CAAC,cAAc,SAAS;AACjC;;;ACvCA,IAAM,qBAAqB,CAAC,IAAI,oBAAoB,aAAa;AAC/D,QAAM,QAAQ,gBAAgB,GAAG,OAAO,EAAE,OAAO,CAAC,MAAM;AACtD,QAAIC;AACJ,WAAO,QAAQ,CAAC,OAAOA,MAAK,EAAE,SAAS,OAAO,SAASA,IAAG,UAAU,sBAAsB,CAAC,CAAC,EAAE;EAClG,CAAG;AACD,QAAM,OAAO,MAAM,IAAI,CAAC,MAAM,EAAE,UAAU,GAAG;AAC7C,SAAO,KAAK,IAAI,CAAC,QAAQ,SAAS,GAAG,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAC3D;AACY,IAAC,qBAAqB,CAAC,IAAI,uBAAuB;AAC5D,QAAM,WAAW,CAAA;AACjB,QAAM,kBAAkB,WAAW,CAAA,CAAE;AACrC,QAAM,WAAW,CAAC,UAAU;AAC1B,aAAS,MAAM,GAAG,IAAI;AACtB,oBAAgB,QAAQ,mBAAmB,IAAI,oBAAoB,QAAQ;EAC/E;AACE,QAAM,cAAc,CAAC,QAAQ;AAC3B,WAAO,SAAS,GAAG;AACnB,oBAAgB,QAAQ,gBAAgB,MAAM,OAAO,CAAC,cAAc,UAAU,QAAQ,GAAG;EAC7F;AACE,SAAO;IACL,UAAU;IACV;IACA;EACJ;AACA;;;ACvBY,IAAC,cAAc,UAAU;EACnC,MAAM;EACN,QAAQ;EACR,UAAU;AACZ,CAAC;AACW,IAAC,eAAe;EAC1B,MAAM;AACR;AACY,IAAC,qBAAqB,OAAO,MAAM;AACnC,IAAC,gBAAgB,MAAM;AACjC,QAAM,eAAe,OAAO,oBAAoB,CAAA,CAAE;AAClD,SAAOC,UAAS,MAAM;AACpB,WAAO,MAAM,aAAa,IAAI,KAAK;EACvC,CAAG;AACH;;;ACdO,SAAS,mBAAmBC,SAAQ,EAAE,YAAY,YAAY,UAAS,IAAK,CAAA,GAAI;AACrF,QAAM,WAAW,mBAAkB;AACnC,QAAM,EAAE,KAAI,IAAK;AACjB,QAAM,aAAa,WAAU;AAC7B,QAAM,YAAY,IAAI,KAAK;AAC3B,QAAM,cAAc,CAAC,UAAU;AAC7B,QAAI,UAAU;AACZ;AACF,cAAU,QAAQ;AAClB,SAAK,SAAS,KAAK;AACnB,kBAAc,OAAO,SAAS,WAAU;EAC5C;AACE,QAAM,aAAa,CAAC,UAAU;AAC5B,QAAIC;AACJ,UAAM,aAAa,WAAW,UAAU,IAAI,WAAW,KAAK,IAAI;AAChE,QAAI,cAAc,MAAM,mBAAmBA,MAAK,WAAW,UAAU,OAAO,SAASA,IAAG,SAAS,MAAM,aAAa;AAClH;AACF,cAAU,QAAQ;AAClB,SAAK,QAAQ,KAAK;AAClB,iBAAa,OAAO,SAAS,UAAS;EAC1C;AACE,QAAM,cAAc,MAAM;AACxB,QAAIA;AACJ,KAACA,MAAKD,QAAO,UAAU,OAAO,SAASC,IAAG,MAAK;EACnD;AACE,QAAM,YAAY,CAAC,OAAO;AACxB,QAAI,IAAI;AACN,SAAG,aAAa,YAAY,IAAI;IACtC;EACA,CAAG;AACD,mBAAiB,YAAY,SAAS,WAAW;AACjD,SAAO;IACL;IACA;IACA;IACA;EACJ;AACA;;;ACvCA,IAAA,cAAe,CAAC,KAAK,UAAU;AAC7B,QAAMC,UAAS,IAAI,aAAa;AAChC,aAAW,CAAC,KAAK,GAAG,KAAK,OAAO;AAC9B,IAAAA,QAAO,GAAG,IAAI;EAClB;AACE,SAAOA;AACT;",
  "names": ["computed", "shallowRef", "watchEffect", "unref", "ref", "watch", "onScopeDispose", "provide", "inject", "isRef", "computed", "getCurrentInstance", "onBeforeMount", "nextTick", "onBeforeUnmount", "onMounted", "onUnmounted", "_a", "isFunction", "isString", "unref", "onScopeDispose", "ref", "watch", "getCurrentInstance", "onMounted", "nextTick", "ref", "isRef", "ref", "shallowRef", "watchEffect", "computed", "inject", "unref", "watch", "getCurrentInstance", "customRef", "reactive", "nextTick", "onMounted", "readonly", "getCurrentScope", "isVue2", "_a", "target", "isString", "watch", "window", "target2", "ref", "target", "window", "ref", "computed", "_a", "watch", "document", "ref", "target", "_a", "window", "watch", "ref", "target", "_a", "window", "watch", "_a", "getCurrentInstance", "isVue2", "isFunction", "ref", "watch", "computed", "window", "ref", "window", "ref", "offset", "isNumber", "capitalize", "toCapitalize", "_a", "computed", "isNumber", "_a", "ref", "size", "SCOPE", "SCOPE", "_a", "computed", "_a", "version", "ref", "_a", "_a", "computed", "computed", "scrollBarWidth", "computed", "hide", "computed", "_a", "computed", "_a", "computed", "computed", "isNumber", "computed", "isNumber", "clamp", "platform", "platform", "max", "offset", "clamp", "platform", "isElement", "getComputedStyle", "getComputedStyle", "isElement", "window", "computePosition", "computePosition", "arrowCore", "_a", "computed", "target", "_a", "target"]
}
