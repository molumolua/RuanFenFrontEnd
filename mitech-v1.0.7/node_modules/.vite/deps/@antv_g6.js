import {
  __assign,
  __awaiter,
  __extends,
  __generator,
  __rest,
  __spreadArray,
  addEventListener,
  base_default3 as base_default,
  canvas_default,
  canvas_default2,
  catmull_rom_2_bezier_default,
  clone_default,
  createDom,
  debounce_default,
  deep_mix_default,
  each_default,
  esm_default,
  esm_exports,
  esm_exports2,
  ext_exports,
  get_default,
  graph_event_default,
  group_by_default,
  head,
  init_esm,
  init_esm2,
  init_src,
  init_tslib_es6,
  is_array_default,
  is_boolean_default,
  is_equal_default,
  is_function_default,
  is_nil_default,
  is_number_default,
  is_object_default,
  is_plain_object_default,
  is_string_default,
  linear_default,
  map_default,
  mat3_exports,
  mix,
  modifyCSS,
  parsePathString,
  size,
  throttle_default,
  timer,
  uniq,
  unique_id_default,
  upper_first_default,
  vec2_exports,
  vec3_exports,
  wrap_behavior_default
} from "./chunk-CXWOMV77.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-CLC6CPQL.js";

// node_modules/@antv/matrix-util/lib/ext.js
var require_ext = __commonJS({
  "node_modules/@antv/matrix-util/lib/ext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var gl_matrix_1 = (init_esm2(), __toCommonJS(esm_exports2));
    function leftTranslate2(out, a3, v2) {
      var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      gl_matrix_1.mat3.fromTranslation(transMat, v2);
      return gl_matrix_1.mat3.multiply(out, transMat, a3);
    }
    exports.leftTranslate = leftTranslate2;
    function leftRotate2(out, a3, rad) {
      var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      gl_matrix_1.mat3.fromRotation(rotateMat, rad);
      return gl_matrix_1.mat3.multiply(out, rotateMat, a3);
    }
    exports.leftRotate = leftRotate2;
    function leftScale2(out, a3, v2) {
      var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      gl_matrix_1.mat3.fromScaling(scaleMat, v2);
      return gl_matrix_1.mat3.multiply(out, scaleMat, a3);
    }
    exports.leftScale = leftScale2;
    function leftMultiply2(out, a3, a1) {
      return gl_matrix_1.mat3.multiply(out, a1, a3);
    }
    function transform13(m3, actions) {
      var matrix = m3 ? [].concat(m3) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
      for (var i2 = 0, len = actions.length; i2 < len; i2++) {
        var action = actions[i2];
        switch (action[0]) {
          case "t":
            leftTranslate2(matrix, matrix, [action[1], action[2]]);
            break;
          case "s":
            leftScale2(matrix, matrix, [action[1], action[2]]);
            break;
          case "r":
            leftRotate2(matrix, matrix, action[1]);
            break;
          case "m":
            leftMultiply2(matrix, matrix, action[1]);
            break;
          default:
            break;
        }
      }
      return matrix;
    }
    exports.transform = transform13;
    function direction2(v1, v2) {
      return v1[0] * v2[1] - v2[0] * v1[1];
    }
    exports.direction = direction2;
    function angleTo2(v1, v2, direct) {
      var ang = gl_matrix_1.vec2.angle(v1, v2);
      var angleLargeThanPI = direction2(v1, v2) >= 0;
      if (direct) {
        if (angleLargeThanPI) {
          return Math.PI * 2 - ang;
        }
        return ang;
      }
      if (angleLargeThanPI) {
        return ang;
      }
      return Math.PI * 2 - ang;
    }
    exports.angleTo = angleTo2;
    function vertical2(out, v2, flag) {
      if (flag) {
        out[0] = v2[1];
        out[1] = -1 * v2[0];
      } else {
        out[0] = -1 * v2[1];
        out[1] = v2[0];
      }
      return out;
    }
    exports.vertical = vertical2;
  }
});

// node_modules/@antv/algorithm/lib/workers/constant.js
var require_constant = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/constant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MESSAGE = exports.ALGORITHM = void 0;
    var ALGORITHM = {
      pageRank: "pageRank",
      breadthFirstSearch: "breadthFirstSearch",
      connectedComponent: "connectedComponent",
      depthFirstSearch: "depthFirstSearch",
      detectCycle: "detectCycle",
      detectDirectedCycle: "detectDirectedCycle",
      detectAllCycles: "detectAllCycles",
      detectAllDirectedCycle: "detectAllDirectedCycle",
      detectAllUndirectedCycle: "detectAllUndirectedCycle",
      dijkstra: "dijkstra",
      findAllPath: "findAllPath",
      findShortestPath: "findShortestPath",
      floydWarshall: "floydWarshall",
      getAdjMatrix: "getAdjMatrix",
      getDegree: "getDegree",
      getInDegree: "getInDegree",
      getNeighbors: "getNeighbors",
      getOutDegree: "getOutDegree",
      labelPropagation: "labelPropagation",
      louvain: "louvain",
      GADDI: "GADDI",
      minimumSpanningTree: "minimumSpanningTree",
      SUCCESS: "SUCCESS",
      FAILURE: "FAILURE"
    };
    exports.ALGORITHM = ALGORITHM;
    var MESSAGE = {
      SUCCESS: "SUCCESS",
      FAILURE: "FAILURE"
    };
    exports.MESSAGE = MESSAGE;
  }
});

// node_modules/@antv/algorithm/lib/adjacent-matrix.js
var require_adjacent_matrix = __commonJS({
  "node_modules/@antv/algorithm/lib/adjacent-matrix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var adjMatrix3 = function adjMatrix4(graphData, directed) {
      var nodes = graphData.nodes, edges = graphData.edges;
      var matrix = [];
      var nodeMap = {};
      if (!nodes) {
        throw new Error("invalid nodes data!");
      }
      if (nodes) {
        nodes.forEach(function(node, i2) {
          nodeMap[node.id] = i2;
          var row = [];
          matrix.push(row);
        });
      }
      if (edges) {
        edges.forEach(function(edge) {
          var source = edge.source, target = edge.target;
          var sIndex = nodeMap[source];
          var tIndex = nodeMap[target];
          if (!sIndex && sIndex !== 0 || !tIndex && tIndex !== 0)
            return;
          matrix[sIndex][tIndex] = 1;
          if (!directed) {
            matrix[tIndex][sIndex] = 1;
          }
        });
      }
      return matrix;
    };
    var _default = adjMatrix3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/linked-list.js
var require_linked_list = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/linked-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.LinkedListNode = void 0;
    var defaultComparator3 = function defaultComparator4(a3, b2) {
      if (a3 === b2) {
        return true;
      }
      return false;
    };
    var LinkedListNode2 = (
      /** @class */
      function() {
        function LinkedListNode3(value, next) {
          if (next === void 0) {
            next = null;
          }
          this.value = value;
          this.next = next;
        }
        LinkedListNode3.prototype.toString = function(callback) {
          return callback ? callback(this.value) : "".concat(this.value);
        };
        return LinkedListNode3;
      }()
    );
    exports.LinkedListNode = LinkedListNode2;
    var LinkedList2 = (
      /** @class */
      function() {
        function LinkedList3(comparator) {
          if (comparator === void 0) {
            comparator = defaultComparator3;
          }
          this.head = null;
          this.tail = null;
          this.compare = comparator;
        }
        LinkedList3.prototype.prepend = function(value) {
          var newNode = new LinkedListNode2(value, this.head);
          this.head = newNode;
          if (!this.tail) {
            this.tail = newNode;
          }
          return this;
        };
        LinkedList3.prototype.append = function(value) {
          var newNode = new LinkedListNode2(value);
          if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
            return this;
          }
          this.tail.next = newNode;
          this.tail = newNode;
          return this;
        };
        LinkedList3.prototype.delete = function(value) {
          if (!this.head) {
            return null;
          }
          var deleteNode = null;
          while (this.head && this.compare(this.head.value, value)) {
            deleteNode = this.head;
            this.head = this.head.next;
          }
          var currentNode = this.head;
          if (currentNode !== null) {
            while (currentNode.next) {
              if (this.compare(currentNode.next.value, value)) {
                deleteNode = currentNode.next;
                currentNode.next = currentNode.next.next;
              } else {
                currentNode = currentNode.next;
              }
            }
          }
          if (this.compare(this.tail.value, value)) {
            this.tail = currentNode;
          }
          return deleteNode;
        };
        LinkedList3.prototype.find = function(_a2) {
          var _b = _a2.value, value = _b === void 0 ? void 0 : _b, _c = _a2.callback, callback = _c === void 0 ? void 0 : _c;
          if (!this.head) {
            return null;
          }
          var currentNode = this.head;
          while (currentNode) {
            if (callback && callback(currentNode.value)) {
              return currentNode;
            }
            if (value !== void 0 && this.compare(currentNode.value, value)) {
              return currentNode;
            }
            currentNode = currentNode.next;
          }
          return null;
        };
        LinkedList3.prototype.deleteTail = function() {
          var deletedTail = this.tail;
          if (this.head === this.tail) {
            this.head = null;
            this.tail = null;
            return deletedTail;
          }
          var currentNode = this.head;
          while (currentNode.next) {
            if (!currentNode.next.next) {
              currentNode.next = null;
            } else {
              currentNode = currentNode.next;
            }
          }
          this.tail = currentNode;
          return deletedTail;
        };
        LinkedList3.prototype.deleteHead = function() {
          if (!this.head) {
            return null;
          }
          var deletedHead = this.head;
          if (this.head.next) {
            this.head = this.head.next;
          } else {
            this.head = null;
            this.tail = null;
          }
          return deletedHead;
        };
        LinkedList3.prototype.fromArray = function(values2) {
          var _this = this;
          values2.forEach(function(value) {
            return _this.append(value);
          });
          return this;
        };
        LinkedList3.prototype.toArray = function() {
          var nodes = [];
          var currentNode = this.head;
          while (currentNode) {
            nodes.push(currentNode);
            currentNode = currentNode.next;
          }
          return nodes;
        };
        LinkedList3.prototype.reverse = function() {
          var currentNode = this.head;
          var prevNode = null;
          var nextNode = null;
          while (currentNode) {
            nextNode = currentNode.next;
            currentNode.next = prevNode;
            prevNode = currentNode;
            currentNode = nextNode;
          }
          this.tail = this.head;
          this.head = prevNode;
        };
        LinkedList3.prototype.toString = function(callback) {
          if (callback === void 0) {
            callback = void 0;
          }
          return this.toArray().map(function(node) {
            return node.toString(callback);
          }).toString();
        };
        return LinkedList3;
      }()
    );
    var _default = LinkedList2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/queue.js
var require_queue = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _linkedList = _interopRequireDefault(require_linked_list());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Queue2 = (
      /** @class */
      function() {
        function Queue3() {
          this.linkedList = new _linkedList.default();
        }
        Queue3.prototype.isEmpty = function() {
          return !this.linkedList.head;
        };
        Queue3.prototype.peek = function() {
          if (!this.linkedList.head) {
            return null;
          }
          return this.linkedList.head.value;
        };
        Queue3.prototype.enqueue = function(value) {
          this.linkedList.append(value);
        };
        Queue3.prototype.dequeue = function() {
          var removeHead = this.linkedList.deleteHead();
          return removeHead ? removeHead.value : null;
        };
        Queue3.prototype.toString = function(callback) {
          return this.linkedList.toString(callback);
        };
        return Queue3;
      }()
    );
    var _default = Queue2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/util.js
var require_util = __commonJS({
  "node_modules/@antv/algorithm/lib/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.uniqueId = exports.getOutEdgesNodeId = exports.getNeighbors = exports.getEdgesByNodeId = void 0;
    var getNeighbors3 = function getNeighbors4(nodeId, edges, type) {
      if (edges === void 0) {
        edges = [];
      }
      var currentEdges = edges.filter(function(edge) {
        return edge.source === nodeId || edge.target === nodeId;
      });
      if (type === "target") {
        var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
          return edge.source === nodeId;
        };
        return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
          return edge.target;
        });
      }
      if (type === "source") {
        var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
          return edge.target === nodeId;
        };
        return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
          return edge.source;
        });
      }
      var neighhborsConverter = function neighhborsConverter2(edge) {
        return edge.source === nodeId ? edge.target : edge.source;
      };
      return currentEdges.map(neighhborsConverter);
    };
    exports.getNeighbors = getNeighbors3;
    var getOutEdgesNodeId3 = function getOutEdgesNodeId4(nodeId, edges) {
      return edges.filter(function(edge) {
        return edge.source === nodeId;
      });
    };
    exports.getOutEdgesNodeId = getOutEdgesNodeId3;
    var getEdgesByNodeId3 = function getEdgesByNodeId4(nodeId, edges) {
      return edges.filter(function(edge) {
        return edge.source === nodeId || edge.target === nodeId;
      });
    };
    exports.getEdgesByNodeId = getEdgesByNodeId3;
    var uniqueId5 = function uniqueId6(index2) {
      if (index2 === void 0) {
        index2 = 0;
      }
      var random1 = "".concat(Math.random()).split(".")[1].substr(0, 5);
      var random2 = "".concat(Math.random()).split(".")[1].substr(0, 5);
      return "".concat(index2, "-").concat(random1).concat(random2);
    };
    exports.uniqueId = uniqueId5;
  }
});

// node_modules/@antv/algorithm/lib/bfs.js
var require_bfs = __commonJS({
  "node_modules/@antv/algorithm/lib/bfs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _queue = _interopRequireDefault(require_queue());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function initCallbacks3(callbacks) {
      if (callbacks === void 0) {
        callbacks = {};
      }
      var initiatedCallback = callbacks;
      var stubCallback = function stubCallback2() {
      };
      var allowTraversalCallback = function() {
        var seen = {};
        return function(_a2) {
          var next = _a2.next;
          var id = next;
          if (!seen[id]) {
            seen[id] = true;
            return true;
          }
          return false;
        };
      }();
      initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
      initiatedCallback.enter = callbacks.enter || stubCallback;
      initiatedCallback.leave = callbacks.leave || stubCallback;
      return initiatedCallback;
    }
    var breadthFirstSearch3 = function breadthFirstSearch4(graphData, startNodeId, originalCallbacks, directed) {
      if (directed === void 0) {
        directed = true;
      }
      var callbacks = initCallbacks3(originalCallbacks);
      var nodeQueue = new _queue.default();
      var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
      nodeQueue.enqueue(startNodeId);
      var previousNode = "";
      var _loop_1 = function _loop_12() {
        var currentNode = nodeQueue.dequeue();
        callbacks.enter({
          current: currentNode,
          previous: previousNode
        });
        (0, _util.getNeighbors)(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
          if (callbacks.allowTraversal({
            previous: previousNode,
            current: currentNode,
            next: nextNode
          })) {
            nodeQueue.enqueue(nextNode);
          }
        });
        callbacks.leave({
          current: currentNode,
          previous: previousNode
        });
        previousNode = currentNode;
      };
      while (!nodeQueue.isEmpty()) {
        _loop_1();
      }
    };
    var _default = breadthFirstSearch3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/connected-component.js
var require_connected_component = __commonJS({
  "node_modules/@antv/algorithm/lib/connected-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getConnectedComponents2;
    exports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;
    var _util = require_util();
    var detectConnectedComponents3 = function detectConnectedComponents4(graphData) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var allComponents = [];
      var visited = {};
      var nodeStack = [];
      var getComponent = function getComponent2(node2) {
        nodeStack.push(node2);
        visited[node2.id] = true;
        var neighbors = (0, _util.getNeighbors)(node2.id, edges);
        var _loop_1 = function _loop_12(i4) {
          var neighbor = neighbors[i4];
          if (!visited[neighbor]) {
            var targetNode = nodes.filter(function(node3) {
              return node3.id === neighbor;
            });
            if (targetNode.length > 0) {
              getComponent2(targetNode[0]);
            }
          }
        };
        for (var i3 = 0; i3 < neighbors.length; ++i3) {
          _loop_1(i3);
        }
      };
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (!visited[node.id]) {
          getComponent(node);
          var component = [];
          while (nodeStack.length > 0) {
            component.push(nodeStack.pop());
          }
          allComponents.push(component);
        }
      }
      return allComponents;
    };
    exports.detectConnectedComponents = detectConnectedComponents3;
    var detectStrongConnectComponents3 = function detectStrongConnectComponents4(graphData) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodeStack = [];
      var inStack = {};
      var indices = {};
      var lowLink = {};
      var allComponents = [];
      var index2 = 0;
      var getComponent = function getComponent2(node2) {
        indices[node2.id] = index2;
        lowLink[node2.id] = index2;
        index2 += 1;
        nodeStack.push(node2);
        inStack[node2.id] = true;
        var neighbors = (0, _util.getNeighbors)(node2.id, edges, "target").filter(function(n2) {
          return nodes.map(function(node3) {
            return node3.id;
          }).indexOf(n2) > -1;
        });
        var _loop_2 = function _loop_22(i3) {
          var targetNodeID = neighbors[i3];
          if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {
            var targetNode = nodes.filter(function(node3) {
              return node3.id === targetNodeID;
            });
            if (targetNode.length > 0) {
              getComponent2(targetNode[0]);
            }
            lowLink[node2.id] = Math.min(lowLink[node2.id], lowLink[targetNodeID]);
          } else if (inStack[targetNodeID]) {
            lowLink[node2.id] = Math.min(lowLink[node2.id], indices[targetNodeID]);
          }
        };
        for (var i2 = 0; i2 < neighbors.length; i2++) {
          _loop_2(i2);
        }
        if (lowLink[node2.id] === indices[node2.id]) {
          var component = [];
          while (nodeStack.length > 0) {
            var tmpNode = nodeStack.pop();
            inStack[tmpNode.id] = false;
            component.push(tmpNode);
            if (tmpNode === node2)
              break;
          }
          if (component.length > 0) {
            allComponents.push(component);
          }
        }
      };
      for (var _i2 = 0, nodes_1 = nodes; _i2 < nodes_1.length; _i2++) {
        var node = nodes_1[_i2];
        if (!indices[node.id] && indices[node.id] !== 0) {
          getComponent(node);
        }
      }
      return allComponents;
    };
    exports.detectStrongConnectComponents = detectStrongConnectComponents3;
    function getConnectedComponents2(graphData, directed) {
      if (directed)
        return detectStrongConnectComponents3(graphData);
      return detectConnectedComponents3(graphData);
    }
  }
});

// node_modules/@antv/algorithm/lib/degree.js
var require_degree = __commonJS({
  "node_modules/@antv/algorithm/lib/degree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOutDegree = exports.getInDegree = exports.default = void 0;
    var degree3 = function degree4(graphData) {
      var degrees = {};
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      nodes.forEach(function(node) {
        degrees[node.id] = {
          degree: 0,
          inDegree: 0,
          outDegree: 0
        };
      });
      edges.forEach(function(edge) {
        degrees[edge.source].degree++;
        degrees[edge.source].outDegree++;
        degrees[edge.target].degree++;
        degrees[edge.target].inDegree++;
      });
      return degrees;
    };
    var _default = degree3;
    exports.default = _default;
    var getInDegree3 = function getInDegree4(graphData, nodeId) {
      var nodeDegree = degree3(graphData);
      if (nodeDegree[nodeId]) {
        return degree3(graphData)[nodeId].inDegree;
      }
      return 0;
    };
    exports.getInDegree = getInDegree3;
    var getOutDegree3 = function getOutDegree4(graphData, nodeId) {
      var nodeDegree = degree3(graphData);
      if (nodeDegree[nodeId]) {
        return degree3(graphData)[nodeId].outDegree;
      }
      return 0;
    };
    exports.getOutDegree = getOutDegree3;
  }
});

// node_modules/@antv/algorithm/lib/dfs.js
var require_dfs = __commonJS({
  "node_modules/@antv/algorithm/lib/dfs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = depthFirstSearch2;
    var _util = require_util();
    function initCallbacks3(callbacks) {
      if (callbacks === void 0) {
        callbacks = {};
      }
      var initiatedCallback = callbacks;
      var stubCallback = function stubCallback2() {
      };
      var allowTraversalCallback = function() {
        var seen = {};
        return function(_a2) {
          var next = _a2.next;
          if (!seen[next]) {
            seen[next] = true;
            return true;
          }
          return false;
        };
      }();
      initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
      initiatedCallback.enter = callbacks.enter || stubCallback;
      initiatedCallback.leave = callbacks.leave || stubCallback;
      return initiatedCallback;
    }
    function depthFirstSearchRecursive2(graphData, currentNode, previousNode, callbacks, directed) {
      if (directed === void 0) {
        directed = true;
      }
      callbacks.enter({
        current: currentNode,
        previous: previousNode
      });
      var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
      (0, _util.getNeighbors)(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
        if (callbacks.allowTraversal({
          previous: previousNode,
          current: currentNode,
          next: nextNode
        })) {
          depthFirstSearchRecursive2(graphData, nextNode, currentNode, callbacks, directed);
        }
      });
      callbacks.leave({
        current: currentNode,
        previous: previousNode
      });
    }
    function depthFirstSearch2(graphData, startNodeId, callbacks, directed) {
      if (directed === void 0) {
        directed = true;
      }
      depthFirstSearchRecursive2(graphData, startNodeId, "", initCallbacks3(callbacks), directed);
    }
  }
});

// node_modules/@antv/algorithm/lib/detect-cycle.js
var require_detect_cycle = __commonJS({
  "node_modules/@antv/algorithm/lib/detect-cycle.js"(exports) {
    "use strict";
    function _typeof8(obj) {
      "@babel/helpers - typeof";
      return _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof8(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.detectAllUndirectedCycle = exports.detectAllDirectedCycle = exports.detectAllCycles = exports.default = void 0;
    var _dfs = _interopRequireDefault(require_dfs());
    var _connectedComponent = _interopRequireWildcard(require_connected_component());
    var _util = require_util();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof8(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var detectDirectedCycle4 = function detectDirectedCycle5(graphData) {
      var cycle = null;
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
      var dfsParentMap = {};
      var unvisitedSet = {};
      var visitingSet = {};
      var visitedSet = {};
      nodes.forEach(function(node) {
        unvisitedSet[node.id] = node;
      });
      var callbacks = {
        enter: function enter(_a3) {
          var currentNode = _a3.current, previousNode = _a3.previous;
          if (visitingSet[currentNode]) {
            cycle = {};
            var currentCycleNode = currentNode;
            var previousCycleNode = previousNode;
            while (previousCycleNode !== currentNode) {
              cycle[currentCycleNode] = previousCycleNode;
              currentCycleNode = previousCycleNode;
              previousCycleNode = dfsParentMap[previousCycleNode];
            }
            cycle[currentCycleNode] = previousCycleNode;
          } else {
            visitingSet[currentNode] = currentNode;
            delete unvisitedSet[currentNode];
            dfsParentMap[currentNode] = previousNode;
          }
        },
        leave: function leave(_a3) {
          var currentNode = _a3.current;
          visitedSet[currentNode] = currentNode;
          delete visitingSet[currentNode];
        },
        allowTraversal: function allowTraversal(_a3) {
          var nextNode = _a3.next;
          if (cycle) {
            return false;
          }
          return !visitedSet[nextNode];
        }
      };
      while (Object.keys(unvisitedSet).length) {
        var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];
        (0, _dfs.default)(graphData, firsetUnVisitedKey, callbacks);
      }
      return cycle;
    };
    var detectAllUndirectedCycle3 = function detectAllUndirectedCycle4(graphData, nodeIds, include) {
      var _a2, _b;
      if (include === void 0) {
        include = true;
      }
      var allCycles = [];
      var components3 = (0, _connectedComponent.default)(graphData, false);
      for (var _i2 = 0, components_1 = components3; _i2 < components_1.length; _i2++) {
        var component = components_1[_i2];
        if (!component.length)
          continue;
        var root = component[0];
        var rootId = root.id;
        var stack = [root];
        var parent_1 = (_a2 = {}, _a2[rootId] = root, _a2);
        var used = (_b = {}, _b[rootId] = /* @__PURE__ */ new Set(), _b);
        while (stack.length > 0) {
          var curNode = stack.pop();
          var curNodeId = curNode.id;
          var neighbors = (0, _util.getNeighbors)(curNodeId, graphData.edges);
          var _loop_1 = function _loop_12(i3) {
            var _c;
            var neighborId = neighbors[i3];
            var neighbor = graphData.nodes.find(function(node) {
              return node.id === neighborId;
            });
            if (neighborId === curNodeId) {
              allCycles.push((_c = {}, _c[neighborId] = curNode, _c));
            } else if (!(neighborId in used)) {
              parent_1[neighborId] = curNode;
              stack.push(neighbor);
              used[neighborId] = /* @__PURE__ */ new Set([curNode]);
            } else if (!used[curNodeId].has(neighbor)) {
              var cycleValid = true;
              var cyclePath = [neighbor, curNode];
              var p2 = parent_1[curNodeId];
              while (used[neighborId].size && !used[neighborId].has(p2)) {
                cyclePath.push(p2);
                if (p2 === parent_1[p2.id])
                  break;
                else
                  p2 = parent_1[p2.id];
              }
              cyclePath.push(p2);
              if (nodeIds && include) {
                cycleValid = false;
                if (cyclePath.findIndex(function(node) {
                  return nodeIds.indexOf(node.id) > -1;
                }) > -1) {
                  cycleValid = true;
                }
              } else if (nodeIds && !include) {
                if (cyclePath.findIndex(function(node) {
                  return nodeIds.indexOf(node.id) > -1;
                }) > -1) {
                  cycleValid = false;
                }
              }
              if (cycleValid) {
                var cycle = {};
                for (var index2 = 1; index2 < cyclePath.length; index2 += 1) {
                  cycle[cyclePath[index2 - 1].id] = cyclePath[index2];
                }
                if (cyclePath.length) {
                  cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];
                }
                allCycles.push(cycle);
              }
              used[neighborId].add(curNode);
            }
          };
          for (var i2 = 0; i2 < neighbors.length; i2 += 1) {
            _loop_1(i2);
          }
        }
      }
      return allCycles;
    };
    exports.detectAllUndirectedCycle = detectAllUndirectedCycle3;
    var detectAllDirectedCycle3 = function detectAllDirectedCycle4(graphData, nodeIds, include) {
      if (include === void 0) {
        include = true;
      }
      var path = [];
      var blocked = /* @__PURE__ */ new Set();
      var B2 = [];
      var allCycles = [];
      var idx2Node = {};
      var node2Idx = {};
      var unblock = function unblock2(thisNode) {
        var stack = [thisNode];
        while (stack.length > 0) {
          var node2 = stack.pop();
          if (blocked.has(node2)) {
            blocked.delete(node2);
            B2[node2.id].forEach(function(n2) {
              stack.push(n2);
            });
            B2[node2.id].clear();
          }
        }
      };
      var circuit = function circuit2(node2, start, adjList2) {
        var closed = false;
        if (nodeIds && include === false && nodeIds.indexOf(node2.id) > -1)
          return closed;
        path.push(node2);
        blocked.add(node2);
        var neighbors = adjList2[node2.id];
        for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
          var neighbor = idx2Node[neighbors[i3]];
          if (neighbor === start) {
            var cycle = {};
            for (var index2 = 1; index2 < path.length; index2 += 1) {
              cycle[path[index2 - 1].id] = path[index2];
            }
            if (path.length) {
              cycle[path[path.length - 1].id] = path[0];
            }
            allCycles.push(cycle);
            closed = true;
          } else if (!blocked.has(neighbor)) {
            if (circuit2(neighbor, start, adjList2)) {
              closed = true;
            }
          }
        }
        if (closed) {
          unblock(node2);
        } else {
          for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
            var neighbor = idx2Node[neighbors[i3]];
            if (!B2[neighbor.id].has(node2)) {
              B2[neighbor.id].add(node2);
            }
          }
        }
        path.pop();
        return closed;
      };
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
      for (var i2 = 0; i2 < nodes.length; i2 += 1) {
        var node = nodes[i2];
        var nodeId = node.id;
        node2Idx[nodeId] = i2;
        idx2Node[i2] = node;
      }
      if (nodeIds && include) {
        var _loop_2 = function _loop_22(i3) {
          var nodeId2 = nodeIds[i3];
          node2Idx[nodes[i3].id] = node2Idx[nodeId2];
          node2Idx[nodeId2] = 0;
          idx2Node[0] = nodes.find(function(node2) {
            return node2.id === nodeId2;
          });
          idx2Node[node2Idx[nodes[i3].id]] = nodes[i3];
        };
        for (var i2 = 0; i2 < nodeIds.length; i2++) {
          _loop_2(i2);
        }
      }
      var getMinComponentAdj = function getMinComponentAdj2(components3) {
        var _a3;
        var minCompIdx;
        var minIdx2 = Infinity;
        for (var i3 = 0; i3 < components3.length; i3 += 1) {
          var comp = components3[i3];
          for (var j2 = 0; j2 < comp.length; j2++) {
            var nodeIdx_1 = node2Idx[comp[j2].id];
            if (nodeIdx_1 < minIdx2) {
              minIdx2 = nodeIdx_1;
              minCompIdx = i3;
            }
          }
        }
        var component2 = components3[minCompIdx];
        var adjList2 = [];
        for (var i3 = 0; i3 < component2.length; i3 += 1) {
          var node2 = component2[i3];
          adjList2[node2.id] = [];
          for (var _i2 = 0, _b = (0, _util.getNeighbors)(node2.id, graphData.edges, "target").filter(function(n2) {
            return component2.map(function(c3) {
              return c3.id;
            }).indexOf(n2) > -1;
          }); _i2 < _b.length; _i2++) {
            var neighbor = _b[_i2];
            if (neighbor === node2.id && !(include === false && nodeIds.indexOf(node2.id) > -1)) {
              allCycles.push((_a3 = {}, _a3[node2.id] = node2, _a3));
            } else {
              adjList2[node2.id].push(node2Idx[neighbor]);
            }
          }
        }
        return {
          component: component2,
          adjList: adjList2,
          minIdx: minIdx2
        };
      };
      var nodeIdx = 0;
      while (nodeIdx < nodes.length) {
        var subgraphNodes = nodes.filter(function(n2) {
          return node2Idx[n2.id] >= nodeIdx;
        });
        var sccs = (0, _connectedComponent.detectStrongConnectComponents)({
          nodes: subgraphNodes,
          edges: graphData.edges
        }).filter(function(component2) {
          return component2.length > 1;
        });
        if (sccs.length === 0)
          break;
        var scc = getMinComponentAdj(sccs);
        var minIdx = scc.minIdx, adjList = scc.adjList, component = scc.component;
        if (component.length > 1) {
          component.forEach(function(node2) {
            B2[node2.id] = /* @__PURE__ */ new Set();
          });
          var startNode = idx2Node[minIdx];
          if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1)
            return allCycles;
          circuit(startNode, startNode, adjList);
          nodeIdx = minIdx + 1;
        } else {
          break;
        }
      }
      return allCycles;
    };
    exports.detectAllDirectedCycle = detectAllDirectedCycle3;
    var detectAllCycles3 = function detectAllCycles4(graphData, directed, nodeIds, include) {
      if (include === void 0) {
        include = true;
      }
      if (directed)
        return detectAllDirectedCycle3(graphData, nodeIds, include);
      return detectAllUndirectedCycle3(graphData, nodeIds, include);
    };
    exports.detectAllCycles = detectAllCycles3;
    var _default = detectDirectedCycle4;
    exports.default = _default;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module) {
    var __extends15;
    var __assign14;
    var __rest4;
    var __decorate;
    var __param;
    var __esDecorate;
    var __runInitializers;
    var __propKey;
    var __setFunctionName;
    var __metadata;
    var __awaiter2;
    var __generator2;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray3;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    var __addDisposableResource;
    var __disposeResources;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d2[p2] = b2[p2];
      };
      __extends15 = function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign14 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest4 = function(s2, e8) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c3 < 3 ? d2(r2) : c3 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f2) {
          if (f2 !== void 0 && typeof f2 !== "function")
            throw new TypeError("Function expected");
          return f2;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _2, done = false;
        for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
          var context = {};
          for (var p2 in contextIn)
            context[p2] = p2 === "access" ? {} : contextIn[p2];
          for (var p2 in contextIn.access)
            context.access[p2] = contextIn.access[p2];
          context.addInitializer = function(f2) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f2 || null));
          };
          var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_2 = accept(result.get))
              descriptor.get = _2;
            if (_2 = accept(result.set))
              descriptor.set = _2;
            if (_2 = accept(result.init))
              initializers.unshift(_2);
          } else if (_2 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_2);
            else
              descriptor[key] = _2;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __runInitializers = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i2 = 0; i2 < initializers.length; i2++) {
          value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __propKey = function(x4) {
        return typeof x4 === "symbol" ? x4 : "".concat(x4);
      };
      __setFunctionName = function(f2, name, prefix) {
        if (typeof name === "symbol")
          name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e8) {
              reject(e8);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e8) {
              reject(e8);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _2 = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y4, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
            try {
              if (f2 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done)
                return t2;
              if (y4 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _2.label++;
                  return { value: op[1], done: false };
                case 5:
                  _2.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _2.ops.pop();
                  _2.trys.pop();
                  continue;
                default:
                  if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _2 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _2.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _2.label < t2[1]) {
                    _2.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _2.label < t2[2]) {
                    _2.label = t2[2];
                    _2.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _2.ops.pop();
                  _2.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _2);
            } catch (e8) {
              op = [6, e8];
              y4 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m3, o2) {
        for (var p2 in m3)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
            __createBinding(o2, m3, p2);
      };
      __createBinding = Object.create ? function(o2, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m3, k2);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m3[k2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o2[s2], i2 = 0;
        if (m3)
          return m3.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m3)
          return o2;
        var i2 = m3.call(o2), r2, ar2 = [], e8;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e8 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m3 = i2["return"]))
              m3.call(i2);
          } finally {
            if (e8)
              throw e8.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a3 = arguments[i2], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
            r2[k2] = a3[j2];
        return r2;
      };
      __spreadArray3 = function(to2, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
            if (ar2 || !(i2 in from)) {
              if (!ar2)
                ar2 = Array.prototype.slice.call(from, 0, i2);
              ar2[i2] = from[i2];
            }
          }
        return to2.concat(ar2 || Array.prototype.slice.call(from));
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a3, b2) {
                q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e8) {
            settle(q2[0][3], e8);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e8) {
          throw e8;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: false } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o2[Symbol.asyncIterator], i2;
        return m3 ? m3.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      };
      __importStar = function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k2 in mod2)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
              __createBinding(result, mod2, k2);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      __importDefault = function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      __addDisposableResource = function(env, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env.stack.push({ value, dispose, async });
        } else if (async) {
          env.stack.push({ async: true });
        }
        return value;
      };
      var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e8 = new Error(message);
        return e8.name = "SuppressedError", e8.error = error, e8.suppressed = suppressed, e8;
      };
      __disposeResources = function(env) {
        function fail(e8) {
          env.error = env.hasError ? new _SuppressedError(e8, env.error, "An error was suppressed during disposal.") : e8;
          env.hasError = true;
        }
        function next() {
          while (env.stack.length) {
            var rec = env.stack.pop();
            try {
              var result = rec.dispose && rec.dispose.call(rec.value);
              if (rec.async)
                return Promise.resolve(result).then(next, function(e8) {
                  fail(e8);
                  return next();
                });
            } catch (e8) {
              fail(e8);
            }
          }
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
      exporter("__extends", __extends15);
      exporter("__assign", __assign14);
      exporter("__rest", __rest4);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__esDecorate", __esDecorate);
      exporter("__runInitializers", __runInitializers);
      exporter("__propKey", __propKey);
      exporter("__setFunctionName", __setFunctionName);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray3);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
      exporter("__addDisposableResource", __addDisposableResource);
      exporter("__disposeResources", __disposeResources);
    });
  }
});

// node_modules/@antv/algorithm/lib/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/@antv/algorithm/lib/dijkstra.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _tslib = require_tslib();
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _util2 = require_util();
    var minVertex3 = function minVertex4(D2, nodes, marks) {
      var minDis = Infinity;
      var minNode;
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var nodeId = nodes[i2].id;
        if (!marks[nodeId] && D2[nodeId] <= minDis) {
          minDis = D2[nodeId];
          minNode = nodes[i2];
        }
      }
      return minNode;
    };
    var dijkstra5 = function dijkstra6(graphData, source, directed, weightPropertyName) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodeIds = [];
      var marks = {};
      var D2 = {};
      var prevs = {};
      nodes.forEach(function(node, i3) {
        var id = node.id;
        nodeIds.push(id);
        D2[id] = Infinity;
        if (id === source)
          D2[id] = 0;
      });
      var nodeNum = nodes.length;
      var _loop_1 = function _loop_12(i3) {
        var minNode = minVertex3(D2, nodes, marks);
        var minNodeId = minNode.id;
        marks[minNodeId] = true;
        if (D2[minNodeId] === Infinity)
          return "continue";
        var relatedEdges = [];
        if (directed)
          relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);
        else
          relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);
        relatedEdges.forEach(function(edge) {
          var edgeTarget = edge.target;
          var edgeSource = edge.source;
          var w2 = edgeTarget === minNodeId ? edgeSource : edgeTarget;
          var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
          if (D2[w2] > D2[minNode.id] + weight) {
            D2[w2] = D2[minNode.id] + weight;
            prevs[w2] = [minNode.id];
          } else if (D2[w2] === D2[minNode.id] + weight) {
            prevs[w2].push(minNode.id);
          }
        });
      };
      for (var i2 = 0; i2 < nodeNum; i2++) {
        _loop_1(i2);
      }
      prevs[source] = [source];
      var paths = {};
      for (var target in D2) {
        if (D2[target] !== Infinity) {
          findAllPaths2(source, target, prevs, paths);
        }
      }
      var path = {};
      for (var target in paths) {
        path[target] = paths[target][0];
      }
      return {
        length: D2,
        path,
        allPath: paths
      };
    };
    var _default = dijkstra5;
    exports.default = _default;
    function findAllPaths2(source, target, prevs, foundPaths) {
      if (source === target) {
        return [source];
      }
      if (foundPaths[target]) {
        return foundPaths[target];
      }
      var paths = [];
      for (var _i2 = 0, _a2 = prevs[target]; _i2 < _a2.length; _i2++) {
        var prev = _a2[_i2];
        var prevPaths = findAllPaths2(source, prev, prevs, foundPaths);
        if (!prevPaths)
          return;
        for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
          var prePath = prevPaths_1[_b];
          if ((0, _util.isArray)(prePath))
            paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath, true), [target], false));
          else
            paths.push([prePath, target]);
        }
      }
      foundPaths[target] = paths;
      return foundPaths[target];
    }
  }
});

// node_modules/@antv/algorithm/lib/find-path.js
var require_find_path = __commonJS({
  "node_modules/@antv/algorithm/lib/find-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findShortestPath = exports.findAllPath = void 0;
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var findShortestPath3 = function findShortestPath4(graphData, start, end2, directed, weightPropertyName) {
      var _a2 = (0, _dijkstra.default)(graphData, start, directed, weightPropertyName), length = _a2.length, path = _a2.path, allPath = _a2.allPath;
      return {
        length: length[end2],
        path: path[end2],
        allPath: allPath[end2]
      };
    };
    exports.findShortestPath = findShortestPath3;
    var findAllPath3 = function findAllPath4(graphData, start, end2, directed) {
      var _a2;
      if (start === end2)
        return [[start]];
      var _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var visited = [start];
      var isVisited = (_a2 = {}, _a2[start] = true, _a2);
      var stack = [];
      var allPath = [];
      var neighbors = directed ? (0, _util.getNeighbors)(start, edges, "target") : (0, _util.getNeighbors)(start, edges);
      stack.push(neighbors);
      while (visited.length > 0 && stack.length > 0) {
        var children = stack[stack.length - 1];
        if (children.length) {
          var child = children.shift();
          if (child) {
            visited.push(child);
            isVisited[child] = true;
            neighbors = directed ? (0, _util.getNeighbors)(child, edges, "target") : (0, _util.getNeighbors)(child, edges);
            stack.push(neighbors.filter(function(neighbor) {
              return !isVisited[neighbor];
            }));
          }
        } else {
          var node = visited.pop();
          isVisited[node] = false;
          stack.pop();
          continue;
        }
        if (visited[visited.length - 1] === end2) {
          var path = visited.map(function(node2) {
            return node2;
          });
          allPath.push(path);
          var node = visited.pop();
          isVisited[node] = false;
          stack.pop();
        }
      }
      return allPath;
    };
    exports.findAllPath = findAllPath3;
  }
});

// node_modules/@antv/algorithm/lib/floydWarshall.js
var require_floydWarshall = __commonJS({
  "node_modules/@antv/algorithm/lib/floydWarshall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var floydWarshall6 = function floydWarshall7(graphData, directed) {
      var adjacentMatrix = (0, _adjacentMatrix.default)(graphData, directed);
      var dist = [];
      var size3 = adjacentMatrix.length;
      for (var i2 = 0; i2 < size3; i2 += 1) {
        dist[i2] = [];
        for (var j2 = 0; j2 < size3; j2 += 1) {
          if (i2 === j2) {
            dist[i2][j2] = 0;
          } else if (adjacentMatrix[i2][j2] === 0 || !adjacentMatrix[i2][j2]) {
            dist[i2][j2] = Infinity;
          } else {
            dist[i2][j2] = adjacentMatrix[i2][j2];
          }
        }
      }
      for (var k2 = 0; k2 < size3; k2 += 1) {
        for (var i2 = 0; i2 < size3; i2 += 1) {
          for (var j2 = 0; j2 < size3; j2 += 1) {
            if (dist[i2][j2] > dist[i2][k2] + dist[k2][j2]) {
              dist[i2][j2] = dist[i2][k2] + dist[k2][j2];
            }
          }
        }
      }
      return dist;
    };
    var _default = floydWarshall6;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/label-propagation.js
var require_label_propagation = __commonJS({
  "node_modules/@antv/algorithm/lib/label-propagation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var labelPropagation3 = function labelPropagation4(graphData, directed, weightPropertyName, maxIteration) {
      if (directed === void 0) {
        directed = false;
      }
      if (weightPropertyName === void 0) {
        weightPropertyName = "weight";
      }
      if (maxIteration === void 0) {
        maxIteration = 1e3;
      }
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var clusters = {};
      var nodeMap = {};
      nodes.forEach(function(node, i2) {
        var cid = (0, _util.uniqueId)();
        node.clusterId = cid;
        clusters[cid] = {
          id: cid,
          nodes: [node]
        };
        nodeMap[node.id] = {
          node,
          idx: i2
        };
      });
      var adjMatrix3 = (0, _adjacentMatrix.default)(graphData, directed);
      var ks = [];
      var neighbors = {};
      adjMatrix3.forEach(function(row, i2) {
        var k2 = 0;
        var iid = nodes[i2].id;
        neighbors[iid] = {};
        row.forEach(function(entry, j2) {
          if (!entry)
            return;
          k2 += entry;
          var jid = nodes[j2].id;
          neighbors[iid][jid] = entry;
        });
        ks.push(k2);
      });
      var iter = 0;
      var _loop_1 = function _loop_12() {
        var changed = false;
        nodes.forEach(function(node) {
          var neighborClusters = {};
          Object.keys(neighbors[node.id]).forEach(function(neighborId) {
            var neighborWeight = neighbors[node.id][neighborId];
            var neighborNode = nodeMap[neighborId].node;
            var neighborClusterId = neighborNode.clusterId;
            if (!neighborClusters[neighborClusterId])
              neighborClusters[neighborClusterId] = 0;
            neighborClusters[neighborClusterId] += neighborWeight;
          });
          var maxWeight = -Infinity;
          var bestClusterIds = [];
          Object.keys(neighborClusters).forEach(function(clusterId) {
            if (maxWeight < neighborClusters[clusterId]) {
              maxWeight = neighborClusters[clusterId];
              bestClusterIds = [clusterId];
            } else if (maxWeight === neighborClusters[clusterId]) {
              bestClusterIds.push(clusterId);
            }
          });
          if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId)
            return;
          var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);
          if (selfClusterIdx >= 0)
            bestClusterIds.splice(selfClusterIdx, 1);
          if (bestClusterIds && bestClusterIds.length) {
            changed = true;
            var selfCluster = clusters[node.clusterId];
            var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
            selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
            var randomIdx = Math.floor(Math.random() * bestClusterIds.length);
            var bestCluster = clusters[bestClusterIds[randomIdx]];
            bestCluster.nodes.push(node);
            node.clusterId = bestCluster.id;
          }
        });
        if (!changed)
          return "break";
        iter++;
      };
      while (iter < maxIteration) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
      Object.keys(clusters).forEach(function(clusterId) {
        var cluster = clusters[clusterId];
        if (!cluster.nodes || !cluster.nodes.length) {
          delete clusters[clusterId];
        }
      });
      var clusterEdges = [];
      var clusterEdgeMap = {};
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var weight = edge[weightPropertyName] || 1;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
        if (clusterEdgeMap[newEdgeId]) {
          clusterEdgeMap[newEdgeId].weight += weight;
          clusterEdgeMap[newEdgeId].count++;
        } else {
          var newEdge = {
            source: sourceClusterId,
            target: targetClusterId,
            weight,
            count: 1
          };
          clusterEdgeMap[newEdgeId] = newEdge;
          clusterEdges.push(newEdge);
        }
      });
      var clustersArray = [];
      Object.keys(clusters).forEach(function(clusterId) {
        clustersArray.push(clusters[clusterId]);
      });
      return {
        clusters: clustersArray,
        clusterEdges
      };
    };
    var _default = labelPropagation3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/utils/vector.js
var require_vector = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var Vector2 = (
      /** @class */
      function() {
        function Vector3(arr) {
          this.arr = arr;
        }
        Vector3.prototype.getArr = function() {
          return this.arr || [];
        };
        Vector3.prototype.add = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            return new Vector3(otherArr);
          }
          if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return new Vector3(this.arr);
          }
          if (this.arr.length === otherArr.length) {
            var res = [];
            for (var index2 in this.arr) {
              res[index2] = this.arr[index2] + otherArr[index2];
            }
            return new Vector3(res);
          }
        };
        Vector3.prototype.subtract = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            return new Vector3(otherArr);
          }
          if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return new Vector3(this.arr);
          }
          if (this.arr.length === otherArr.length) {
            var res = [];
            for (var index2 in this.arr) {
              res[index2] = this.arr[index2] - otherArr[index2];
            }
            return new Vector3(res);
          }
        };
        Vector3.prototype.avg = function(length) {
          var res = [];
          if (length !== 0) {
            for (var index2 in this.arr) {
              res[index2] = this.arr[index2] / length;
            }
          }
          return new Vector3(res);
        };
        Vector3.prototype.negate = function() {
          var res = [];
          for (var index2 in this.arr) {
            res[index2] = -this.arr[index2];
          }
          return new Vector3(res);
        };
        Vector3.prototype.squareEuclideanDistance = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return 0;
          }
          if (this.arr.length === otherArr.length) {
            var res = 0;
            for (var index2 in this.arr) {
              res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
            }
            return res;
          }
        };
        Vector3.prototype.euclideanDistance = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return 0;
          }
          if (this.arr.length === otherArr.length) {
            var res = 0;
            for (var index2 in this.arr) {
              res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
            }
            return Math.sqrt(res);
          } else {
            console.error("The two vectors are unequal in length.");
          }
        };
        Vector3.prototype.normalize = function() {
          var res = [];
          var cloneArr = (0, _util.clone)(this.arr);
          cloneArr.sort(function(a3, b2) {
            return a3 - b2;
          });
          var max4 = cloneArr[cloneArr.length - 1];
          var min3 = cloneArr[0];
          for (var index2 in this.arr) {
            res[index2] = (this.arr[index2] - min3) / (max4 - min3);
          }
          return new Vector3(res);
        };
        Vector3.prototype.norm2 = function() {
          var _a2;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            return 0;
          }
          var res = 0;
          for (var index2 in this.arr) {
            res += Math.pow(this.arr[index2], 2);
          }
          return Math.sqrt(res);
        };
        Vector3.prototype.dot = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return 0;
          }
          if (this.arr.length === otherArr.length) {
            var res = 0;
            for (var index2 in this.arr) {
              res += this.arr[index2] * otherVector.arr[index2];
            }
            return res;
          } else {
            console.error("The two vectors are unequal in length.");
          }
        };
        Vector3.prototype.equal = function(otherVector) {
          var _a2;
          var otherArr = otherVector.arr;
          if (((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
            return false;
          }
          for (var index2 in this.arr) {
            if (this.arr[index2] !== otherArr[index2]) {
              return false;
            }
          }
          return true;
        };
        return Vector3;
      }()
    );
    var _default = Vector2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/constants/time.js
var require_time = __commonJS({
  "node_modules/@antv/algorithm/lib/constants/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.secondReg = exports.dateReg = void 0;
    var secondReg2 = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/;
    exports.secondReg = secondReg2;
    var dateReg2 = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/;
    exports.dateReg = dateReg2;
  }
});

// node_modules/@antv/algorithm/lib/utils/node-properties.js
var require_node_properties = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/node-properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPropertyWeight = exports.getAllSortProperties = exports.getAllProperties = exports.default = void 0;
    var _time = require_time();
    var getAllSortProperties = function getAllSortProperties2(nodes, n2) {
      if (nodes === void 0) {
        nodes = [];
      }
      if (n2 === void 0) {
        n2 = 100;
      }
      var propertyKeyInfo = {};
      nodes.forEach(function(node) {
        if (!node.properties) {
          return;
        }
        Object.keys(node.properties).forEach(function(propertyKey) {
          if (propertyKey === "id" || !"".concat(node.properties[propertyKey]).match(_time.secondReg) && !"".concat(node.properties[propertyKey]).match(_time.dateReg) && isNaN(Number(node.properties[propertyKey]))) {
            if (propertyKeyInfo.hasOwnProperty(propertyKey)) {
              delete propertyKeyInfo[propertyKey];
            }
            return;
          }
          if (propertyKeyInfo.hasOwnProperty(propertyKey)) {
            propertyKeyInfo[propertyKey] += 1;
          } else {
            propertyKeyInfo[propertyKey] = 1;
          }
        });
      });
      var sortKeys = Object.keys(propertyKeyInfo).sort(function(a3, b2) {
        return propertyKeyInfo[b2] - propertyKeyInfo[a3];
      });
      return sortKeys.length < n2 ? sortKeys : sortKeys.slice(0, n2);
    };
    exports.getAllSortProperties = getAllSortProperties;
    var processProperty = function processProperty2(properties, propertyKeys) {
      return propertyKeys.map(function(key) {
        if (properties.hasOwnProperty(key)) {
          return properties[key];
        }
        return 0;
      });
    };
    var getPropertyWeight = function getPropertyWeight2(nodes) {
      var propertyKeys = getAllSortProperties(nodes);
      var allPropertiesWeight = [];
      for (var i2 = 0; i2 < nodes.length; i2++) {
        allPropertiesWeight[i2] = processProperty(nodes[i2].properties, propertyKeys);
      }
      return allPropertiesWeight;
    };
    exports.getPropertyWeight = getPropertyWeight;
    var getAllProperties3 = function getAllProperties4(nodes, key) {
      if (key === void 0) {
        key = void 0;
      }
      var allProperties = [];
      nodes.forEach(function(node) {
        if (key === void 0) {
          allProperties.push(node);
        }
        if (node[key] !== void 0) {
          allProperties.push(node[key]);
        }
      });
      return allProperties;
    };
    exports.getAllProperties = getAllProperties3;
    var _default = {
      getAllSortProperties,
      getPropertyWeight,
      getAllProperties: getAllProperties3
    };
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/types.js
var require_types = __commonJS({
  "node_modules/@antv/algorithm/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DistanceType = void 0;
    var DistanceType2;
    exports.DistanceType = DistanceType2;
    (function(DistanceType3) {
      DistanceType3["EuclideanDistance"] = "euclideanDistance";
    })(DistanceType2 || (exports.DistanceType = DistanceType2 = {}));
  }
});

// node_modules/@antv/algorithm/lib/utils/data-preprocessing.js
var require_data_preprocessing = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/data-preprocessing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.oneHot = exports.getDistance = exports.getAllKeyValueMap = exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _types = require_types();
    var _vector = _interopRequireDefault(require_vector());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getAllKeyValueMap3 = function getAllKeyValueMap4(dataList, involvedKeys, uninvolvedKeys) {
      var keys2 = [];
      if (involvedKeys === null || involvedKeys === void 0 ? void 0 : involvedKeys.length) {
        keys2 = involvedKeys;
      } else {
        dataList.forEach(function(data) {
          keys2 = keys2.concat(Object.keys(data));
        });
        keys2 = (0, _util.uniq)(keys2);
      }
      var allKeyValueMap = {};
      keys2.forEach(function(key) {
        var value = [];
        dataList.forEach(function(data) {
          if (data[key] !== void 0 && data[key] !== "") {
            value.push(data[key]);
          }
        });
        if (value.length && !(uninvolvedKeys === null || uninvolvedKeys === void 0 ? void 0 : uninvolvedKeys.includes(key))) {
          allKeyValueMap[key] = (0, _util.uniq)(value);
        }
      });
      return allKeyValueMap;
    };
    exports.getAllKeyValueMap = getAllKeyValueMap3;
    var oneHot3 = function oneHot4(dataList, involvedKeys, uninvolvedKeys) {
      var allKeyValueMap = getAllKeyValueMap3(dataList, involvedKeys, uninvolvedKeys);
      var oneHotCode = [];
      if (!Object.keys(allKeyValueMap).length) {
        return oneHotCode;
      }
      var allValue = Object.values(allKeyValueMap);
      var isAllNumber = allValue.every(function(value) {
        return value.every(function(item) {
          return typeof item === "number";
        });
      });
      dataList.forEach(function(data, index2) {
        var code = [];
        Object.keys(allKeyValueMap).forEach(function(key) {
          var keyValue = data[key];
          var allKeyValue = allKeyValueMap[key];
          var valueIndex = allKeyValue.findIndex(function(value) {
            return keyValue === value;
          });
          var subCode = [];
          if (isAllNumber) {
            subCode.push(keyValue);
          } else {
            for (var i2 = 0; i2 < allKeyValue.length; i2++) {
              if (i2 === valueIndex) {
                subCode.push(1);
              } else {
                subCode.push(0);
              }
            }
          }
          code = code.concat(subCode);
        });
        oneHotCode[index2] = code;
      });
      return oneHotCode;
    };
    exports.oneHot = oneHot3;
    var getDistance3 = function getDistance4(item, otherItem, distanceType, graphData) {
      if (distanceType === void 0) {
        distanceType = _types.DistanceType.EuclideanDistance;
      }
      var distance6 = 0;
      switch (distanceType) {
        case _types.DistanceType.EuclideanDistance:
          distance6 = new _vector.default(item).euclideanDistance(new _vector.default(otherItem));
          break;
        default:
          break;
      }
      return distance6;
    };
    exports.getDistance = getDistance3;
    var _default = {
      getAllKeyValueMap: getAllKeyValueMap3,
      oneHot: oneHot3,
      getDistance: getDistance3
    };
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/louvain.js
var require_louvain = __commonJS({
  "node_modules/@antv/algorithm/lib/louvain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _vector = _interopRequireDefault(require_vector());
    var _nodeProperties = require_node_properties();
    var _dataPreprocessing = require_data_preprocessing();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getModularity3 = function getModularity4(nodes, adjMatrix3, ks, m3) {
      var length = adjMatrix3.length;
      var param = 2 * m3;
      var modularity = 0;
      for (var i2 = 0; i2 < length; i2++) {
        var clusteri = nodes[i2].clusterId;
        for (var j2 = 0; j2 < length; j2++) {
          var clusterj = nodes[j2].clusterId;
          if (clusteri !== clusterj)
            continue;
          var entry = adjMatrix3[i2][j2] || 0;
          var ki2 = ks[i2] || 0;
          var kj = ks[j2] || 0;
          modularity += entry - ki2 * kj / param;
        }
      }
      modularity *= 1 / param;
      return modularity;
    };
    var getInertialModularity3 = function getInertialModularity4(nodes, allPropertiesWeight) {
      if (nodes === void 0) {
        nodes = [];
      }
      var length = nodes.length;
      var totalProperties = new _vector.default([]);
      for (var i2 = 0; i2 < length; i2++) {
        totalProperties = totalProperties.add(new _vector.default(allPropertiesWeight[i2]));
      }
      var avgProperties = totalProperties.avg(length);
      avgProperties.normalize();
      var variance = 0;
      for (var i2 = 0; i2 < length; i2++) {
        var propertiesi = new _vector.default(allPropertiesWeight[i2]);
        var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);
        variance += squareEuclideanDistance;
      }
      var squareEuclideanDistanceInfo = [];
      nodes.forEach(function() {
        squareEuclideanDistanceInfo.push([]);
      });
      for (var i2 = 0; i2 < length; i2++) {
        var propertiesi = new _vector.default(allPropertiesWeight[i2]);
        nodes[i2]["clusterInertial"] = 0;
        for (var j2 = 0; j2 < length; j2++) {
          if (i2 === j2) {
            squareEuclideanDistanceInfo[i2][j2] = 0;
            continue;
          }
          var propertiesj = new _vector.default(allPropertiesWeight[j2]);
          squareEuclideanDistanceInfo[i2][j2] = propertiesi.squareEuclideanDistance(propertiesj);
          nodes[i2]["clusterInertial"] += squareEuclideanDistanceInfo[i2][j2];
        }
      }
      var inertialModularity = 0;
      var param = 2 * length * variance;
      for (var i2 = 0; i2 < length; i2++) {
        var clusteri = nodes[i2].clusterId;
        for (var j2 = 0; j2 < length; j2++) {
          var clusterj = nodes[j2].clusterId;
          if (i2 === j2 || clusteri !== clusterj)
            continue;
          var inertial = nodes[i2].clusterInertial * nodes[j2].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i2][j2] / param;
          inertialModularity += inertial;
        }
      }
      return Number(inertialModularity.toFixed(4));
    };
    var louvain3 = function louvain4(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
      if (directed === void 0) {
        directed = false;
      }
      if (weightPropertyName === void 0) {
        weightPropertyName = "weight";
      }
      if (threshold === void 0) {
        threshold = 1e-4;
      }
      if (inertialModularity === void 0) {
        inertialModularity = false;
      }
      if (propertyKey === void 0) {
        propertyKey = void 0;
      }
      if (involvedKeys === void 0) {
        involvedKeys = [];
      }
      if (uninvolvedKeys === void 0) {
        uninvolvedKeys = ["id"];
      }
      if (inertialWeight === void 0) {
        inertialWeight = 1;
      }
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var allPropertiesWeight = [];
      if (inertialModularity) {
        nodes.forEach(function(node, index2) {
          node.properties = node.properties || {};
          node.originIndex = index2;
        });
        var nodeTypeInfo_1 = [];
        if (nodes.every(function(node) {
          return node.hasOwnProperty("nodeType");
        })) {
          nodeTypeInfo_1 = Array.from(new Set(nodes.map(function(node) {
            return node.nodeType;
          })));
          nodes.forEach(function(node) {
            node.properties.nodeType = nodeTypeInfo_1.findIndex(function(nodeType) {
              return nodeType === node.nodeType;
            });
          });
        }
        var properties = (0, _nodeProperties.getAllProperties)(nodes, propertyKey);
        allPropertiesWeight = (0, _dataPreprocessing.oneHot)(properties, involvedKeys, uninvolvedKeys);
      }
      var uniqueId5 = 1;
      var clusters = {};
      var nodeMap = {};
      nodes.forEach(function(node, i2) {
        var cid = String(uniqueId5++);
        node.clusterId = cid;
        clusters[cid] = {
          id: cid,
          nodes: [node]
        };
        nodeMap[node.id] = {
          node,
          idx: i2
        };
      });
      var adjMatrix3 = (0, _adjacentMatrix.default)(graphData, directed);
      var ks = [];
      var neighbors = {};
      var m3 = 0;
      adjMatrix3.forEach(function(row, i2) {
        var k2 = 0;
        var iid = nodes[i2].id;
        neighbors[iid] = {};
        row.forEach(function(entry, j2) {
          if (!entry)
            return;
          k2 += entry;
          var jid = nodes[j2].id;
          neighbors[iid][jid] = entry;
          m3 += entry;
        });
        ks.push(k2);
      });
      m3 /= 2;
      var totalModularity = Infinity;
      var previousModularity = Infinity;
      var iter = 0;
      var finalNodes = [];
      var finalClusters = {};
      while (true) {
        if (inertialModularity && nodes.every(function(node) {
          return node.hasOwnProperty("properties");
        })) {
          totalModularity = getModularity3(nodes, adjMatrix3, ks, m3) + getInertialModularity3(nodes, allPropertiesWeight) * inertialWeight;
        } else {
          totalModularity = getModularity3(nodes, adjMatrix3, ks, m3);
        }
        if (iter === 0) {
          previousModularity = totalModularity;
          finalNodes = nodes;
          finalClusters = clusters;
        }
        var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;
        if (totalModularity > previousModularity) {
          finalNodes = nodes.map(function(node) {
            return {
              node,
              clusterId: node.clusterId
            };
          });
          finalClusters = (0, _util.clone)(clusters);
          previousModularity = totalModularity;
        }
        if (increaseWithinThreshold || iter > 100) {
          break;
        }
        ;
        iter++;
        Object.keys(clusters).forEach(function(clusterId) {
          var sumTot = 0;
          edges.forEach(function(edge) {
            var source = edge.source, target = edge.target;
            var sourceClusterId = nodeMap[source].node.clusterId;
            var targetClusterId = nodeMap[target].node.clusterId;
            if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {
              sumTot = sumTot + (edge[weightPropertyName] || 1);
            }
          });
          clusters[clusterId].sumTot = sumTot;
        });
        nodes.forEach(function(node, i2) {
          var selfCluster = clusters[node.clusterId];
          var bestIncrease = 0;
          var bestCluster;
          var commonParam = ks[i2] / (2 * m3);
          var kiin = 0;
          var selfClusterNodes = selfCluster.nodes;
          selfClusterNodes.forEach(function(scNode) {
            var scNodeIdx = nodeMap[scNode.id].idx;
            kiin += adjMatrix3[i2][scNodeIdx] || 0;
          });
          var removeModurarity = kiin - selfCluster.sumTot * commonParam;
          var selfClusterNodesAfterRemove = selfClusterNodes.filter(function(scNode) {
            return scNode.id !== node.id;
          });
          var propertiesWeightRemove = [];
          selfClusterNodesAfterRemove.forEach(function(nodeRemove, index2) {
            propertiesWeightRemove[index2] = allPropertiesWeight[nodeRemove.originIndex];
          });
          var removeInertialModularity = getInertialModularity3(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;
          var nodeNeighborIds = neighbors[node.id];
          Object.keys(nodeNeighborIds).forEach(function(neighborNodeId) {
            var neighborNode = nodeMap[neighborNodeId].node;
            var neighborClusterId = neighborNode.clusterId;
            if (neighborClusterId === node.clusterId)
              return;
            var neighborCluster = clusters[neighborClusterId];
            var clusterNodes = neighborCluster.nodes;
            if (!clusterNodes || !clusterNodes.length)
              return;
            var neighborClusterKiin = 0;
            clusterNodes.forEach(function(cNode) {
              var cNodeIdx = nodeMap[cNode.id].idx;
              neighborClusterKiin += adjMatrix3[i2][cNodeIdx] || 0;
            });
            var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;
            var clusterNodesAfterAdd = clusterNodes.concat([node]);
            var propertiesWeightAdd = [];
            clusterNodesAfterAdd.forEach(function(nodeAdd, index2) {
              propertiesWeightAdd[index2] = allPropertiesWeight[nodeAdd.originIndex];
            });
            var addInertialModularity = getInertialModularity3(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;
            var increase = addModurarity - removeModurarity;
            if (inertialModularity) {
              increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);
            }
            if (increase > bestIncrease) {
              bestIncrease = increase;
              bestCluster = neighborCluster;
            }
          });
          if (bestIncrease > 0) {
            bestCluster.nodes.push(node);
            var previousClusterId_1 = node.clusterId;
            node.clusterId = bestCluster.id;
            var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
            selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
            var neighborClusterSumTot_1 = 0;
            var selfClusterSumTot_1 = 0;
            edges.forEach(function(edge) {
              var source = edge.source, target = edge.target;
              var sourceClusterId = nodeMap[source].node.clusterId;
              var targetClusterId = nodeMap[target].node.clusterId;
              if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {
                neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);
              }
              if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {
                selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);
              }
            });
            bestCluster.sumTot = neighborClusterSumTot_1;
            selfCluster.sumTot = selfClusterSumTot_1;
          }
        });
      }
      var newClusterIdMap = {};
      var clusterIdx = 0;
      Object.keys(finalClusters).forEach(function(clusterId) {
        var cluster = finalClusters[clusterId];
        if (!cluster.nodes || !cluster.nodes.length) {
          delete finalClusters[clusterId];
          return;
        }
        var newId = String(clusterIdx + 1);
        if (newId === clusterId) {
          return;
        }
        cluster.id = newId;
        cluster.nodes = cluster.nodes.map(function(item) {
          return {
            id: item.id,
            clusterId: newId
          };
        });
        finalClusters[newId] = cluster;
        newClusterIdMap[clusterId] = newId;
        delete finalClusters[clusterId];
        clusterIdx++;
      });
      finalNodes.forEach(function(nodeInfo) {
        var node = nodeInfo.node, clusterId = nodeInfo.clusterId;
        if (!node)
          return;
        node.clusterId = clusterId;
        if (node.clusterId && newClusterIdMap[node.clusterId])
          node.clusterId = newClusterIdMap[node.clusterId];
      });
      var clusterEdges = [];
      var clusterEdgeMap = {};
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var weight = edge[weightPropertyName] || 1;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        if (!sourceClusterId || !targetClusterId)
          return;
        var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
        if (clusterEdgeMap[newEdgeId]) {
          clusterEdgeMap[newEdgeId].weight += weight;
          clusterEdgeMap[newEdgeId].count++;
        } else {
          var newEdge = {
            source: sourceClusterId,
            target: targetClusterId,
            weight,
            count: 1
          };
          clusterEdgeMap[newEdgeId] = newEdge;
          clusterEdges.push(newEdge);
        }
      });
      var clustersArray = [];
      Object.keys(finalClusters).forEach(function(clusterId) {
        clustersArray.push(finalClusters[clusterId]);
      });
      return {
        clusters: clustersArray,
        clusterEdges
      };
    };
    var _default = louvain3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/union-find.js
var require_union_find = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/union-find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UnionFind2 = (
      /** @class */
      function() {
        function UnionFind3(items) {
          this.count = items.length;
          this.parent = {};
          for (var _i2 = 0, items_1 = items; _i2 < items_1.length; _i2++) {
            var i2 = items_1[_i2];
            this.parent[i2] = i2;
          }
        }
        UnionFind3.prototype.find = function(item) {
          while (this.parent[item] !== item) {
            item = this.parent[item];
          }
          return item;
        };
        UnionFind3.prototype.union = function(a3, b2) {
          var rootA = this.find(a3);
          var rootB = this.find(b2);
          if (rootA === rootB)
            return;
          if (rootA < rootB) {
            if (this.parent[b2] !== b2)
              this.union(this.parent[b2], a3);
            this.parent[b2] = this.parent[a3];
          } else {
            if (this.parent[a3] !== a3)
              this.union(this.parent[a3], b2);
            this.parent[a3] = this.parent[b2];
          }
        };
        UnionFind3.prototype.connected = function(a3, b2) {
          return this.find(a3) === this.find(b2);
        };
        return UnionFind3;
      }()
    );
    var _default = UnionFind2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/binary-heap.js
var require_binary_heap = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/binary-heap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var defaultCompare3 = function defaultCompare4(a3, b2) {
      return a3 - b2;
    };
    var MinBinaryHeap2 = (
      /** @class */
      function() {
        function MinBinaryHeap3(compareFn) {
          if (compareFn === void 0) {
            compareFn = defaultCompare3;
          }
          this.compareFn = compareFn;
          this.list = [];
        }
        MinBinaryHeap3.prototype.getLeft = function(index2) {
          return 2 * index2 + 1;
        };
        MinBinaryHeap3.prototype.getRight = function(index2) {
          return 2 * index2 + 2;
        };
        MinBinaryHeap3.prototype.getParent = function(index2) {
          if (index2 === 0) {
            return null;
          }
          return Math.floor((index2 - 1) / 2);
        };
        MinBinaryHeap3.prototype.isEmpty = function() {
          return this.list.length <= 0;
        };
        MinBinaryHeap3.prototype.top = function() {
          return this.isEmpty() ? void 0 : this.list[0];
        };
        MinBinaryHeap3.prototype.delMin = function() {
          var top = this.top();
          var bottom = this.list.pop();
          if (this.list.length > 0) {
            this.list[0] = bottom;
            this.moveDown(0);
          }
          return top;
        };
        MinBinaryHeap3.prototype.insert = function(value) {
          if (value !== null) {
            this.list.push(value);
            var index2 = this.list.length - 1;
            this.moveUp(index2);
            return true;
          }
          return false;
        };
        MinBinaryHeap3.prototype.moveUp = function(index2) {
          var parent = this.getParent(index2);
          while (index2 && index2 > 0 && this.compareFn(this.list[parent], this.list[index2]) > 0) {
            var tmp = this.list[parent];
            this.list[parent] = this.list[index2];
            this.list[index2] = tmp;
            index2 = parent;
            parent = this.getParent(index2);
          }
        };
        MinBinaryHeap3.prototype.moveDown = function(index2) {
          var _a2;
          var element = index2;
          var left = this.getLeft(index2);
          var right = this.getRight(index2);
          var size3 = this.list.length;
          if (left !== null && left < size3 && this.compareFn(this.list[element], this.list[left]) > 0) {
            element = left;
          } else if (right !== null && right < size3 && this.compareFn(this.list[element], this.list[right]) > 0) {
            element = right;
          }
          if (index2 !== element) {
            _a2 = [this.list[element], this.list[index2]], this.list[index2] = _a2[0], this.list[element] = _a2[1];
            this.moveDown(element);
          }
        };
        return MinBinaryHeap3;
      }()
    );
    var _default = MinBinaryHeap2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/mts.js
var require_mts = __commonJS({
  "node_modules/@antv/algorithm/lib/mts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _unionFind = _interopRequireDefault(require_union_find());
    var _binaryHeap = _interopRequireDefault(require_binary_heap());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var primMST3 = function primMST4(graphData, weight) {
      var selectedEdges = [];
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      if (nodes.length === 0) {
        return selectedEdges;
      }
      var currNode = nodes[0];
      var visited = /* @__PURE__ */ new Set();
      visited.add(currNode);
      var compareWeight = function compareWeight2(a3, b2) {
        if (weight) {
          return a3.weight - b2.weight;
        }
        return 0;
      };
      var edgeQueue = new _binaryHeap.default(compareWeight);
      (0, _util.getEdgesByNodeId)(currNode.id, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
      while (!edgeQueue.isEmpty()) {
        var currEdge = edgeQueue.delMin();
        var source = currEdge.source;
        var target = currEdge.target;
        if (visited.has(source) && visited.has(target))
          continue;
        selectedEdges.push(currEdge);
        if (!visited.has(source)) {
          visited.add(source);
          (0, _util.getEdgesByNodeId)(source, edges).forEach(function(edge) {
            edgeQueue.insert(edge);
          });
        }
        if (!visited.has(target)) {
          visited.add(target);
          (0, _util.getEdgesByNodeId)(target, edges).forEach(function(edge) {
            edgeQueue.insert(edge);
          });
        }
      }
      return selectedEdges;
    };
    var kruskalMST3 = function kruskalMST4(graphData, weight) {
      var selectedEdges = [];
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      if (nodes.length === 0) {
        return selectedEdges;
      }
      var weightEdges = edges.map(function(edge) {
        return edge;
      });
      if (weight) {
        weightEdges.sort(function(a3, b2) {
          return a3.weight - b2.weight;
        });
      }
      var disjointSet = new _unionFind.default(nodes.map(function(n2) {
        return n2.id;
      }));
      while (weightEdges.length > 0) {
        var curEdge = weightEdges.shift();
        var source = curEdge.source;
        var target = curEdge.target;
        if (!disjointSet.connected(source, target)) {
          selectedEdges.push(curEdge);
          disjointSet.union(source, target);
        }
      }
      return selectedEdges;
    };
    var minimumSpanningTree3 = function minimumSpanningTree4(graphData, weight, algo) {
      var algos = {
        prim: primMST3,
        kruskal: kruskalMST3
      };
      if (!algo)
        return kruskalMST3(graphData, weight);
      return algos[algo](graphData, weight);
    };
    var _default = minimumSpanningTree3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/pageRank.js
var require_pageRank = __commonJS({
  "node_modules/@antv/algorithm/lib/pageRank.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _degree = _interopRequireDefault(require_degree());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pageRank3 = function pageRank4(graphData, epsilon, linkProb) {
      if (typeof epsilon !== "number")
        epsilon = 1e-6;
      if (typeof linkProb !== "number")
        linkProb = 0.85;
      var distance6 = 1;
      var leakedRank = 0;
      var maxIterations = 1e3;
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodesCount = nodes.length;
      var currentRank;
      var curRanks = {};
      var prevRanks = {};
      for (var j2 = 0; j2 < nodesCount; ++j2) {
        var node = nodes[j2];
        var nodeId = node.id;
        curRanks[nodeId] = 1 / nodesCount;
        prevRanks[nodeId] = 1 / nodesCount;
      }
      var nodeDegree = (0, _degree.default)(graphData);
      while (maxIterations > 0 && distance6 > epsilon) {
        leakedRank = 0;
        for (var j2 = 0; j2 < nodesCount; ++j2) {
          var node = nodes[j2];
          var nodeId = node.id;
          currentRank = 0;
          if (nodeDegree[node.id].inDegree === 0) {
            curRanks[nodeId] = 0;
          } else {
            var neighbors = (0, _util.getNeighbors)(nodeId, edges, "source");
            for (var i2 = 0; i2 < neighbors.length; ++i2) {
              var neighbor = neighbors[i2];
              var outDegree = nodeDegree[neighbor].outDegree;
              if (outDegree > 0)
                currentRank += prevRanks[neighbor] / outDegree;
            }
            curRanks[nodeId] = linkProb * currentRank;
            leakedRank += curRanks[nodeId];
          }
        }
        leakedRank = (1 - leakedRank) / nodesCount;
        distance6 = 0;
        for (var j2 = 0; j2 < nodesCount; ++j2) {
          var node = nodes[j2];
          var nodeId = node.id;
          currentRank = curRanks[nodeId] + leakedRank;
          distance6 += Math.abs(currentRank - prevRanks[nodeId]);
          prevRanks[nodeId] = currentRank;
        }
        maxIterations -= 1;
      }
      return prevRanks;
    };
    var _default = pageRank3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/gSpan/struct.js
var require_struct = __commonJS({
  "node_modules/@antv/algorithm/lib/gSpan/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VACANT_NODE_LABEL = exports.VACANT_NODE_ID = exports.VACANT_GRAPH_ID = exports.VACANT_EDGE_LABEL = exports.VACANT_EDGE_ID = exports.Node = exports.Graph = exports.Edge = exports.AUTO_EDGE_ID = void 0;
    var VACANT_EDGE_ID2 = -1;
    exports.VACANT_EDGE_ID = VACANT_EDGE_ID2;
    var VACANT_NODE_ID2 = -1;
    exports.VACANT_NODE_ID = VACANT_NODE_ID2;
    var VACANT_EDGE_LABEL2 = "-1";
    exports.VACANT_EDGE_LABEL = VACANT_EDGE_LABEL2;
    var VACANT_NODE_LABEL2 = "-1";
    exports.VACANT_NODE_LABEL = VACANT_NODE_LABEL2;
    var VACANT_GRAPH_ID2 = -1;
    exports.VACANT_GRAPH_ID = VACANT_GRAPH_ID2;
    var AUTO_EDGE_ID = "-1";
    exports.AUTO_EDGE_ID = AUTO_EDGE_ID;
    var Edge3 = (
      /** @class */
      function() {
        function Edge4(id, from, to2, label) {
          if (id === void 0) {
            id = VACANT_EDGE_ID2;
          }
          if (from === void 0) {
            from = VACANT_NODE_ID2;
          }
          if (to2 === void 0) {
            to2 = VACANT_NODE_ID2;
          }
          if (label === void 0) {
            label = VACANT_EDGE_LABEL2;
          }
          this.id = id;
          this.from = from;
          this.to = to2;
          this.label = label;
        }
        return Edge4;
      }()
    );
    exports.Edge = Edge3;
    var Node3 = (
      /** @class */
      function() {
        function Node4(id, label) {
          if (id === void 0) {
            id = VACANT_NODE_ID2;
          }
          if (label === void 0) {
            label = VACANT_NODE_LABEL2;
          }
          this.id = id;
          this.label = label;
          this.edges = [];
          this.edgeMap = {};
        }
        Node4.prototype.addEdge = function(edge) {
          this.edges.push(edge);
          this.edgeMap[edge.id] = edge;
        };
        return Node4;
      }()
    );
    exports.Node = Node3;
    var Graph4 = (
      /** @class */
      function() {
        function Graph5(id, edgeIdAutoIncrease, directed) {
          if (id === void 0) {
            id = VACANT_NODE_ID2;
          }
          if (edgeIdAutoIncrease === void 0) {
            edgeIdAutoIncrease = true;
          }
          if (directed === void 0) {
            directed = false;
          }
          this.id = id;
          this.edgeIdAutoIncrease = edgeIdAutoIncrease;
          this.edges = [];
          this.nodes = [];
          this.nodeMap = {};
          this.edgeMap = {};
          this.nodeLabelMap = {};
          this.edgeLabelMap = {};
          this.counter = 0;
          this.directed = directed;
        }
        Graph5.prototype.getNodeNum = function() {
          return this.nodes.length;
        };
        Graph5.prototype.addNode = function(id, label) {
          if (this.nodeMap[id])
            return;
          var node = new Node3(id, label);
          this.nodes.push(node);
          this.nodeMap[id] = node;
          if (!this.nodeLabelMap[label])
            this.nodeLabelMap[label] = [];
          this.nodeLabelMap[label].push(id);
        };
        Graph5.prototype.addEdge = function(id, from, to2, label) {
          if (this.edgeIdAutoIncrease || id === void 0)
            id = this.counter++;
          if (this.nodeMap[from] && this.nodeMap[to2] && this.nodeMap[to2].edgeMap[id])
            return;
          var edge = new Edge3(id, from, to2, label);
          this.edges.push(edge);
          this.edgeMap[id] = edge;
          this.nodeMap[from].addEdge(edge);
          if (!this.edgeLabelMap[label])
            this.edgeLabelMap[label] = [];
          this.edgeLabelMap[label].push(edge);
          if (!this.directed) {
            var rEdge = new Edge3(id, to2, from, label);
            this.nodeMap[to2].addEdge(rEdge);
            this.edgeLabelMap[label].push(rEdge);
          }
        };
        return Graph5;
      }()
    );
    exports.Graph = Graph4;
  }
});

// node_modules/@antv/algorithm/lib/gSpan/gSpan.js
var require_gSpan = __commonJS({
  "node_modules/@antv/algorithm/lib/gSpan/gSpan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _struct = require_struct();
    var DFSedge2 = (
      /** @class */
      function() {
        function DFSedge3(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
          this.fromNode = fromNode;
          this.toNode = toNode;
          this.nodeEdgeNodeLabel = {
            nodeLabel1: fromNodeLabel || _struct.VACANT_NODE_LABEL,
            edgeLabel: edgeLabel || _struct.VACANT_EDGE_LABEL,
            nodeLabel2: toNodeLabel || _struct.VACANT_NODE_LABEL
          };
        }
        DFSedge3.prototype.equalTo = function(other) {
          return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;
        };
        DFSedge3.prototype.notEqualTo = function(other) {
          return !this.equalTo(other);
        };
        return DFSedge3;
      }()
    );
    var DFScode2 = (
      /** @class */
      function() {
        function DFScode3() {
          this.rmpath = [];
          this.dfsEdgeList = [];
        }
        DFScode3.prototype.equalTo = function(other) {
          var aLength = this.dfsEdgeList.length;
          var bLength = other.length;
          if (aLength !== bLength)
            return false;
          for (var i2 = 0; i2 < aLength; i2++) {
            if (this.dfsEdgeList[i2] !== other[i2])
              return false;
          }
          return true;
        };
        DFScode3.prototype.notEqualTo = function(other) {
          return !this.equalTo(other);
        };
        DFScode3.prototype.pushBack = function(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
          this.dfsEdgeList.push(new DFSedge2(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));
          return this.dfsEdgeList;
        };
        DFScode3.prototype.toGraph = function(graphId, directed) {
          if (graphId === void 0) {
            graphId = _struct.VACANT_GRAPH_ID;
          }
          if (directed === void 0) {
            directed = false;
          }
          var graph = new _struct.Graph(graphId, true, directed);
          this.dfsEdgeList.forEach(function(dfsEdge) {
            var fromNodeId = dfsEdge.fromNode;
            var toNodeId = dfsEdge.toNode;
            var _a2 = dfsEdge.nodeEdgeNodeLabel, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
            if (nodeLabel1 !== _struct.VACANT_NODE_LABEL)
              graph.addNode(fromNodeId, nodeLabel1);
            if (nodeLabel2 !== _struct.VACANT_NODE_LABEL)
              graph.addNode(toNodeId, nodeLabel2);
            if (nodeLabel1 !== _struct.VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1)
              graph.addEdge(void 0, fromNodeId, toNodeId, edgeLabel);
          });
          return graph;
        };
        DFScode3.prototype.buildRmpath = function() {
          this.rmpath = [];
          var oldFrom = void 0;
          var selfLength = this.dfsEdgeList.length;
          for (var i2 = selfLength - 1; i2 >= 0; i2--) {
            var dfsEdge = this.dfsEdgeList[i2];
            var fromNodeIdx = dfsEdge.fromNode;
            var toNodeIdx = dfsEdge.toNode;
            if (fromNodeIdx < toNodeIdx && (oldFrom === void 0 || toNodeIdx === oldFrom)) {
              this.rmpath.push(i2);
              oldFrom = fromNodeIdx;
            }
          }
          return this.rmpath;
        };
        DFScode3.prototype.getNodeNum = function() {
          var nodeMap = {};
          this.dfsEdgeList.forEach(function(dfsEdge) {
            if (!nodeMap[dfsEdge.fromNode])
              nodeMap[dfsEdge.fromNode] = true;
            if (!nodeMap[dfsEdge.toNode])
              nodeMap[dfsEdge.toNode] = true;
          });
          return Object.keys(nodeMap).length;
        };
        return DFScode3;
      }()
    );
    var History2 = (
      /** @class */
      function() {
        function History3(pdfs) {
          this.his = {};
          this.nodesUsed = {};
          this.edgesUsed = {};
          this.edges = [];
          if (!pdfs)
            return;
          while (pdfs) {
            var e8 = pdfs.edge;
            this.edges.push(e8);
            this.nodesUsed[e8.from] = 1;
            this.nodesUsed[e8.to] = 1;
            this.edgesUsed[e8.id] = 1;
            pdfs = pdfs.preNode;
          }
          this.edges = this.edges.reverse();
        }
        History3.prototype.hasNode = function(node) {
          return this.nodesUsed[node.id] === 1;
        };
        History3.prototype.hasEdge = function(edge) {
          return this.edgesUsed[edge.id] === 1;
        };
        return History3;
      }()
    );
    var GSpan2 = (
      /** @class */
      function() {
        function GSpan3(_a2) {
          var graphs = _a2.graphs, _b = _a2.minSupport, minSupport = _b === void 0 ? 2 : _b, _c = _a2.minNodeNum, minNodeNum = _c === void 0 ? 1 : _c, _d = _a2.maxNodeNum, maxNodeNum = _d === void 0 ? 4 : _d, _e2 = _a2.top, top = _e2 === void 0 ? 10 : _e2, _f = _a2.directed, directed = _f === void 0 ? false : _f, _g = _a2.verbose, verbose = _g === void 0 ? false : _g;
          this.graphs = graphs;
          this.dfsCode = new DFScode2();
          this.support = 0;
          this.frequentSize1Subgraphs = [];
          this.frequentSubgraphs = [];
          this.minSupport = minSupport;
          this.top = top;
          this.directed = directed;
          this.counter = 0;
          this.maxNodeNum = maxNodeNum;
          this.minNodeNum = minNodeNum;
          this.verbose = verbose;
          if (this.maxNodeNum < this.minNodeNum)
            this.maxNodeNum = this.minNodeNum;
          this.reportDF = [];
        }
        GSpan3.prototype.findForwardRootEdges = function(graph, fromNode) {
          var _this = this;
          var result = [];
          var nodeMap = graph.nodeMap;
          fromNode.edges.forEach(function(edge) {
            if (_this.directed || fromNode.label <= nodeMap[edge.to].label)
              result.push(edge);
          });
          return result;
        };
        GSpan3.prototype.findBackwardEdge = function(graph, edge1, edge2, history) {
          if (!this.directed && edge1 === edge2)
            return null;
          var nodeMap = graph.nodeMap;
          var edge2To = nodeMap[edge2.to];
          var edge2ToEdges = edge2To.edges;
          var edgeLength = edge2ToEdges.length;
          for (var i2 = 0; i2 < edgeLength; i2++) {
            var edge = edge2ToEdges[i2];
            if (history.hasEdge(edge) || edge.to !== edge1.from)
              continue;
            if (!this.directed) {
              if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {
                return edge;
              }
            } else {
              if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {
                return edge;
              }
            }
          }
          return null;
        };
        GSpan3.prototype.findForwardPureEdges = function(graph, rightmostEdge, minNodeLabel, history) {
          var result = [];
          var rightmostEdgeToId = rightmostEdge.to;
          var edges = graph.nodeMap[rightmostEdgeToId].edges;
          var edgeLength = edges.length;
          for (var i2 = 0; i2 < edgeLength; i2++) {
            var edge = edges[i2];
            var toNode = graph.nodeMap[edge.to];
            if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {
              result.push(edge);
            }
          }
          return result;
        };
        GSpan3.prototype.findForwardRmpathEdges = function(graph, rightmostEdge, minNodeLabel, history) {
          var result = [];
          var nodeMap = graph.nodeMap;
          var toNodeLabel = nodeMap[rightmostEdge.to].label;
          var fromNode = nodeMap[rightmostEdge.from];
          var edges = fromNode.edges;
          var edgeLength = edges.length;
          for (var i2 = 0; i2 < edgeLength; i2++) {
            var edge = edges[i2];
            var newToNodeLabel = nodeMap[edge.to].label;
            if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {
              continue;
            }
            if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {
              result.push(edge);
            }
          }
          return result;
        };
        GSpan3.prototype.getSupport = function(projected) {
          var graphMap = {};
          projected.forEach(function(pro) {
            if (!graphMap[pro.graphId])
              graphMap[pro.graphId] = true;
          });
          return Object.keys(graphMap).length;
        };
        GSpan3.prototype.findMinLabel = function(obj) {
          var minLabel = void 0;
          Object.keys(obj).forEach(function(nodeEdgeNodeLabel) {
            var _a2 = obj[nodeEdgeNodeLabel], nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
            if (!minLabel) {
              minLabel = {
                nodeLabel1,
                edgeLabel,
                nodeLabel2
              };
              return;
            }
            if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {
              minLabel = {
                nodeLabel1,
                edgeLabel,
                nodeLabel2
              };
            }
          });
          return minLabel;
        };
        GSpan3.prototype.isMin = function() {
          var _this = this;
          var dfsCode = this.dfsCode;
          if (this.verbose)
            console.log("isMin checking", dfsCode);
          if (dfsCode.dfsEdgeList.length === 1)
            return true;
          var directed = this.directed;
          var graph = dfsCode.toGraph(_struct.VACANT_GRAPH_ID, directed);
          var nodeMap = graph.nodeMap;
          var dfsCodeMin = new DFScode2();
          var root = {};
          graph.nodes.forEach(function(node) {
            var forwardEdges = _this.findForwardRootEdges(graph, node);
            forwardEdges.forEach(function(edge) {
              var otherNode = nodeMap[edge.to];
              var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(otherNode.label);
              if (!root[nodeEdgeNodeLabel])
                root[nodeEdgeNodeLabel] = {
                  projected: [],
                  nodeLabel1: node.label,
                  edgeLabel: edge.label,
                  nodeLabel2: otherNode.label
                };
              var pdfs = {
                graphId: graph.id,
                edge,
                preNode: null
              };
              root[nodeEdgeNodeLabel].projected.push(pdfs);
            });
          });
          var minLabel = this.findMinLabel(root);
          if (!minLabel)
            return;
          dfsCodeMin.dfsEdgeList.push(new DFSedge2(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2));
          var projectIsMin = function projectIsMin2(projected) {
            var rmpath = dfsCodeMin.buildRmpath();
            var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
            var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode;
            var backwardRoot = {};
            var flag = false, newTo = 0;
            var end2 = directed ? -1 : 0;
            var _loop_1 = function _loop_12(i3) {
              if (flag)
                return "break";
              projected.forEach(function(p2) {
                var history = new History2(p2);
                var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i3]], history.edges[rmpath[0]], history);
                if (backwardEdge) {
                  if (!backwardRoot[backwardEdge.label]) {
                    backwardRoot[backwardEdge.label] = {
                      projected: [],
                      edgeLabel: backwardEdge.label
                    };
                  }
                  backwardRoot[backwardEdge.label].projected.push({
                    graphId: graph.id,
                    edge: backwardRoot,
                    preNode: p2
                  });
                  newTo = dfsCodeMin.dfsEdgeList[rmpath[i3]].fromNode;
                  flag = true;
                }
              });
            };
            for (var i2 = rmpath.length - 1; i2 > end2; i2--) {
              var state_1 = _loop_1(i2);
              if (state_1 === "break")
                break;
            }
            if (flag) {
              var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);
              dfsCodeMin.dfsEdgeList.push(new DFSedge2(maxToC, newTo, _struct.VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, _struct.VACANT_NODE_LABEL));
              var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;
              if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1])
                return false;
              return projectIsMin2(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);
            }
            var forwardRoot = {};
            flag = false;
            var newFrom = 0;
            projected.forEach(function(p2) {
              var history = new History2(p2);
              var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
              if (forwardPureEdges.length > 0) {
                flag = true;
                newFrom = maxToC;
                forwardPureEdges.forEach(function(edge) {
                  var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                  if (!forwardRoot[key2])
                    forwardRoot[key2] = {
                      projected: [],
                      edgeLabel: edge.label,
                      nodeLabel2: nodeMap[edge.to].label
                    };
                  forwardRoot[key2].projected.push({
                    graphId: graph.id,
                    edge,
                    preNode: p2
                  });
                });
              }
            });
            var pathLength = rmpath.length;
            var _loop_2 = function _loop_22(i3) {
              if (flag)
                return "break";
              var value = rmpath[i3];
              projected.forEach(function(p2) {
                var history = new History2(p2);
                var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);
                if (forwardRmpathEdges.length > 0) {
                  flag = true;
                  newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;
                  forwardRmpathEdges.forEach(function(edge) {
                    var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                    if (!forwardRoot[key2])
                      forwardRoot[key2] = {
                        projected: [],
                        edgeLabel: edge.label,
                        nodeLabel2: nodeMap[edge.to].label
                      };
                    forwardRoot[key2].projected.push({
                      graphId: graph.id,
                      edge,
                      preNode: p2
                    });
                  });
                }
              });
            };
            for (var i2 = 0; i2 < pathLength; i2++) {
              var state_2 = _loop_2(i2);
              if (state_2 === "break")
                break;
            }
            if (!flag)
              return true;
            var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);
            dfsCodeMin.dfsEdgeList.push(new DFSedge2(newFrom, maxToC + 1, _struct.VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));
            var idx = dfsCodeMin.dfsEdgeList.length - 1;
            if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])
              return false;
            return projectIsMin2(forwardRoot["".concat(forwardMinEdgeNodeLabel.edgeLabel, "-").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);
          };
          var key = "".concat(minLabel.nodeLabel1, "-").concat(minLabel.edgeLabel, "-").concat(minLabel.nodeLabel2);
          return projectIsMin(root[key].projected);
        };
        GSpan3.prototype.report = function() {
          if (this.dfsCode.getNodeNum() < this.minNodeNum)
            return;
          this.counter++;
          var graph = this.dfsCode.toGraph(this.counter, this.directed);
          this.frequentSubgraphs.push((0, _util.clone)(graph));
        };
        GSpan3.prototype.subGraphMining = function(projected) {
          var _this = this;
          var support = this.getSupport(projected);
          if (support < this.minSupport)
            return;
          if (!this.isMin())
            return;
          this.report();
          var nodeNum = this.dfsCode.getNodeNum();
          var rmpath = this.dfsCode.buildRmpath();
          var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;
          var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
          var forwardRoot = {};
          var backwardRoot = {};
          projected.forEach(function(p2) {
            var graph = _this.graphs[p2.graphId];
            var nodeMap = graph.nodeMap;
            var history = new History2(p2);
            for (var i2 = rmpath.length - 1; i2 >= 0; i2--) {
              var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i2]], history.edges[rmpath[0]], history);
              if (backwardEdge) {
                var key = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode, "-").concat(backwardEdge.label);
                if (!backwardRoot[key])
                  backwardRoot[key] = {
                    projected: [],
                    toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode,
                    edgeLabel: backwardEdge.label
                  };
                backwardRoot[key].projected.push({
                  graphId: p2.graphId,
                  edge: backwardEdge,
                  preNode: p2
                });
              }
            }
            if (nodeNum >= _this.maxNodeNum)
              return;
            var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
            forwardPureEdges.forEach(function(edge) {
              var key2 = "".concat(maxToC, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
              if (!forwardRoot[key2])
                forwardRoot[key2] = {
                  projected: [],
                  fromNodeId: maxToC,
                  edgeLabel: edge.label,
                  nodeLabel2: nodeMap[edge.to].label
                };
              forwardRoot[key2].projected.push({
                graphId: p2.graphId,
                edge,
                preNode: p2
              });
            });
            var _loop_3 = function _loop_32(i3) {
              var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i3]], minNodeLabel, history);
              forwardRmpathEdges.forEach(function(edge) {
                var key2 = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
                if (!forwardRoot[key2])
                  forwardRoot[key2] = {
                    projected: [],
                    fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode,
                    edgeLabel: edge.label,
                    nodeLabel2: nodeMap[edge.to].label
                  };
                forwardRoot[key2].projected.push({
                  graphId: p2.graphId,
                  edge,
                  preNode: p2
                });
              });
            };
            for (var i2 = 0; i2 < rmpath.length; i2++) {
              _loop_3(i2);
            }
          });
          Object.keys(backwardRoot).forEach(function(key) {
            var _a2 = backwardRoot[key], toNodeId = _a2.toNodeId, edgeLabel = _a2.edgeLabel;
            _this.dfsCode.dfsEdgeList.push(new DFSedge2(maxToC, toNodeId, "-1", edgeLabel, "-1"));
            _this.subGraphMining(backwardRoot[key].projected);
            _this.dfsCode.dfsEdgeList.pop();
          });
          Object.keys(forwardRoot).forEach(function(key) {
            var _a2 = forwardRoot[key], fromNodeId = _a2.fromNodeId, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
            _this.dfsCode.dfsEdgeList.push(new DFSedge2(fromNodeId, maxToC + 1, _struct.VACANT_NODE_LABEL, edgeLabel, nodeLabel2));
            _this.subGraphMining(forwardRoot[key].projected);
            _this.dfsCode.dfsEdgeList.pop();
          });
        };
        GSpan3.prototype.generate1EdgeFrequentSubGraphs = function() {
          var graphs = this.graphs;
          var directed = this.directed;
          var minSupport = this.minSupport;
          var frequentSize1Subgraphs = this.frequentSize1Subgraphs;
          var nodeLabelCounter = {}, nodeEdgeNodeCounter = {};
          var nodeLableCounted = {};
          var nodeEdgeNodeLabelCounted = {};
          Object.keys(graphs).forEach(function(key) {
            var graph = graphs[key];
            var nodeMap = graph.nodeMap;
            graph.nodes.forEach(function(node, i2) {
              var nodeLabel = node.label;
              var graphNodeKey = "".concat(key, "-").concat(nodeLabel);
              if (!nodeLableCounted[graphNodeKey]) {
                var counter = nodeLabelCounter[nodeLabel] || 0;
                counter++;
                nodeLabelCounter[nodeLabel] = counter;
              }
              nodeLableCounted[graphNodeKey] = {
                graphKey: key,
                label: nodeLabel
              };
              node.edges.forEach(function(edge) {
                var nodeLabel1 = nodeLabel;
                var nodeLabel2 = nodeMap[edge.to].label;
                if (!directed && nodeLabel1 > nodeLabel2) {
                  var tmp = nodeLabel2;
                  nodeLabel2 = nodeLabel1;
                  nodeLabel1 = tmp;
                }
                var edgeLabel = edge.label;
                var graphNodeEdgeNodeKey = "".concat(key, "-").concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
                var nodeEdgeNodeKey = "".concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
                if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {
                  var counter2 = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;
                  counter2++;
                  nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter2;
                }
                nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {
                  graphId: key,
                  nodeLabel1,
                  edgeLabel,
                  nodeLabel2
                };
              });
            });
          });
          Object.keys(nodeLabelCounter).forEach(function(label) {
            var count = nodeLabelCounter[label];
            if (count < minSupport)
              return;
            var g2 = {
              nodes: [],
              edges: []
            };
            g2.nodes.push({
              id: "0",
              label
            });
            frequentSize1Subgraphs.push(g2);
          });
          return frequentSize1Subgraphs;
        };
        GSpan3.prototype.run = function() {
          var _this = this;
          this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();
          if (this.maxNodeNum < 2)
            return;
          var graphs = this.graphs;
          var directed = this.directed;
          var root = {};
          Object.keys(graphs).forEach(function(graphId) {
            var graph = graphs[graphId];
            var nodeMap = graph.nodeMap;
            graph.nodes.forEach(function(node) {
              var forwardRootEdges = _this.findForwardRootEdges(graph, node);
              forwardRootEdges.forEach(function(edge) {
                var toNode = nodeMap[edge.to];
                var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(toNode.label);
                if (!root[nodeEdgeNodeLabel])
                  root[nodeEdgeNodeLabel] = {
                    projected: [],
                    nodeLabel1: node.label,
                    edgeLabel: edge.label,
                    nodeLabel2: toNode.label
                  };
                var pdfs = {
                  graphId,
                  edge,
                  preNode: null
                };
                root[nodeEdgeNodeLabel].projected.push(pdfs);
              });
            });
          });
          Object.keys(root).forEach(function(nodeEdgeNodeLabel) {
            var _a2 = root[nodeEdgeNodeLabel], projected = _a2.projected, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
            _this.dfsCode.dfsEdgeList.push(new DFSedge2(0, 1, nodeLabel1, edgeLabel, nodeLabel2));
            _this.subGraphMining(projected);
            _this.dfsCode.dfsEdgeList.pop();
          });
        };
        return GSpan3;
      }()
    );
    var formatGraphs3 = function formatGraphs4(graphs, directed, nodeLabelProp, edgeLabelProp) {
      var result = {};
      Object.keys(graphs).forEach(function(key, i2) {
        var graph = graphs[key];
        var fGraph = new _struct.Graph(i2, true, directed);
        var nodeIdxMap = {};
        graph.nodes.forEach(function(node, j2) {
          fGraph.addNode(j2, node[nodeLabelProp]);
          nodeIdxMap[node.id] = j2;
        });
        graph.edges.forEach(function(edge, k2) {
          var sourceIdx = nodeIdxMap[edge.source];
          var targetIdx = nodeIdxMap[edge.target];
          fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);
        });
        if (fGraph && fGraph.getNodeNum())
          result[fGraph.id] = fGraph;
      });
      return result;
    };
    var toGraphDatas3 = function toGraphDatas4(graphs, nodeLabelProp, edgeLabelProp) {
      var result = [];
      graphs.forEach(function(graph) {
        var graphData = {
          nodes: [],
          edges: []
        };
        graph.nodes.forEach(function(node) {
          var _a2;
          graphData.nodes.push((_a2 = {
            id: "".concat(node.id)
          }, _a2[nodeLabelProp] = node.label, _a2));
        });
        graph.edges.forEach(function(edge) {
          var _a2;
          graphData.edges.push((_a2 = {
            source: "".concat(edge.from),
            target: "".concat(edge.to)
          }, _a2[edgeLabelProp] = edge.label, _a2));
        });
        result.push(graphData);
      });
      return result;
    };
    var DEFAULT_LABEL_NAME2 = "cluster";
    var gSpan3 = function gSpan4(params) {
      var graphs = params.graphs, _a2 = params.directed, directed = _a2 === void 0 ? false : _a2, _b = params.nodeLabelProp, nodeLabelProp = _b === void 0 ? DEFAULT_LABEL_NAME2 : _b, _c = params.edgeLabelProp, edgeLabelProp = _c === void 0 ? DEFAULT_LABEL_NAME2 : _c;
      var formattedGraphs = formatGraphs3(graphs, directed, nodeLabelProp, edgeLabelProp);
      var minSupport = params.minSupport, maxNodeNum = params.maxNodeNum, minNodeNum = params.minNodeNum, verbose = params.verbose, top = params.top;
      var algoParams = {
        graphs: formattedGraphs,
        minSupport,
        maxNodeNum,
        minNodeNum,
        top,
        verbose,
        directed
      };
      var calculator = new GSpan2(algoParams);
      calculator.run();
      var result = toGraphDatas3(calculator.frequentSubgraphs, nodeLabelProp, edgeLabelProp);
      return result;
    };
    var _default = gSpan3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/gaddi.js
var require_gaddi = __commonJS({
  "node_modules/@antv/algorithm/lib/gaddi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _tslib = require_tslib();
    var _floydWarshall = _interopRequireDefault(require_floydWarshall());
    var _gSpan = _interopRequireDefault(require_gSpan());
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var findKNeighborUnits3 = function findKNeighborUnits4(graphData, spm, nodeLabelProp, k2) {
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (k2 === void 0) {
        k2 = 2;
      }
      var units = [];
      var nodes = graphData.nodes;
      spm.forEach(function(row, i2) {
        units.push(findKNeighborUnit3(nodes, row, i2, nodeLabelProp, k2));
      });
      return units;
    };
    var findKNeighborUnit3 = function findKNeighborUnit4(nodes, row, i2, nodeLabelProp, k2) {
      var unitNodeIdxs = [i2];
      var neighbors = [];
      var labelCountMap = {};
      row.forEach(function(v2, j2) {
        if (v2 <= k2 && i2 !== j2) {
          unitNodeIdxs.push(j2);
          neighbors.push(nodes[j2]);
          var label = nodes[j2][nodeLabelProp];
          if (!labelCountMap[label])
            labelCountMap[label] = {
              count: 1,
              dists: [v2]
            };
          else {
            labelCountMap[label].count++;
            labelCountMap[label].dists.push(v2);
          }
        }
      });
      Object.keys(labelCountMap).forEach(function(label) {
        labelCountMap[label].dists = labelCountMap[label].dists.sort(function(a3, b2) {
          return a3 - b2;
        });
      });
      return {
        nodeIdx: i2,
        nodeId: nodes[i2].id,
        nodeIdxs: unitNodeIdxs,
        neighbors,
        neighborNum: unitNodeIdxs.length - 1,
        nodeLabelCountMap: labelCountMap
      };
    };
    var findNodePairsRandomly3 = function findNodePairsRandomly4(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm) {
      var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);
      var nodePairMap = {};
      var foundNodePairCount = 0;
      kNeighborUnits.forEach(function(unit, i2) {
        var nodePairForICount = 0;
        var outerLoopCount = 0;
        var neighbors = unit.nodeIdxs;
        var neighborNum = unit.neighborNum - 1;
        while (nodePairForICount < nodePairNumEachNode) {
          var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];
          var innerLoopCount = 0;
          while (nodePairMap["".concat(i2, "-").concat(oidx)] || nodePairMap["".concat(oidx, "-").concat(i2)]) {
            oidx = Math.floor(Math.random() * nodeNum);
            innerLoopCount++;
            if (innerLoopCount > 2 * nodeNum)
              break;
          }
          if (innerLoopCount < 2 * nodeNum) {
            nodePairMap["".concat(i2, "-").concat(oidx)] = {
              start: i2,
              end: oidx,
              distance: spm[i2][oidx]
            };
            nodePairForICount++;
            foundNodePairCount++;
            if (foundNodePairCount >= maxNodePairNum)
              return nodePairMap;
          }
          outerLoopCount++;
          if (outerLoopCount > 2 * nodeNum)
            break;
        }
        if (nodePairForICount < nodePairNumEachNode) {
          var gap = nodePairNumEachNode - nodePairForICount;
          nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i2 - 1);
        }
      });
      return nodePairMap;
    };
    var getIntersectNeighborInducedGraph3 = function getIntersectNeighborInducedGraph4(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {
      var nodes = graphData.nodes;
      if (!cachedInducedGraphMap)
        cachedInducedGraphMap = {};
      Object.keys(nodePairMap).forEach(function(key) {
        var _a2, _b;
        if (cachedInducedGraphMap && cachedInducedGraphMap[key])
          return;
        cachedInducedGraphMap[key] = {
          nodes: [],
          edges: []
        };
        var pair = nodePairMap[key];
        var startUnitNodeIds = (_a2 = neighborUnits[pair.start]) === null || _a2 === void 0 ? void 0 : _a2.nodeIdxs;
        var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;
        if (!startUnitNodeIds || !endUnitNodeIds)
          return;
        var endSet = new Set(endUnitNodeIds);
        var intersect = startUnitNodeIds.filter(function(x4) {
          return endSet.has(x4);
        });
        if (!intersect || !intersect.length)
          return;
        var intersectIdMap = {};
        var intersectLength = intersect.length;
        for (var i2 = 0; i2 < intersectLength; i2++) {
          var node = nodes[intersect[i2]];
          cachedInducedGraphMap[key].nodes.push(node);
          intersectIdMap[node.id] = true;
        }
        graphData.edges.forEach(function(edge) {
          if (intersectIdMap[edge.source] && intersectIdMap[edge.target])
            cachedInducedGraphMap[key].edges.push(edge);
        });
      });
      return cachedInducedGraphMap;
    };
    var getMatchedCount3 = function getMatchedCount4(graph, structure, nodeLabelProp, edgeLabelProp) {
      var _a2, _b;
      var nodeMap = {};
      graph.nodes.forEach(function(node) {
        nodeMap[node.id] = node;
      });
      var count = 0;
      if (!((_a2 = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2)
        return 0;
      graph.edges.forEach(function(e8) {
        var sourceLabel = nodeMap[e8.source][nodeLabelProp];
        var targetLabel = nodeMap[e8.target][nodeLabelProp];
        var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];
        var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];
        var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];
        if (e8[edgeLabelProp] !== strEdgeLabel)
          return;
        if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {
          count++;
        }
      });
      return count;
    };
    var findRepresentStructure3 = function findRepresentStructure4(matchedCountMap, structureNum, structures) {
      var maxOffset = Infinity, representClusterType = 0;
      var _loop_1 = function _loop_12(i3) {
        var countMapI = matchedCountMap[i3];
        var sortedGraphKeys = Object.keys(countMapI).sort(function(a3, b2) {
          return countMapI[a3] - countMapI[b2];
        });
        var groupNum = 10;
        var clusters = [];
        sortedGraphKeys.forEach(function(key, j2) {
          if (!clusters[j2 % groupNum])
            clusters[j2 % groupNum] = {
              graphs: [],
              totalCount: 0,
              aveCount: 0
            };
          clusters[j2 % groupNum].graphs.push(key);
          clusters[j2 % groupNum].totalCount += countMapI[key];
        });
        var aveIntraDist = 0;
        var aveCounts = [];
        clusters.forEach(function(graphsInCluster) {
          var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;
          graphsInCluster.aveCount = aveCount;
          aveCounts.push(aveCount);
          var aveIntraPerCluster = 0;
          var graphsNum = graphsInCluster.length;
          graphsInCluster.graphs.forEach(function(graphKey1, j2) {
            var graph1Count = countMapI[graphKey1];
            graphsInCluster.graphs.forEach(function(graphKey2, k2) {
              if (j2 === k2)
                return;
              aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);
            });
          });
          aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;
          aveIntraDist += aveIntraPerCluster;
        });
        aveIntraDist /= clusters.length;
        var aveInterDist = 0;
        aveCounts.forEach(function(aveCount1, j2) {
          aveCounts.forEach(function(aveCount2, k2) {
            if (j2 === k2)
              return;
            aveInterDist += Math.abs(aveCount1 - aveCount2);
          });
          aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;
        });
        var offset = aveInterDist - aveIntraDist;
        if (maxOffset < offset) {
          maxOffset = offset;
          representClusterType = i3;
        }
      };
      for (var i2 = 0; i2 < structureNum; i2++) {
        _loop_1(i2);
      }
      return {
        structure: structures[representClusterType],
        structureCountMap: matchedCountMap[representClusterType]
      };
    };
    var getNodeMaps3 = function getNodeMaps4(nodes, nodeLabelProp) {
      var nodeMap = {}, nodeLabelMap = {};
      nodes.forEach(function(node, i2) {
        nodeMap[node.id] = {
          idx: i2,
          node,
          degree: 0,
          inDegree: 0,
          outDegree: 0
        };
        var label = node[nodeLabelProp];
        if (!nodeLabelMap[label])
          nodeLabelMap[label] = [];
        nodeLabelMap[label].push(node);
      });
      return {
        nodeMap,
        nodeLabelMap
      };
    };
    var getEdgeMaps3 = function getEdgeMaps4(edges, edgeLabelProp, nodeMap) {
      var edgeMap = {}, edgeLabelMap = {};
      edges.forEach(function(edge, i2) {
        edgeMap["".concat(_util.uniqueId)] = {
          idx: i2,
          edge
        };
        var label = edge[edgeLabelProp];
        if (!edgeLabelMap[label])
          edgeLabelMap[label] = [];
        edgeLabelMap[label].push(edge);
        var sourceNode = nodeMap[edge.source];
        if (sourceNode) {
          sourceNode.degree++;
          sourceNode.outDegree++;
        }
        var targetNode = nodeMap[edge.target];
        if (targetNode) {
          targetNode.degree++;
          targetNode.inDegree++;
        }
      });
      return {
        edgeMap,
        edgeLabelMap
      };
    };
    var getSpmMap3 = function getSpmMap4(nodes, spm, directed) {
      var length = spm.length;
      var map3 = {};
      spm.forEach(function(row, i2) {
        var start = directed ? 0 : i2 + 1;
        var iId = nodes[i2].id;
        for (var j2 = start; j2 < length; j2++) {
          if (i2 === j2)
            continue;
          var jId = nodes[j2].id;
          var dist = row[j2];
          map3["".concat(iId, "-").concat(jId)] = dist;
          if (!directed)
            map3["".concat(jId, "-").concat(iId)] = dist;
        }
      });
      return map3;
    };
    var getNDSDist3 = function getNDSDist4(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {
      var _a2;
      var key = "".concat(node1.id, "-").concat(node2.id);
      if (cachedNDSMap && cachedNDSMap[key])
        return cachedNDSMap[key];
      var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : void 0;
      if (!interInducedGraph) {
        var pairMap = (_a2 = {}, _a2[key] = {
          start: nodeMap[node1.id].idx,
          end: nodeMap[node2.id].idx,
          distance: spDist
        }, _a2);
        cachedInterInducedGraph = getIntersectNeighborInducedGraph3(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);
        interInducedGraph = cachedInterInducedGraph[key];
      }
      return getMatchedCount3(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);
    };
    var stashPatternNodeLabelDegreeMap3 = function stashPatternNodeLabelDegreeMap4(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {
      var _a2, _b, _c;
      var minPatternNodeLabelDegree = (_a2 = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a2 === void 0 ? void 0 : _a2.degree;
      var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;
      var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;
      if (minPatternNodeLabelDegreeMap[neighborLabel] === void 0) {
        minPatternNodeLabelDegree = Infinity;
        minPatternNodeLabelInDegree = Infinity;
        minPatternNodeLabelOutDegree = Infinity;
        patternNodeLabelMap[neighborLabel].forEach(function(patternNodeWithLabel) {
          var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;
          if (minPatternNodeLabelDegree > patternNodeDegree)
            minPatternNodeLabelDegree = patternNodeDegree;
          var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;
          if (minPatternNodeLabelInDegree > patternNodeInDegree)
            minPatternNodeLabelInDegree = patternNodeInDegree;
          var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;
          if (minPatternNodeLabelOutDegree > patternNodeOutDegree)
            minPatternNodeLabelOutDegree = patternNodeOutDegree;
        });
        minPatternNodeLabelDegreeMap[neighborLabel] = {
          degree: minPatternNodeLabelDegree,
          inDegree: minPatternNodeLabelInDegree,
          outDegree: minPatternNodeLabelOutDegree
        };
      }
      return {
        minPatternNodeLabelDegree,
        minPatternNodeLabelInDegree,
        minPatternNodeLabelOutDegree
      };
    };
    var GADDI3 = function GADDI4(graphData, pattern, directed, k2, length, nodeLabelProp, edgeLabelProp) {
      var _a2;
      if (directed === void 0) {
        directed = false;
      }
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (edgeLabelProp === void 0) {
        edgeLabelProp = "cluster";
      }
      if (!graphData || !graphData.nodes)
        return;
      var nodeNum = graphData.nodes.length;
      if (!nodeNum)
        return;
      var spm = (0, _floydWarshall.default)(graphData, directed);
      var patternSpm = (0, _floydWarshall.default)(pattern, directed);
      var spmMap = getSpmMap3(graphData.nodes, spm, directed);
      var patternSpmMap = getSpmMap3(pattern.nodes, patternSpm, directed);
      var _b = getNodeMaps3(graphData.nodes, nodeLabelProp), nodeMap = _b.nodeMap, nodeLabelMap = _b.nodeLabelMap;
      var _c = getNodeMaps3(pattern.nodes, nodeLabelProp), patternNodeMap = _c.nodeMap, patternNodeLabelMap = _c.nodeLabelMap;
      getEdgeMaps3(graphData.edges, edgeLabelProp, nodeMap);
      var patternEdgeLabelMap = getEdgeMaps3(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap;
      var patternSpmSpread = [];
      patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function(row) {
        patternSpmSpread = patternSpmSpread.concat(row);
      });
      if (!length)
        length = Math.max.apply(Math, (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], patternSpmSpread, false), [2], false));
      if (!k2)
        k2 = length;
      var kNeighborUnits = findKNeighborUnits3(graphData, spm, nodeLabelProp, k2);
      var patternKNeighborUnits = findKNeighborUnits3(pattern, patternSpm, nodeLabelProp, k2);
      var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);
      var nodePairsMap = findNodePairsRandomly3(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm);
      var intGMap = getIntersectNeighborInducedGraph3(nodePairsMap, kNeighborUnits, graphData);
      var top = 10, minSupport = 1, minNodeNum = 1, maxNodeNum = 4;
      var params = {
        graphs: intGMap,
        nodeLabelProp,
        edgeLabelProp,
        minSupport,
        minNodeNum,
        maxNodeNum,
        directed
      };
      var freStructures = (0, _gSpan.default)(params).slice(0, top);
      var structureNum = freStructures.length;
      var matchedCountMap = [];
      freStructures.forEach(function(structure, i3) {
        matchedCountMap[i3] = {};
        Object.keys(intGMap).forEach(function(key) {
          var graph = intGMap[key];
          var subStructureCount = getMatchedCount3(graph, structure, nodeLabelProp, edgeLabelProp);
          matchedCountMap[i3][key] = subStructureCount;
        });
      });
      var _d = findRepresentStructure3(matchedCountMap, structureNum, freStructures), dsG = _d.structure, ndsDist = _d.structureCountMap;
      var beginPNode = pattern.nodes[0], candidates = [], label = (_a2 = pattern.nodes[0]) === null || _a2 === void 0 ? void 0 : _a2[nodeLabelProp], maxNodeNumWithSameLabel = -Infinity;
      pattern.nodes.forEach(function(node) {
        var pLabel = node[nodeLabelProp];
        var nodesWithSameLabel = nodeLabelMap[pLabel];
        if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {
          maxNodeNumWithSameLabel = nodesWithSameLabel.length;
          candidates = nodesWithSameLabel;
          label = pLabel;
          beginPNode = node;
        }
      });
      var minPatternNodeLabelDegreeMap = {};
      var patternIntGraphMap = {}, patternNDSDist = {}, patternNDSDistMap = {};
      var patternSpDist = {};
      var patternSpDistBack = {};
      Object.keys(patternNodeLabelMap).forEach(function(label2, j2) {
        patternSpDist[label2] = [];
        if (directed) {
          patternSpDistBack[label2] = [];
        }
        var maxDist = -Infinity;
        var patternNodesWithLabel2 = patternNodeLabelMap[label2];
        var patternNodePairMap = {};
        patternNodesWithLabel2.forEach(function(nodeWithLabel2) {
          var dist = patternSpmMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)];
          dist && patternSpDist[label2].push(dist);
          if (maxDist < dist)
            maxDist = dist;
          patternNodePairMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)] = {
            start: 0,
            end: patternNodeMap[nodeWithLabel2.id].idx,
            distance: dist
          };
          if (directed) {
            var distBack = patternSpmMap["".concat(nodeWithLabel2.id, "-").concat(beginPNode.id)];
            distBack && patternSpDistBack[label2].push(distBack);
          }
        });
        patternSpDist[label2] = patternSpDist[label2].sort(function(a3, b2) {
          return a3 - b2;
        });
        if (directed)
          patternSpDistBack[label2] = patternSpDistBack[label2].sort(function(a3, b2) {
            return a3 - b2;
          });
        patternIntGraphMap = getIntersectNeighborInducedGraph3(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap);
        var currentPatternNDSDistArray = [];
        Object.keys(patternNodePairMap).forEach(function(key) {
          if (patternNDSDist[key]) {
            currentPatternNDSDistArray.push(patternNDSDist[key]);
            return;
          }
          var patternIntGraph = patternIntGraphMap[key];
          patternNDSDist[key] = getMatchedCount3(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);
          currentPatternNDSDistArray.push(patternNDSDist[key]);
        });
        currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function(a3, b2) {
          return b2 - a3;
        });
        patternNDSDistMap["".concat(beginPNode.id, "-").concat(label2)] = currentPatternNDSDistArray;
        if (label2 === label)
          return;
        var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;
        var _loop_4 = function _loop_42(m4) {
          var cNode = candidates[m4];
          var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];
          var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];
          var patternLabel2Num = patternNodeLabelMap[label2].length;
          if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {
            candidates.splice(m4, 1);
            return "continue";
          }
          var prune2Invalid = false;
          for (var n2 = 0; n2 < patternLabel2Num; n2++) {
            if (graphNeighborUnitCountMap.dists[n2] > patternSpDist[label2][n2]) {
              prune2Invalid = true;
              break;
            }
          }
          if (prune2Invalid) {
            candidates.splice(m4, 1);
            return "continue";
          }
          var cNodePairMap = {};
          graphNeighborUnit.neighbors.forEach(function(neighborNode) {
            var dist = spmMap["".concat(cNode.id, "-").concat(neighborNode.id)];
            cNodePairMap["".concat(cNode.id, "-").concat(neighborNode.id)] = {
              start: nodeMap[cNode.id].idx,
              end: nodeMap[neighborNode.id].idx,
              distance: dist
            };
          });
          intGMap = getIntersectNeighborInducedGraph3(cNodePairMap, kNeighborUnits, graphData, intGMap);
          var currentNDSDistArray = [];
          Object.keys(cNodePairMap).forEach(function(key) {
            if (ndsDist[key]) {
              currentNDSDistArray.push(ndsDist[key]);
              return;
            }
            var intGraph = intGMap[key];
            ndsDist[key] = getMatchedCount3(intGraph, dsG, nodeLabelProp, edgeLabelProp);
            currentNDSDistArray.push(ndsDist[key]);
          });
          currentNDSDistArray = currentNDSDistArray.sort(function(a3, b2) {
            return b2 - a3;
          });
          var prune3Invalid = false;
          for (var n2 = 0; n2 < patternLabel2Num; n2++) {
            if (currentNDSDistArray[n2] < currentPatternNDSDistArray[n2]) {
              prune3Invalid = true;
              break;
            }
          }
          if (prune3Invalid) {
            candidates.splice(m4, 1);
            return "continue";
          }
        };
        for (var m3 = candidatesNum - 1; m3 >= 0; m3--) {
          _loop_4(m3);
        }
      });
      var candidateGraphs = [];
      candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function(candidate) {
        var nodeIdx = nodeMap[candidate.id].idx;
        var lengthNeighborUnit = findKNeighborUnit3(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);
        var neighborNodes = lengthNeighborUnit.neighbors;
        var neighborNum = neighborNodes.length;
        var unmatched = false;
        for (var i3 = neighborNum - 1; i3 >= 0; i3--) {
          if (neighborNodes.length + 1 < pattern.nodes.length) {
            unmatched = true;
            return;
          }
          var neighborNode = neighborNodes[i3];
          var neighborLabel = neighborNode[nodeLabelProp];
          if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          var key = "".concat(candidate.id, "-").concat(neighborNode.id);
          var distToCandidate = spmMap[key];
          var idx = patternSpDist[neighborLabel].length - 1;
          var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx];
          if (distToCandidate > maxDistWithLabelInPattern) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          if (directed) {
            var keyBack = "".concat(neighborNode.id, "-").concat(candidate.id);
            var distFromCandidate = spmMap[keyBack];
            idx = patternSpDistBack[neighborLabel].length - 1;
            var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];
            if (distFromCandidate > maxBackDistWithLabelInPattern) {
              neighborNodes.splice(i3, 1);
              continue;
            }
          }
          var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist3(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);
          var patternKey = "".concat(beginPNode.id, "-").concat(neighborLabel);
          var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1];
          if (ndsToCandidate < minNdsWithLabelInPattern) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          var _a3 = stashPatternNodeLabelDegreeMap3(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _a3.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _a3.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _a3.minPatternNodeLabelOutDegree;
          if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {
            neighborNodes.splice(i3, 1);
            continue;
          }
        }
        if (!unmatched) {
          candidateGraphs.push({
            nodes: [candidate].concat(neighborNodes)
          });
        }
      });
      var undirectedLengthsToBeginPNode = (0, _dijkstra.default)(pattern, beginPNode.id, false).length;
      var undirectedLengthsToBeginPNodeLabelMap = {};
      if (directed) {
        Object.keys(undirectedLengthsToBeginPNode).forEach(function(nodeId) {
          var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];
          if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel])
            undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];
          else
            undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);
        });
        Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function(pLabel) {
          undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function(a3, b2) {
            return a3 - b2;
          });
        });
      } else {
        undirectedLengthsToBeginPNodeLabelMap = patternSpDist;
      }
      var candidateGraphNum = candidateGraphs.length;
      var _loop_2 = function _loop_22(i3) {
        var candidateGraph = candidateGraphs[i3];
        var candidate = candidateGraph.nodes[0];
        var candidateNodeLabelCountMap = {};
        var candidateNodeMap = {};
        candidateGraph.nodes.forEach(function(node, q2) {
          candidateNodeMap[node.id] = {
            idx: q2,
            node,
            degree: 0,
            inDegree: 0,
            outDegree: 0
          };
          var cNodeLabel2 = node[nodeLabelProp];
          if (!candidateNodeLabelCountMap[cNodeLabel2])
            candidateNodeLabelCountMap[cNodeLabel2] = 1;
          else
            candidateNodeLabelCountMap[cNodeLabel2]++;
        });
        var candidateEdges = [];
        var edgeLabelCountMap = {};
        graphData.edges.forEach(function(edge) {
          if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {
            candidateEdges.push(edge);
            if (!edgeLabelCountMap[edge[edgeLabelProp]])
              edgeLabelCountMap[edge[edgeLabelProp]] = 1;
            else
              edgeLabelCountMap[edge[edgeLabelProp]]++;
            candidateNodeMap[edge.source].degree++;
            candidateNodeMap[edge.target].degree++;
            candidateNodeMap[edge.source].outDegree++;
            candidateNodeMap[edge.target].inDegree++;
          }
        });
        var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;
        var prunedByEdgeLabel = false;
        for (var e8 = 0; e8 < pattenrEdgeLabelNum; e8++) {
          var label_1 = Object.keys(patternEdgeLabelMap)[e8];
          if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {
            prunedByEdgeLabel = true;
            break;
          }
        }
        if (prunedByEdgeLabel) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        var candidateEdgeNum = candidateEdges.length;
        if (candidateEdgeNum < pattern.edges.length) {
          candidateGraphs.splice(i3, 1);
          return "break";
        }
        var candidateGraphInvalid = false;
        var _loop_5 = function _loop_52(e9) {
          var edge = candidateEdges[e9];
          var edgeLabel2 = edge[edgeLabelProp];
          var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel2];
          if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {
            edgeLabelCountMap[edgeLabel2]--;
            if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
              candidateGraphInvalid = true;
              return "break";
            }
            candidateEdges.splice(e9, 1);
            candidateNodeMap[edge.source].degree--;
            candidateNodeMap[edge.target].degree--;
            candidateNodeMap[edge.source].outDegree--;
            candidateNodeMap[edge.target].inDegree--;
            return "continue";
          }
          var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];
          var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];
          var edgeMatched = false;
          patternEdgesWithLabel.forEach(function(patternEdge) {
            var patternSource = patternNodeMap[patternEdge.source].node;
            var patternTarget = patternNodeMap[patternEdge.target].node;
            if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel)
              edgeMatched = true;
            if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel)
              edgeMatched = true;
          });
          if (!edgeMatched) {
            edgeLabelCountMap[edgeLabel2]--;
            if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
              candidateGraphInvalid = true;
              return "break";
            }
            candidateEdges.splice(e9, 1);
            candidateNodeMap[edge.source].degree--;
            candidateNodeMap[edge.target].degree--;
            candidateNodeMap[edge.source].outDegree--;
            candidateNodeMap[edge.target].inDegree--;
            return "continue";
          }
        };
        for (var e8 = candidateEdgeNum - 1; e8 >= 0; e8--) {
          var state_2 = _loop_5(e8);
          if (state_2 === "break")
            break;
        }
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        candidateGraph.edges = candidateEdges;
        var lengthsToCandidate = (0, _dijkstra.default)(candidateGraph, candidateGraph.nodes[0].id, false).length;
        Object.keys(lengthsToCandidate).reverse().forEach(function(targetId) {
          if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid)
            return;
          if (lengthsToCandidate[targetId] === Infinity) {
            var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
            candidateNodeLabelCountMap[targetNodeLabel]--;
            if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
              candidateGraphInvalid = true;
              return;
            }
            var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
            candidateGraph.nodes.splice(idx, 1);
            candidateNodeMap[targetId] = void 0;
            return;
          }
          var nLabel = nodeMap[targetId].node[nodeLabelProp];
          if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {
            var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
            candidateNodeLabelCountMap[targetNodeLabel]--;
            if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
              candidateGraphInvalid = true;
              return;
            }
            var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
            candidateGraph.nodes.splice(idx, 1);
            candidateNodeMap[targetId] = void 0;
          }
        });
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        var degreeChanged = true;
        var loopCount = 0;
        while (degreeChanged && !candidateGraphInvalid) {
          degreeChanged = false;
          var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;
          if (condition) {
            candidateGraphInvalid = true;
            break;
          }
          if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {
            candidateGraphInvalid = true;
            break;
          }
          var currentCandidateNodeNum = candidateGraph.nodes.length;
          for (var o2 = currentCandidateNodeNum - 1; o2 >= 0; o2--) {
            var cgNode = candidateGraph.nodes[o2];
            var nodeDegree = candidateNodeMap[cgNode.id].degree;
            var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;
            var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;
            var cNodeLabel = cgNode[nodeLabelProp];
            var _e2 = stashPatternNodeLabelDegreeMap3(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _e2.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _e2.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _e2.minPatternNodeLabelOutDegree;
            var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;
            if (deleteCondition) {
              candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;
              if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {
                candidateGraphInvalid = true;
                break;
              }
              candidateGraph.nodes.splice(o2, 1);
              candidateNodeMap[cgNode.id] = void 0;
              degreeChanged = true;
            }
          }
          if (candidateGraphInvalid || !degreeChanged && loopCount !== 0)
            break;
          candidateEdgeNum = candidateEdges.length;
          for (var y4 = candidateEdgeNum - 1; y4 >= 0; y4--) {
            var cedge = candidateEdges[y4];
            if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {
              candidateEdges.splice(y4, 1);
              var edgeLabel = cedge[edgeLabelProp];
              edgeLabelCountMap[edgeLabel]--;
              if (candidateNodeMap[cedge.source]) {
                candidateNodeMap[cedge.source].degree--;
                candidateNodeMap[cedge.source].outDegree--;
              }
              if (candidateNodeMap[cedge.target]) {
                candidateNodeMap[cedge.target].degree--;
                candidateNodeMap[cedge.target].inDegree--;
              }
              if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {
                candidateGraphInvalid = true;
                break;
              }
              degreeChanged = true;
            }
          }
          loopCount++;
        }
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
      };
      for (var i2 = candidateGraphNum - 1; i2 >= 0; i2--) {
        var state_1 = _loop_2(i2);
        if (state_1 === "break")
          break;
      }
      var currentLength = candidateGraphs.length;
      var _loop_3 = function _loop_32(i3) {
        var cg1 = candidateGraphs[i3];
        var cg1EdgeMap = {};
        cg1.edges.forEach(function(edge) {
          var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
          if (!cg1EdgeMap[key])
            cg1EdgeMap[key] = 1;
          else
            cg1EdgeMap[key]++;
        });
        var _loop_6 = function _loop_62(j3) {
          var cg2 = candidateGraphs[j3];
          var cg2EdgeMap = {};
          cg2.edges.forEach(function(edge) {
            var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
            if (!cg2EdgeMap[key])
              cg2EdgeMap[key] = 1;
            else
              cg2EdgeMap[key]++;
          });
          var same = true;
          if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {
            same = false;
          } else {
            Object.keys(cg1EdgeMap).forEach(function(key) {
              if (cg2EdgeMap[key] !== cg1EdgeMap[key])
                same = false;
            });
          }
          if (same) {
            candidateGraphs.splice(j3, 1);
          }
        };
        for (var j2 = currentLength - 1; j2 > i3; j2--) {
          _loop_6(j2);
        }
        currentLength = candidateGraphs.length;
      };
      for (var i2 = 0; i2 <= currentLength - 1; i2++) {
        _loop_3(i2);
      }
      return candidateGraphs;
    };
    var _default = GADDI3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/algorithm.js
var require_algorithm = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/algorithm.js"(exports) {
    "use strict";
    function _typeof8(obj) {
      "@babel/helpers - typeof";
      return _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof8(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GADDI", {
      enumerable: true,
      get: function get3() {
        return _gaddi.default;
      }
    });
    Object.defineProperty(exports, "breadthFirstSearch", {
      enumerable: true,
      get: function get3() {
        return _bfs.default;
      }
    });
    Object.defineProperty(exports, "connectedComponent", {
      enumerable: true,
      get: function get3() {
        return _connectedComponent.default;
      }
    });
    Object.defineProperty(exports, "depthFirstSearch", {
      enumerable: true,
      get: function get3() {
        return _dfs.default;
      }
    });
    Object.defineProperty(exports, "detectCycle", {
      enumerable: true,
      get: function get3() {
        return _detectCycle.default;
      }
    });
    Object.defineProperty(exports, "dijkstra", {
      enumerable: true,
      get: function get3() {
        return _dijkstra.default;
      }
    });
    Object.defineProperty(exports, "findAllPath", {
      enumerable: true,
      get: function get3() {
        return _findPath.findAllPath;
      }
    });
    Object.defineProperty(exports, "findShortestPath", {
      enumerable: true,
      get: function get3() {
        return _findPath.findShortestPath;
      }
    });
    Object.defineProperty(exports, "floydWarshall", {
      enumerable: true,
      get: function get3() {
        return _floydWarshall.default;
      }
    });
    Object.defineProperty(exports, "getAdjMatrix", {
      enumerable: true,
      get: function get3() {
        return _adjacentMatrix.default;
      }
    });
    Object.defineProperty(exports, "getDegree", {
      enumerable: true,
      get: function get3() {
        return _degree.default;
      }
    });
    Object.defineProperty(exports, "getInDegree", {
      enumerable: true,
      get: function get3() {
        return _degree.getInDegree;
      }
    });
    Object.defineProperty(exports, "getNeighbors", {
      enumerable: true,
      get: function get3() {
        return _util.getNeighbors;
      }
    });
    Object.defineProperty(exports, "getOutDegree", {
      enumerable: true,
      get: function get3() {
        return _degree.getOutDegree;
      }
    });
    Object.defineProperty(exports, "labelPropagation", {
      enumerable: true,
      get: function get3() {
        return _labelPropagation.default;
      }
    });
    Object.defineProperty(exports, "louvain", {
      enumerable: true,
      get: function get3() {
        return _louvain.default;
      }
    });
    Object.defineProperty(exports, "minimumSpanningTree", {
      enumerable: true,
      get: function get3() {
        return _mts.default;
      }
    });
    Object.defineProperty(exports, "pageRank", {
      enumerable: true,
      get: function get3() {
        return _pageRank.default;
      }
    });
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _bfs = _interopRequireDefault(require_bfs());
    var _connectedComponent = _interopRequireDefault(require_connected_component());
    var _degree = _interopRequireWildcard(require_degree());
    var _detectCycle = _interopRequireDefault(require_detect_cycle());
    var _dfs = _interopRequireDefault(require_dfs());
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _findPath = require_find_path();
    var _floydWarshall = _interopRequireDefault(require_floydWarshall());
    var _labelPropagation = _interopRequireDefault(require_label_propagation());
    var _louvain = _interopRequireDefault(require_louvain());
    var _mts = _interopRequireDefault(require_mts());
    var _pageRank = _interopRequireDefault(require_pageRank());
    var _gaddi = _interopRequireDefault(require_gaddi());
    var _util = require_util();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof8(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/@antv/algorithm/lib/workers/index.worker.js
var require_index_worker = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/index.worker.js"(exports) {
    "use strict";
    function _typeof8(obj) {
      "@babel/helpers - typeof";
      return _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof8(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var algorithm = _interopRequireWildcard(require_algorithm());
    var _constant = require_constant();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof8(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    var ctx = typeof self !== "undefined" ? self : {};
    ctx.onmessage = function(event) {
      var _a2 = event.data, _algorithmType = _a2._algorithmType, data = _a2.data;
      if (!_algorithmType) {
        return;
      }
      if (typeof algorithm[_algorithmType] === "function") {
        var result = algorithm[_algorithmType].apply(algorithm, data);
        ctx.postMessage({
          _algorithmType: _constant.MESSAGE.SUCCESS,
          data: result
        });
        return;
      }
      ctx.postMessage({
        _algorithmType: _constant.MESSAGE.FAILURE
      });
    };
    var _default = null;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/createWorker.js
var require_createWorker = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/createWorker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _constant = require_constant();
    var _index = _interopRequireDefault(require_index_worker());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var createWorker = function createWorker2(type) {
      return function() {
        var data = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          data[_i2] = arguments[_i2];
        }
        return new Promise(function(resolve, reject) {
          var worker = new _index.default();
          worker.postMessage({
            _algorithmType: type,
            data
          });
          worker.onmessage = function(event) {
            var _a2 = event.data, data2 = _a2.data, _algorithmType = _a2._algorithmType;
            if (_constant.MESSAGE.SUCCESS === _algorithmType) {
              resolve(data2);
            } else {
              reject();
            }
            worker.terminate();
          };
        });
      };
    };
    var _default = createWorker;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/index.js
var require_workers = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pageRankAsync = exports.minimumSpanningTreeAsync = exports.louvainAsync = exports.labelPropagationAsync = exports.getOutDegreeAsync = exports.getNeighborsAsync = exports.getInDegreeAsync = exports.getDegreeAsync = exports.getAdjMatrixAsync = exports.floydWarshallAsync = exports.findShortestPathAsync = exports.findAllPathAsync = exports.dijkstraAsync = exports.detectCycleAsync = exports.detectAllUndirectedCycleAsync = exports.detectAllDirectedCycleAsync = exports.detectAllCyclesAsync = exports.connectedComponentAsync = exports.GADDIAsync = void 0;
    var _createWorker = _interopRequireDefault(require_createWorker());
    var _constant = require_constant();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getAdjMatrixAsync = function getAdjMatrixAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getAdjMatrix).apply(void 0, [graphData, directed]);
    };
    exports.getAdjMatrixAsync = getAdjMatrixAsync;
    var connectedComponentAsync = function connectedComponentAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.connectedComponent).apply(void 0, [graphData, directed]);
    };
    exports.connectedComponentAsync = connectedComponentAsync;
    var getDegreeAsync = function getDegreeAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getDegree)(graphData);
    };
    exports.getDegreeAsync = getDegreeAsync;
    var getInDegreeAsync = function getInDegreeAsync2(graphData, nodeId) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getInDegree)(graphData, nodeId);
    };
    exports.getInDegreeAsync = getInDegreeAsync;
    var getOutDegreeAsync = function getOutDegreeAsync2(graphData, nodeId) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getOutDegree)(graphData, nodeId);
    };
    exports.getOutDegreeAsync = getOutDegreeAsync;
    var detectCycleAsync = function detectCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectCycle)(graphData);
    };
    exports.detectCycleAsync = detectCycleAsync;
    var detectAllCyclesAsync = function detectAllCyclesAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllCycles)(graphData);
    };
    exports.detectAllCyclesAsync = detectAllCyclesAsync;
    var detectAllDirectedCycleAsync = function detectAllDirectedCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllDirectedCycle)(graphData);
    };
    exports.detectAllDirectedCycleAsync = detectAllDirectedCycleAsync;
    var detectAllUndirectedCycleAsync = function detectAllUndirectedCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllUndirectedCycle)(graphData);
    };
    exports.detectAllUndirectedCycleAsync = detectAllUndirectedCycleAsync;
    var dijkstraAsync = function dijkstraAsync2(graphData, source, directed, weightPropertyName) {
      return (0, _createWorker.default)(_constant.ALGORITHM.dijkstra).apply(void 0, [graphData, source, directed, weightPropertyName]);
    };
    exports.dijkstraAsync = dijkstraAsync;
    var findAllPathAsync = function findAllPathAsync2(graphData, start, end2, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.findAllPath).apply(void 0, [graphData, start, end2, directed]);
    };
    exports.findAllPathAsync = findAllPathAsync;
    var findShortestPathAsync = function findShortestPathAsync2(graphData, start, end2, directed, weightPropertyName) {
      return (0, _createWorker.default)(_constant.ALGORITHM.findShortestPath).apply(void 0, [graphData, start, end2, directed, weightPropertyName]);
    };
    exports.findShortestPathAsync = findShortestPathAsync;
    var floydWarshallAsync = function floydWarshallAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.floydWarshall).apply(void 0, [graphData, directed]);
    };
    exports.floydWarshallAsync = floydWarshallAsync;
    var labelPropagationAsync = function labelPropagationAsync2(graphData, directed, weightPropertyName, maxIteration) {
      if (maxIteration === void 0) {
        maxIteration = 1e3;
      }
      return (0, _createWorker.default)(_constant.ALGORITHM.labelPropagation)(graphData, directed, weightPropertyName, maxIteration);
    };
    exports.labelPropagationAsync = labelPropagationAsync;
    var louvainAsync = function louvainAsync2(graphData, directed, weightPropertyName, threshold) {
      return (0, _createWorker.default)(_constant.ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);
    };
    exports.louvainAsync = louvainAsync;
    var minimumSpanningTreeAsync = function minimumSpanningTreeAsync2(graphData, weight, algo) {
      return (0, _createWorker.default)(_constant.ALGORITHM.minimumSpanningTree).apply(void 0, [graphData, weight, algo]);
    };
    exports.minimumSpanningTreeAsync = minimumSpanningTreeAsync;
    var pageRankAsync = function pageRankAsync2(graphData, epsilon, linkProb) {
      return (0, _createWorker.default)(_constant.ALGORITHM.pageRank).apply(void 0, [graphData, epsilon, linkProb]);
    };
    exports.pageRankAsync = pageRankAsync;
    var getNeighborsAsync = function getNeighborsAsync2(nodeId, edges, type) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getNeighbors).apply(void 0, [nodeId, edges, type]);
    };
    exports.getNeighborsAsync = getNeighborsAsync;
    var GADDIAsync = function GADDIAsync2(graphData, pattern, directed, k2, length, nodeLabelProp, edgeLabelProp) {
      if (directed === void 0) {
        directed = false;
      }
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (edgeLabelProp === void 0) {
        edgeLabelProp = "cluster";
      }
      return (0, _createWorker.default)(_constant.ALGORITHM.GADDI).apply(void 0, [graphData, pattern, directed, k2, length, nodeLabelProp, edgeLabelProp]);
    };
    exports.GADDIAsync = GADDIAsync;
  }
});

// node_modules/@antv/algorithm/lib/asyncIndex.js
var require_asyncIndex = __commonJS({
  "node_modules/@antv/algorithm/lib/asyncIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GADDIAsync", {
      enumerable: true,
      get: function get3() {
        return _index.GADDIAsync;
      }
    });
    Object.defineProperty(exports, "connectedComponentAsync", {
      enumerable: true,
      get: function get3() {
        return _index.connectedComponentAsync;
      }
    });
    exports.default = void 0;
    Object.defineProperty(exports, "detectAllCyclesAsync", {
      enumerable: true,
      get: function get3() {
        return _index.detectAllCyclesAsync;
      }
    });
    Object.defineProperty(exports, "detectAllDirectedCycleAsync", {
      enumerable: true,
      get: function get3() {
        return _index.detectAllDirectedCycleAsync;
      }
    });
    Object.defineProperty(exports, "detectAllUndirectedCycleAsync", {
      enumerable: true,
      get: function get3() {
        return _index.detectAllUndirectedCycleAsync;
      }
    });
    Object.defineProperty(exports, "detectCycleAsync", {
      enumerable: true,
      get: function get3() {
        return _index.detectCycleAsync;
      }
    });
    exports.detectDirectedCycleAsync = void 0;
    Object.defineProperty(exports, "dijkstraAsync", {
      enumerable: true,
      get: function get3() {
        return _index.dijkstraAsync;
      }
    });
    Object.defineProperty(exports, "findAllPathAsync", {
      enumerable: true,
      get: function get3() {
        return _index.findAllPathAsync;
      }
    });
    Object.defineProperty(exports, "findShortestPathAsync", {
      enumerable: true,
      get: function get3() {
        return _index.findShortestPathAsync;
      }
    });
    Object.defineProperty(exports, "floydWarshallAsync", {
      enumerable: true,
      get: function get3() {
        return _index.floydWarshallAsync;
      }
    });
    Object.defineProperty(exports, "getAdjMatrixAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getAdjMatrixAsync;
      }
    });
    Object.defineProperty(exports, "getDegreeAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getDegreeAsync;
      }
    });
    Object.defineProperty(exports, "getInDegreeAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getInDegreeAsync;
      }
    });
    Object.defineProperty(exports, "getNeighborsAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getNeighborsAsync;
      }
    });
    Object.defineProperty(exports, "getOutDegreeAsync", {
      enumerable: true,
      get: function get3() {
        return _index.getOutDegreeAsync;
      }
    });
    Object.defineProperty(exports, "labelPropagationAsync", {
      enumerable: true,
      get: function get3() {
        return _index.labelPropagationAsync;
      }
    });
    Object.defineProperty(exports, "louvainAsync", {
      enumerable: true,
      get: function get3() {
        return _index.louvainAsync;
      }
    });
    Object.defineProperty(exports, "minimumSpanningTreeAsync", {
      enumerable: true,
      get: function get3() {
        return _index.minimumSpanningTreeAsync;
      }
    });
    Object.defineProperty(exports, "pageRankAsync", {
      enumerable: true,
      get: function get3() {
        return _index.pageRankAsync;
      }
    });
    var _index = require_workers();
    var detectDirectedCycleAsync = _index.detectCycleAsync;
    exports.detectDirectedCycleAsync = detectDirectedCycleAsync;
    var _default = {
      getAdjMatrixAsync: _index.getAdjMatrixAsync,
      connectedComponentAsync: _index.connectedComponentAsync,
      getDegreeAsync: _index.getDegreeAsync,
      getInDegreeAsync: _index.getInDegreeAsync,
      getOutDegreeAsync: _index.getOutDegreeAsync,
      detectCycleAsync: _index.detectCycleAsync,
      detectDirectedCycleAsync,
      detectAllCyclesAsync: _index.detectAllCyclesAsync,
      detectAllDirectedCycleAsync: _index.detectAllDirectedCycleAsync,
      detectAllUndirectedCycleAsync: _index.detectAllUndirectedCycleAsync,
      dijkstraAsync: _index.dijkstraAsync,
      findAllPathAsync: _index.findAllPathAsync,
      findShortestPathAsync: _index.findShortestPathAsync,
      floydWarshallAsync: _index.floydWarshallAsync,
      labelPropagationAsync: _index.labelPropagationAsync,
      louvainAsync: _index.louvainAsync,
      minimumSpanningTreeAsync: _index.minimumSpanningTreeAsync,
      pageRankAsync: _index.pageRankAsync,
      getNeighborsAsync: _index.getNeighborsAsync,
      GADDIAsync: _index.GADDIAsync
    };
    exports.default = _default;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i2 = 0, len = args.length; i2 < len; i2++) {
        var arg = args[i2];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn2) {
      return function() {
        return fn2(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty4 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty4.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i2;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i2 = 0; i2 < 3; i2++) {
          var i22 = i2 * 2;
          rgb[i2] = parseInt(match.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = parseInt(match[i2] + match[i2], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = parseInt(match[i2 + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty4.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] = clamp2(rgb[i2], 0, 255);
      }
      rgb[3] = clamp2(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s2 = clamp2(parseFloat(match[2]), 0, 100);
        var l2 = clamp2(parseFloat(match[3]), 0, 100);
        var a3 = clamp2(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s2, l2, a3];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w2 = clamp2(parseFloat(match[2]), 0, 100);
        var b2 = clamp2(parseFloat(match[3]), 0, 100);
        var a3 = clamp2(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w2, b2, a3];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r2 = Math.round(rgba[0] / 255 * 100);
      var g2 = Math.round(rgba[1] / 255 * 100);
      var b2 = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b2 + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b2 + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a3 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a3 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a3 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp2(num, min3, max4) {
      return Math.min(Math.max(min3, num), max4);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r2 = rgb[0] / 255;
      var g2 = rgb[1] / 255;
      var b2 = rgb[2] / 255;
      var min3 = Math.min(r2, g2, b2);
      var max4 = Math.max(r2, g2, b2);
      var delta = max4 - min3;
      var h2;
      var s2;
      var l2;
      if (max4 === min3) {
        h2 = 0;
      } else if (r2 === max4) {
        h2 = (g2 - b2) / delta;
      } else if (g2 === max4) {
        h2 = 2 + (b2 - r2) / delta;
      } else if (b2 === max4) {
        h2 = 4 + (r2 - g2) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      l2 = (min3 + max4) / 2;
      if (max4 === min3) {
        s2 = 0;
      } else if (l2 <= 0.5) {
        s2 = delta / (max4 + min3);
      } else {
        s2 = delta / (2 - max4 - min3);
      }
      return [h2, s2 * 100, l2 * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h2;
      var s2;
      var r2 = rgb[0] / 255;
      var g2 = rgb[1] / 255;
      var b2 = rgb[2] / 255;
      var v2 = Math.max(r2, g2, b2);
      var diff = v2 - Math.min(r2, g2, b2);
      var diffc = function(c3) {
        return (v2 - c3) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h2 = s2 = 0;
      } else {
        s2 = diff / v2;
        rdif = diffc(r2);
        gdif = diffc(g2);
        bdif = diffc(b2);
        if (r2 === v2) {
          h2 = bdif - gdif;
        } else if (g2 === v2) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b2 === v2) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s2 * 100,
        v2 * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r2 = rgb[0];
      var g2 = rgb[1];
      var b2 = rgb[2];
      var h2 = convert.rgb.hsl(rgb)[0];
      var w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
      b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
      return [h2, w2 * 100, b2 * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r2 = rgb[0] / 255;
      var g2 = rgb[1] / 255;
      var b2 = rgb[2] / 255;
      var c3;
      var m3;
      var y4;
      var k2;
      k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
      c3 = (1 - r2 - k2) / (1 - k2) || 0;
      m3 = (1 - g2 - k2) / (1 - k2) || 0;
      y4 = (1 - b2 - k2) / (1 - k2) || 0;
      return [c3 * 100, m3 * 100, y4 * 100, k2 * 100];
    };
    function comparativeDistance(x4, y4) {
      return Math.pow(x4[0] - y4[0], 2) + Math.pow(x4[1] - y4[1], 2) + Math.pow(x4[2] - y4[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance6 = comparativeDistance(rgb, value);
          if (distance6 < currentClosestDistance) {
            currentClosestDistance = distance6;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r2 = rgb[0] / 255;
      var g2 = rgb[1] / 255;
      var b2 = rgb[2] / 255;
      r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
      g2 = g2 > 0.04045 ? Math.pow((g2 + 0.055) / 1.055, 2.4) : g2 / 12.92;
      b2 = b2 > 0.04045 ? Math.pow((b2 + 0.055) / 1.055, 2.4) : b2 / 12.92;
      var x4 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
      var y4 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
      var z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
      return [x4 * 100, y4 * 100, z2 * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x4 = xyz[0];
      var y4 = xyz[1];
      var z2 = xyz[2];
      var l2;
      var a3;
      var b2;
      x4 /= 95.047;
      y4 /= 100;
      z2 /= 108.883;
      x4 = x4 > 8856e-6 ? Math.pow(x4, 1 / 3) : 7.787 * x4 + 16 / 116;
      y4 = y4 > 8856e-6 ? Math.pow(y4, 1 / 3) : 7.787 * y4 + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l2 = 116 * y4 - 16;
      a3 = 500 * (x4 - y4);
      b2 = 200 * (y4 - z2);
      return [l2, a3, b2];
    };
    convert.hsl.rgb = function(hsl) {
      var h2 = hsl[0] / 360;
      var s2 = hsl[1] / 100;
      var l2 = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s2 === 0) {
        val = l2 * 255;
        return [val, val, val];
      }
      if (l2 < 0.5) {
        t2 = l2 * (1 + s2);
      } else {
        t2 = l2 + s2 - l2 * s2;
      }
      t1 = 2 * l2 - t2;
      rgb = [0, 0, 0];
      for (var i2 = 0; i2 < 3; i2++) {
        t3 = h2 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h2 = hsl[0];
      var s2 = hsl[1] / 100;
      var l2 = hsl[2] / 100;
      var smin = s2;
      var lmin = Math.max(l2, 0.01);
      var sv;
      var v2;
      l2 *= 2;
      s2 *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v2 = (l2 + s2) / 2;
      sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
      return [h2, sv * 100, v2 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h2 = hsv[0] / 60;
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var hi2 = Math.floor(h2) % 6;
      var f2 = h2 - Math.floor(h2);
      var p2 = 255 * v2 * (1 - s2);
      var q2 = 255 * v2 * (1 - s2 * f2);
      var t2 = 255 * v2 * (1 - s2 * (1 - f2));
      v2 *= 255;
      switch (hi2) {
        case 0:
          return [v2, t2, p2];
        case 1:
          return [q2, v2, p2];
        case 2:
          return [p2, v2, t2];
        case 3:
          return [p2, q2, v2];
        case 4:
          return [t2, p2, v2];
        case 5:
          return [v2, p2, q2];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h2 = hsv[0];
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var vmin = Math.max(v2, 0.01);
      var lmin;
      var sl;
      var l2;
      l2 = (2 - s2) * v2;
      lmin = (2 - s2) * vmin;
      sl = s2 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l2 /= 2;
      return [h2, sl * 100, l2 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h2 = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i2;
      var v2;
      var f2;
      var n2;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i2 = Math.floor(6 * h2);
      v2 = 1 - bl;
      f2 = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f2 = 1 - f2;
      }
      n2 = wh + f2 * (v2 - wh);
      var r2;
      var g2;
      var b2;
      switch (i2) {
        default:
        case 6:
        case 0:
          r2 = v2;
          g2 = n2;
          b2 = wh;
          break;
        case 1:
          r2 = n2;
          g2 = v2;
          b2 = wh;
          break;
        case 2:
          r2 = wh;
          g2 = v2;
          b2 = n2;
          break;
        case 3:
          r2 = wh;
          g2 = n2;
          b2 = v2;
          break;
        case 4:
          r2 = n2;
          g2 = wh;
          b2 = v2;
          break;
        case 5:
          r2 = v2;
          g2 = wh;
          b2 = n2;
          break;
      }
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c3 = cmyk[0] / 100;
      var m3 = cmyk[1] / 100;
      var y4 = cmyk[2] / 100;
      var k2 = cmyk[3] / 100;
      var r2;
      var g2;
      var b2;
      r2 = 1 - Math.min(1, c3 * (1 - k2) + k2);
      g2 = 1 - Math.min(1, m3 * (1 - k2) + k2);
      b2 = 1 - Math.min(1, y4 * (1 - k2) + k2);
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x4 = xyz[0] / 100;
      var y4 = xyz[1] / 100;
      var z2 = xyz[2] / 100;
      var r2;
      var g2;
      var b2;
      r2 = x4 * 3.2406 + y4 * -1.5372 + z2 * -0.4986;
      g2 = x4 * -0.9689 + y4 * 1.8758 + z2 * 0.0415;
      b2 = x4 * 0.0557 + y4 * -0.204 + z2 * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * Math.pow(g2, 1 / 2.4) - 0.055 : g2 * 12.92;
      b2 = b2 > 31308e-7 ? 1.055 * Math.pow(b2, 1 / 2.4) - 0.055 : b2 * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b2 = Math.min(Math.max(0, b2), 1);
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x4 = xyz[0];
      var y4 = xyz[1];
      var z2 = xyz[2];
      var l2;
      var a3;
      var b2;
      x4 /= 95.047;
      y4 /= 100;
      z2 /= 108.883;
      x4 = x4 > 8856e-6 ? Math.pow(x4, 1 / 3) : 7.787 * x4 + 16 / 116;
      y4 = y4 > 8856e-6 ? Math.pow(y4, 1 / 3) : 7.787 * y4 + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l2 = 116 * y4 - 16;
      a3 = 500 * (x4 - y4);
      b2 = 200 * (y4 - z2);
      return [l2, a3, b2];
    };
    convert.lab.xyz = function(lab) {
      var l2 = lab[0];
      var a3 = lab[1];
      var b2 = lab[2];
      var x4;
      var y4;
      var z2;
      y4 = (l2 + 16) / 116;
      x4 = a3 / 500 + y4;
      z2 = y4 - b2 / 200;
      var y22 = Math.pow(y4, 3);
      var x22 = Math.pow(x4, 3);
      var z22 = Math.pow(z2, 3);
      y4 = y22 > 8856e-6 ? y22 : (y4 - 16 / 116) / 7.787;
      x4 = x22 > 8856e-6 ? x22 : (x4 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x4 *= 95.047;
      y4 *= 100;
      z2 *= 108.883;
      return [x4, y4, z2];
    };
    convert.lab.lch = function(lab) {
      var l2 = lab[0];
      var a3 = lab[1];
      var b2 = lab[2];
      var hr2;
      var h2;
      var c3;
      hr2 = Math.atan2(b2, a3);
      h2 = hr2 * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      c3 = Math.sqrt(a3 * a3 + b2 * b2);
      return [l2, c3, h2];
    };
    convert.lch.lab = function(lch) {
      var l2 = lch[0];
      var c3 = lch[1];
      var h2 = lch[2];
      var a3;
      var b2;
      var hr2;
      hr2 = h2 / 360 * 2 * Math.PI;
      a3 = c3 * Math.cos(hr2);
      b2 = c3 * Math.sin(hr2);
      return [l2, a3, b2];
    };
    convert.rgb.ansi16 = function(args) {
      var r2 = args[0];
      var g2 = args[1];
      var b2 = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r2 = args[0];
      var g2 = args[1];
      var b2 = args[2];
      if (r2 === g2 && g2 === b2) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r2 = (color2 & 1) * mult * 255;
      var g2 = (color2 >> 1 & 1) * mult * 255;
      var b2 = (color2 >> 2 & 1) * mult * 255;
      return [r2, g2, b2];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c3 = (args - 232) * 10 + 8;
        return [c3, c3, c3];
      }
      args -= 16;
      var rem;
      var r2 = Math.floor(args / 36) / 5 * 255;
      var g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b2 = rem % 6 / 5 * 255;
      return [r2, g2, b2];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r2 = integer >> 16 & 255;
      var g2 = integer >> 8 & 255;
      var b2 = integer & 255;
      return [r2, g2, b2];
    };
    convert.rgb.hcg = function(rgb) {
      var r2 = rgb[0] / 255;
      var g2 = rgb[1] / 255;
      var b2 = rgb[2] / 255;
      var max4 = Math.max(Math.max(r2, g2), b2);
      var min3 = Math.min(Math.min(r2, g2), b2);
      var chroma = max4 - min3;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min3 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max4 === r2) {
        hue = (g2 - b2) / chroma % 6;
      } else if (max4 === g2) {
        hue = 2 + (b2 - r2) / chroma;
      } else {
        hue = 4 + (r2 - g2) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s2 = hsl[1] / 100;
      var l2 = hsl[2] / 100;
      var c3 = 1;
      var f2 = 0;
      if (l2 < 0.5) {
        c3 = 2 * s2 * l2;
      } else {
        c3 = 2 * s2 * (1 - l2);
      }
      if (c3 < 1) {
        f2 = (l2 - 0.5 * c3) / (1 - c3);
      }
      return [hsl[0], c3 * 100, f2 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var c3 = s2 * v2;
      var f2 = 0;
      if (c3 < 1) {
        f2 = (v2 - c3) / (1 - c3);
      }
      return [hsv[0], c3 * 100, f2 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h2 = hcg[0] / 360;
      var c3 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      if (c3 === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      var pure = [0, 0, 0];
      var hi2 = h2 % 1 * 6;
      var v2 = hi2 % 1;
      var w2 = 1 - v2;
      var mg = 0;
      switch (Math.floor(hi2)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg = (1 - c3) * g2;
      return [
        (c3 * pure[0] + mg) * 255,
        (c3 * pure[1] + mg) * 255,
        (c3 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c3 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var v2 = c3 + g2 * (1 - c3);
      var f2 = 0;
      if (v2 > 0) {
        f2 = c3 / v2;
      }
      return [hcg[0], f2 * 100, v2 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c3 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var l2 = g2 * (1 - c3) + 0.5 * c3;
      var s2 = 0;
      if (l2 > 0 && l2 < 0.5) {
        s2 = c3 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s2 = c3 / (2 * (1 - l2));
      }
      return [hcg[0], s2 * 100, l2 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c3 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var v2 = c3 + g2 * (1 - c3);
      return [hcg[0], (v2 - c3) * 100, (1 - v2) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w2 = hwb[1] / 100;
      var b2 = hwb[2] / 100;
      var v2 = 1 - b2;
      var c3 = v2 - w2;
      var g2 = 0;
      if (c3 < 1) {
        g2 = (v2 - c3) / (1 - c3);
      }
      return [hwb[0], c3 * 100, g2 * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i2 = 0; i2 < len; i2++) {
        graph[models[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i2 = 0; i2 < len; i2++) {
          var adjacent = adjacents[i2];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to2) {
      return function(args) {
        return to2(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn2 = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn2 = link(conversions[graph[cur].parent][cur], fn2);
        cur = graph[cur].parent;
      }
      fn2.conversion = path;
      return fn2;
    }
    module.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i2 = 0; i2 < len; i2++) {
        var toModel = models[i2];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn2) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn2(args);
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn2) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn2(args);
        if (typeof result === "object") {
          for (var len = result.length, i2 = 0; i2 < len; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn2 = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn2);
        convert[fromModel][toModel].raw = wrapRaw(fn2);
      });
    });
    module.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports, module) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i2;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys2 = Object.keys(obj);
        if ("alpha" in obj) {
          keys2.splice(keys2.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys2.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color2 = [];
        for (i2 = 0; i2 < labels.length; i2++) {
          color2.push(obj[labels[i2]]);
        }
        this.color = zeroArray(color2);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i2 = 0; i2 < channels; i2++) {
          var limit = limiters[this.model][i2];
          if (limit) {
            this.color[i2] = limit(this.color[i2]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i2 = 0; i2 < channels; i2++) {
          result[labels[i2]] = this.color[i2];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i2 = 0; i2 < rgb.length; i2++) {
          var chan = rgb[i2] / 255;
          lum[i2] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i2 = 0; i2 < 3; i2++) {
          rgb.color[i2] = 255 - rgb.color[i2];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p2 = weight === void 0 ? 0.5 : weight;
        var w2 = 2 * p2 - 1;
        var a3 = color1.alpha() - color2.alpha();
        var w1 = ((w2 * a3 === -1 ? w2 : (w2 + a3) / (1 + w2 * a3)) + 1) / 2;
        var w22 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w22 * color2.red(),
          w1 * color1.green() + w22 * color2.green(),
          w1 * color1.blue() + w22 * color2.blue(),
          color1.alpha() * p2 + color2.alpha() * (1 - p2)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color2) {
        if (typeof color2 === "number") {
          color2 = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color2, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m3) {
        (limiters[m3] || (limiters[m3] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max4) {
      return function(v2) {
        return Math.max(0, Math.min(max4, v2));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length) {
      for (var i2 = 0; i2 < length; i2++) {
        if (typeof arr[i2] !== "number") {
          arr[i2] = 0;
        }
      }
      return arr;
    }
    module.exports = Color;
  }
});

// node_modules/@antv/layout/lib/layout/base.js
var require_base = __commonJS({
  "node_modules/@antv/layout/lib/layout/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Base = void 0;
    var Base = (
      /** @class */
      function() {
        function Base2() {
          this.nodes = [];
          this.edges = [];
          this.combos = [];
          this.comboEdges = [];
          this.hiddenNodes = [];
          this.hiddenEdges = [];
          this.hiddenCombos = [];
          this.vedges = [];
          this.positions = [];
          this.destroyed = false;
          this.onLayoutEnd = function() {
          };
        }
        Base2.prototype.layout = function(data) {
          this.init(data);
          return this.execute(true);
        };
        Base2.prototype.init = function(data) {
          this.nodes = data.nodes || [];
          this.edges = data.edges || [];
          this.combos = data.combos || [];
          this.comboEdges = data.comboEdges || [];
          this.hiddenNodes = data.hiddenNodes || [];
          this.hiddenEdges = data.hiddenEdges || [];
          this.hiddenCombos = data.hiddenCombos || [];
          this.vedges = data.vedges || [];
        };
        Base2.prototype.execute = function(reloadData) {
        };
        Base2.prototype.executeWithWorker = function() {
        };
        Base2.prototype.getDefaultCfg = function() {
          return {};
        };
        Base2.prototype.updateCfg = function(cfg) {
          if (cfg) {
            Object.assign(this, cfg);
          }
        };
        Base2.prototype.getType = function() {
          return "base";
        };
        Base2.prototype.destroy = function() {
          this.nodes = null;
          this.edges = null;
          this.combos = null;
          this.positions = null;
          this.destroyed = true;
        };
        return Base2;
      }()
    );
    exports.Base = Base;
  }
});

// node_modules/@antv/layout/lib/util/string.js
var require_string = __commonJS({
  "node_modules/@antv/layout/lib/util/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.camelize = exports.isString = void 0;
    var isString = function(val) {
      return typeof val === "string";
    };
    exports.isString = isString;
    var cacheStringFunction = function(fn2) {
      var cache2 = /* @__PURE__ */ Object.create(null);
      return function(str) {
        var hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    exports.camelize = cacheStringFunction(function(str) {
      return str.replace(camelizeRE, function(_2, c3) {
        return c3 ? c3.toUpperCase() : "";
      });
    });
  }
});

// node_modules/@antv/layout/lib/util/array.js
var require_array = __commonJS({
  "node_modules/@antv/layout/lib/util/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArray = void 0;
    exports.isArray = Array.isArray;
  }
});

// node_modules/@antv/layout/lib/util/number.js
var require_number = __commonJS({
  "node_modules/@antv/layout/lib/util/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toNumber = exports.isNaN = exports.isNumber = void 0;
    var isNumber2 = function(val) {
      return typeof val === "number";
    };
    exports.isNumber = isNumber2;
    var isNaN5 = function(num) {
      return Number.isNaN(Number(num));
    };
    exports.isNaN = isNaN5;
    var toNumber = function(val) {
      var n2 = parseFloat(val);
      return (0, exports.isNaN)(n2) ? val : n2;
    };
    exports.toNumber = toNumber;
  }
});

// node_modules/@antv/layout/lib/util/object.js
var require_object = __commonJS({
  "node_modules/@antv/layout/lib/util/object.js"(exports) {
    "use strict";
    var __assign14 = exports && exports.__assign || function() {
      __assign14 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign14.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = exports.isObject = void 0;
    var isObject = function(val) {
      return val !== null && typeof val === "object";
    };
    exports.isObject = isObject;
    var clone3 = function(target) {
      if (target === null) {
        return target;
      }
      if (target instanceof Date) {
        return new Date(target.getTime());
      }
      if (target instanceof Array) {
        var cp_1 = [];
        target.forEach(function(v2) {
          cp_1.push(v2);
        });
        return cp_1.map(function(n2) {
          return (0, exports.clone)(n2);
        });
      }
      if (typeof target === "object" && Object.keys(target).length) {
        var cp_2 = __assign14({}, target);
        Object.keys(cp_2).forEach(function(k2) {
          cp_2[k2] = (0, exports.clone)(cp_2[k2]);
        });
        return cp_2;
      }
      return target;
    };
    exports.clone = clone3;
  }
});

// node_modules/@antv/layout/lib/util/math.js
var require_math = __commonJS({
  "node_modules/@antv/layout/lib/util/math.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCoreNodeAndRelativeLeafNodes = exports.getAvgNodePosition = exports.getLayoutBBox = exports.traverseTreeUp = exports.scaleMatrix = exports.getAdjMatrix = exports.floydWarshall = exports.getDegreeMap = exports.getDegree = exports.getEdgeTerminal = void 0;
    var array_1 = require_array();
    var number_1 = require_number();
    var object_1 = require_object();
    var getEdgeTerminal = function(edge, type) {
      var terminal = edge[type];
      if ((0, object_1.isObject)(terminal)) {
        return terminal.cell;
      }
      return terminal;
    };
    exports.getEdgeTerminal = getEdgeTerminal;
    var getDegree3 = function(n2, nodeIdxMap, edges) {
      var degrees = [];
      for (var i2 = 0; i2 < n2; i2++) {
        degrees[i2] = {
          in: 0,
          out: 0,
          all: 0
        };
      }
      if (!edges)
        return degrees;
      edges.forEach(function(e8) {
        var source = (0, exports.getEdgeTerminal)(e8, "source");
        var target = (0, exports.getEdgeTerminal)(e8, "target");
        if (source && degrees[nodeIdxMap[source]]) {
          degrees[nodeIdxMap[source]].out += 1;
          degrees[nodeIdxMap[source]].all += 1;
        }
        if (target && degrees[nodeIdxMap[target]]) {
          degrees[nodeIdxMap[target]].in += 1;
          degrees[nodeIdxMap[target]].all += 1;
        }
      });
      return degrees;
    };
    exports.getDegree = getDegree3;
    var getDegreeMap = function(nodes, edges) {
      var degreesMap = {};
      nodes.forEach(function(node) {
        degreesMap[node.id] = {
          in: 0,
          out: 0,
          all: 0
        };
      });
      if (!edges)
        return degreesMap;
      edges.forEach(function(e8) {
        var source = (0, exports.getEdgeTerminal)(e8, "source");
        var target = (0, exports.getEdgeTerminal)(e8, "target");
        if (source) {
          degreesMap[source].out += 1;
          degreesMap[source].all += 1;
        }
        if (target) {
          degreesMap[target].in += 1;
          degreesMap[target].all += 1;
        }
      });
      return degreesMap;
    };
    exports.getDegreeMap = getDegreeMap;
    var floydWarshall6 = function(adjMatrix3) {
      var dist = [];
      var size3 = adjMatrix3.length;
      for (var i2 = 0; i2 < size3; i2 += 1) {
        dist[i2] = [];
        for (var j2 = 0; j2 < size3; j2 += 1) {
          if (i2 === j2) {
            dist[i2][j2] = 0;
          } else if (adjMatrix3[i2][j2] === 0 || !adjMatrix3[i2][j2]) {
            dist[i2][j2] = Infinity;
          } else {
            dist[i2][j2] = adjMatrix3[i2][j2];
          }
        }
      }
      for (var k2 = 0; k2 < size3; k2 += 1) {
        for (var i2 = 0; i2 < size3; i2 += 1) {
          for (var j2 = 0; j2 < size3; j2 += 1) {
            if (dist[i2][j2] > dist[i2][k2] + dist[k2][j2]) {
              dist[i2][j2] = dist[i2][k2] + dist[k2][j2];
            }
          }
        }
      }
      return dist;
    };
    exports.floydWarshall = floydWarshall6;
    var getAdjMatrix3 = function(data, directed) {
      var nodes = data.nodes, edges = data.edges;
      var matrix = [];
      var nodeMap = {};
      if (!nodes) {
        throw new Error("invalid nodes data!");
      }
      if (nodes) {
        nodes.forEach(function(node, i2) {
          nodeMap[node.id] = i2;
          var row = [];
          matrix.push(row);
        });
      }
      edges === null || edges === void 0 ? void 0 : edges.forEach(function(e8) {
        var source = (0, exports.getEdgeTerminal)(e8, "source");
        var target = (0, exports.getEdgeTerminal)(e8, "target");
        var sIndex = nodeMap[source];
        var tIndex = nodeMap[target];
        if (sIndex === void 0 || tIndex === void 0)
          return;
        matrix[sIndex][tIndex] = 1;
        if (!directed) {
          matrix[tIndex][sIndex] = 1;
        }
      });
      return matrix;
    };
    exports.getAdjMatrix = getAdjMatrix3;
    var scaleMatrix3 = function(matrix, ratio) {
      var result = [];
      matrix.forEach(function(row) {
        var newRow = [];
        row.forEach(function(v2) {
          newRow.push(v2 * ratio);
        });
        result.push(newRow);
      });
      return result;
    };
    exports.scaleMatrix = scaleMatrix3;
    var traverseUp3 = function(data, fn2) {
      if (data && data.children) {
        for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
          if (!traverseUp3(data.children[i2], fn2))
            return;
        }
      }
      if (!fn2(data)) {
        return false;
      }
      return true;
    };
    var traverseTreeUp3 = function(data, fn2) {
      if (typeof fn2 !== "function") {
        return;
      }
      traverseUp3(data, fn2);
    };
    exports.traverseTreeUp = traverseTreeUp3;
    var getLayoutBBox = function(nodes) {
      var minX = Infinity;
      var minY = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      nodes.forEach(function(node) {
        var size3 = node.size;
        if ((0, array_1.isArray)(size3)) {
          if (size3.length === 1)
            size3 = [size3[0], size3[0]];
        } else if ((0, number_1.isNumber)(size3)) {
          size3 = [size3, size3];
        } else if (size3 === void 0 || isNaN(size3)) {
          size3 = [30, 30];
        }
        var halfSize = [size3[0] / 2, size3[1] / 2];
        var left = node.x - halfSize[0];
        var right = node.x + halfSize[0];
        var top = node.y - halfSize[1];
        var bottom = node.y + halfSize[1];
        if (minX > left)
          minX = left;
        if (minY > top)
          minY = top;
        if (maxX < right)
          maxX = right;
        if (maxY < bottom)
          maxY = bottom;
      });
      return { minX, minY, maxX, maxY };
    };
    exports.getLayoutBBox = getLayoutBBox;
    var getAvgNodePosition = function(nodes) {
      var totalNodes = { x: 0, y: 0 };
      nodes.forEach(function(node) {
        totalNodes.x += node.x || 0;
        totalNodes.y += node.y || 0;
      });
      var length = nodes.length || 1;
      return {
        x: totalNodes.x / length,
        y: totalNodes.y / length
      };
    };
    exports.getAvgNodePosition = getAvgNodePosition;
    var getCoreNode = function(type, node, edges) {
      var _a2, _b;
      if (type === "source") {
        return ((_a2 = edges === null || edges === void 0 ? void 0 : edges.find(function(edge) {
          return edge.target === node.id;
        })) === null || _a2 === void 0 ? void 0 : _a2.source) || {};
      }
      return ((_b = edges === null || edges === void 0 ? void 0 : edges.find(function(edge) {
        return edge.source === node.id;
      })) === null || _b === void 0 ? void 0 : _b.target) || {};
    };
    var getRelativeNodeIds = function(type, coreNode, edges) {
      var relativeNodes = [];
      switch (type) {
        case "source":
          relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function(edge) {
            return edge.source === coreNode.id;
          }).map(function(edge) {
            return edge.target;
          });
          break;
        case "target":
          relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function(edge) {
            return edge.target === coreNode.id;
          }).map(function(edge) {
            return edge.source;
          });
          break;
        case "both":
          relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function(edge) {
            return edge.source === coreNode.id;
          }).map(function(edge) {
            return edge.target;
          }).concat(edges === null || edges === void 0 ? void 0 : edges.filter(function(edge) {
            return edge.target === coreNode.id;
          }).map(function(edge) {
            return edge.source;
          }));
          break;
        default:
          break;
      }
      var set3 = new Set(relativeNodes);
      return Array.from(set3);
    };
    var getSameTypeNodes = function(type, nodeClusterBy, node, relativeNodes, degreesMap) {
      var typeName = node[nodeClusterBy] || "";
      var sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter(function(item) {
        return item[nodeClusterBy] === typeName;
      })) || [];
      if (type === "leaf") {
        sameTypeNodes = sameTypeNodes.filter(function(node2) {
          var _a2, _b;
          return ((_a2 = degreesMap[node2.id]) === null || _a2 === void 0 ? void 0 : _a2.in) === 0 || ((_b = degreesMap[node2.id]) === null || _b === void 0 ? void 0 : _b.out) === 0;
        });
      }
      return sameTypeNodes;
    };
    var getCoreNodeAndRelativeLeafNodes = function(type, node, edges, nodeClusterBy, degreesMap, nodeMap) {
      var _a2 = degreesMap[node.id], inDegree = _a2.in, outDegree = _a2.out;
      var coreNode = node;
      var relativeLeafNodes = [];
      if (inDegree === 0) {
        coreNode = getCoreNode("source", node, edges);
        relativeLeafNodes = getRelativeNodeIds("both", coreNode, edges).map(function(nodeId) {
          return nodeMap[nodeId];
        });
      } else if (outDegree === 0) {
        coreNode = getCoreNode("target", node, edges);
        relativeLeafNodes = getRelativeNodeIds("both", coreNode, edges).map(function(nodeId) {
          return nodeMap[nodeId];
        });
      }
      relativeLeafNodes = relativeLeafNodes.filter(function(node2) {
        return degreesMap[node2.id] && (degreesMap[node2.id].in === 0 || degreesMap[node2.id].out === 0);
      });
      var sameTypeLeafNodes = getSameTypeNodes(type, nodeClusterBy, node, relativeLeafNodes, degreesMap);
      return { coreNode, relativeLeafNodes, sameTypeLeafNodes };
    };
    exports.getCoreNodeAndRelativeLeafNodes = getCoreNodeAndRelativeLeafNodes;
  }
});

// node_modules/@antv/layout/lib/util/function.js
var require_function = __commonJS({
  "node_modules/@antv/layout/lib/util/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFuncByUnknownType = exports.getFunc = exports.isFunction = void 0;
    var _1 = require_util2();
    var number_1 = require_number();
    var isFunction2 = function(val) {
      return typeof val === "function";
    };
    exports.isFunction = isFunction2;
    var getFunc = function(value, defaultValue, func) {
      var resultFunc;
      if (func) {
        resultFunc = func;
      } else if ((0, number_1.isNumber)(value)) {
        resultFunc = function() {
          return value;
        };
      } else {
        resultFunc = function() {
          return defaultValue;
        };
      }
      return resultFunc;
    };
    exports.getFunc = getFunc;
    var getFuncByUnknownType = function(defaultValue, value, resultIsNumber) {
      if (resultIsNumber === void 0) {
        resultIsNumber = true;
      }
      if (!value && value !== 0) {
        return function(d2) {
          if (d2.size) {
            if ((0, _1.isArray)(d2.size))
              return d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
            if ((0, _1.isObject)(d2.size))
              return d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
            return d2.size;
          }
          return defaultValue;
        };
      }
      if ((0, exports.isFunction)(value)) {
        return value;
      }
      if ((0, number_1.isNumber)(value)) {
        return function() {
          return value;
        };
      }
      if ((0, _1.isArray)(value)) {
        return function() {
          if (resultIsNumber) {
            var max4 = Math.max.apply(Math, value);
            return isNaN(max4) ? defaultValue : max4;
          }
          return value;
        };
      }
      if ((0, _1.isObject)(value)) {
        return function() {
          if (resultIsNumber) {
            var max4 = Math.max(value.width, value.height);
            return isNaN(max4) ? defaultValue : max4;
          }
          return [value.width, value.height];
        };
      }
      return function() {
        return defaultValue;
      };
    };
    exports.getFuncByUnknownType = getFuncByUnknownType;
  }
});

// node_modules/@antv/layout/lib/util/index.js
var require_util2 = __commonJS({
  "node_modules/@antv/layout/lib/util/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_string(), exports);
    __exportStar(require_array(), exports);
    __exportStar(require_number(), exports);
    __exportStar(require_math(), exports);
    __exportStar(require_object(), exports);
    __exportStar(require_function(), exports);
  }
});

// node_modules/@antv/layout/lib/registy/index.js
var require_registy = __commonJS({
  "node_modules/@antv/layout/lib/registy/index.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLayoutByName = exports.unRegisterLayout = exports.registerLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var map3 = /* @__PURE__ */ new Map();
    var registerLayout3 = function(name, layoutOverride) {
      if (map3.get(name)) {
        console.warn("The layout with the name ".concat(name, " exists already, it will be overridden"));
      }
      if ((0, util_1.isObject)(layoutOverride)) {
        var GLayout = (
          /** @class */
          function(_super) {
            __extends15(GLayout2, _super);
            function GLayout2(cfg) {
              var _this = this;
              var _a2;
              _this = _super.call(this) || this;
              var self2 = _this;
              var props = {};
              var defaultCfg2 = Object.assign({}, self2.getDefaultCfg(), ((_a2 = layoutOverride.getDefaultCfg) === null || _a2 === void 0 ? void 0 : _a2.call(layoutOverride)) || {});
              Object.assign(props, defaultCfg2, layoutOverride, cfg);
              Object.keys(props).forEach(function(key) {
                var value = props[key];
                self2[key] = value;
              });
              return _this;
            }
            return GLayout2;
          }(base_1.Base)
        );
        map3.set(name, GLayout);
      } else {
        map3.set(name, layoutOverride);
      }
      return map3.get(name);
    };
    exports.registerLayout = registerLayout3;
    var unRegisterLayout = function(name) {
      if (map3.has(name)) {
        map3.delete(name);
      }
    };
    exports.unRegisterLayout = unRegisterLayout;
    var getLayoutByName = function(name) {
      if (map3.has(name)) {
        return map3.get(name);
      }
      return null;
    };
    exports.getLayoutByName = getLayoutByName;
  }
});

// node_modules/@antv/layout/lib/layout/grid.js
var require_grid = __commonJS({
  "node_modules/@antv/layout/lib/layout/grid.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var GridLayout2 = (
      /** @class */
      function(_super) {
        __extends15(GridLayout3, _super);
        function GridLayout3(options) {
          var _this = _super.call(this) || this;
          _this.begin = [0, 0];
          _this.preventOverlap = true;
          _this.preventOverlapPadding = 10;
          _this.condense = false;
          _this.sortBy = "degree";
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.row = 0;
          _this.col = 0;
          _this.cellWidth = 0;
          _this.cellHeight = 0;
          _this.cellUsed = {};
          _this.id2manPos = {};
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        GridLayout3.prototype.getDefaultCfg = function() {
          return {
            begin: [0, 0],
            preventOverlap: true,
            preventOverlapPadding: 10,
            condense: false,
            rows: void 0,
            cols: void 0,
            position: void 0,
            sortBy: "degree",
            nodeSize: 30
          };
        };
        GridLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges, begin = self2.begin;
          var n2 = nodes.length;
          if (n2 === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return {
              nodes,
              edges
            };
          }
          if (n2 === 1) {
            nodes[0].x = begin[0];
            nodes[0].y = begin[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return {
              nodes,
              edges
            };
          }
          var sortBy2 = self2.sortBy, width = self2.width, height = self2.height;
          var condense = self2.condense, preventOverlapPadding = self2.preventOverlapPadding, preventOverlap = self2.preventOverlap, paramNodeSpacing = self2.nodeSpacing, paramNodeSize = self2.nodeSize;
          var layoutNodes = [];
          nodes.forEach(function(node2) {
            layoutNodes.push(node2);
          });
          var nodeIdxMap = {};
          layoutNodes.forEach(function(node2, i3) {
            nodeIdxMap[node2.id] = i3;
          });
          if (sortBy2 === "degree" || !(0, util_1.isString)(sortBy2) || layoutNodes[0][sortBy2] === void 0) {
            sortBy2 = "degree";
            if ((0, util_1.isNaN)(nodes[0].degree)) {
              var values_1 = (0, util_1.getDegree)(layoutNodes.length, nodeIdxMap, edges);
              layoutNodes.forEach(function(node2, i3) {
                node2.degree = values_1[i3].all;
              });
            }
          }
          layoutNodes.sort(function(n1, n22) {
            return n22[sortBy2] - n1[sortBy2];
          });
          if (!width && typeof window !== "undefined") {
            width = window.innerWidth;
          }
          if (!height && typeof window !== "undefined") {
            height = window.innerHeight;
          }
          var oRows = self2.rows;
          var oCols = self2.cols != null ? self2.cols : self2.columns;
          self2.cells = n2;
          if (oRows != null && oCols != null) {
            self2.rows = oRows;
            self2.cols = oCols;
          } else if (oRows != null && oCols == null) {
            self2.rows = oRows;
            self2.cols = Math.ceil(self2.cells / self2.rows);
          } else if (oRows == null && oCols != null) {
            self2.cols = oCols;
            self2.rows = Math.ceil(self2.cells / self2.cols);
          } else {
            self2.splits = Math.sqrt(self2.cells * self2.height / self2.width);
            self2.rows = Math.round(self2.splits);
            self2.cols = Math.round(self2.width / self2.height * self2.splits);
          }
          self2.rows = Math.max(self2.rows, 1);
          self2.cols = Math.max(self2.cols, 1);
          if (self2.cols * self2.rows > self2.cells) {
            var sm = self2.small();
            var lg = self2.large();
            if ((sm - 1) * lg >= self2.cells) {
              self2.small(sm - 1);
            } else if ((lg - 1) * sm >= self2.cells) {
              self2.large(lg - 1);
            }
          } else {
            while (self2.cols * self2.rows < self2.cells) {
              var sm = self2.small();
              var lg = self2.large();
              if ((lg + 1) * sm >= self2.cells) {
                self2.large(lg + 1);
              } else {
                self2.small(sm + 1);
              }
            }
          }
          self2.cellWidth = width / self2.cols;
          self2.cellHeight = height / self2.rows;
          if (condense) {
            self2.cellWidth = 0;
            self2.cellHeight = 0;
          }
          if (preventOverlap || paramNodeSpacing) {
            var nodeSpacing_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSpacing);
            var nodeSize_1 = (0, util_1.getFuncByUnknownType)(30, paramNodeSize, false);
            layoutNodes.forEach(function(node2) {
              if (!node2.x || !node2.y) {
                node2.x = 0;
                node2.y = 0;
              }
              var res = nodeSize_1(node2) || 30;
              var nodeW;
              var nodeH;
              if ((0, util_1.isArray)(res)) {
                nodeW = res[0];
                nodeH = res[1];
              } else {
                nodeW = res;
                nodeH = res;
              }
              var p2 = nodeSpacing_1 !== void 0 ? nodeSpacing_1(node2) : preventOverlapPadding;
              var w2 = nodeW + p2;
              var h2 = nodeH + p2;
              self2.cellWidth = Math.max(self2.cellWidth, w2);
              self2.cellHeight = Math.max(self2.cellHeight, h2);
            });
          }
          self2.cellUsed = {};
          self2.row = 0;
          self2.col = 0;
          self2.id2manPos = {};
          for (var i2 = 0; i2 < layoutNodes.length; i2++) {
            var node = layoutNodes[i2];
            var rcPos = void 0;
            if (self2.position) {
              rcPos = self2.position(node);
            }
            if (rcPos && (rcPos.row !== void 0 || rcPos.col !== void 0)) {
              var pos = {
                row: rcPos.row,
                col: rcPos.col
              };
              if (pos.col === void 0) {
                pos.col = 0;
                while (self2.used(pos.row, pos.col)) {
                  pos.col++;
                }
              } else if (pos.row === void 0) {
                pos.row = 0;
                while (self2.used(pos.row, pos.col)) {
                  pos.row++;
                }
              }
              self2.id2manPos[node.id] = pos;
              self2.use(pos.row, pos.col);
            }
            self2.getPos(node);
          }
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            edges,
            nodes: layoutNodes
          };
        };
        GridLayout3.prototype.small = function(val) {
          var self2 = this;
          var res;
          var rows = self2.rows || 5;
          var cols = self2.cols || 5;
          if (val == null) {
            res = Math.min(rows, cols);
          } else {
            var min3 = Math.min(rows, cols);
            if (min3 === self2.rows) {
              self2.rows = val;
            } else {
              self2.cols = val;
            }
          }
          return res;
        };
        GridLayout3.prototype.large = function(val) {
          var self2 = this;
          var res;
          var rows = self2.rows || 5;
          var cols = self2.cols || 5;
          if (val == null) {
            res = Math.max(rows, cols);
          } else {
            var max4 = Math.max(rows, cols);
            if (max4 === self2.rows) {
              self2.rows = val;
            } else {
              self2.cols = val;
            }
          }
          return res;
        };
        GridLayout3.prototype.used = function(row, col) {
          var self2 = this;
          return self2.cellUsed["c-".concat(row, "-").concat(col)] || false;
        };
        GridLayout3.prototype.use = function(row, col) {
          var self2 = this;
          self2.cellUsed["c-".concat(row, "-").concat(col)] = true;
        };
        GridLayout3.prototype.moveToNextCell = function() {
          var self2 = this;
          var cols = self2.cols || 5;
          self2.col++;
          if (self2.col >= cols) {
            self2.col = 0;
            self2.row++;
          }
        };
        GridLayout3.prototype.getPos = function(node) {
          var self2 = this;
          var begin = self2.begin, cellWidth = self2.cellWidth, cellHeight = self2.cellHeight;
          var x4;
          var y4;
          var rcPos = self2.id2manPos[node.id];
          if (rcPos) {
            x4 = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
            y4 = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
          } else {
            while (self2.used(self2.row, self2.col)) {
              self2.moveToNextCell();
            }
            x4 = self2.col * cellWidth + cellWidth / 2 + begin[0];
            y4 = self2.row * cellHeight + cellHeight / 2 + begin[1];
            self2.use(self2.row, self2.col);
            self2.moveToNextCell();
          }
          node.x = x4;
          node.y = y4;
        };
        GridLayout3.prototype.getType = function() {
          return "grid";
        };
        return GridLayout3;
      }(base_1.Base)
    );
    exports.GridLayout = GridLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/random.js
var require_random = __commonJS({
  "node_modules/@antv/layout/lib/layout/random.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomLayout = void 0;
    var base_1 = require_base();
    var RandomLayout2 = (
      /** @class */
      function(_super) {
        __extends15(RandomLayout3, _super);
        function RandomLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.width = 300;
          _this.height = 300;
          _this.nodes = [];
          _this.edges = [];
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        RandomLayout3.prototype.getDefaultCfg = function() {
          return {
            center: [0, 0],
            width: 300,
            height: 300
          };
        };
        RandomLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var layoutScale = 0.9;
          var center = self2.center;
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (nodes) {
            nodes.forEach(function(node) {
              node.x = (Math.random() - 0.5) * layoutScale * self2.width + center[0];
              node.y = (Math.random() - 0.5) * layoutScale * self2.height + center[1];
            });
          }
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges: this.edges
          };
        };
        RandomLayout3.prototype.getType = function() {
          return "random";
        };
        return RandomLayout3;
      }(base_1.Base)
    );
    exports.RandomLayout = RandomLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/gForce.js
var require_gForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/gForce.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GForceLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var proccessToFunc3 = function(value, defaultV) {
      var func;
      if (!value) {
        func = function(d2) {
          return defaultV || 1;
        };
      } else if ((0, util_1.isNumber)(value)) {
        func = function(d2) {
          return value;
        };
      } else {
        func = value;
      }
      return func;
    };
    var GForceLayout2 = (
      /** @class */
      function(_super) {
        __extends15(GForceLayout3, _super);
        function GForceLayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 500;
          _this.workerEnabled = false;
          _this.edgeStrength = 200;
          _this.nodeStrength = 1e3;
          _this.coulombDisScale = 5e-3;
          _this.damping = 0.9;
          _this.maxSpeed = 1e3;
          _this.minMovement = 0.5;
          _this.interval = 0.02;
          _this.factor = 1;
          _this.linkDistance = 1;
          _this.gravity = 10;
          _this.preventOverlap = true;
          _this.collideStrength = 1;
          _this.tick = function() {
          };
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.animate = true;
          _this.updateCfg(options);
          return _this;
        }
        GForceLayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 500,
            gravity: 10,
            enableTick: true,
            animate: true
          };
        };
        GForceLayout3.prototype.execute = function() {
          var _a2, _b;
          var self2 = this;
          var nodes = self2.nodes;
          if (self2.timeInterval !== void 0 && typeof window !== "undefined") {
            window.clearInterval(self2.timeInterval);
          }
          if (!nodes || nodes.length === 0) {
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
            return;
          }
          var nodeMap = {};
          var nodeIdxMap = {};
          nodes.forEach(function(node, i2) {
            if (!(0, util_1.isNumber)(node.x))
              node.x = Math.random() * self2.width;
            if (!(0, util_1.isNumber)(node.y))
              node.y = Math.random() * self2.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i2;
          });
          self2.nodeMap = nodeMap;
          self2.nodeIdxMap = nodeIdxMap;
          self2.linkDistance = proccessToFunc3(self2.linkDistance, 1);
          self2.nodeStrength = proccessToFunc3(self2.nodeStrength, 1);
          self2.edgeStrength = proccessToFunc3(self2.edgeStrength, 1);
          var nodeSize = self2.nodeSize;
          var nodeSizeFunc;
          if (self2.preventOverlap) {
            var nodeSpacing_1 = self2.nodeSpacing;
            var nodeSpacingFunc_1;
            if ((0, util_1.isNumber)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = function() {
                return nodeSpacing_1;
              };
            } else if ((0, util_1.isFunction)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = nodeSpacing_1;
            } else {
              nodeSpacingFunc_1 = function() {
                return 0;
              };
            }
            if (!nodeSize) {
              nodeSizeFunc = function(d2) {
                if (d2.size) {
                  if ((0, util_1.isArray)(d2.size)) {
                    return Math.max(d2.size[0], d2.size[1]) + nodeSpacingFunc_1(d2);
                  }
                  if ((0, util_1.isObject)(d2.size)) {
                    return Math.max(d2.size.width, d2.size.height) + nodeSpacingFunc_1(d2);
                  }
                  return d2.size + nodeSpacingFunc_1(d2);
                }
                return 10 + nodeSpacingFunc_1(d2);
              };
            } else if ((0, util_1.isArray)(nodeSize)) {
              nodeSizeFunc = function(d2) {
                return Math.max(nodeSize[0], nodeSize[1]) + nodeSpacingFunc_1(d2);
              };
            } else {
              nodeSizeFunc = function(d2) {
                return nodeSize + nodeSpacingFunc_1(d2);
              };
            }
          }
          self2.nodeSize = nodeSizeFunc;
          var edges = self2.edges;
          self2.degrees = (0, util_1.getDegree)(nodes.length, self2.nodeIdxMap, edges);
          if (!self2.getMass) {
            self2.getMass = function(d2) {
              var mass = d2.mass || self2.degrees[self2.nodeIdxMap[d2.id]].all || 1;
              return mass;
            };
          }
          self2.run();
        };
        GForceLayout3.prototype.run = function() {
          var _a2;
          var self2 = this;
          var maxIteration = self2.maxIteration, nodes = self2.nodes, workerEnabled = self2.workerEnabled, minMovement = self2.minMovement, animate = self2.animate;
          if (!nodes)
            return;
          if (workerEnabled || !animate) {
            for (var i2 = 0; i2 < maxIteration; i2++) {
              var previousPos = self2.runOneStep(i2);
              if (self2.reachMoveThreshold(nodes, previousPos, minMovement)) {
                break;
              }
            }
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          } else {
            if (typeof window === "undefined")
              return;
            var iter_1 = 0;
            this.timeInterval = window.setInterval(function() {
              var _a3, _b;
              if (!nodes)
                return;
              var previousPos2 = self2.runOneStep(iter_1) || [];
              if (self2.reachMoveThreshold(nodes, previousPos2, minMovement)) {
                (_a3 = self2.onLayoutEnd) === null || _a3 === void 0 ? void 0 : _a3.call(self2);
                window.clearInterval(self2.timeInterval);
              }
              iter_1++;
              if (iter_1 >= maxIteration) {
                (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
                window.clearInterval(self2.timeInterval);
              }
            }, 0);
          }
        };
        GForceLayout3.prototype.reachMoveThreshold = function(nodes, previousPos, minMovement) {
          var movement = 0;
          nodes.forEach(function(node, j2) {
            var vx = node.x - previousPos[j2].x;
            var vy = node.y - previousPos[j2].y;
            movement += Math.sqrt(vx * vx + vy * vy);
          });
          movement /= nodes.length;
          return movement < minMovement;
        };
        GForceLayout3.prototype.runOneStep = function(iter) {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges;
          var accArray = [];
          var velArray = [];
          if (!nodes)
            return;
          nodes.forEach(function(_2, i2) {
            accArray[2 * i2] = 0;
            accArray[2 * i2 + 1] = 0;
            velArray[2 * i2] = 0;
            velArray[2 * i2 + 1] = 0;
          });
          self2.calRepulsive(accArray, nodes);
          if (edges)
            self2.calAttractive(accArray, edges);
          self2.calGravity(accArray, nodes);
          var stepInterval = Math.max(0.02, self2.interval - iter * 2e-3);
          self2.updateVelocity(accArray, velArray, stepInterval, nodes);
          var previousPos = [];
          nodes.forEach(function(node) {
            previousPos.push({
              x: node.x,
              y: node.y
            });
          });
          self2.updatePosition(velArray, stepInterval, nodes);
          (_a2 = self2.tick) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          return previousPos;
        };
        GForceLayout3.prototype.calRepulsive = function(accArray, nodes) {
          var self2 = this;
          var getMass = self2.getMass, factor = self2.factor, coulombDisScale = self2.coulombDisScale, preventOverlap = self2.preventOverlap, _a2 = self2.collideStrength, collideStrength = _a2 === void 0 ? 1 : _a2;
          var nodeStrength = self2.nodeStrength;
          var nodeSize = self2.nodeSize;
          nodes.forEach(function(ni2, i2) {
            var massi = getMass ? getMass(ni2) : 1;
            nodes.forEach(function(nj, j2) {
              if (i2 >= j2)
                return;
              var vecX = ni2.x - nj.x;
              var vecY = ni2.y - nj.y;
              if (vecX === 0 && vecY === 0) {
                vecX = Math.random() * 0.01;
                vecY = Math.random() * 0.01;
              }
              var lengthSqr = vecX * vecX + vecY * vecY;
              var vecLength = Math.sqrt(lengthSqr);
              var nVecLength = (vecLength + 0.1) * coulombDisScale;
              var direX = vecX / vecLength;
              var direY = vecY / vecLength;
              var param = (nodeStrength(ni2) + nodeStrength(nj)) * 0.5 * factor / (nVecLength * nVecLength);
              var massj = getMass ? getMass(nj) : 1;
              accArray[2 * i2] += direX * param;
              accArray[2 * i2 + 1] += direY * param;
              accArray[2 * j2] -= direX * param;
              accArray[2 * j2 + 1] -= direY * param;
              if (preventOverlap && (nodeSize(ni2) + nodeSize(nj)) / 2 > vecLength) {
                var paramOverlap = collideStrength * (nodeStrength(ni2) + nodeStrength(nj)) * 0.5 / lengthSqr;
                accArray[2 * i2] += direX * paramOverlap / massi;
                accArray[2 * i2 + 1] += direY * paramOverlap / massi;
                accArray[2 * j2] -= direX * paramOverlap / massj;
                accArray[2 * j2 + 1] -= direY * paramOverlap / massj;
              }
            });
          });
        };
        GForceLayout3.prototype.calAttractive = function(accArray, edges) {
          var self2 = this;
          var nodeMap = self2.nodeMap, nodeIdxMap = self2.nodeIdxMap, linkDistance = self2.linkDistance, edgeStrength = self2.edgeStrength;
          var nodeSize = self2.nodeSize;
          var getMass = self2.getMass;
          edges.forEach(function(edge, i2) {
            var source = (0, util_1.getEdgeTerminal)(edge, "source");
            var target = (0, util_1.getEdgeTerminal)(edge, "target");
            var sourceNode = nodeMap[source];
            var targetNode = nodeMap[target];
            var vecX = targetNode.x - sourceNode.x;
            var vecY = targetNode.y - sourceNode.y;
            if (vecX === 0 && vecY === 0) {
              vecX = Math.random() * 0.01;
              vecY = Math.random() * 0.01;
            }
            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            var direX = vecX / vecLength;
            var direY = vecY / vecLength;
            var length = linkDistance(edge, sourceNode, targetNode) || 1 + (nodeSize(sourceNode) + nodeSize(targetNode) || 0) / 2;
            var diff = length - vecLength;
            var param = diff * edgeStrength(edge);
            var sourceIdx = nodeIdxMap[source];
            var targetIdx = nodeIdxMap[target];
            var massSource = getMass ? getMass(sourceNode) : 1;
            var massTarget = getMass ? getMass(targetNode) : 1;
            accArray[2 * sourceIdx] -= direX * param / massSource;
            accArray[2 * sourceIdx + 1] -= direY * param / massSource;
            accArray[2 * targetIdx] += direX * param / massTarget;
            accArray[2 * targetIdx + 1] += direY * param / massTarget;
          });
        };
        GForceLayout3.prototype.calGravity = function(accArray, nodes) {
          var self2 = this;
          var center = self2.center;
          var defaultGravity = self2.gravity;
          var degrees = self2.degrees;
          var nodeLength = nodes.length;
          for (var i2 = 0; i2 < nodeLength; i2++) {
            var node = nodes[i2];
            var vecX = node.x - center[0];
            var vecY = node.y - center[1];
            var gravity = defaultGravity;
            if (self2.getCenter) {
              var customCenterOpt = self2.getCenter(node, degrees[i2].all);
              if (customCenterOpt && (0, util_1.isNumber)(customCenterOpt[0]) && (0, util_1.isNumber)(customCenterOpt[1]) && (0, util_1.isNumber)(customCenterOpt[2])) {
                vecX = node.x - customCenterOpt[0];
                vecY = node.y - customCenterOpt[1];
                gravity = customCenterOpt[2];
              }
            }
            if (!gravity)
              continue;
            accArray[2 * i2] -= gravity * vecX;
            accArray[2 * i2 + 1] -= gravity * vecY;
          }
        };
        GForceLayout3.prototype.updateVelocity = function(accArray, velArray, stepInterval, nodes) {
          var self2 = this;
          var param = stepInterval * self2.damping;
          nodes.forEach(function(node, i2) {
            var vx = accArray[2 * i2] * param || 0.01;
            var vy = accArray[2 * i2 + 1] * param || 0.01;
            var vLength = Math.sqrt(vx * vx + vy * vy);
            if (vLength > self2.maxSpeed) {
              var param2 = self2.maxSpeed / vLength;
              vx = param2 * vx;
              vy = param2 * vy;
            }
            velArray[2 * i2] = vx;
            velArray[2 * i2 + 1] = vy;
          });
        };
        GForceLayout3.prototype.updatePosition = function(velArray, stepInterval, nodes) {
          nodes.forEach(function(node, i2) {
            if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
              node.x = node.fx;
              node.y = node.fy;
              return;
            }
            var distX = velArray[2 * i2] * stepInterval;
            var distY = velArray[2 * i2 + 1] * stepInterval;
            node.x += distX;
            node.y += distY;
          });
        };
        GForceLayout3.prototype.stop = function() {
          if (this.timeInterval && typeof window !== "undefined") {
            window.clearInterval(this.timeInterval);
          }
        };
        GForceLayout3.prototype.destroy = function() {
          var self2 = this;
          self2.stop();
          self2.tick = null;
          self2.nodes = null;
          self2.edges = null;
          self2.destroyed = true;
        };
        GForceLayout3.prototype.getType = function() {
          return "gForce";
        };
        return GForceLayout3;
      }(base_1.Base)
    );
    exports.GForceLayout = GForceLayout2;
  }
});

// node_modules/d3-quadtree/src/add.js
function add_default(d2) {
  const x4 = +this._x.call(null, d2), y4 = +this._y.call(null, d2);
  return add(this.cover(x4, y4), x4, y4, d2);
}
function add(tree, x4, y4, d2) {
  if (isNaN(x4) || isNaN(y4))
    return tree;
  var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j2;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x4 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (parent = node, !(node = node[i2 = bottom << 1 | right]))
      return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x4 === xp && y4 === yp)
    return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
    if (right = x4 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
  } while ((i2 = bottom << 1 | right) === (j2 = (yp >= ym) << 1 | xp >= xm));
  return parent[j2] = node, parent[i2] = leaf, tree;
}
function addAll(data) {
  var d2, i2, n2 = data.length, x4, y4, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x4 = +this._x.call(null, d2 = data[i2])) || isNaN(y4 = +this._y.call(null, d2)))
      continue;
    xz[i2] = x4;
    yz[i2] = y4;
    if (x4 < x0)
      x0 = x4;
    if (x4 > x1)
      x1 = x4;
    if (y4 < y0)
      y0 = y4;
    if (y4 > y1)
      y1 = y4;
  }
  if (x0 > x1 || y0 > y1)
    return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i2 = 0; i2 < n2; ++i2) {
    add(this, xz[i2], yz[i2], data[i2]);
  }
  return this;
}
var init_add = __esm({
  "node_modules/d3-quadtree/src/add.js"() {
  }
});

// node_modules/d3-quadtree/src/cover.js
function cover_default(x4, y4) {
  if (isNaN(x4 = +x4) || isNaN(y4 = +y4))
    return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x4)) + 1;
    y1 = (y0 = Math.floor(y4)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x4 || x4 >= x1 || y0 > y4 || y4 >= y1) {
      i2 = (y4 < y0) << 1 | x4 < x0;
      parent = new Array(4), parent[i2] = node, node = parent, z2 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z2, y1 = y0 + z2;
          break;
        case 1:
          x0 = x1 - z2, y1 = y0 + z2;
          break;
        case 2:
          x1 = x0 + z2, y0 = y1 - z2;
          break;
        case 3:
          x0 = x1 - z2, y0 = y1 - z2;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}
var init_cover = __esm({
  "node_modules/d3-quadtree/src/cover.js"() {
  }
});

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data.push(node.data);
      while (node = node.next);
  });
  return data;
}
var init_data = __esm({
  "node_modules/d3-quadtree/src/data.js"() {
  }
});

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
var init_extent = __esm({
  "node_modules/d3-quadtree/src/extent.js"() {
  }
});

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}
var init_quad = __esm({
  "node_modules/d3-quadtree/src/quad.js"() {
  }
});

// node_modules/d3-quadtree/src/find.js
function find_default(x4, y4, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q2, i2;
  if (node)
    quads.push(new quad_default(node, x0, y0, x32, y32));
  if (radius == null)
    radius = Infinity;
  else {
    x0 = x4 - radius, y0 = y4 - radius;
    x32 = x4 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q2 = quads.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x32 || (y1 = q2.y0) > y32 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0)
      continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i2 = (y4 >= ym) << 1 | x4 >= xm) {
        q2 = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q2;
      }
    } else {
      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d3 = Math.sqrt(radius = d2);
        x0 = x4 - d3, y0 = y4 - d3;
        x32 = x4 + d3, y32 = y4 + d3;
        data = node.data;
      }
    }
  }
  return data;
}
var init_find = __esm({
  "node_modules/d3-quadtree/src/find.js"() {
    init_quad();
  }
});

// node_modules/d3-quadtree/src/remove.js
function remove_default(d2) {
  if (isNaN(x4 = +this._x.call(null, d2)) || isNaN(y4 = +this._y.call(null, d2)))
    return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x4, y4, xm, ym, right, bottom, i2, j2;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x4 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y4 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (!(parent = node, node = node[i2 = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3])
        retainer = parent, j2 = i2;
    }
  while (node.data !== d2)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j2] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2)
    this.remove(data[i2]);
  return this;
}
var init_remove = __esm({
  "node_modules/d3-quadtree/src/remove.js"() {
  }
});

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}
var init_root = __esm({
  "node_modules/d3-quadtree/src/root.js"() {
  }
});

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size3 = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size3;
      while (node = node.next);
  });
  return size3;
}
var init_size = __esm({
  "node_modules/d3-quadtree/src/size.js"() {
  }
});

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q2, node = this._root, child, x0, y0, x1, y1;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}
var init_visit = __esm({
  "node_modules/d3-quadtree/src/visit.js"() {
    init_quad();
  }
});

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q2;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
  }
  return this;
}
var init_visitAfter = __esm({
  "node_modules/d3-quadtree/src/visitAfter.js"() {
    init_quad();
  }
});

// node_modules/d3-quadtree/src/x.js
function defaultX(d2) {
  return d2[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
var init_x = __esm({
  "node_modules/d3-quadtree/src/x.js"() {
  }
});

// node_modules/d3-quadtree/src/y.js
function defaultY(d2) {
  return d2[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}
var init_y = __esm({
  "node_modules/d3-quadtree/src/y.js"() {
  }
});

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x4, y4) {
  var tree = new Quadtree(x4 == null ? defaultX : x4, y4 == null ? defaultY : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x4, y4, x0, y0, x1, y1) {
  this._x = x4;
  this._y = y4;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy;
}
var treeProto;
var init_quadtree = __esm({
  "node_modules/d3-quadtree/src/quadtree.js"() {
    init_add();
    init_cover();
    init_data();
    init_extent();
    init_find();
    init_remove();
    init_root();
    init_size();
    init_visit();
    init_visitAfter();
    init_x();
    init_y();
    treeProto = quadtree.prototype = Quadtree.prototype;
    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
      if (!node)
        return copy;
      if (!node.length)
        return copy._root = leaf_copy(node), copy;
      nodes = [{ source: node, target: copy._root = new Array(4) }];
      while (node = nodes.pop()) {
        for (var i2 = 0; i2 < 4; ++i2) {
          if (child = node.source[i2]) {
            if (child.length)
              nodes.push({ source: child, target: node.target[i2] = new Array(4) });
            else
              node.target[i2] = leaf_copy(child);
          }
        }
      }
      return copy;
    };
    treeProto.add = add_default;
    treeProto.addAll = addAll;
    treeProto.cover = cover_default;
    treeProto.data = data_default;
    treeProto.extent = extent_default;
    treeProto.find = find_default;
    treeProto.remove = remove_default;
    treeProto.removeAll = removeAll;
    treeProto.root = root_default;
    treeProto.size = size_default;
    treeProto.visit = visit_default;
    treeProto.visitAfter = visitAfter_default;
    treeProto.x = x_default;
    treeProto.y = y_default;
  }
});

// node_modules/d3-quadtree/src/index.js
var src_exports = {};
__export(src_exports, {
  quadtree: () => quadtree
});
var init_src2 = __esm({
  "node_modules/d3-quadtree/src/index.js"() {
    init_quadtree();
  }
});

// node_modules/@antv/layout/lib/layout/force2/ForceNBody.js
var require_ForceNBody = __commonJS({
  "node_modules/@antv/layout/lib/layout/force2/ForceNBody.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forceNBody = void 0;
    var d3_quadtree_1 = (init_src2(), __toCommonJS(src_exports));
    var theta2 = 0.81;
    var epsilon = 0.1;
    function forceNBody(nodes, nodeMap, factor, coulombDisScale2, accArray) {
      var weightParam = factor / coulombDisScale2;
      var data = nodes.map(function(n2, i2) {
        var mappedNode = nodeMap[n2.id];
        var nodeData = mappedNode.data, x4 = mappedNode.x, y4 = mappedNode.y, size3 = mappedNode.size;
        var nodeStrength = nodeData.layout.force.nodeStrength;
        return {
          x: x4,
          y: y4,
          size: size3,
          index: i2,
          vx: 0,
          vy: 0,
          weight: weightParam * nodeStrength
        };
      });
      var tree = (0, d3_quadtree_1.quadtree)(data, function(d2) {
        return d2.x;
      }, function(d2) {
        return d2.y;
      }).visitAfter(accumulate);
      data.forEach(function(n2) {
        computeForce(n2, tree);
      });
      data.map(function(n2, i2) {
        var mappedNode = nodeMap[nodes[i2].id];
        var _a2 = mappedNode.data.layout.force.mass, mass = _a2 === void 0 ? 1 : _a2;
        accArray[2 * i2] = n2.vx / mass;
        accArray[2 * i2 + 1] = n2.vy / mass;
      });
      return accArray;
    }
    exports.forceNBody = forceNBody;
    function accumulate(quad) {
      var accWeight = 0;
      var accX = 0;
      var accY = 0;
      if (quad.length) {
        for (var i2 = 0; i2 < 4; i2++) {
          var q2 = quad[i2];
          if (q2 && q2.weight) {
            accWeight += q2.weight;
            accX += q2.x * q2.weight;
            accY += q2.y * q2.weight;
          }
        }
        quad.x = accX / accWeight;
        quad.y = accY / accWeight;
        quad.weight = accWeight;
      } else {
        var q2 = quad;
        quad.x = q2.data.x;
        quad.y = q2.data.y;
        quad.weight = q2.data.weight;
      }
    }
    var apply = function(quad, x1, y1, x22, y22, node) {
      var dx = node.x - quad.x || epsilon;
      var dy = node.y - quad.y || epsilon;
      var width = x22 - x1;
      var len2 = dx * dx + dy * dy;
      var len3 = Math.sqrt(len2) * len2;
      if (width * width * theta2 < len2) {
        var param = quad.weight / len3;
        node.vx += dx * param;
        node.vy += dy * param;
        return true;
      }
      if (quad.length)
        return false;
      if (quad.data !== node) {
        var param = quad.data.weight / len3;
        node.vx += dx * param;
        node.vy += dy * param;
      }
    };
    function computeForce(node, tree) {
      tree.visit(function(quad, x1, y1, x22, y22) {
        return apply(quad, x1, y1, x22, y22, node);
      });
    }
  }
});

// node_modules/@antv/layout/lib/layout/force2/index.js
var require_force2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/force2/index.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __assign14 = exports && exports.__assign || function() {
      __assign14 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign14.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Force2Layout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var ForceNBody_1 = require_ForceNBody();
    var proccessToFunc3 = function(value, defaultV) {
      var func;
      if (!value) {
        func = function(d2) {
          return defaultV || 1;
        };
      } else if ((0, util_1.isNumber)(value)) {
        func = function(d2) {
          return value;
        };
      } else {
        func = value;
      }
      return func;
    };
    var Force2Layout2 = (
      /** @class */
      function(_super) {
        __extends15(Force2Layout3, _super);
        function Force2Layout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.workerEnabled = false;
          _this.edgeStrength = 200;
          _this.nodeStrength = 1e3;
          _this.coulombDisScale = 5e-3;
          _this.damping = 0.9;
          _this.maxSpeed = 500;
          _this.minMovement = 0.4;
          _this.interval = 0.02;
          _this.factor = 1;
          _this.linkDistance = 200;
          _this.gravity = 0;
          _this.clusterNodeStrength = 20;
          _this.preventOverlap = true;
          _this.distanceThresholdMode = "mean";
          _this.tick = function() {
          };
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.judgingDistance = 0;
          _this.centripetalOptions = {
            leaf: 2,
            single: 2,
            others: 1,
            // eslint-disable-next-line
            center: function(n2) {
              return {
                x: _this.width / 2,
                y: _this.height / 2
              };
            }
          };
          var getMass = options.getMass;
          _this.propsGetMass = getMass;
          _this.updateCfg(options);
          return _this;
        }
        Force2Layout3.prototype.getCentripetalOptions = function() {
          var _a2 = this, leafCluster = _a2.leafCluster, clustering = _a2.clustering, nodeClusterBy = _a2.nodeClusterBy, nodes = _a2.nodes, nodeMap = _a2.nodeMap, propsClusterNodeStrength = _a2.clusterNodeStrength;
          var getClusterNodeStrength = function(node) {
            return typeof propsClusterNodeStrength === "function" ? propsClusterNodeStrength(node) : propsClusterNodeStrength;
          };
          var centripetalOptions = {};
          var sameTypeLeafMap;
          if (leafCluster) {
            sameTypeLeafMap = this.getSameTypeLeafMap() || {};
            var relativeNodesType_1 = Array.from(new Set(nodes === null || nodes === void 0 ? void 0 : nodes.map(function(node) {
              return node[nodeClusterBy];
            }))) || [];
            centripetalOptions = {
              single: 100,
              leaf: function(node, nodes2, edges) {
                var _a3 = sameTypeLeafMap[node.id] || {}, relativeLeafNodes = _a3.relativeLeafNodes, sameTypeLeafNodes = _a3.sameTypeLeafNodes;
                if ((sameTypeLeafNodes === null || sameTypeLeafNodes === void 0 ? void 0 : sameTypeLeafNodes.length) === (relativeLeafNodes === null || relativeLeafNodes === void 0 ? void 0 : relativeLeafNodes.length) || (relativeNodesType_1 === null || relativeNodesType_1 === void 0 ? void 0 : relativeNodesType_1.length) === 1) {
                  return 1;
                }
                return getClusterNodeStrength(node);
              },
              others: 1,
              center: function(node, nodes2, edges) {
                var _a3;
                var degree3 = (((_a3 = node.data) === null || _a3 === void 0 ? void 0 : _a3.layout) || {}).degree;
                if (!degree3) {
                  return {
                    x: 100,
                    y: 100
                  };
                }
                var centerNode;
                if (degree3 === 1) {
                  var _b2 = (sameTypeLeafMap[node.id] || {}).sameTypeLeafNodes, sameTypeLeafNodes = _b2 === void 0 ? [] : _b2;
                  if (sameTypeLeafNodes.length === 1) {
                    centerNode = void 0;
                  } else if (sameTypeLeafNodes.length > 1) {
                    centerNode = (0, util_1.getAvgNodePosition)(sameTypeLeafNodes);
                  }
                } else {
                  centerNode = void 0;
                }
                return {
                  x: centerNode === null || centerNode === void 0 ? void 0 : centerNode.x,
                  y: centerNode === null || centerNode === void 0 ? void 0 : centerNode.y
                };
              }
            };
          }
          if (clustering) {
            if (!sameTypeLeafMap)
              sameTypeLeafMap = this.getSameTypeLeafMap();
            var clusters = Array.from(new Set(nodes.map(function(node, i2) {
              return node[nodeClusterBy];
            }))).filter(function(item) {
              return item !== void 0;
            });
            var centerNodeInfo_1 = {};
            clusters.forEach(function(cluster) {
              var sameTypeNodes = nodes.filter(function(item) {
                return item[nodeClusterBy] === cluster;
              }).map(function(node) {
                return nodeMap[node.id];
              });
              centerNodeInfo_1[cluster] = (0, util_1.getAvgNodePosition)(sameTypeNodes);
            });
            centripetalOptions = {
              single: function(node) {
                return getClusterNodeStrength(node);
              },
              leaf: function(node) {
                return getClusterNodeStrength(node);
              },
              others: function(node) {
                return getClusterNodeStrength(node);
              },
              center: function(node, nodes2, edges) {
                var centerNode = centerNodeInfo_1[node[nodeClusterBy]];
                return {
                  x: centerNode === null || centerNode === void 0 ? void 0 : centerNode.x,
                  y: centerNode === null || centerNode === void 0 ? void 0 : centerNode.y
                };
              }
            };
          }
          this.centripetalOptions = __assign14(__assign14({}, this.centripetalOptions), centripetalOptions);
          var _b = this.centripetalOptions, leaf = _b.leaf, single = _b.single, others = _b.others;
          if (leaf && typeof leaf !== "function")
            this.centripetalOptions.leaf = function() {
              return leaf;
            };
          if (single && typeof single !== "function")
            this.centripetalOptions.single = function() {
              return single;
            };
          if (others && typeof others !== "function")
            this.centripetalOptions.others = function() {
              return others;
            };
        };
        Force2Layout3.prototype.updateCfg = function(cfg) {
          if (cfg)
            Object.assign(this, cfg);
        };
        Force2Layout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 500,
            gravity: 10,
            enableTick: true,
            animate: true
          };
        };
        Force2Layout3.prototype.execute = function() {
          var self2 = this;
          self2.stop();
          var nodes = self2.nodes, edges = self2.edges, defSpringLen = self2.defSpringLen;
          self2.judgingDistance = 0;
          if (!nodes || nodes.length === 0) {
            self2.onLayoutEnd([]);
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            self2.onLayoutEnd([__assign14({}, nodes[0])]);
            return;
          }
          self2.degreesMap = (0, util_1.getDegreeMap)(nodes, edges);
          if (self2.propsGetMass) {
            self2.getMass = self2.propsGetMass;
          } else {
            self2.getMass = function(d2) {
              var massWeight = 1;
              if ((0, util_1.isNumber)(d2.mass))
                massWeight = d2.mass;
              var degree3 = self2.degreesMap[d2.id].all;
              return !degree3 || degree3 < 5 ? massWeight : degree3 * 5 * massWeight;
            };
          }
          var nodeSize = self2.nodeSize;
          var nodeSizeFunc;
          if (self2.preventOverlap) {
            var nodeSpacing_1 = self2.nodeSpacing;
            var nodeSpacingFunc_1;
            if ((0, util_1.isNumber)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = function() {
                return nodeSpacing_1;
              };
            } else if ((0, util_1.isFunction)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = nodeSpacing_1;
            } else {
              nodeSpacingFunc_1 = function() {
                return 0;
              };
            }
            if (!nodeSize) {
              nodeSizeFunc = function(d2) {
                if (d2.size) {
                  if ((0, util_1.isArray)(d2.size)) {
                    return Math.max(d2.size[0], d2.size[1]) + nodeSpacingFunc_1(d2);
                  } else if ((0, util_1.isObject)(d2.size)) {
                    return Math.max(d2.size.width, d2.size.height) + nodeSpacingFunc_1(d2);
                  }
                  return d2.size + nodeSpacingFunc_1(d2);
                }
                return 10 + nodeSpacingFunc_1(d2);
              };
            } else if ((0, util_1.isArray)(nodeSize)) {
              nodeSizeFunc = function(d2) {
                return Math.max(nodeSize[0], nodeSize[1]) + nodeSpacingFunc_1(d2);
              };
            } else {
              nodeSizeFunc = function(d2) {
                return nodeSize + nodeSpacingFunc_1(d2);
              };
            }
          }
          self2.nodeSize = nodeSizeFunc;
          self2.linkDistance = proccessToFunc3(self2.linkDistance, 1);
          self2.nodeStrength = proccessToFunc3(self2.nodeStrength, 1);
          self2.edgeStrength = proccessToFunc3(self2.edgeStrength, 1);
          var nodeMap = {};
          var nodeIdxMap = {};
          nodes.forEach(function(node, i2) {
            if (!(0, util_1.isNumber)(node.x))
              node.x = Math.random() * self2.width;
            if (!(0, util_1.isNumber)(node.y))
              node.y = Math.random() * self2.height;
            var degree3 = self2.degreesMap[node.id];
            nodeMap[node.id] = __assign14(__assign14({}, node), { data: __assign14(__assign14({}, node.data), { size: self2.nodeSize(node) || 30, layout: {
              inDegree: degree3.in,
              outDegree: degree3.out,
              degree: degree3.all,
              tDegree: degree3.in,
              sDegree: degree3.out,
              force: {
                mass: self2.getMass(node),
                nodeStrength: self2.nodeStrength(node, edges)
              }
            } }) });
            nodeIdxMap[node.id] = i2;
          });
          self2.nodeMap = nodeMap;
          self2.nodeIdxMap = nodeIdxMap;
          self2.edgeInfos = [];
          edges === null || edges === void 0 ? void 0 : edges.forEach(function(edge) {
            var sourceNode = nodeMap[edge.source];
            var targetNode = nodeMap[edge.target];
            if (!sourceNode || !targetNode) {
              elf.edgeInfos.push({});
            } else {
              self2.edgeInfos.push({
                edgeStrength: self2.edgeStrength(edge),
                linkDistance: defSpringLen ? defSpringLen(__assign14(__assign14({}, edge), { source: sourceNode, target: targetNode }), sourceNode, targetNode) : self2.linkDistance(edge, sourceNode, targetNode) || 1 + (nodeSize(sourceNode) + nodeSize(sourceNode) || 0) / 2
              });
            }
          });
          this.getCentripetalOptions();
          self2.onLayoutEnd = self2.onLayoutEnd || function() {
          };
          self2.run();
        };
        Force2Layout3.prototype.run = function() {
          var self2 = this;
          var maxIteration = self2.maxIteration, nodes = self2.nodes, edges = self2.edges, workerEnabled = self2.workerEnabled, minMovement = self2.minMovement, animate = self2.animate, nodeMap = self2.nodeMap, height = self2.height;
          self2.currentMinY = 0;
          self2.currentMaxY = height;
          if (!nodes)
            return;
          var velArray = [];
          nodes.forEach(function(_2, i3) {
            velArray[2 * i3] = 0;
            velArray[2 * i3 + 1] = 0;
          });
          if (this.defSideCoe && typeof this.defSideCoe === "function") {
            var relatedEdges_1 = {};
            edges.forEach(function(edge) {
              var source = edge.source, target = edge.target;
              relatedEdges_1[source] = relatedEdges_1[source] || [];
              relatedEdges_1[source].push(edge);
              relatedEdges_1[target] = relatedEdges_1[target] || [];
              relatedEdges_1[target].push(edge);
            });
            this.relatedEdges = relatedEdges_1;
          }
          var maxIter = maxIteration;
          var silence = !animate;
          if (workerEnabled || silence) {
            var usedIter = 0;
            for (var i2 = 0; (self2.judgingDistance > minMovement || i2 < 1) && i2 < maxIter; i2++) {
              usedIter = i2;
              self2.runOneStep(i2, velArray);
            }
            self2.onLayoutEnd(Object.values(nodeMap));
          } else {
            if (typeof window === "undefined")
              return;
            var iter_1 = 0;
            this.timeInterval = window.setInterval(function() {
              if (!nodes)
                return;
              self2.runOneStep(iter_1, velArray);
              iter_1++;
              if (iter_1 >= maxIter || self2.judgingDistance < minMovement) {
                self2.onLayoutEnd(Object.values(nodeMap));
                window.clearInterval(self2.timeInterval);
              }
            }, 0);
          }
        };
        Force2Layout3.prototype.runOneStep = function(iter, velArray) {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges, nodeMap = self2.nodeMap, monitor = self2.monitor;
          var accArray = [];
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          self2.calRepulsive(accArray);
          if (edges)
            self2.calAttractive(accArray);
          self2.calGravity(accArray);
          self2.attractToSide(accArray);
          var stepInterval = self2.interval;
          self2.updateVelocity(accArray, velArray, stepInterval);
          self2.updatePosition(velArray, stepInterval);
          (_a2 = self2.tick) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          if (monitor) {
            var energy = this.calTotalEnergy(accArray);
            monitor({ energy, nodes, edges, iterations: iter });
          }
        };
        Force2Layout3.prototype.calTotalEnergy = function(accArray) {
          var _a2 = this, nodes = _a2.nodes, nodeMap = _a2.nodeMap;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return 0;
          var energy = 0;
          nodes.forEach(function(node, i2) {
            var vx = accArray[2 * i2];
            var vy = accArray[2 * i2 + 1];
            var speed2 = vx * vx + vy * vy;
            var _a3 = nodeMap[node.id].data.layout.force.mass, mass = _a3 === void 0 ? 1 : _a3;
            energy += mass * speed2 * 0.5;
          });
          return energy;
        };
        Force2Layout3.prototype.calRepulsive = function(accArray) {
          var self2 = this;
          var nodes = self2.nodes, nodeMap = self2.nodeMap, factor = self2.factor, coulombDisScale = self2.coulombDisScale;
          var nodeSize = self2.nodeSize;
          (0, ForceNBody_1.forceNBody)(nodes, nodeMap, factor, coulombDisScale * coulombDisScale, accArray);
        };
        Force2Layout3.prototype.calAttractive = function(accArray) {
          var self2 = this;
          var edges = self2.edges, nodeMap = self2.nodeMap, nodeIdxMap = self2.nodeIdxMap, edgeInfos = self2.edgeInfos;
          var nodeSize = self2.nodeSize;
          edges.forEach(function(edge, i2) {
            var source = (0, util_1.getEdgeTerminal)(edge, "source");
            var target = (0, util_1.getEdgeTerminal)(edge, "target");
            var sourceNode = nodeMap[source];
            var targetNode = nodeMap[target];
            if (!sourceNode || !targetNode)
              return;
            var vecX = targetNode.x - sourceNode.x;
            var vecY = targetNode.y - sourceNode.y;
            if (!vecX && !vecY) {
              vecX = Math.random() * 0.01;
              vecY = Math.random() * 0.01;
            }
            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            var direX = vecX / vecLength;
            var direY = vecY / vecLength;
            var _a2 = edgeInfos[i2] || {}, _b = _a2.linkDistance, linkDistance = _b === void 0 ? 200 : _b, _c = _a2.edgeStrength, edgeStrength = _c === void 0 ? 200 : _c;
            var diff = linkDistance - vecLength;
            var param = diff * edgeStrength;
            var massSource = sourceNode.data.layout.force.mass || 1;
            var massTarget = targetNode.data.layout.force.mass || 1;
            var sourceMassRatio = 1 / massSource;
            var targetMassRatio = 1 / massTarget;
            var disX = direX * param;
            var disY = direY * param;
            var sourceIdx = 2 * nodeIdxMap[source];
            var targetIdx = 2 * nodeIdxMap[target];
            accArray[sourceIdx] -= disX * sourceMassRatio;
            accArray[sourceIdx + 1] -= disY * sourceMassRatio;
            accArray[targetIdx] += disX * targetMassRatio;
            accArray[targetIdx + 1] += disY * targetMassRatio;
          });
        };
        Force2Layout3.prototype.calGravity = function(accArray) {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes, _b = self2.edges, edges = _b === void 0 ? [] : _b, nodeMap = self2.nodeMap, width = self2.width, height = self2.height, center = self2.center, defaultGravity = self2.gravity, degreesMap = self2.degreesMap, centripetalOptions = self2.centripetalOptions;
          if (!nodes)
            return;
          var nodeLength = nodes.length;
          for (var i2 = 0; i2 < nodeLength; i2++) {
            var idx = 2 * i2;
            var node = nodeMap[nodes[i2].id];
            var _c = node.data.layout.force.mass, mass = _c === void 0 ? 1 : _c;
            var vecX = 0;
            var vecY = 0;
            var gravity = defaultGravity;
            var _d = degreesMap[node.id], inDegree = _d.in, outDegree = _d.out, degree3 = _d.all;
            var forceCenter = (_a2 = self2.getCenter) === null || _a2 === void 0 ? void 0 : _a2.call(self2, node, degree3);
            if (forceCenter) {
              var centerX = forceCenter[0], centerY = forceCenter[1], strength = forceCenter[2];
              vecX = node.x - centerX;
              vecY = node.y - centerY;
              gravity = strength;
            } else {
              vecX = node.x - center[0];
              vecY = node.y - center[1];
            }
            if (gravity) {
              accArray[idx] -= gravity * vecX / mass;
              accArray[idx + 1] -= gravity * vecY / mass;
            }
            if (centripetalOptions) {
              var leaf = centripetalOptions.leaf, single = centripetalOptions.single, others = centripetalOptions.others, centriCenter = centripetalOptions.center;
              var _e2 = (centriCenter === null || centriCenter === void 0 ? void 0 : centriCenter(node, nodes, edges, width, height)) || {
                x: 0,
                y: 0,
                centerStrength: 0
              }, centriX = _e2.x, centriY = _e2.y, centerStrength = _e2.centerStrength;
              if (!(0, util_1.isNumber)(centriX) || !(0, util_1.isNumber)(centriY))
                continue;
              var vx = (node.x - centriX) / mass;
              var vy = (node.y - centriY) / mass;
              if (centerStrength) {
                accArray[idx] -= centerStrength * vx;
                accArray[idx + 1] -= centerStrength * vy;
              }
              if (degree3 === 0) {
                var singleStrength = single(node);
                if (!singleStrength)
                  continue;
                accArray[idx] -= singleStrength * vx;
                accArray[idx + 1] -= singleStrength * vy;
                continue;
              }
              if (inDegree === 0 || outDegree === 0) {
                var leafStrength = leaf(node, nodes, edges);
                if (!leafStrength)
                  continue;
                accArray[idx] -= leafStrength * vx;
                accArray[idx + 1] -= leafStrength * vy;
                continue;
              }
              var othersStrength = others(node);
              if (!othersStrength)
                continue;
              accArray[idx] -= othersStrength * vx;
              accArray[idx + 1] -= othersStrength * vy;
            }
          }
        };
        Force2Layout3.prototype.attractToSide = function(accArray) {
          var _a2 = this, defSideCoe = _a2.defSideCoe, height = _a2.height, nodes = _a2.nodes, relatedEdges = _a2.relatedEdges, _b = _a2.currentMinY, currentMinY = _b === void 0 ? 0 : _b, _c = _a2.currentMaxY, currentMaxY = _c === void 0 ? this.height : _c;
          if (!defSideCoe || typeof defSideCoe !== "function" || !(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          nodes.forEach(function(node, i2) {
            var sideCoe = defSideCoe(node, relatedEdges[node.id] || []);
            if (sideCoe === 0)
              return;
            var targetY = sideCoe < 0 ? currentMinY : currentMaxY;
            var strength = Math.abs(sideCoe);
            accArray[2 * i2 + 1] -= strength * (node.y - targetY);
          });
        };
        Force2Layout3.prototype.updateVelocity = function(accArray, velArray, stepInterval) {
          var self2 = this;
          var nodes = self2.nodes, damping = self2.damping, maxSpeed = self2.maxSpeed;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          nodes.forEach(function(_2, i2) {
            var vx = (velArray[2 * i2] + accArray[2 * i2] * stepInterval) * damping || 0.01;
            var vy = (velArray[2 * i2 + 1] + accArray[2 * i2 + 1] * stepInterval) * damping || 0.01;
            var vLength = Math.sqrt(vx * vx + vy * vy);
            if (vLength > maxSpeed) {
              var param2 = maxSpeed / vLength;
              vx = param2 * vx;
              vy = param2 * vy;
            }
            velArray[2 * i2] = vx;
            velArray[2 * i2 + 1] = vy;
          });
        };
        Force2Layout3.prototype.updatePosition = function(velArray, stepInterval) {
          var self2 = this;
          var nodes = self2.nodes, distanceThresholdMode = self2.distanceThresholdMode, nodeMap = self2.nodeMap;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
            this.judgingDistance = 0;
            return;
          }
          var sum = 0;
          if (distanceThresholdMode === "max")
            self2.judgingDistance = -Infinity;
          else if (distanceThresholdMode === "min")
            self2.judgingDistance = Infinity;
          var currentMinY = Infinity;
          var currentMaxY = -Infinity;
          nodes.forEach(function(node, i2) {
            var mappedNode = nodeMap[node.id];
            if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
              node.x = node.fx;
              node.y = node.fy;
              mappedNode.x = node.x;
              mappedNode.y = node.y;
              return;
            }
            var distX = velArray[2 * i2] * stepInterval;
            var distY = velArray[2 * i2 + 1] * stepInterval;
            node.x += distX;
            node.y += distY;
            mappedNode.x = node.x;
            mappedNode.y = node.y;
            if (node.y < currentMinY)
              currentMinY = node.y;
            if (node.y > currentMaxY)
              currentMaxY = node.y;
            var distanceMagnitude = Math.sqrt(distX * distX + distY * distY);
            switch (distanceThresholdMode) {
              case "max":
                if (self2.judgingDistance < distanceMagnitude)
                  self2.judgingDistance = distanceMagnitude;
                break;
              case "min":
                if (self2.judgingDistance > distanceMagnitude)
                  self2.judgingDistance = distanceMagnitude;
                break;
              default:
                sum = sum + distanceMagnitude;
                break;
            }
          });
          this.currentMinY = currentMinY;
          this.currentMaxY = currentMaxY;
          if (!distanceThresholdMode || distanceThresholdMode === "mean")
            self2.judgingDistance = sum / nodes.length;
        };
        Force2Layout3.prototype.stop = function() {
          if (this.timeInterval && typeof window !== "undefined") {
            window.clearInterval(this.timeInterval);
          }
        };
        Force2Layout3.prototype.destroy = function() {
          var self2 = this;
          self2.stop();
          self2.tick = null;
          self2.nodes = null;
          self2.edges = null;
          self2.destroyed = true;
        };
        Force2Layout3.prototype.getType = function() {
          return "force2";
        };
        Force2Layout3.prototype.getSameTypeLeafMap = function() {
          var _a2 = this, nodeClusterBy = _a2.nodeClusterBy, nodes = _a2.nodes, edges = _a2.edges, nodeMap = _a2.nodeMap, degreesMap = _a2.degreesMap;
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          var sameTypeLeafMap = {};
          nodes.forEach(function(node, i2) {
            var degree3 = degreesMap[node.id].all;
            if (degree3 === 1) {
              sameTypeLeafMap[node.id] = (0, util_1.getCoreNodeAndRelativeLeafNodes)("leaf", node, edges, nodeClusterBy, degreesMap, nodeMap);
            }
          });
          return sameTypeLeafMap;
        };
        return Force2Layout3;
      }(base_1.Base)
    );
    exports.Force2Layout = Force2Layout2;
  }
});

// node_modules/d3-force/src/center.js
function center_default(x4, y4) {
  var nodes, strength = 1;
  if (x4 == null)
    x4 = 0;
  if (y4 == null)
    y4 = 0;
  function force() {
    var i2, n2 = nodes.length, node, sx = 0, sy = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n2 - x4) * strength, sy = (sy / n2 - y4) * strength, i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x4 = +_2, force) : x4;
  };
  force.y = function(_2) {
    return arguments.length ? (y4 = +_2, force) : y4;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}
var init_center = __esm({
  "node_modules/d3-force/src/center.js"() {
  }
});

// node_modules/d3-force/src/constant.js
function constant_default(x4) {
  return function() {
    return x4;
  };
}
var init_constant = __esm({
  "node_modules/d3-force/src/constant.js"() {
  }
});

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}
var init_jiggle = __esm({
  "node_modules/d3-force/src/jiggle.js"() {
  }
});

// node_modules/d3-force/src/collide.js
function x(d2) {
  return d2.x + d2.vx;
}
function y(d2) {
  return d2.y + d2.vy;
}
function collide_default(radius) {
  var nodes, radii, random, strength = 1, iterations = 1;
  if (typeof radius !== "function")
    radius = constant_default(radius == null ? 1 : +radius);
  function force() {
    var i2, n2 = nodes.length, tree, node, xi2, yi2, ri2, ri22;
    for (var k2 = 0; k2 < iterations; ++k2) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        ri2 = radii[node.index], ri22 = ri2 * ri2;
        xi2 = node.x + node.vx;
        yi2 = node.y + node.vy;
        tree.visit(apply);
      }
    }
    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r2 = ri2 + rj;
      if (data) {
        if (data.index > node.index) {
          var x4 = xi2 - data.x - data.vx, y4 = yi2 - data.y - data.vy, l2 = x4 * x4 + y4 * y4;
          if (l2 < r2 * r2) {
            if (x4 === 0)
              x4 = jiggle_default(random), l2 += x4 * x4;
            if (y4 === 0)
              y4 = jiggle_default(random), l2 += y4 * y4;
            l2 = (r2 - (l2 = Math.sqrt(l2))) / l2 * strength;
            node.vx += (x4 *= l2) * (r2 = (rj *= rj) / (ri22 + rj));
            node.vy += (y4 *= l2) * r2;
            data.vx -= x4 * (r2 = 1 - r2);
            data.vy -= y4 * r2;
          }
        }
        return;
      }
      return x0 > xi2 + r2 || x1 < xi2 - r2 || y0 > yi2 + r2 || y1 < yi2 - r2;
    }
  }
  function prepare(quad) {
    if (quad.data)
      return quad.r = radii[quad.data.index];
    for (var i2 = quad.r = 0; i2 < 4; ++i2) {
      if (quad[i2] && quad[i2].r > quad.r) {
        quad.r = quad[i2].r;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length, node;
    radii = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2)
      node = nodes[i2], radii[node.index] = +radius(node, i2, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : radius;
  };
  return force;
}
var init_collide = __esm({
  "node_modules/d3-force/src/collide.js"() {
    init_src2();
    init_constant();
    init_jiggle();
  }
});

// node_modules/d3-force/src/link.js
function index(d2) {
  return d2.index;
}
function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id = index, strength = defaultStrength, strengths, distance6 = constant_default(30), distances, nodes, count, bias, random, iterations = 1;
  if (links == null)
    links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n2 = links.length; k2 < iterations; ++k2) {
      for (var i2 = 0, link, source, target, x4, y4, l2, b2; i2 < n2; ++i2) {
        link = links[i2], source = link.source, target = link.target;
        x4 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
        l2 = Math.sqrt(x4 * x4 + y4 * y4);
        l2 = (l2 - distances[i2]) / l2 * alpha * strengths[i2];
        x4 *= l2, y4 *= l2;
        target.vx -= x4 * (b2 = bias[i2]);
        target.vy -= y4 * b2;
        source.vx += x4 * (b2 = 1 - b2);
        source.vy += y4 * b2;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d2, i3) => [id(d2, i3, nodes), d2])), link;
    for (i2 = 0, count = new Array(n2); i2 < m3; ++i2) {
      link = links[i2], link.index = i2;
      if (typeof link.source !== "object")
        link.source = find(nodeById, link.source);
      if (typeof link.target !== "object")
        link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m3); i2 < m3; ++i2) {
      link = links[i2], bias[i2] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance6(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id = _2, force) : id;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance6 = typeof _2 === "function" ? _2 : constant_default(+_2), initializeDistance(), force) : distance6;
  };
  return force;
}
var init_link = __esm({
  "node_modules/d3-force/src/link.js"() {
    init_constant();
    init_jiggle();
  }
});

// node_modules/d3-dispatch/src/dispatch.js
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _2 || /[\s.]/.test(t2))
      throw new Error("illegal type: " + t2);
    _2[t2] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0)
      name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    if (t2 && !types.hasOwnProperty(t2))
      throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
function get2(type, name) {
  for (var i2 = 0, n2 = type.length, c3; i2 < n2; ++i2) {
    if ((c3 = type[i2]).name === name) {
      return c3.value;
    }
  }
}
function set2(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
    if (type[i2].name === name) {
      type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
var noop, dispatch_default;
var init_dispatch = __esm({
  "node_modules/d3-dispatch/src/dispatch.js"() {
    noop = { value: () => {
    } };
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _2 = this._, T2 = parseTypenames(typename + "", _2), t2, i2 = -1, n2 = T2.length;
        if (arguments.length < 2) {
          while (++i2 < n2)
            if ((t2 = (typename = T2[i2]).type) && (t2 = get2(_2[t2], typename.name)))
              return t2;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i2 < n2) {
          if (t2 = (typename = T2[i2]).type)
            _2[t2] = set2(_2[t2], typename.name, callback);
          else if (callback == null)
            for (t2 in _2)
              _2[t2] = set2(_2[t2], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy = {}, _2 = this._;
        for (var t2 in _2)
          copy[t2] = _2[t2].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n2 = arguments.length - 2) > 0)
          for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2)
            args[i2] = arguments[i2 + 2];
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2)
          t2[i2].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2)
          t2[i2].value.apply(that, args);
      }
    };
    dispatch_default = dispatch;
  }
});

// node_modules/d3-dispatch/src/index.js
var init_src3 = __esm({
  "node_modules/d3-dispatch/src/index.js"() {
    init_dispatch();
  }
});

// node_modules/d3-force/src/lcg.js
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a * s2 + c) % m) / m;
}
var a, c, m;
var init_lcg = __esm({
  "node_modules/d3-force/src/lcg.js"() {
    a = 1664525;
    c = 1013904223;
    m = 4294967296;
  }
});

// node_modules/d3-force/src/simulation.js
function x2(d2) {
  return d2.x;
}
function y2(d2) {
  return d2.y;
}
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i2, n2 = nodes.length, node;
    if (iterations === void 0)
      iterations = 1;
    for (var k2 = 0; k2 < iterations; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i2), angle = i2 * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function(x4, y4, radius) {
      var i2 = 0, n2 = nodes.length, dx, dy, d2, node, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x4 - node.x;
        dy = y4 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius)
          closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}
var initialRadius, initialAngle;
var init_simulation = __esm({
  "node_modules/d3-force/src/simulation.js"() {
    init_src3();
    init_src();
    init_lcg();
    initialRadius = 10;
    initialAngle = Math.PI * (3 - Math.sqrt(5));
  }
});

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random, alpha, strength = constant_default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i2, n2 = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _2, i2 = 0; i2 < n2; ++i2)
      node = nodes[i2], tree.visit(apply);
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2)
      node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q2, c3, weight = 0, x4, y4, i2;
    if (quad.length) {
      for (x4 = y4 = i2 = 0; i2 < 4; ++i2) {
        if ((q2 = quad[i2]) && (c3 = Math.abs(q2.value))) {
          strength2 += q2.value, weight += c3, x4 += c3 * q2.x, y4 += c3 * q2.y;
        }
      }
      quad.x = x4 / weight;
      quad.y = y4 / weight;
    } else {
      q2 = quad;
      q2.x = q2.data.x;
      q2.y = q2.data.y;
      do
        strength2 += strengths[q2.data.index];
      while (q2 = q2.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x1, _2, x22) {
    if (!quad.value)
      return true;
    var x4 = quad.x - node.x, y4 = quad.y - node.y, w2 = x22 - x1, l2 = x4 * x4 + y4 * y4;
    if (w2 * w2 / theta2 < l2) {
      if (l2 < distanceMax2) {
        if (x4 === 0)
          x4 = jiggle_default(random), l2 += x4 * x4;
        if (y4 === 0)
          y4 = jiggle_default(random), l2 += y4 * y4;
        if (l2 < distanceMin2)
          l2 = Math.sqrt(distanceMin2 * l2);
        node.vx += x4 * quad.value * alpha / l2;
        node.vy += y4 * quad.value * alpha / l2;
      }
      return true;
    } else if (quad.length || l2 >= distanceMax2)
      return;
    if (quad.data !== node || quad.next) {
      if (x4 === 0)
        x4 = jiggle_default(random), l2 += x4 * x4;
      if (y4 === 0)
        y4 = jiggle_default(random), l2 += y4 * y4;
      if (l2 < distanceMin2)
        l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (quad.data !== node) {
        w2 = strengths[quad.data.index] * alpha / l2;
        node.vx += x4 * w2;
        node.vy += y4 * w2;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}
var init_manyBody = __esm({
  "node_modules/d3-force/src/manyBody.js"() {
    init_src2();
    init_constant();
    init_jiggle();
    init_simulation();
  }
});

// node_modules/d3-force/src/radial.js
function radial_default(radius, x4, y4) {
  var nodes, strength = constant_default(0.1), strengths, radiuses;
  if (typeof radius !== "function")
    radius = constant_default(+radius);
  if (x4 == null)
    x4 = 0;
  if (y4 == null)
    y4 = 0;
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      var node = nodes[i2], dx = node.x - x4 || 1e-6, dy = node.y - y4 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i2] - r2) * strengths[i2] * alpha / r2;
      node.vx += dx * k2;
      node.vy += dy * k2;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    radiuses = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      radiuses[i2] = +radius(nodes[i2], i2, nodes);
      strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2, initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x4 = +_2, force) : x4;
  };
  force.y = function(_2) {
    return arguments.length ? (y4 = +_2, force) : y4;
  };
  return force;
}
var init_radial = __esm({
  "node_modules/d3-force/src/radial.js"() {
    init_constant();
  }
});

// node_modules/d3-force/src/x.js
function x_default2(x4) {
  var strength = constant_default(0.1), nodes, strengths, xz;
  if (typeof x4 !== "function")
    x4 = constant_default(x4 == null ? 0 : +x4);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vx += (xz[i2] - node.x) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    xz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(xz[i2] = +x4(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x4 = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : x4;
  };
  return force;
}
var init_x2 = __esm({
  "node_modules/d3-force/src/x.js"() {
    init_constant();
  }
});

// node_modules/d3-force/src/y.js
function y_default2(y4) {
  var strength = constant_default(0.1), nodes, strengths, yz;
  if (typeof y4 !== "function")
    y4 = constant_default(y4 == null ? 0 : +y4);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.vy += (yz[i2] - node.y) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    yz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(yz[i2] = +y4(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : y4;
  };
  return force;
}
var init_y2 = __esm({
  "node_modules/d3-force/src/y.js"() {
    init_constant();
  }
});

// node_modules/d3-force/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  forceCenter: () => center_default,
  forceCollide: () => collide_default,
  forceLink: () => link_default,
  forceManyBody: () => manyBody_default,
  forceRadial: () => radial_default,
  forceSimulation: () => simulation_default,
  forceX: () => x_default2,
  forceY: () => y_default2
});
var init_src4 = __esm({
  "node_modules/d3-force/src/index.js"() {
    init_center();
    init_collide();
    init_link();
    init_manyBody();
    init_radial();
    init_simulation();
    init_x2();
    init_y2();
  }
});

// node_modules/@antv/layout/lib/layout/force/force-in-a-box.js
var require_force_in_a_box = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/force-in-a-box.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3Force = __importStar((init_src4(), __toCommonJS(src_exports2)));
    var util_1 = require_util2();
    function forceInABox() {
      function constant(_2) {
        return function() {
          return _2;
        };
      }
      var groupBy2 = function(d2) {
        return d2.cluster;
      };
      var forceNodeSize = constant(1);
      var forceCharge = constant(-1);
      var forceLinkDistance = constant(100);
      var forceLinkStrength = constant(0.1);
      var offset = [0, 0];
      var nodes = [];
      var nodesMap = {};
      var links = [];
      var centerX = 100;
      var centerY = 100;
      var foci = {
        none: {
          x: 0,
          y: 0
        }
      };
      var templateNodes = [];
      var templateForce;
      var template = "force";
      var enableGrouping = true;
      var strength = 0.1;
      function force(alpha) {
        if (!enableGrouping) {
          return force;
        }
        templateForce.tick();
        getFocisFromTemplate();
        for (var i2 = 0, n2 = nodes.length, node = void 0, k2 = alpha * strength; i2 < n2; ++i2) {
          node = nodes[i2];
          node.vx += (foci[groupBy2(node)].x - node.x) * k2;
          node.vy += (foci[groupBy2(node)].y - node.y) * k2;
        }
      }
      function initialize() {
        if (!nodes)
          return;
        initializeWithForce();
      }
      function initializeWithForce() {
        if (!nodes || !nodes.length) {
          return;
        }
        if (groupBy2(nodes[0]) === void 0) {
          throw Error("Couldnt find the grouping attribute for the nodes. Make sure to set it up with forceInABox.groupBy('clusterAttr') before calling .links()");
        }
        var net = getGroupsGraph();
        templateForce = d3Force.forceSimulation(net.nodes).force("x", d3Force.forceX(centerX).strength(0.1)).force("y", d3Force.forceY(centerY).strength(0.1)).force("collide", d3Force.forceCollide(function(d2) {
          return d2.r;
        }).iterations(4)).force("charge", d3Force.forceManyBody().strength(forceCharge)).force("links", d3Force.forceLink(net.nodes.length ? net.links : []).distance(forceLinkDistance).strength(forceLinkStrength));
        templateNodes = templateForce.nodes();
        getFocisFromTemplate();
      }
      function getGroupsGraph() {
        var gnodes = [];
        var glinks = [];
        var dNodes = {};
        var clustersList = [];
        var clustersCounts = {};
        var clustersLinks = [];
        clustersCounts = computeClustersNodeCounts(nodes);
        clustersLinks = computeClustersLinkCounts(links);
        clustersList = Object.keys(clustersCounts);
        clustersList.forEach(function(key, index2) {
          var val = clustersCounts[key];
          gnodes.push({
            id: key,
            size: val.count,
            r: Math.sqrt(val.sumforceNodeSize / Math.PI)
          });
          dNodes[key] = index2;
        });
        clustersLinks.forEach(function(l2) {
          var sourceTerminal = (0, util_1.getEdgeTerminal)(l2, "source");
          var targetTerminal = (0, util_1.getEdgeTerminal)(l2, "target");
          var source = dNodes[sourceTerminal];
          var target = dNodes[targetTerminal];
          if (source !== void 0 && target !== void 0) {
            glinks.push({
              source,
              target,
              count: l2.count
            });
          }
        });
        return {
          nodes: gnodes,
          links: glinks
        };
      }
      function computeClustersNodeCounts(nodes2) {
        var clustersCounts = {};
        nodes2.forEach(function(d2) {
          var key = groupBy2(d2);
          if (!clustersCounts[key]) {
            clustersCounts[key] = {
              count: 0,
              sumforceNodeSize: 0
            };
          }
        });
        nodes2.forEach(function(d2) {
          var key = groupBy2(d2);
          var nodeSize = forceNodeSize(d2);
          var tmpCount = clustersCounts[key];
          tmpCount.count = tmpCount.count + 1;
          tmpCount.sumforceNodeSize = tmpCount.sumforceNodeSize + Math.PI * (nodeSize * nodeSize) * 1.3;
          clustersCounts[key] = tmpCount;
        });
        return clustersCounts;
      }
      function computeClustersLinkCounts(links2) {
        var dClusterLinks = {};
        var clusterLinks = [];
        links2.forEach(function(l2) {
          var key = getLinkKey(l2);
          var count = 0;
          if (dClusterLinks[key] !== void 0) {
            count = dClusterLinks[key];
          }
          count += 1;
          dClusterLinks[key] = count;
        });
        var entries = Object.entries(dClusterLinks);
        entries.forEach(function(_a2) {
          var key = _a2[0], count = _a2[1];
          var source = key.split("~")[0];
          var target = key.split("~")[1];
          if (source !== void 0 && target !== void 0) {
            clusterLinks.push({
              source,
              target,
              count
            });
          }
        });
        return clusterLinks;
      }
      function getFocisFromTemplate() {
        foci = {
          none: {
            x: 0,
            y: 0
          }
        };
        templateNodes.forEach(function(d2) {
          foci[d2.id] = {
            x: d2.x - offset[0],
            y: d2.y - offset[1]
          };
        });
        return foci;
      }
      function getLinkKey(l2) {
        var source = (0, util_1.getEdgeTerminal)(l2, "source");
        var target = (0, util_1.getEdgeTerminal)(l2, "target");
        var sourceID = groupBy2(nodesMap[source]);
        var targetID = groupBy2(nodesMap[target]);
        return sourceID <= targetID ? "".concat(sourceID, "~").concat(targetID) : "".concat(targetID, "~").concat(sourceID);
      }
      function genNodesMap(nodes2) {
        nodesMap = {};
        nodes2.forEach(function(node) {
          nodesMap[node.id] = node;
        });
      }
      function setTemplate(x4) {
        if (!arguments.length)
          return template;
        template = x4;
        initialize();
        return force;
      }
      function setGroupBy(x4) {
        if (!arguments.length)
          return groupBy2;
        if (typeof x4 === "string") {
          groupBy2 = function(d2) {
            return d2[x4];
          };
          return force;
        }
        groupBy2 = x4;
        return force;
      }
      function setEnableGrouping(x4) {
        if (!arguments.length)
          return enableGrouping;
        enableGrouping = x4;
        return force;
      }
      function setStrength(x4) {
        if (!arguments.length)
          return strength;
        strength = x4;
        return force;
      }
      function setCenterX(_2) {
        if (arguments.length) {
          centerX = _2;
          return force;
        }
        return centerX;
      }
      function setCenterY(_2) {
        if (arguments.length) {
          centerY = _2;
          return force;
        }
        return centerY;
      }
      function setNodes(_2) {
        if (arguments.length) {
          genNodesMap(_2 || []);
          nodes = _2 || [];
          return force;
        }
        return nodes;
      }
      function setLinks(_2) {
        if (arguments.length) {
          links = _2 || [];
          initialize();
          return force;
        }
        return links;
      }
      function setForceNodeSize(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceNodeSize = _2;
          } else {
            forceNodeSize = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceNodeSize;
      }
      function setForceCharge(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceCharge = _2;
          } else {
            forceCharge = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceCharge;
      }
      function setForceLinkDistance(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceLinkDistance = _2;
          } else {
            forceLinkDistance = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceLinkDistance;
      }
      function setForceLinkStrength(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceLinkStrength = _2;
          } else {
            forceLinkStrength = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceLinkStrength;
      }
      function setOffset(_2) {
        if (arguments.length) {
          offset = _2;
          return force;
        }
        return offset;
      }
      force.initialize = function(_2) {
        nodes = _2;
        initialize();
      };
      force.template = setTemplate;
      force.groupBy = setGroupBy;
      force.enableGrouping = setEnableGrouping;
      force.strength = setStrength;
      force.centerX = setCenterX;
      force.centerY = setCenterY;
      force.nodes = setNodes;
      force.links = setLinks;
      force.forceNodeSize = setForceNodeSize;
      force.nodeSize = force.forceNodeSize;
      force.forceCharge = setForceCharge;
      force.forceLinkDistance = setForceLinkDistance;
      force.forceLinkStrength = setForceLinkStrength;
      force.offset = setOffset;
      force.getFocis = getFocisFromTemplate;
      return force;
    }
    exports.default = forceInABox;
  }
});

// node_modules/@antv/layout/lib/layout/constants.js
var require_constants = __commonJS({
  "node_modules/@antv/layout/lib/layout/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FORCE_LAYOUT_TYPE_MAP = exports.LAYOUT_MESSAGE = void 0;
    exports.LAYOUT_MESSAGE = {
      // run layout
      RUN: "LAYOUT_RUN",
      // layout ended with success
      END: "LAYOUT_END",
      // layout error
      ERROR: "LAYOUT_ERROR",
      // layout tick, used in force directed layout
      TICK: "LAYOUT_TICK",
      GPURUN: "GPU_LAYOUT_RUN",
      GPUEND: "GPU_LAYOUT_END"
    };
    exports.FORCE_LAYOUT_TYPE_MAP = {
      "gForce": true,
      "force2": true,
      "fruchterman": true,
      "forceAtlas2": true,
      "force": true,
      "graphin-force": true
    };
  }
});

// node_modules/@antv/layout/lib/layout/force/force.js
var require_force = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/force.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForceLayout = void 0;
    var d3Force = __importStar((init_src4(), __toCommonJS(src_exports2)));
    var force_in_a_box_1 = __importDefault(require_force_in_a_box());
    var util_1 = require_util2();
    var base_1 = require_base();
    var constants_1 = require_constants();
    var ForceLayout2 = (
      /** @class */
      function(_super) {
        __extends15(ForceLayout3, _super);
        function ForceLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.nodeStrength = null;
          _this.edgeStrength = null;
          _this.preventOverlap = false;
          _this.clusterNodeStrength = null;
          _this.clusterEdgeStrength = null;
          _this.clusterEdgeDistance = null;
          _this.clusterNodeSize = null;
          _this.clusterFociStrength = null;
          _this.linkDistance = 50;
          _this.alphaDecay = 0.028;
          _this.alphaMin = 1e-3;
          _this.alpha = 0.3;
          _this.collideStrength = 1;
          _this.workerEnabled = false;
          _this.tick = function() {
          };
          _this.onLayoutEnd = function() {
          };
          _this.ticking = void 0;
          if (options) {
            _this.updateCfg(options);
          }
          return _this;
        }
        ForceLayout3.prototype.getDefaultCfg = function() {
          return {
            center: [0, 0],
            nodeStrength: null,
            edgeStrength: null,
            preventOverlap: false,
            nodeSize: void 0,
            nodeSpacing: void 0,
            linkDistance: 50,
            forceSimulation: null,
            alphaDecay: 0.028,
            alphaMin: 1e-3,
            alpha: 0.3,
            collideStrength: 1,
            clustering: false,
            clusterNodeStrength: -1,
            clusterEdgeStrength: 0.1,
            clusterEdgeDistance: 100,
            clusterFociStrength: 0.8,
            clusterNodeSize: 10,
            tick: function() {
            },
            onLayoutEnd: function() {
            },
            // 是否启用web worker。前提是在web worker里执行布局，否则无效
            workerEnabled: false
          };
        };
        ForceLayout3.prototype.init = function(data) {
          var self2 = this;
          self2.nodes = data.nodes || [];
          var edges = data.edges || [];
          self2.edges = edges.map(function(edge) {
            var res = {};
            var expectKeys = ["targetNode", "sourceNode", "startPoint", "endPoint"];
            Object.keys(edge).forEach(function(key) {
              if (!(expectKeys.indexOf(key) > -1)) {
                res[key] = edge[key];
              }
            });
            return res;
          });
          self2.ticking = false;
        };
        ForceLayout3.prototype.execute = function(reloadData) {
          var self2 = this;
          var nodes = self2.nodes;
          var edges = self2.edges;
          if (self2.ticking) {
            return;
          }
          var simulation = self2.forceSimulation;
          var alphaMin = self2.alphaMin;
          var alphaDecay = self2.alphaDecay;
          var alpha = self2.alpha;
          if (!simulation) {
            try {
              var nodeForce = d3Force.forceManyBody();
              if (self2.nodeStrength) {
                nodeForce.strength(self2.nodeStrength);
              }
              simulation = d3Force.forceSimulation().nodes(nodes);
              if (self2.clustering) {
                var clusterForce = (0, force_in_a_box_1.default)();
                clusterForce.centerX(self2.center[0]).centerY(self2.center[1]).template("force").strength(self2.clusterFociStrength);
                if (edges) {
                  clusterForce.links(edges);
                }
                if (nodes) {
                  clusterForce.nodes(nodes);
                }
                clusterForce.forceLinkDistance(self2.clusterEdgeDistance).forceLinkStrength(self2.clusterEdgeStrength).forceCharge(self2.clusterNodeStrength).forceNodeSize(self2.clusterNodeSize);
                self2.clusterForce = clusterForce;
                simulation.force("group", clusterForce);
              }
              simulation.force("center", d3Force.forceCenter(self2.center[0], self2.center[1])).force("charge", nodeForce).alpha(alpha).alphaDecay(alphaDecay).alphaMin(alphaMin);
              if (self2.preventOverlap) {
                self2.overlapProcess(simulation);
              }
              if (edges) {
                var edgeForce = d3Force.forceLink().id(function(d2) {
                  return d2.id;
                }).links(edges);
                if (self2.edgeStrength) {
                  edgeForce.strength(self2.edgeStrength);
                }
                if (self2.linkDistance) {
                  edgeForce.distance(self2.linkDistance);
                }
                self2.edgeForce = edgeForce;
                simulation.force("link", edgeForce);
              }
              if (self2.workerEnabled && !isInWorker()) {
                self2.workerEnabled = false;
                console.warn("workerEnabled option is only supported when running in web worker.");
              }
              if (!self2.workerEnabled) {
                simulation.on("tick", function() {
                  self2.tick();
                }).on("end", function() {
                  self2.ticking = false;
                  if (self2.onLayoutEnd)
                    self2.onLayoutEnd();
                });
                self2.ticking = true;
              } else {
                simulation.stop();
                var totalTicks = getSimulationTicks(simulation);
                for (var currentTick = 1; currentTick <= totalTicks; currentTick++) {
                  simulation.tick();
                  postMessage({
                    nodes,
                    currentTick,
                    totalTicks,
                    type: constants_1.LAYOUT_MESSAGE.TICK
                  }, void 0);
                }
                self2.ticking = false;
              }
              self2.forceSimulation = simulation;
              self2.ticking = true;
            } catch (e8) {
              self2.ticking = false;
              console.warn(e8);
            }
          } else {
            if (reloadData) {
              if (self2.clustering && self2.clusterForce) {
                self2.clusterForce.nodes(nodes);
                self2.clusterForce.links(edges);
              }
              simulation.nodes(nodes);
              if (edges && self2.edgeForce)
                self2.edgeForce.links(edges);
              else if (edges && !self2.edgeForce) {
                var edgeForce = d3Force.forceLink().id(function(d2) {
                  return d2.id;
                }).links(edges);
                if (self2.edgeStrength) {
                  edgeForce.strength(self2.edgeStrength);
                }
                if (self2.linkDistance) {
                  edgeForce.distance(self2.linkDistance);
                }
                self2.edgeForce = edgeForce;
                simulation.force("link", edgeForce);
              }
            }
            if (self2.preventOverlap) {
              self2.overlapProcess(simulation);
            }
            simulation.alpha(alpha).restart();
            this.ticking = true;
          }
        };
        ForceLayout3.prototype.overlapProcess = function(simulation) {
          var self2 = this;
          var nodeSize = self2.nodeSize;
          var nodeSpacing = self2.nodeSpacing;
          var nodeSizeFunc;
          var nodeSpacingFunc;
          var collideStrength = self2.collideStrength;
          if ((0, util_1.isNumber)(nodeSpacing)) {
            nodeSpacingFunc = function() {
              return nodeSpacing;
            };
          } else if ((0, util_1.isFunction)(nodeSpacing)) {
            nodeSpacingFunc = nodeSpacing;
          } else {
            nodeSpacingFunc = function() {
              return 0;
            };
          }
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                  return res / 2 + nodeSpacingFunc(d2);
                }
                if ((0, util_1.isObject)(d2.size)) {
                  var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                  return res / 2 + nodeSpacingFunc(d2);
                }
                return d2.size / 2 + nodeSpacingFunc(d2);
              }
              return 10 + nodeSpacingFunc(d2);
            };
          } else if ((0, util_1.isFunction)(nodeSize)) {
            nodeSizeFunc = function(d2) {
              var size3 = nodeSize(d2);
              return size3 + nodeSpacingFunc(d2);
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            var radius_1 = larger / 2;
            nodeSizeFunc = function(d2) {
              return radius_1 + nodeSpacingFunc(d2);
            };
          } else if ((0, util_1.isNumber)(nodeSize)) {
            var radius_2 = nodeSize / 2;
            nodeSizeFunc = function(d2) {
              return radius_2 + nodeSpacingFunc(d2);
            };
          } else {
            nodeSizeFunc = function() {
              return 10;
            };
          }
          simulation.force("collisionForce", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));
        };
        ForceLayout3.prototype.updateCfg = function(cfg) {
          var self2 = this;
          if (self2.ticking) {
            self2.forceSimulation.stop();
            self2.ticking = false;
          }
          self2.forceSimulation = null;
          Object.assign(self2, cfg);
        };
        ForceLayout3.prototype.destroy = function() {
          var self2 = this;
          if (self2.ticking) {
            self2.forceSimulation.stop();
            self2.ticking = false;
          }
          self2.nodes = null;
          self2.edges = null;
          self2.destroyed = true;
        };
        return ForceLayout3;
      }(base_1.Base)
    );
    exports.ForceLayout = ForceLayout2;
    function getSimulationTicks(simulation) {
      var alphaMin = simulation.alphaMin();
      var alphaTarget = simulation.alphaTarget();
      var alpha = simulation.alpha();
      var totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) / Math.log(1 - simulation.alphaDecay());
      var totalTicks = Math.ceil(totalTicksFloat);
      return totalTicks;
    }
    function isInWorker() {
      return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    }
  }
});

// node_modules/@antv/layout/lib/layout/force/index.js
var require_force3 = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_force(), exports);
  }
});

// node_modules/@antv/layout/lib/layout/circular.js
var require_circular = __commonJS({
  "node_modules/@antv/layout/lib/layout/circular.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    function initHierarchy(nodes, edges, nodeMap, directed) {
      nodes.forEach(function(_2, i2) {
        nodes[i2].children = [];
        nodes[i2].parent = [];
      });
      if (directed) {
        edges.forEach(function(e8) {
          var source = (0, util_1.getEdgeTerminal)(e8, "source");
          var target = (0, util_1.getEdgeTerminal)(e8, "target");
          var sourceIdx = 0;
          if (source) {
            sourceIdx = nodeMap[source];
          }
          var targetIdx = 0;
          if (target) {
            targetIdx = nodeMap[target];
          }
          var child = nodes[sourceIdx].children;
          var parent = nodes[targetIdx].parent;
          child.push(nodes[targetIdx].id);
          parent.push(nodes[sourceIdx].id);
        });
      } else {
        edges.forEach(function(e8) {
          var source = (0, util_1.getEdgeTerminal)(e8, "source");
          var target = (0, util_1.getEdgeTerminal)(e8, "target");
          var sourceIdx = 0;
          if (source) {
            sourceIdx = nodeMap[source];
          }
          var targetIdx = 0;
          if (target) {
            targetIdx = nodeMap[target];
          }
          var sourceChildren = nodes[sourceIdx].children;
          var targetChildren = nodes[targetIdx].children;
          sourceChildren.push(nodes[targetIdx].id);
          targetChildren.push(nodes[sourceIdx].id);
        });
      }
    }
    function connect(a3, b2, edges) {
      var m3 = edges.length;
      for (var i2 = 0; i2 < m3; i2++) {
        var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
        var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
        if (a3.id === source && b2.id === target || b2.id === source && a3.id === target) {
          return true;
        }
      }
      return false;
    }
    function compareDegree(a3, b2) {
      var aDegree = a3.degree;
      var bDegree = b2.degree;
      if (aDegree < bDegree) {
        return -1;
      }
      if (aDegree > bDegree) {
        return 1;
      }
      return 0;
    }
    var CircularLayout2 = (
      /** @class */
      function(_super) {
        __extends15(CircularLayout3, _super);
        function CircularLayout3(options) {
          var _this = _super.call(this) || this;
          _this.radius = null;
          _this.nodeSize = void 0;
          _this.startRadius = null;
          _this.endRadius = null;
          _this.startAngle = 0;
          _this.endAngle = 2 * Math.PI;
          _this.clockwise = true;
          _this.divisions = 1;
          _this.ordering = null;
          _this.angleRatio = 1;
          _this.nodes = [];
          _this.edges = [];
          _this.nodeMap = {};
          _this.degrees = [];
          _this.width = 300;
          _this.height = 300;
          _this.updateCfg(options);
          return _this;
        }
        CircularLayout3.prototype.getDefaultCfg = function() {
          return {
            radius: null,
            startRadius: null,
            endRadius: null,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            clockwise: true,
            divisions: 1,
            ordering: null,
            angleRatio: 1
          };
        };
        CircularLayout3.prototype.execute = function() {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes;
          var edges = self2.edges;
          var n2 = nodes.length;
          if (n2 === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (n2 === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          var radius = self2.radius, startRadius = self2.startRadius, endRadius = self2.endRadius;
          var divisions = self2.divisions, startAngle = self2.startAngle, endAngle = self2.endAngle, angleRatio = self2.angleRatio, ordering = self2.ordering, clockwise = self2.clockwise, paramNodeSpacing = self2.nodeSpacing, paramNodeSize = self2.nodeSize;
          var angleStep = (endAngle - startAngle) / n2;
          var nodeMap = {};
          nodes.forEach(function(node, i3) {
            nodeMap[node.id] = i3;
          });
          self2.nodeMap = nodeMap;
          var degrees = (0, util_1.getDegree)(nodes.length, nodeMap, edges);
          self2.degrees = degrees;
          if (paramNodeSpacing) {
            var nodeSpacing_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSpacing);
            var nodeSize_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSize);
            var maxNodeSize_1 = -Infinity;
            nodes.forEach(function(node) {
              var nSize = nodeSize_1(node);
              if (maxNodeSize_1 < nSize)
                maxNodeSize_1 = nSize;
            });
            var length_1 = 0;
            nodes.forEach(function(node, i3) {
              if (i3 === 0)
                length_1 += maxNodeSize_1 || 10;
              else
                length_1 += (nodeSpacing_1(node) || 0) + (maxNodeSize_1 || 10);
            });
            radius = length_1 / (2 * Math.PI);
          } else if (!radius && !startRadius && !endRadius) {
            radius = self2.height > self2.width ? self2.width / 2 : self2.height / 2;
          } else if (!startRadius && endRadius) {
            startRadius = endRadius;
          } else if (startRadius && !endRadius) {
            endRadius = startRadius;
          }
          var astep = angleStep * angleRatio;
          var layoutNodes = [];
          if (ordering === "topology") {
            layoutNodes = self2.topologyOrdering();
          } else if (ordering === "topology-directed") {
            layoutNodes = self2.topologyOrdering(true);
          } else if (ordering === "degree") {
            layoutNodes = self2.degreeOrdering();
          } else {
            layoutNodes = nodes;
          }
          var divN = Math.ceil(n2 / divisions);
          for (var i2 = 0; i2 < n2; ++i2) {
            var r2 = radius;
            if (!r2 && startRadius !== null && endRadius !== null) {
              r2 = startRadius + i2 * (endRadius - startRadius) / (n2 - 1);
            }
            if (!r2) {
              r2 = 10 + i2 * 100 / (n2 - 1);
            }
            var angle = startAngle + i2 % divN * astep + 2 * Math.PI / divisions * Math.floor(i2 / divN);
            if (!clockwise) {
              angle = endAngle - i2 % divN * astep - 2 * Math.PI / divisions * Math.floor(i2 / divN);
            }
            layoutNodes[i2].x = center[0] + Math.cos(angle) * r2;
            layoutNodes[i2].y = center[1] + Math.sin(angle) * r2;
            layoutNodes[i2].weight = degrees[i2].all;
          }
          (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          return {
            nodes: layoutNodes,
            edges: this.edges
          };
        };
        CircularLayout3.prototype.topologyOrdering = function(directed) {
          if (directed === void 0) {
            directed = false;
          }
          var self2 = this;
          var degrees = self2.degrees;
          var edges = self2.edges;
          var nodes = self2.nodes;
          var cnodes = (0, util_1.clone)(nodes);
          var nodeMap = self2.nodeMap;
          var orderedCNodes = [cnodes[0]];
          var resNodes = [nodes[0]];
          var pickFlags = [];
          var n2 = nodes.length;
          pickFlags[0] = true;
          initHierarchy(cnodes, edges, nodeMap, directed);
          var k2 = 0;
          cnodes.forEach(function(cnode, i2) {
            if (i2 !== 0) {
              if ((i2 === n2 - 1 || degrees[i2].all !== degrees[i2 + 1].all || connect(orderedCNodes[k2], cnode, edges)) && !pickFlags[i2]) {
                orderedCNodes.push(cnode);
                resNodes.push(nodes[nodeMap[cnode.id]]);
                pickFlags[i2] = true;
                k2++;
              } else {
                var children = orderedCNodes[k2].children;
                var foundChild = false;
                for (var j2 = 0; j2 < children.length; j2++) {
                  var childIdx = nodeMap[children[j2]];
                  if (degrees[childIdx].all === degrees[i2].all && !pickFlags[childIdx]) {
                    orderedCNodes.push(cnodes[childIdx]);
                    resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);
                    pickFlags[childIdx] = true;
                    foundChild = true;
                    break;
                  }
                }
                var ii2 = 0;
                while (!foundChild) {
                  if (!pickFlags[ii2]) {
                    orderedCNodes.push(cnodes[ii2]);
                    resNodes.push(nodes[nodeMap[cnodes[ii2].id]]);
                    pickFlags[ii2] = true;
                    foundChild = true;
                  }
                  ii2++;
                  if (ii2 === n2) {
                    break;
                  }
                }
              }
            }
          });
          return resNodes;
        };
        CircularLayout3.prototype.degreeOrdering = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var orderedNodes = [];
          var degrees = self2.degrees;
          nodes.forEach(function(node, i2) {
            node.degree = degrees[i2].all;
            orderedNodes.push(node);
          });
          orderedNodes.sort(compareDegree);
          return orderedNodes;
        };
        CircularLayout3.prototype.getType = function() {
          return "circular";
        };
        return CircularLayout3;
      }(base_1.Base)
    );
    exports.CircularLayout = CircularLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/data/list.js
var require_list = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/data/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var filterOutLinks = function(k2, v2) {
      if (k2 !== "next" && k2 !== "prev") {
        return v2;
      }
    };
    var unlink = function(entry) {
      entry.prev.next = entry.next;
      entry.next.prev = entry.prev;
      delete entry.next;
      delete entry.prev;
    };
    var List = (
      /** @class */
      function() {
        function List2() {
          var shortcut = {};
          shortcut.prev = shortcut;
          shortcut.next = shortcut.prev;
          this.shortcut = shortcut;
        }
        List2.prototype.dequeue = function() {
          var shortcut = this.shortcut;
          var entry = shortcut.prev;
          if (entry && entry !== shortcut) {
            unlink(entry);
            return entry;
          }
        };
        List2.prototype.enqueue = function(entry) {
          var shortcut = this.shortcut;
          if (entry.prev && entry.next) {
            unlink(entry);
          }
          entry.next = shortcut.next;
          shortcut.next.prev = entry;
          shortcut.next = entry;
          entry.prev = shortcut;
        };
        List2.prototype.toString = function() {
          var strs = [];
          var sentinel = this.shortcut;
          var curr = sentinel.prev;
          while (curr !== sentinel) {
            strs.push(JSON.stringify(curr, filterOutLinks));
            curr = curr === null || curr === void 0 ? void 0 : curr.prev;
          }
          return "[".concat(strs.join(", "), "]");
        };
        return List2;
      }()
    );
    exports.default = List;
  }
});

// node_modules/@antv/graphlib/es/Graph/enum.js
var GraphEnum;
var init_enum = __esm({
  "node_modules/@antv/graphlib/es/Graph/enum.js"() {
    (function(GraphEnum2) {
      GraphEnum2["DEFAULT_EDGE_NAME"] = "\0";
      GraphEnum2["GRAPH_NODE"] = "\0";
      GraphEnum2["EDGE_KEY_DELIM"] = "";
    })(GraphEnum || (GraphEnum = {}));
  }
});

// node_modules/@antv/graphlib/es/util.js
function incrementOrInitEntry(map3, key) {
  var val = map3.get(key) || 0;
  map3.set(key, val + 1);
}
function decrementOrRemoveEntry(map3, key) {
  var val = map3.get(key);
  if (val !== void 0) {
    val = val - 1;
    if (val > 0) {
      map3.set(key, val);
    } else {
      map3.delete(key);
    }
  }
}
function edgeArgsToId(isDirected, v_, w_, name) {
  var v2 = String(v_);
  var w2 = String(w_);
  if (!isDirected && v2 > w2) {
    var tmp = v2;
    v2 = w2;
    w2 = tmp;
  }
  return v2 + GraphEnum.EDGE_KEY_DELIM + w2 + GraphEnum.EDGE_KEY_DELIM + (name === void 0 ? GraphEnum.DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v2, w2, name) {
  var strV = String(v2);
  var strW = String(w2);
  var edgeObj = {
    v: v2,
    w: w2
  };
  if (!isDirected && strV > strW) {
    var tmp = edgeObj.v;
    edgeObj.v = edgeObj.w;
    edgeObj.w = tmp;
  }
  if (name !== void 0) {
    edgeObj.name = name;
  }
  return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
function isFunction(obj) {
  return typeof obj === "function";
}
var init_util = __esm({
  "node_modules/@antv/graphlib/es/util.js"() {
    init_enum();
  }
});

// node_modules/@antv/graphlib/es/Graph/toJSON.js
var nodeToJSON, edgeToJSON, write, read;
var init_toJSON = __esm({
  "node_modules/@antv/graphlib/es/Graph/toJSON.js"() {
    init_Graph();
    nodeToJSON = function nodeToJSON2(graph) {
      return graph.nodes().map(function(n2) {
        var value = graph.node(n2);
        var parent = graph.parent(n2);
        var node = {
          id: n2,
          value,
          parent
        };
        if (node.value === void 0) {
          delete node.value;
        }
        if (node.parent === void 0) {
          delete node.parent;
        }
        return node;
      });
    };
    edgeToJSON = function edgeToJSON2(graph) {
      return graph.edges().map(function(edge) {
        var value = graph.edge(edge);
        var e8 = {
          v: edge.v,
          w: edge.w,
          value,
          name: edge.name
        };
        if (e8.name === void 0) {
          delete e8.name;
        }
        if (e8.value === void 0) {
          delete e8.value;
        }
        return e8;
      });
    };
    write = function write2(graph) {
      var json = {
        options: {
          directed: graph.isDirected(),
          multigraph: graph.isMultigraph(),
          compound: graph.isCompound()
        },
        nodes: nodeToJSON(graph),
        edges: edgeToJSON(graph),
        value: graph.graph()
      };
      if (json.value === void 0) {
        delete json.value;
      }
      return json;
    };
    read = function read2(json) {
      var graph = new Graph2(json.options);
      if (json.value !== void 0) {
        graph.setGraph(json.value);
      }
      json.nodes.forEach(function(entry) {
        graph.setNode(entry.id, entry.value);
        if (entry.parent) {
          graph.setParent(entry.id, entry.parent);
        }
      });
      json.edges.forEach(function(entry) {
        graph.setEdge(entry.v, entry.w, entry.value, entry.name);
      });
      return graph;
    };
  }
});

// node_modules/@antv/graphlib/es/Graph/index.js
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var defaultOption, Graph2;
var init_Graph = __esm({
  "node_modules/@antv/graphlib/es/Graph/index.js"() {
    init_util();
    init_enum();
    init_util();
    init_toJSON();
    defaultOption = {
      compound: false,
      multigraph: false,
      directed: true
    };
    Graph2 = function() {
      function Graph4() {
        var _this = this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Graph4);
        this.directed = true;
        this.multigraph = false;
        this.compound = false;
        this.GRAPH_NODE = GraphEnum.GRAPH_NODE;
        this.label = void 0;
        this.nodeCountNum = 0;
        this.edgeCountNum = 0;
        this.defaultNodeLabelFn = function() {
          return void 0;
        };
        this.defaultEdgeLabelFn = function() {
          return void 0;
        };
        this.parentMap = void 0;
        this.childrenMap = void 0;
        this.nodesLabelMap = /* @__PURE__ */ new Map();
        this.inEdgesMap = /* @__PURE__ */ new Map();
        this.outEdgesMap = /* @__PURE__ */ new Map();
        this.predecessorsMap = /* @__PURE__ */ new Map();
        this.successorsMap = /* @__PURE__ */ new Map();
        this.edgesMap = /* @__PURE__ */ new Map();
        this.edgesLabelsMap = /* @__PURE__ */ new Map();
        this.isDirected = function() {
          return _this.directed;
        };
        this.isMultigraph = function() {
          return _this.multigraph;
        };
        this.isCompound = function() {
          return _this.compound;
        };
        this.setGraph = function(label) {
          _this.label = label;
          return _this;
        };
        this.graph = function() {
          return _this.label;
        };
        this.setDefaultNodeLabel = function(newDefault) {
          if (isFunction(newDefault)) {
            _this.defaultNodeLabelFn = newDefault;
          } else {
            _this.defaultNodeLabelFn = function() {
              return newDefault;
            };
          }
          return _this;
        };
        this.nodeCount = function() {
          return _this.nodeCountNum;
        };
        this.node = function(n2) {
          return _this.nodesLabelMap.get(n2);
        };
        this.nodes = function() {
          return Array.from(_this.nodesLabelMap.keys());
        };
        this.sources = function() {
          return _this.nodes().filter(function(n2) {
            var _this$inEdgesMap$get;
            return !((_this$inEdgesMap$get = _this.inEdgesMap.get(n2)) === null || _this$inEdgesMap$get === void 0 ? void 0 : _this$inEdgesMap$get.size);
          });
        };
        this.sinks = function() {
          return _this.nodes().filter(function(n2) {
            var _this$outEdgesMap$get;
            return !((_this$outEdgesMap$get = _this.outEdgesMap.get(n2)) === null || _this$outEdgesMap$get === void 0 ? void 0 : _this$outEdgesMap$get.size);
          });
        };
        this.setNodes = function(nodes, value) {
          nodes.map(function(node) {
            return _this.setNode(node, value);
          });
          return _this;
        };
        this.hasNode = function(node) {
          return _this.nodesLabelMap.has(node);
        };
        this.checkCompound = function() {
          if (!_this.isCompound()) {
            throw new Error("Cannot construct parent-children relations in a non-compound graph");
          }
        };
        this.parent = function(node) {
          if (_this.isCompound()) {
            var _this$parentMap;
            var parent = (_this$parentMap = _this.parentMap) === null || _this$parentMap === void 0 ? void 0 : _this$parentMap.get(node);
            if (parent !== _this.GRAPH_NODE) {
              return parent;
            }
          }
        };
        this.removeFromParentsChildList = function(node) {
          var targetParent = _this.parentMap.get(node);
          _this.childrenMap.get(targetParent).delete(node);
        };
        this.setParent = function(node, parent) {
          var _this$parentMap2, _this$childrenMap;
          _this.checkCompound();
          var realParent = parent === void 0 ? _this.GRAPH_NODE : parent;
          var checkNode = _this.parent(realParent);
          while (checkNode) {
            if (node === checkNode) {
              throw new Error("Setting " + parent + " as parent of " + node + " would create a cycle");
            }
            checkNode = _this.parent(checkNode);
          }
          if (parent) {
            _this.setNode(parent);
          }
          _this.setNode(node);
          _this.removeFromParentsChildList(node);
          (_this$parentMap2 = _this.parentMap) === null || _this$parentMap2 === void 0 ? void 0 : _this$parentMap2.set(node, realParent);
          var realParentChilren = _this.childrenMap.get(realParent);
          realParentChilren.set(node, true);
          (_this$childrenMap = _this.childrenMap) === null || _this$childrenMap === void 0 ? void 0 : _this$childrenMap.set(realParent, realParentChilren);
          return _this;
        };
        this.children = function(node) {
          var targetNode = node === void 0 ? _this.GRAPH_NODE : node;
          if (_this.isCompound()) {
            var _this$childrenMap2;
            var target = (_this$childrenMap2 = _this.childrenMap) === null || _this$childrenMap2 === void 0 ? void 0 : _this$childrenMap2.get(targetNode);
            if (target) {
              return Array.from(target.keys());
            }
            return void 0;
          }
          if (targetNode === _this.GRAPH_NODE) {
            return _this.nodes();
          }
          if (node && _this.hasNode(node)) {
            return [];
          }
        };
        this.predecessors = function(node) {
          var preds = _this.predecessorsMap.get(node);
          return preds ? Array.from(preds.keys()) : void 0;
        };
        this.successors = function(node) {
          var succs = _this.successorsMap.get(node);
          return succs ? Array.from(succs.keys()) : void 0;
        };
        this.neighbors = function(node) {
          var _this$predecessors;
          if (!_this.hasNode(node)) {
            return void 0;
          }
          return Array.from(new Set((_this$predecessors = _this.predecessors(node)) === null || _this$predecessors === void 0 ? void 0 : _this$predecessors.concat(_this.successors(node))));
        };
        this.isLeaf = function(node) {
          var _this$neighbors;
          if (_this.isDirected()) {
            var _this$successors;
            return !((_this$successors = _this.successors(node)) === null || _this$successors === void 0 ? void 0 : _this$successors.length);
          }
          return !((_this$neighbors = _this.neighbors(node)) === null || _this$neighbors === void 0 ? void 0 : _this$neighbors.length);
        };
        this.filterNodes = function(filter2) {
          var directed = _this.directed, multigraph = _this.multigraph, compound = _this.compound;
          var copyGraph = new Graph4({
            directed,
            multigraph,
            compound
          });
          copyGraph.setGraph(_this.graph());
          _this.nodes().forEach(function(n2) {
            if (filter2(n2)) {
              copyGraph.setNode(n2, _this.node(n2));
            }
          });
          _this.edges().forEach(function(edgeObj) {
            if (copyGraph.hasNode(edgeObj.v) && copyGraph.hasNode(edgeObj.w)) {
              copyGraph.setEdgeObj(edgeObj, _this.edge(edgeObj));
            }
          });
          if (compound) {
            var findParent = function findParent2(node) {
              var parent = _this.parent(node);
              while (parent !== void 0 && !copyGraph.hasNode(parent)) {
                parent = _this.parent(parent);
              }
              return parent;
            };
            copyGraph.nodes().forEach(function(node) {
              copyGraph.setParent(node, findParent(node));
            });
          }
          return copyGraph;
        };
        this.setDefaultEdgeLabel = function(newDefault) {
          if (isFunction(newDefault)) {
            _this.defaultEdgeLabelFn = newDefault;
          } else {
            _this.defaultEdgeLabelFn = function() {
              return newDefault;
            };
          }
          return _this;
        };
        this.edgeCount = function() {
          return _this.edgeCountNum;
        };
        this.setEdgeObj = function(edgeObj, value) {
          return _this.setEdge(edgeObj.v, edgeObj.w, value, edgeObj.name);
        };
        this.setPath = function(edges, value) {
          edges.reduce(function(v2, w2) {
            _this.setEdge(v2, w2, value);
            return w2;
          });
          return _this;
        };
        this.edgeFromArgs = function(v2, w2, name) {
          return _this.edge({
            v: v2,
            w: w2,
            name
          });
        };
        this.edge = function(edgeObj) {
          return _this.edgesLabelsMap.get(edgeObjToId(_this.isDirected(), edgeObj));
        };
        this.hasEdge = function(v2, w2, name) {
          return _this.edgesLabelsMap.has(edgeObjToId(_this.isDirected(), {
            v: v2,
            w: w2,
            name
          }));
        };
        this.removeEdgeObj = function(_ref) {
          var v2 = _ref.v, w2 = _ref.w, name = _ref.name;
          return _this.removeEdge(v2, w2, name);
        };
        this.edges = function() {
          return Array.from(_this.edgesMap.values());
        };
        this.inEdges = function(v2, u2) {
          var inV = _this.inEdgesMap.get(v2);
          if (inV) {
            return Array.from(inV.values()).filter(function(e8) {
              return !u2 || e8.v === u2;
            });
          }
          return void 0;
        };
        this.outEdges = function(w2, u2) {
          var outW = _this.outEdgesMap.get(w2);
          if (outW) {
            return Array.from(outW.values()).filter(function(e8) {
              return !u2 || e8.w === u2;
            });
          }
          return void 0;
        };
        this.nodeEdges = function(v2, w2) {
          var _this$inEdges;
          if (!_this.hasNode(v2)) {
            return void 0;
          }
          return (_this$inEdges = _this.inEdges(v2, w2)) === null || _this$inEdges === void 0 ? void 0 : _this$inEdges.concat(_this.outEdges(v2, w2));
        };
        this.toJSON = function() {
          return write(_this);
        };
        this.nodeInDegree = function(node) {
          var inEdges = _this.inEdgesMap.get(node);
          if (inEdges) {
            return inEdges.size;
          }
          return 0;
        };
        this.nodeOutDegree = function(node) {
          var outEdges = _this.outEdgesMap.get(node);
          if (outEdges) {
            return outEdges.size;
          }
          return 0;
        };
        this.nodeDegree = function(node) {
          return _this.nodeInDegree(node) + _this.nodeOutDegree(node);
        };
        this.source = function(edge) {
          return edge.v;
        };
        this.target = function(edge) {
          return edge.w;
        };
        var resultOptions = _objectSpread(_objectSpread({}, defaultOption), options);
        this.compound = resultOptions.compound;
        this.directed = resultOptions.directed;
        this.multigraph = resultOptions.multigraph;
        if (this.compound) {
          this.parentMap = /* @__PURE__ */ new Map();
          this.childrenMap = /* @__PURE__ */ new Map();
        }
      }
      _createClass(Graph4, [{
        key: "setNode",
        value: (
          /**
           * @description Set Node label in graph if node not in graph then create it
           * @description.zh-CN 设置节点的label，如果这个节点不在图中，则在图中创建这个节点
           * @param node
           * @param value
           * @returns
           */
          function setNode(node, value) {
            var nodesLabelMap = this.nodesLabelMap, defaultNodeLabelFn = this.defaultNodeLabelFn, isCompound = this.isCompound, parentMap = this.parentMap, childrenMap = this.childrenMap, inEdgesMap = this.inEdgesMap, outEdgesMap = this.outEdgesMap, predecessorsMap = this.predecessorsMap, successorsMap = this.successorsMap;
            if (nodesLabelMap.has(node)) {
              if (value !== void 0) {
                nodesLabelMap.set(node, value);
              }
              return this;
            }
            nodesLabelMap.set(node, value || defaultNodeLabelFn(node));
            if (isCompound()) {
              var _childrenMap$get;
              parentMap === null || parentMap === void 0 ? void 0 : parentMap.set(node, this.GRAPH_NODE);
              childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(node, /* @__PURE__ */ new Map());
              if (!(childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.has(this.GRAPH_NODE))) {
                childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(this.GRAPH_NODE, /* @__PURE__ */ new Map());
              }
              childrenMap === null || childrenMap === void 0 ? void 0 : (_childrenMap$get = childrenMap.get(this.GRAPH_NODE)) === null || _childrenMap$get === void 0 ? void 0 : _childrenMap$get.set(node, true);
            }
            [inEdgesMap, outEdgesMap, predecessorsMap, successorsMap].forEach(function(map3) {
              return map3.set(node, /* @__PURE__ */ new Map());
            });
            this.nodeCountNum += 1;
            return this;
          }
        )
        /**
         * @description Set nodes or add nodes in batch
         * @description.zh-CN 批量设置或者创建节点
         * @param nodes
         * @param value
         * @returns
         */
      }, {
        key: "removeNode",
        value: (
          /**
           * @description Remove node from graph
           * @description.zh-CN 将节点从图中移除
           * @param node
           * @returns
           */
          function removeNode(node) {
            var _this2 = this;
            if (this.hasNode(node)) {
              var cleanEdge = function cleanEdge2(edgeObj) {
                _this2.removeEdge(edgeObj.v, edgeObj.w, edgeObj.name);
              };
              var inEdgesMap = this.inEdgesMap, outEdgesMap = this.outEdgesMap, predecessorsMap = this.predecessorsMap, successorsMap = this.successorsMap, nodesLabelMap = this.nodesLabelMap;
              if (this.isCompound()) {
                var _this$parentMap3, _this$children, _this$childrenMap3;
                this.removeFromParentsChildList(node);
                (_this$parentMap3 = this.parentMap) === null || _this$parentMap3 === void 0 ? void 0 : _this$parentMap3.delete(node);
                (_this$children = this.children(node)) === null || _this$children === void 0 ? void 0 : _this$children.forEach(function(n2) {
                  return _this2.setParent(n2);
                });
                (_this$childrenMap3 = this.childrenMap) === null || _this$childrenMap3 === void 0 ? void 0 : _this$childrenMap3.delete(node);
              }
              var inE = inEdgesMap.get(node);
              var outE = outEdgesMap.get(node);
              Array.from(inE.values()).forEach(function(edge) {
                return cleanEdge(edge);
              });
              Array.from(outE.values()).forEach(function(edge) {
                return cleanEdge(edge);
              });
              nodesLabelMap.delete(node);
              inEdgesMap.delete(node);
              outEdgesMap.delete(node);
              predecessorsMap.delete(node);
              successorsMap.delete(node);
              this.nodeCountNum -= 1;
            }
            return this;
          }
        )
        /**
         * @description Set function that generate default label for edge, if param is non-function value then default label will always be this value;
         * @description.zh-CN 设置默认获取边Label的方法，如果传入不是函数的，那么默认label 的值只会是传入值
         * @param newDefault
         * @returns
         */
      }, {
        key: "setEdge",
        value: (
          /**
           * @description set edge value, if nodes or edges not exsit then add to graph
           * @description.zh-CN 设置边的属性，如果边或节点不存在，那么将他们加入这个图
           * @param v
           * @param w
           * @param value
           * @param name
           * @returns
           */
          function setEdge(v_, w_, value, name) {
            var _this$inEdgesMap$get2, _this$outEdgesMap$get2;
            var edgeObj = edgeArgsToObj(this.isDirected(), v_, w_, name);
            var edgeId = edgeObjToId(this.isDirected(), edgeObj);
            var v2 = edgeObj.v, w2 = edgeObj.w;
            if (this.edgesLabelsMap.has(edgeId)) {
              this.edgesLabelsMap.set(edgeId, value);
              return this;
            }
            if (name !== void 0 && !this.isMultigraph()) {
              throw new Error("Cannot set a named edge when isMultigraph = false");
            }
            this.setNode(v2);
            this.setNode(w2);
            this.edgesLabelsMap.set(edgeId, value || this.defaultEdgeLabelFn(v2, w2, name));
            Object.freeze(edgeObj);
            this.edgesMap.set(edgeId, edgeObj);
            var preds = this.predecessorsMap.get(w2);
            var succs = this.successorsMap.get(v2);
            incrementOrInitEntry(preds, v2);
            incrementOrInitEntry(succs, w2);
            (_this$inEdgesMap$get2 = this.inEdgesMap.get(w2)) === null || _this$inEdgesMap$get2 === void 0 ? void 0 : _this$inEdgesMap$get2.set(edgeId, edgeObj);
            (_this$outEdgesMap$get2 = this.outEdgesMap.get(v2)) === null || _this$outEdgesMap$get2 === void 0 ? void 0 : _this$outEdgesMap$get2.set(edgeId, edgeObj);
            this.edgeCountNum += 1;
            return this;
          }
        )
      }, {
        key: "removeEdge",
        value: (
          /**
           * @description remove a specific edge
           * @description.zh-CN 删除一条边
           * @param v
           * @param w
           * @param name
           * @returns
           */
          function removeEdge(v_, w_, name) {
            var edgeId = edgeArgsToId(this.isDirected(), v_, w_, name);
            var edgeObj = this.edgesMap.get(edgeId);
            if (edgeObj) {
              var _edgeArgsToObj = edgeArgsToObj(this.isDirected(), v_, w_, name), v2 = _edgeArgsToObj.v, w2 = _edgeArgsToObj.w;
              this.edgesLabelsMap.delete(edgeId);
              this.edgesMap.delete(edgeId);
              var preds = this.predecessorsMap.get(w2);
              var succs = this.successorsMap.get(v2);
              decrementOrRemoveEntry(preds, v2);
              decrementOrRemoveEntry(succs, w2);
              this.inEdgesMap.get(w2).delete(edgeId);
              this.outEdgesMap.get(v2).delete(edgeId);
              this.edgeCountNum -= 1;
            }
            return this;
          }
        )
        /**
         * @description remove a specific edge by edge object
         * @description.zh-CN 删除一条边
         */
      }]);
      return Graph4;
    }();
    Graph2.fromJSON = read;
  }
});

// node_modules/@antv/graphlib/es/Graph/event.js
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof4(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var GraphWithEvent;
var init_event = __esm({
  "node_modules/@antv/graphlib/es/Graph/event.js"() {
    init_Graph();
    GraphWithEvent = function(_Graph) {
      _inherits(GraphWithEvent2, _Graph);
      var _super = _createSuper(GraphWithEvent2);
      function GraphWithEvent2() {
        var _this;
        _classCallCheck2(this, GraphWithEvent2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.eventPool = {};
        return _this;
      }
      _createClass2(GraphWithEvent2, [{
        key: "appendEvent",
        value: (
          /**
           * @description Add an event listener.
           * @description.zh-CN 添加事件监听器。
           */
          function appendEvent(type, callback) {
            if (!this.eventPool[type]) {
              this.eventPool[type] = [];
            }
            this.eventPool[type].push(callback);
          }
        )
        /**
         * @description remove an event listener.
         * @description.zh-CN 移除事件监听器。
         */
      }, {
        key: "removeEvent",
        value: function removeEvent(type, callback) {
          if (!this.eventPool[type]) {
            return;
          }
          var index2 = this.eventPool[type].indexOf(callback);
          if (index2 > -1) {
            this.eventPool[type].splice(index2, 1);
          }
        }
        /**
         * @description trigger an event.
         * @description.zh-CN 触发事件。
         */
      }, {
        key: "emitEvent",
        value: function emitEvent(type) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          if (!this.eventPool[type]) {
            return;
          }
          this.eventPool[type].forEach(function(callback) {
            callback.apply(void 0, args);
          });
        }
      }, {
        key: "setNode",
        value: function setNode(node, value) {
          _get(_getPrototypeOf(GraphWithEvent2.prototype), "setNode", this).call(this, node, value);
          this.emitEvent("nodeAdd", node, value);
          return this;
        }
      }, {
        key: "removeNode",
        value: function removeNode(node) {
          _get(_getPrototypeOf(GraphWithEvent2.prototype), "removeNode", this).call(this, node);
          this.emitEvent("nodeRemove", node);
          return this;
        }
      }, {
        key: "setEdge",
        value: function setEdge(v_, w_, value, name) {
          _get(_getPrototypeOf(GraphWithEvent2.prototype), "setEdge", this).call(this, v_, w_, value, name);
          this.emitEvent("edgeAdd", v_, w_, value, name);
          return this;
        }
      }, {
        key: "removeEdge",
        value: function removeEdge(v_, w_, name) {
          _get(_getPrototypeOf(GraphWithEvent2.prototype), "removeEdge", this).call(this, v_, w_, name);
          this.emitEvent("edgeRemove", v_, w_, name);
          return this;
        }
      }]);
      return GraphWithEvent2;
    }(Graph2);
  }
});

// node_modules/@antv/graphlib/es/algorithm/PriorityQueue/index.js
function _defineProperties3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var PriorityQueue;
var init_PriorityQueue = __esm({
  "node_modules/@antv/graphlib/es/algorithm/PriorityQueue/index.js"() {
    PriorityQueue = _createClass3(function PriorityQueue2() {
      var _this = this;
      _classCallCheck3(this, PriorityQueue2);
      this.arr = [];
      this.keyIndice = /* @__PURE__ */ new Map();
      this.size = function() {
        return _this.arr.length;
      };
      this.keys = function() {
        return _this.arr.map(function(e8) {
          return e8.key;
        });
      };
      this.has = function(key) {
        return _this.keyIndice.has(key);
      };
      this.priority = function(key) {
        var index2 = _this.keyIndice.get(key);
        if (index2 !== void 0) {
          return _this.arr[index2].priority;
        }
      };
      this.swap = function(i2, j2) {
        var arr = _this.arr, keyIndice = _this.keyIndice;
        var _ref = [arr[i2], arr[j2]], originI = _ref[0], originJ = _ref[1];
        arr[i2] = originJ;
        arr[j2] = originI;
        keyIndice.set(originI.key, j2);
        keyIndice.set(originJ.key, i2);
      };
      this.innerDecrease = function(index2) {
        var arr = _this.arr;
        var priority = arr[index2].priority;
        var parent;
        var i2 = index2;
        while (i2 !== 0) {
          var _arr$parent;
          parent = i2 >> 1;
          if (((_arr$parent = arr[parent]) === null || _arr$parent === void 0 ? void 0 : _arr$parent.priority) < priority) {
            break;
          }
          _this.swap(i2, parent);
          i2 = parent;
        }
      };
      this.heapify = function(i2) {
        var arr = _this.arr;
        var l2 = i2 << 1;
        var r2 = l2 + 1;
        var largest = i2;
        if (l2 < arr.length) {
          largest = arr[l2].priority < arr[largest].priority ? l2 : largest;
          if (r2 < arr.length) {
            largest = arr[r2].priority < arr[largest].priority ? r2 : largest;
          }
          if (largest !== i2) {
            _this.swap(i2, largest);
            _this.heapify(largest);
          }
        }
      };
      this.min = function() {
        if (_this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return _this.arr[0].key;
      };
      this.add = function(key, priority) {
        var keyIndice = _this.keyIndice, arr = _this.arr;
        if (!keyIndice.has(key)) {
          var index2 = arr.length;
          keyIndice.set(key, index2);
          arr.push({
            key,
            priority
          });
          _this.innerDecrease(index2);
          return true;
        }
        return false;
      };
      this.removeMin = function() {
        _this.swap(0, _this.arr.length - 1);
        var min3 = _this.arr.pop();
        _this.keyIndice.delete(min3.key);
        _this.heapify(0);
        return min3.key;
      };
      this.decrease = function(key, priority) {
        if (!_this.has(key)) {
          throw new Error("There's no key named ".concat(key));
        }
        var index2 = _this.keyIndice.get(key);
        if (priority > _this.arr[index2].priority) {
          throw new Error("New priority is greater than current priority.Key: ".concat(key, " Old: + ").concat(_this.arr[index2].priority, " New: ").concat(priority));
        }
        _this.arr[index2].priority = priority;
        _this.innerDecrease(index2);
      };
    });
  }
});

// node_modules/@antv/graphlib/es/algorithm/prim.js
var prim, prim_default;
var init_prim = __esm({
  "node_modules/@antv/graphlib/es/algorithm/prim.js"() {
    init_Graph();
    init_PriorityQueue();
    prim = function prim2(graph, weightFn) {
      var result = new Graph2();
      var parents = /* @__PURE__ */ new Map();
      var pq = new PriorityQueue();
      var v2;
      function updateNeighbors(edge) {
        var w2 = edge.v === v2 ? edge.w : edge.v;
        var pri = pq.priority(w2);
        if (pri !== void 0) {
          var edgeWeight = weightFn(edge);
          if (edgeWeight < pri) {
            parents.set(w2, v2);
            pq.decrease(w2, edgeWeight);
          }
        }
      }
      if (graph.nodeCount() === 0) {
        return result;
      }
      graph.nodes().forEach(function(node) {
        pq.add(node, Number.POSITIVE_INFINITY);
        result.setNode(node);
      });
      pq.decrease(graph.nodes()[0], 0);
      var init = false;
      while (pq.size() > 0) {
        var _graph$nodeEdges;
        v2 = pq.removeMin();
        if (parents.has(v2)) {
          result.setEdge(v2, parents.get(v2));
        } else if (init) {
          throw new Error("Input graph is not connected: " + graph.graph());
        } else {
          init = true;
        }
        (_graph$nodeEdges = graph.nodeEdges(v2)) === null || _graph$nodeEdges === void 0 ? void 0 : _graph$nodeEdges.forEach(updateNeighbors);
      }
      return result;
    };
    prim_default = prim;
  }
});

// node_modules/@antv/graphlib/es/algorithm/components.js
var components, components_default;
var init_components = __esm({
  "node_modules/@antv/graphlib/es/algorithm/components.js"() {
    components = function components2(graph) {
      var visited = /* @__PURE__ */ new Set();
      var resultComponents = [];
      var nodes = graph.nodes();
      nodes.forEach(function(n2) {
        var componentsArr = [];
        var waitingList = [n2];
        while (waitingList.length > 0) {
          var node = waitingList.pop();
          if (!visited.has(node)) {
            var _graph$successors, _graph$predecessors;
            visited.add(node);
            componentsArr.push(node);
            (_graph$successors = graph.successors(node)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function(n3) {
              return waitingList.push(n3);
            });
            (_graph$predecessors = graph.predecessors(node)) === null || _graph$predecessors === void 0 ? void 0 : _graph$predecessors.forEach(function(n3) {
              return waitingList.push(n3);
            });
          }
        }
        if (componentsArr.length) {
          resultComponents.push(componentsArr);
        }
      });
      return resultComponents;
    };
    components_default = components;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dfs.js
var doDFS, dfs, dfs_default;
var init_dfs = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dfs.js"() {
    doDFS = function doDFS2(graph, node, postorder3, visited, navigator2, result) {
      if (!visited.includes(node)) {
        visited.push(node);
        if (!postorder3) {
          result.push(node);
        }
        navigator2(node).forEach(function(n2) {
          return doDFS2(graph, n2, postorder3, visited, navigator2, result);
        });
        if (postorder3) {
          result.push(node);
        }
      }
    };
    dfs = function dfs2(graph, node, order) {
      var nodes = Array.isArray(node) ? node : [node];
      var navigator2 = function navigator3(n2) {
        return graph.isDirected() ? graph.successors(n2) : graph.neighbors(n2);
      };
      var results = [];
      var visited = [];
      nodes.forEach(function(node2) {
        if (!graph.hasNode(node2)) {
          throw new Error("Graph does not have node: " + node2);
        } else {
          doDFS(graph, node2, order === "post", visited, navigator2, results);
        }
      });
      return results;
    };
    dfs_default = dfs;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dijkstra.js
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i2) {
  var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i2 == null)
    return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i2 = _i2.call(arr); !(_n2 = (_s = _i2.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null)
        _i2["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var DEFAULT_WEIGHT_FUNC, dijkstra3, runDijkstra, dijkstra_default2;
var init_dijkstra = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dijkstra.js"() {
    init_PriorityQueue();
    DEFAULT_WEIGHT_FUNC = function DEFAULT_WEIGHT_FUNC2() {
      return 1;
    };
    dijkstra3 = function dijkstra4(graph, source, weightFn, edgeFn) {
      return runDijkstra(graph, source, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v2) {
        return graph.outEdges(v2);
      });
    };
    runDijkstra = function runDijkstra2(graph, source, weightFn, edgeFn) {
      var results = /* @__PURE__ */ new Map();
      var pq = new PriorityQueue();
      var v2;
      var vEntry;
      var updateNeighbors = function updateNeighbors2(edge) {
        var w2 = edge.v !== v2 ? edge.v : edge.w;
        var wEntry = results.get(w2);
        var weight = weightFn(edge);
        var distance6 = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance6 < wEntry.distance) {
          wEntry.distance = distance6;
          wEntry.predecessor = v2;
          pq.decrease(w2, distance6);
        }
      };
      graph.nodes().forEach(function(v3) {
        var distance6 = v3 === source ? 0 : Number.POSITIVE_INFINITY;
        results.set(v3, {
          distance: distance6
        });
        pq.add(v3, distance6);
      });
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        vEntry = results.get(v2);
        if (vEntry && vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v2).forEach(updateNeighbors);
      }
      var obj = {};
      Array.from(results.entries()).forEach(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), node = _ref2[0], e8 = _ref2[1];
        obj[String(node)] = e8;
        return obj;
      });
      return obj;
    };
    dijkstra_default2 = dijkstra3;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js
var dijkstraAll, dijkstra_all_default;
var init_dijkstra_all = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js"() {
    init_dijkstra();
    dijkstraAll = function dijkstraAll2(graph, weightFn, edgeFn) {
      var map3 = {};
      graph.nodes().forEach(function(node) {
        map3[String(node)] = dijkstra_default2(graph, node, weightFn, edgeFn);
        return map3;
      });
      return map3;
    };
    dijkstra_all_default = dijkstraAll;
  }
});

// node_modules/@antv/graphlib/es/algorithm/tarjan.js
var tarjan, tarjan_default;
var init_tarjan = __esm({
  "node_modules/@antv/graphlib/es/algorithm/tarjan.js"() {
    tarjan = function tarjan2(graph) {
      var index2 = 0;
      var stack = [];
      var visited = /* @__PURE__ */ new Map();
      var results = [];
      function dfs3(v2) {
        var _graph$successors;
        var entry = {
          onStack: true,
          lowlink: index2,
          index: index2
        };
        visited.set(v2, entry);
        index2 += 1;
        stack.push(v2);
        (_graph$successors = graph.successors(v2)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function(w3) {
          var _visited$get;
          if (!visited.has(w3)) {
            dfs3(w3);
            var wEntry2 = visited.get(w3);
            entry.lowlink = Math.min(entry.lowlink, wEntry2.lowlink);
          } else if ((_visited$get = visited.get(w3)) === null || _visited$get === void 0 ? void 0 : _visited$get.onStack) {
            var _wEntry = visited.get(w3);
            entry.lowlink = Math.min(entry.lowlink, _wEntry.index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w2;
          do {
            w2 = stack.pop();
            var wEntry = visited.get(w2);
            wEntry.onStack = false;
            cmpt.push(w2);
          } while (v2 !== w2);
          results.push(cmpt);
        }
      }
      graph.nodes().forEach(function(v2) {
        if (!visited.has(v2)) {
          dfs3(v2);
        }
      });
      return results;
    };
    tarjan_default = tarjan;
  }
});

// node_modules/@antv/graphlib/es/algorithm/find-cycles.js
var findCycles, find_cycles_default;
var init_find_cycles = __esm({
  "node_modules/@antv/graphlib/es/algorithm/find-cycles.js"() {
    init_tarjan();
    findCycles = function findCycles2(graph) {
      return tarjan_default(graph).filter(function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && graph.hasEdge(cmpt[0], cmpt[0]);
      });
    };
    find_cycles_default = findCycles;
  }
});

// node_modules/@antv/graphlib/es/algorithm/topsort.js
function _typeof5(obj) {
  "@babel/helpers - typeof";
  return _typeof5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof5(obj);
}
function _defineProperties4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _possibleConstructorReturn2(self2, call) {
  if (call && (_typeof5(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized2(self2);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf2(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf2(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct2()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a3 = [null];
      a3.push.apply(a3, args2);
      var Constructor = Function.bind.apply(Parent2, a3);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _setPrototypeOf2(o2, p2) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf2(o2, p2);
}
function _getPrototypeOf2(o2) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf2(o2);
}
function topsort(graph) {
  var visited = /* @__PURE__ */ new Set();
  var stack = /* @__PURE__ */ new Set();
  var results = [];
  function visit(node) {
    if (stack.has(node)) {
      throw new CycleException();
    }
    if (!visited.has(node)) {
      var _graph$predecessors;
      stack.add(node);
      visited.add(node);
      (_graph$predecessors = graph.predecessors(node)) === null || _graph$predecessors === void 0 ? void 0 : _graph$predecessors.forEach(visit);
      stack.delete(node);
      results.push(node);
    }
  }
  graph.sinks().forEach(visit);
  if (visited.size !== graph.nodeCount()) {
    throw new CycleException();
  }
  return results;
}
var CycleException, topsort_default;
var init_topsort = __esm({
  "node_modules/@antv/graphlib/es/algorithm/topsort.js"() {
    CycleException = function(_Error) {
      _inherits2(CycleException2, _Error);
      var _super = _createSuper2(CycleException2);
      function CycleException2() {
        _classCallCheck4(this, CycleException2);
        return _super.apply(this, arguments);
      }
      return _createClass4(CycleException2);
    }(_wrapNativeSuper(Error));
    topsort_default = topsort;
  }
});

// node_modules/@antv/graphlib/es/algorithm/is-acyclic.js
var isAcyclic, is_acyclic_default;
var init_is_acyclic = __esm({
  "node_modules/@antv/graphlib/es/algorithm/is-acyclic.js"() {
    init_topsort();
    isAcyclic = function isAcyclic2(graph) {
      try {
        topsort_default(graph);
      } catch (e8) {
        if (e8 instanceof CycleException) {
          return false;
        }
        throw e8;
      }
      return true;
    };
    is_acyclic_default = isAcyclic;
  }
});

// node_modules/@antv/graphlib/es/algorithm/postorder.js
var postorder, postorder_default;
var init_postorder = __esm({
  "node_modules/@antv/graphlib/es/algorithm/postorder.js"() {
    init_dfs();
    postorder = function postorder2(graph, nodes) {
      return dfs_default(graph, nodes, "post");
    };
    postorder_default = postorder;
  }
});

// node_modules/@antv/graphlib/es/algorithm/preorder.js
var preorder, preorder_default;
var init_preorder = __esm({
  "node_modules/@antv/graphlib/es/algorithm/preorder.js"() {
    init_dfs();
    preorder = function preorder2(graph, nodes) {
      return dfs_default(graph, nodes, "pre");
    };
    preorder_default = preorder;
  }
});

// node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js
function floydWarshall5(graph, weightFn, edgeFn) {
  return runFloydWarshall(graph, weightFn || DEFAULT_WEIGHT_FUNC3, edgeFn || function(v2) {
    return graph.outEdges(v2);
  });
}
function runFloydWarshall(graph, weightFn, edgeFn) {
  var results = {};
  var nodes = graph.nodes();
  nodes.forEach(function(node) {
    var v2 = String(node);
    results[v2] = {};
    results[v2][v2] = {
      distance: 0
    };
    nodes.forEach(function(w2) {
      if (node !== w2) {
        results[v2][String(w2)] = {
          distance: Number.POSITIVE_INFINITY
        };
      }
    });
    edgeFn(node).forEach(function(edge) {
      var w2 = edge.v === node ? edge.w : edge.v;
      var d2 = weightFn(edge);
      results[v2][String(w2)] = {
        distance: d2,
        predecessor: node
      };
    });
  });
  nodes.forEach(function(nodek) {
    var k2 = String(nodek);
    var rowK = results[k2];
    nodes.forEach(function(nodei) {
      var i2 = String(nodei);
      var rowI = results[i2];
      nodes.forEach(function(nodej) {
        var j2 = String(nodej);
        var ik = rowI[k2];
        var kj = rowK[j2];
        var ij = rowI[j2];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}
var DEFAULT_WEIGHT_FUNC3, floyd_warshall_default;
var init_floyd_warshall = __esm({
  "node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js"() {
    DEFAULT_WEIGHT_FUNC3 = function DEFAULT_WEIGHT_FUNC4() {
      return 1;
    };
    floyd_warshall_default = floydWarshall5;
  }
});

// node_modules/@antv/graphlib/es/algorithm/index.js
var algorithm_exports = {};
__export(algorithm_exports, {
  components: () => components_default,
  dfs: () => dfs_default,
  dijkstra: () => dijkstra_default2,
  dijkstraAll: () => dijkstra_all_default,
  findCycles: () => find_cycles_default,
  floydWarshall: () => floyd_warshall_default,
  isAcyclic: () => is_acyclic_default,
  postorder: () => postorder_default,
  preorder: () => preorder_default,
  prim: () => prim_default,
  tarjan: () => tarjan_default,
  topsort: () => topsort_default
});
var init_algorithm = __esm({
  "node_modules/@antv/graphlib/es/algorithm/index.js"() {
    init_prim();
    init_components();
    init_dfs();
    init_dijkstra();
    init_dijkstra_all();
    init_find_cycles();
    init_is_acyclic();
    init_postorder();
    init_preorder();
    init_tarjan();
    init_topsort();
    init_floyd_warshall();
  }
});

// node_modules/@antv/graphlib/es/comparision/contain.js
var containSameNodes, containSameEdges, getSameNodes, getSameEdges, isGraphOptionSame, containAllSameNodes, containAllSameEdges, isGraphSame, isGraphContainsAnother;
var init_contain = __esm({
  "node_modules/@antv/graphlib/es/comparision/contain.js"() {
    containSameNodes = function containSameNodes2(aGraph, bGraph) {
      var aNodes = aGraph.nodes();
      for (var i2 = 0; i2 < aNodes.length; i2++) {
        var aNode = aNodes[i2];
        if (bGraph.hasNode(aNode)) {
          return true;
        }
      }
      return false;
    };
    containSameEdges = function containSameEdges2(aGraph, bGraph) {
      var aEdges = aGraph.edges();
      for (var i2 = 0; i2 < aEdges.length; i2++) {
        var aEdge = aEdges[i2];
        if (bGraph.hasEdge(aEdge.v, aEdge.w, aEdge.name)) {
          return true;
        }
      }
      return false;
    };
    getSameNodes = function getSameNodes2(aGraph, bGraph) {
      var aNodes = aGraph.nodes();
      var sameNodes = aNodes.filter(function(aNode) {
        return bGraph.hasNode(aNode);
      });
      return sameNodes;
    };
    getSameEdges = function getSameEdges2(aGraph, bGraph) {
      var aEdges = aGraph.edges();
      var sameEdges = aEdges.filter(function(aEdge) {
        return bGraph.hasEdge(aEdge.v, aEdge.w, aEdge.name);
      });
      return sameEdges;
    };
    isGraphOptionSame = function isGraphOptionSame2(aGraph, bGraph) {
      return aGraph.isCompound() === bGraph.isCompound() && aGraph.isDirected() === bGraph.isDirected() && aGraph.isMultigraph() === bGraph.isMultigraph();
    };
    containAllSameNodes = function containAllSameNodes2(aGraph, bGraph) {
      var sameNodes = getSameNodes(aGraph, bGraph);
      return sameNodes.length === aGraph.nodes().length;
    };
    containAllSameEdges = function containAllSameEdges2(aGraph, bGraph) {
      var sameEdges = getSameEdges(aGraph, bGraph);
      return sameEdges.length === aGraph.edges().length;
    };
    isGraphSame = function isGraphSame2(aGraph, bGraph) {
      return isGraphOptionSame(aGraph, bGraph) && aGraph.nodeCount() === bGraph.nodeCount() && containAllSameNodes(aGraph, bGraph) && aGraph.edgeCount() === bGraph.edgeCount() && containAllSameEdges(aGraph, bGraph);
    };
    isGraphContainsAnother = function isGraphContainsAnother2(originGraph, targetGraph) {
      return containAllSameNodes(originGraph, targetGraph) && containAllSameEdges(originGraph, targetGraph);
    };
  }
});

// node_modules/@antv/graphlib/es/essence/index.js
var essence_exports = {};
__export(essence_exports, {
  hasSelfLoop: () => hasSelfLoop,
  isGraph: () => isGraph,
  isNullGraph: () => isNullGraph,
  isSimpleGraph: () => isSimpleGraph
});
function _slicedToArray2(arr, i2) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray2(o2, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i2) {
  var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i2 == null)
    return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i2 = _i2.call(arr); !(_n2 = (_s = _i2.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null)
        _i2["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function isGraph(obj) {
  return obj instanceof Graph2;
}
function isSimpleGraph(graph) {
  if (graph.isMultigraph()) {
    return false;
  }
  var edges = graph.edges();
  var edgeStack = /* @__PURE__ */ new Map();
  for (var i2 = 0; i2 < edges.length; i2++) {
    var edge = edges[i2];
    if (edge.v === edge.w) {
      return false;
    }
    var _sort = [edge.v, edge.w].sort(), _sort2 = _slicedToArray2(_sort, 2), v2 = _sort2[0], w2 = _sort2[1];
    var key = "".concat(v2, "-").concat(w2);
    if (edgeStack.has(key)) {
      return false;
    }
    edgeStack.set(key, true);
  }
  return true;
}
function isNullGraph(graph) {
  return graph.nodes().length === 0;
}
function hasSelfLoop(graph) {
  var edges = graph.edges();
  for (var i2 = 0; i2 < edges.length; i2++) {
    var edge = edges[i2];
    if (edge.v === edge.w) {
      return true;
    }
  }
  return false;
}
var init_essence = __esm({
  "node_modules/@antv/graphlib/es/essence/index.js"() {
    init_Graph();
  }
});

// node_modules/@antv/graphlib/es/comparision/complement.js
var isGraphComplement;
var init_complement = __esm({
  "node_modules/@antv/graphlib/es/comparision/complement.js"() {
    init_essence();
    init_contain();
    isGraphComplement = function isGraphComplement2(originGraph, targetGraph) {
      if (!isSimpleGraph(originGraph) || !isSimpleGraph(targetGraph)) {
        return false;
      }
      if (!containAllSameNodes(originGraph, targetGraph)) {
        return false;
      }
      if (containSameEdges(originGraph, targetGraph)) {
        return false;
      }
      var nodeCount = originGraph.nodeCount();
      return originGraph.edgeCount() + targetGraph.edgeCount() === nodeCount * (nodeCount - 1) / 2;
    };
  }
});

// node_modules/@antv/graphlib/es/comparision/index.js
var comparision_exports = {};
__export(comparision_exports, {
  containAllSameEdges: () => containAllSameEdges,
  containAllSameNodes: () => containAllSameNodes,
  containSameEdges: () => containSameEdges,
  containSameNodes: () => containSameNodes,
  getSameEdges: () => getSameEdges,
  getSameNodes: () => getSameNodes,
  isGraphComplement: () => isGraphComplement,
  isGraphContainsAnother: () => isGraphContainsAnother,
  isGraphOptionSame: () => isGraphOptionSame,
  isGraphSame: () => isGraphSame
});
var init_comparision = __esm({
  "node_modules/@antv/graphlib/es/comparision/index.js"() {
    init_contain();
    init_complement();
  }
});

// node_modules/@antv/graphlib/es/generate/compelement.js
var getGraphComplement;
var init_compelement = __esm({
  "node_modules/@antv/graphlib/es/generate/compelement.js"() {
    init_essence();
    init_Graph();
    getGraphComplement = function getGraphComplement2(originGraph) {
      if (!isSimpleGraph(originGraph)) {
        return null;
      }
      var nodeCount = originGraph.nodeCount();
      var complementGraph = new Graph2({
        compound: originGraph.isCompound(),
        directed: originGraph.isDirected(),
        multigraph: originGraph.isMultigraph()
      });
      var nodes = originGraph.nodes();
      for (var i2 = 0; i2 < nodeCount; i2++) {
        var nodei = nodes[i2];
        complementGraph.setNode(nodei, originGraph.node(nodei));
        for (var j2 = i2 + 1; j2 < nodeCount; j2++) {
          var nodej = nodes[j2];
          if (!originGraph.hasEdge(nodei, nodej)) {
            complementGraph.setEdge(nodei, nodej);
          }
        }
      }
      return complementGraph;
    };
  }
});

// node_modules/@antv/graphlib/es/generate/index.js
var generate_exports = {};
__export(generate_exports, {
  getGraphComplement: () => getGraphComplement
});
var init_generate = __esm({
  "node_modules/@antv/graphlib/es/generate/index.js"() {
    init_compelement();
  }
});

// node_modules/@antv/graphlib/es/index.js
var es_exports2 = {};
__export(es_exports2, {
  Graph: () => Graph2,
  GraphWithEvent: () => GraphWithEvent,
  algorithm: () => algorithm_exports,
  comparision: () => comparision_exports,
  essence: () => essence_exports,
  generate: () => generate_exports
});
var init_es = __esm({
  "node_modules/@antv/graphlib/es/index.js"() {
    init_Graph();
    init_event();
    init_algorithm();
    init_comparision();
    init_essence();
    init_generate();
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/greedy-fas.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var list_1 = __importDefault(require_list());
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var List = (
      /** @class */
      function(_super) {
        __extends15(List2, _super);
        function List2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return List2;
      }(list_1.default)
    );
    var StateGraph = (
      /** @class */
      function(_super) {
        __extends15(StateGraph2, _super);
        function StateGraph2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return StateGraph2;
      }(graphlib_1.Graph)
    );
    var DEFAULT_WEIGHT_FN = function() {
      return 1;
    };
    var greedyFAS = function(g2, weightFn) {
      var _a2;
      if (g2.nodeCount() <= 1)
        return [];
      var state = buildState(g2, weightFn || DEFAULT_WEIGHT_FN);
      var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
      return (_a2 = results.map(function(e8) {
        return g2.outEdges(e8.v, e8.w);
      })) === null || _a2 === void 0 ? void 0 : _a2.flat();
    };
    var doGreedyFAS = function(g2, buckets, zeroIdx) {
      var results = [];
      var sources = buckets[buckets.length - 1];
      var sinks = buckets[0];
      var entry;
      while (g2.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g2, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g2, buckets, zeroIdx, entry);
        }
        if (g2.nodeCount()) {
          for (var i2 = buckets.length - 2; i2 > 0; --i2) {
            entry = buckets[i2].dequeue();
            if (entry) {
              results = results.concat(removeNode(g2, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    };
    var removeNode = function(g2, buckets, zeroIdx, entry, collectPredecessors) {
      var _a2, _b;
      var results = [];
      (_a2 = g2.inEdges(entry.v)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(edge) {
        var weight = g2.edge(edge);
        var uEntry = g2.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w, in: 0, out: 0 });
        }
        if (uEntry.out === void 0)
          uEntry.out = 0;
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      (_b = g2.outEdges(entry.v)) === null || _b === void 0 ? void 0 : _b.forEach(function(edge) {
        var weight = g2.edge(edge);
        var w2 = edge.w;
        var wEntry = g2.node(w2);
        if (wEntry.in === void 0)
          wEntry.in = 0;
        wEntry.in -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g2.removeNode(entry.v);
      return collectPredecessors ? results : void 0;
    };
    var buildState = function(g2, weightFn) {
      var fasGraph = new StateGraph();
      var maxIn = 0;
      var maxOut = 0;
      g2.nodes().forEach(function(v2) {
        fasGraph.setNode(v2, { v: v2, in: 0, out: 0 });
      });
      g2.edges().forEach(function(e8) {
        var prevWeight = fasGraph.edge(e8) || 0;
        var weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e8)) || 1;
        var edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e8.v, e8.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e8.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e8.w).in += weight);
      });
      var buckets = [];
      var rangeMax = maxOut + maxIn + 3;
      for (var i2 = 0; i2 < rangeMax; i2++) {
        buckets.push(new List());
      }
      var zeroIdx = maxIn + 1;
      fasGraph.nodes().forEach(function(v2) {
        assignBucket(buckets, zeroIdx, fasGraph.node(v2));
      });
      return { buckets, zeroIdx, graph: fasGraph };
    };
    var assignBucket = function(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    };
    exports.default = greedyFAS;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/acyclic.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var greedy_fas_1 = __importDefault(require_greedy_fas());
    var run = function(g2) {
      var weightFn = function(g3) {
        return function(e8) {
          var _a2;
          return ((_a2 = g3.edge(e8)) === null || _a2 === void 0 ? void 0 : _a2.weight) || 1;
        };
      };
      var fas = g2.graph().acyclicer === "greedy" ? (0, greedy_fas_1.default)(g2, weightFn(g2)) : dfsFAS(g2);
      fas === null || fas === void 0 ? void 0 : fas.forEach(function(e8) {
        var label = g2.edge(e8);
        g2.removeEdgeObj(e8);
        label.forwardName = e8.name;
        label.reversed = true;
        g2.setEdge(e8.w, e8.v, label, "rev-".concat(Math.random()));
      });
    };
    var dfsFAS = function(g2) {
      var fas = [];
      var stack = {};
      var visited = {};
      var dfs3 = function(v2) {
        var _a2;
        if (visited[v2]) {
          return;
        }
        visited[v2] = true;
        stack[v2] = true;
        (_a2 = g2.outEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          if (stack[e8.w]) {
            fas.push(e8);
          } else {
            dfs3(e8.w);
          }
        });
        delete stack[v2];
      };
      g2.nodes().forEach(dfs3);
      return fas;
    };
    var undo = function(g2) {
      g2.edges().forEach(function(e8) {
        var label = g2.edge(e8);
        if (label.reversed) {
          g2.removeEdgeObj(e8);
          var forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g2.setEdge(e8.w, e8.v, label, forwardName);
        }
      });
    };
    exports.default = { run, undo };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/graph.js
var require_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/graph.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Graph = void 0;
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var Graph4 = (
      /** @class */
      function(_super) {
        __extends15(Graph5, _super);
        function Graph5() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return Graph5;
      }(graphlib_1.Graph)
    );
    exports.Graph = Graph4;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/util.js
var require_util3 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minBy = exports.notime = exports.time = exports.partition = exports.maxRank = exports.addBorderNode = exports.removeEmptyRanks = exports.normalizeRanks = exports.buildLayerMatrix = exports.intersectRect = exports.predecessorWeights = exports.successorWeights = exports.zipObject = exports.asNonCompoundGraph = exports.simplify = exports.addDummyNode = void 0;
    var util_1 = require_util2();
    var graph_1 = require_graph();
    var safeSort = function(valueA, valueB) {
      return Number(valueA) - Number(valueB);
    };
    var addDummyNode = function(g2, type, attrs, name) {
      var v2;
      do {
        v2 = "".concat(name).concat(Math.random());
      } while (g2.hasNode(v2));
      attrs.dummy = type;
      g2.setNode(v2, attrs);
      return v2;
    };
    exports.addDummyNode = addDummyNode;
    var simplify = function(g2) {
      var simplified = new graph_1.Graph().setGraph(g2.graph());
      g2.nodes().forEach(function(v2) {
        simplified.setNode(v2, g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var simpleLabel = simplified.edgeFromArgs(e8.v, e8.w) || { weight: 0, minlen: 1 };
        var label = g2.edge(e8);
        simplified.setEdge(e8.v, e8.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    };
    exports.simplify = simplify;
    var asNonCompoundGraph = function(g2) {
      var simplified = new graph_1.Graph({ multigraph: g2.isMultigraph() }).setGraph(g2.graph());
      g2.nodes().forEach(function(node) {
        var _a2;
        if (!((_a2 = g2.children(node)) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          simplified.setNode(node, g2.node(node));
        }
      });
      g2.edges().forEach(function(edge) {
        simplified.setEdgeObj(edge, g2.edge(edge));
      });
      return simplified;
    };
    exports.asNonCompoundGraph = asNonCompoundGraph;
    var zipObject = function(keys2, values2) {
      return keys2 === null || keys2 === void 0 ? void 0 : keys2.reduce(function(obj, key, i2) {
        obj[key] = values2[i2];
        return obj;
      }, {});
    };
    exports.zipObject = zipObject;
    var successorWeights = function(g2) {
      var weightsMap = {};
      g2.nodes().forEach(function(node) {
        var _a2;
        var sucs = {};
        (_a2 = g2.outEdges(node)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          var _a3;
          sucs[e8.w] = (sucs[e8.w] || 0) + (((_a3 = g2.edge(e8)) === null || _a3 === void 0 ? void 0 : _a3.weight) || 0);
        });
        weightsMap[node] = sucs;
      });
      return weightsMap;
    };
    exports.successorWeights = successorWeights;
    var predecessorWeights = function(g2) {
      var nodes = g2.nodes();
      var weightMap = nodes.map(function(v2) {
        var _a2;
        var preds = {};
        (_a2 = g2.inEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          preds[e8.v] = (preds[e8.v] || 0) + g2.edge(e8).weight;
        });
        return preds;
      });
      return (0, exports.zipObject)(nodes, weightMap);
    };
    exports.predecessorWeights = predecessorWeights;
    var intersectRect = function(rect2, point) {
      var x4 = Number(rect2.x);
      var y4 = Number(rect2.y);
      var dx = Number(point.x) - x4;
      var dy = Number(point.y) - y4;
      var w2 = Number(rect2.width) / 2;
      var h2 = Number(rect2.height) / 2;
      if (!dx && !dy) {
        return { x: 0, y: 0 };
      }
      var sx;
      var sy;
      if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
        if (dy < 0) {
          h2 = -h2;
        }
        sx = h2 * dx / dy;
        sy = h2;
      } else {
        if (dx < 0) {
          w2 = -w2;
        }
        sx = w2;
        sy = w2 * dy / dx;
      }
      return { x: x4 + sx, y: y4 + sy };
    };
    exports.intersectRect = intersectRect;
    var buildLayerMatrix = function(g2) {
      var layeringNodes = [];
      var rankMax = (0, exports.maxRank)(g2) + 1;
      for (var i2 = 0; i2 < rankMax; i2++) {
        layeringNodes.push([]);
      }
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (!node)
          return;
        var rank = node.rank;
        if (rank !== void 0 && layeringNodes[rank]) {
          layeringNodes[rank].push(v2);
        }
      });
      for (var i2 = 0; i2 < rankMax; i2++) {
        layeringNodes[i2] = layeringNodes[i2].sort(function(va2, vb) {
          var _a2, _b;
          return safeSort((_a2 = g2.node(va2)) === null || _a2 === void 0 ? void 0 : _a2.order, (_b = g2.node(vb)) === null || _b === void 0 ? void 0 : _b.order);
        });
      }
      return layeringNodes;
    };
    exports.buildLayerMatrix = buildLayerMatrix;
    var normalizeRanks = function(g2) {
      var nodeRanks = g2.nodes().filter(function(v2) {
        var _a2;
        return ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) !== void 0;
      }).map(function(v2) {
        return g2.node(v2).rank;
      });
      var min3 = Math.min.apply(Math, nodeRanks);
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.hasOwnProperty("rank") && min3 !== Infinity) {
          node.rank -= min3;
        }
      });
    };
    exports.normalizeRanks = normalizeRanks;
    var removeEmptyRanks = function(g2) {
      var nodes = g2.nodes();
      var nodeRanks = nodes.filter(function(v2) {
        var _a2;
        return ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) !== void 0;
      }).map(function(v2) {
        return g2.node(v2).rank;
      });
      var offset = Math.min.apply(Math, nodeRanks);
      var layers = [];
      nodes.forEach(function(v2) {
        var _a2;
        var rank = (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) || 0) - offset;
        if (!layers[rank]) {
          layers[rank] = [];
        }
        layers[rank].push(v2);
      });
      var delta = 0;
      var nodeRankFactor = g2.graph().nodeRankFactor || 0;
      for (var i2 = 0; i2 < layers.length; i2++) {
        var vs = layers[i2];
        if (vs === void 0) {
          if (i2 % nodeRankFactor !== 0) {
            delta -= 1;
          }
        } else if (delta) {
          vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
            var node = g2.node(v2);
            if (node) {
              node.rank = node.rank || 0;
              node.rank += delta;
            }
          });
        }
      }
    };
    exports.removeEmptyRanks = removeEmptyRanks;
    var addBorderNode = function(g2, prefix, rank, order) {
      var node = {
        width: 0,
        height: 0
      };
      if ((0, util_1.isNumber)(rank) && (0, util_1.isNumber)(order)) {
        node.rank = rank;
        node.order = order;
      }
      return (0, exports.addDummyNode)(g2, "border", node, prefix);
    };
    exports.addBorderNode = addBorderNode;
    var maxRank = function(g2) {
      var maxRank2;
      g2.nodes().forEach(function(v2) {
        var _a2;
        var rank = (_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank;
        if (rank !== void 0) {
          if (maxRank2 === void 0 || rank > maxRank2) {
            maxRank2 = rank;
          }
        }
      });
      if (!maxRank2) {
        maxRank2 = 0;
      }
      return maxRank2;
    };
    exports.maxRank = maxRank;
    var partition = function(collection, fn2) {
      var result = { lhs: [], rhs: [] };
      collection === null || collection === void 0 ? void 0 : collection.forEach(function(value) {
        if (fn2(value)) {
          result.lhs.push(value);
        } else {
          result.rhs.push(value);
        }
      });
      return result;
    };
    exports.partition = partition;
    var time = function(name, fn2) {
      var start = Date.now();
      try {
        return fn2();
      } finally {
        console.log("".concat(name, " time: ").concat(Date.now() - start, "ms"));
      }
    };
    exports.time = time;
    var notime = function(name, fn2) {
      return fn2();
    };
    exports.notime = notime;
    var minBy = function(array, func) {
      return array.reduce(function(a3, b2) {
        var valA = func(a3);
        var valB = func(b2);
        return valA > valB ? b2 : a3;
      });
    };
    exports.minBy = minBy;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/normalize.js
var require_normalize = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/normalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var run = function(g2) {
      g2.graph().dummyChains = [];
      g2.edges().forEach(function(edge) {
        return normalizeEdge(g2, edge);
      });
    };
    var normalizeEdge = function(g2, e8) {
      var v2 = e8.v;
      var vRank = g2.node(v2).rank;
      var w2 = e8.w;
      var wRank = g2.node(w2).rank;
      var name = e8.name;
      var edgeLabel = g2.edge(e8);
      var labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1)
        return;
      g2.removeEdgeObj(e8);
      var graph = g2.graph();
      var dummy;
      var attrs;
      var i2;
      for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          edgeLabel,
          width: 0,
          height: 0,
          edgeObj: e8,
          rank: vRank
        };
        dummy = (0, util_1.addDummyNode)(g2, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g2.setEdge(v2, dummy, { weight: edgeLabel.weight }, name);
        if (i2 === 0) {
          if (!graph.dummyChains)
            graph.dummyChains = [];
          graph.dummyChains.push(dummy);
        }
        v2 = dummy;
      }
      g2.setEdge(v2, w2, { weight: edgeLabel.weight }, name);
    };
    var undo = function(g2) {
      var _a2;
      (_a2 = g2.graph().dummyChains) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        var node = g2.node(v2);
        var origLabel = node.edgeLabel;
        var w2;
        if (node.edgeObj) {
          g2.setEdgeObj(node.edgeObj, origLabel);
        }
        var currentV = v2;
        while (node.dummy) {
          w2 = g2.successors(currentV)[0];
          g2.removeNode(currentV);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          currentV = w2;
          node = g2.node(currentV);
        }
      });
    };
    exports.default = { run, undo };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/util.js
var require_util4 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.slack = exports.longestPathWithLayer = exports.longestPath = void 0;
    var longestPath = function(g2) {
      var _a2;
      var visited = {};
      var dfs3 = function(v2) {
        var _a3;
        var label = g2.node(v2);
        if (!label)
          return 0;
        if (visited[v2]) {
          return label.rank;
        }
        visited[v2] = true;
        var rank;
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(edgeObj) {
          var wRank = dfs3(edgeObj.w);
          var minLen = g2.edge(edgeObj).minlen;
          var r2 = wRank - minLen;
          if (r2) {
            if (rank === void 0 || r2 < rank) {
              rank = r2;
            }
          }
        });
        if (!rank) {
          rank = 0;
        }
        label.rank = rank;
        return rank;
      };
      (_a2 = g2.sources()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(source) {
        return dfs3(source);
      });
    };
    exports.longestPath = longestPath;
    var longestPathWithLayer = function(g2) {
      var _a2;
      var visited = {};
      var minRank;
      var dfs3 = function(v2) {
        var _a3;
        var label = g2.node(v2);
        if (!label)
          return 0;
        if (visited[v2]) {
          return label.rank;
        }
        visited[v2] = true;
        var rank;
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(edgeObj) {
          var wRank = dfs3(edgeObj.w);
          var minLen = g2.edge(edgeObj).minlen;
          var r2 = wRank - minLen;
          if (r2) {
            if (rank === void 0 || r2 < rank) {
              rank = r2;
            }
          }
        });
        if (!rank) {
          rank = 0;
        }
        if (minRank === void 0 || rank < minRank) {
          minRank = rank;
        }
        label.rank = rank;
        return rank;
      };
      (_a2 = g2.sources()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(source) {
        if (g2.node(source))
          dfs3(source);
      });
      if (minRank === void 0) {
        minRank = 0;
      }
      var forwardVisited = {};
      var dfsForward = function(v2, nextRank) {
        var _a3;
        var label = g2.node(v2);
        var currRank = !isNaN(label.layer) ? label.layer : nextRank;
        if (label.rank === void 0 || label.rank < currRank) {
          label.rank = currRank;
        }
        if (forwardVisited[v2])
          return;
        forwardVisited[v2] = true;
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.map(function(e8) {
          dfsForward(e8.w, currRank + g2.edge(e8).minlen);
        });
      };
      g2.nodes().forEach(function(n2) {
        var label = g2.node(n2);
        if (!label)
          return;
        if (!isNaN(label.layer)) {
          dfsForward(n2, label.layer);
        } else {
          label.rank -= minRank;
        }
      });
    };
    exports.longestPathWithLayer = longestPathWithLayer;
    var slack = function(g2, e8) {
      return g2.node(e8.w).rank - g2.node(e8.v).rank - g2.edge(e8).minlen;
    };
    exports.slack = slack;
    exports.default = {
      longestPath,
      longestPathWithLayer,
      slack
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/feasible-tree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.feasibleTreeWithLayer = exports.feasibleTree = void 0;
    var util_1 = require_util4();
    var util_2 = require_util3();
    var graph_1 = require_graph();
    var feasibleTree = function(g2) {
      var t2 = new graph_1.Graph({ directed: false });
      var start = g2.nodes()[0];
      var size3 = g2.nodeCount();
      t2.setNode(start, {});
      var edge;
      var delta;
      while (tightTree(t2, g2) < size3) {
        edge = findMinSlackEdge(t2, g2);
        delta = t2.hasNode(edge.v) ? (0, util_1.slack)(g2, edge) : -(0, util_1.slack)(g2, edge);
        shiftRanks(t2, g2, delta);
      }
      return t2;
    };
    exports.feasibleTree = feasibleTree;
    var tightTree = function(t2, g2) {
      var dfs3 = function(v2) {
        g2.nodeEdges(v2).forEach(function(e8) {
          var edgeV = e8.v;
          var w2 = v2 === edgeV ? e8.w : edgeV;
          if (!t2.hasNode(w2) && !(0, util_1.slack)(g2, e8)) {
            t2.setNode(w2, {});
            t2.setEdge(v2, w2, {});
            dfs3(w2);
          }
        });
      };
      t2.nodes().forEach(dfs3);
      return t2.nodeCount();
    };
    var feasibleTreeWithLayer = function(g2) {
      var t2 = new graph_1.Graph({ directed: false });
      var start = g2.nodes()[0];
      var size3 = g2.nodes().filter(function(n2) {
        return !!g2.node(n2);
      }).length;
      t2.setNode(start, {});
      var edge;
      var delta;
      while (tightTreeWithLayer(t2, g2) < size3) {
        edge = findMinSlackEdge(t2, g2);
        delta = t2.hasNode(edge.v) ? (0, util_1.slack)(g2, edge) : -(0, util_1.slack)(g2, edge);
        shiftRanks(t2, g2, delta);
      }
      return t2;
    };
    exports.feasibleTreeWithLayer = feasibleTreeWithLayer;
    var tightTreeWithLayer = function(t2, g2) {
      var dfs3 = function(v2) {
        var _a2;
        (_a2 = g2.nodeEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          var edgeV = e8.v;
          var w2 = v2 === edgeV ? e8.w : edgeV;
          if (!t2.hasNode(w2) && (g2.node(w2).layer !== void 0 || !(0, util_1.slack)(g2, e8))) {
            t2.setNode(w2, {});
            t2.setEdge(v2, w2, {});
            dfs3(w2);
          }
        });
      };
      t2.nodes().forEach(dfs3);
      return t2.nodeCount();
    };
    var findMinSlackEdge = function(t2, g2) {
      return (0, util_2.minBy)(g2.edges(), function(e8) {
        if (t2.hasNode(e8.v) !== t2.hasNode(e8.w)) {
          return (0, util_1.slack)(g2, e8);
        }
        return Infinity;
      });
    };
    var shiftRanks = function(t2, g2, delta) {
      t2.nodes().forEach(function(v2) {
        if (!g2.node(v2).rank)
          g2.node(v2).rank = 0;
        g2.node(v2).rank += delta;
      });
    };
    exports.default = {
      feasibleTree,
      feasibleTreeWithLayer
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/network-simplex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exchangeEdges = exports.enterEdge = exports.leaveEdge = exports.initLowLimValues = exports.calcCutValue = exports.initCutValues = void 0;
    var feasible_tree_1 = require_feasible_tree();
    var util_1 = require_util4();
    var util_2 = require_util3();
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var preorder3 = graphlib_1.algorithm.preorder;
    var postorder3 = graphlib_1.algorithm.postorder;
    var networkSimplex = function(og) {
      var g2 = (0, util_2.simplify)(og);
      (0, util_1.longestPath)(g2);
      var t2 = (0, feasible_tree_1.feasibleTree)(g2);
      (0, exports.initLowLimValues)(t2);
      (0, exports.initCutValues)(t2, g2);
      var e8;
      var f2;
      while (e8 = (0, exports.leaveEdge)(t2)) {
        f2 = (0, exports.enterEdge)(t2, g2, e8);
        (0, exports.exchangeEdges)(t2, g2, e8, f2);
      }
    };
    var initCutValues = function(t2, g2) {
      var vs = postorder3(t2, t2.nodes());
      vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        assignCutValue(t2, g2, v2);
      });
    };
    exports.initCutValues = initCutValues;
    var assignCutValue = function(t2, g2, child) {
      var childLab = t2.node(child);
      var parent = childLab.parent;
      t2.edgeFromArgs(child, parent).cutvalue = (0, exports.calcCutValue)(t2, g2, child);
    };
    var calcCutValue = function(t2, g2, child) {
      var _a2;
      var childLab = t2.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g2.edgeFromArgs(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g2.edgeFromArgs(parent, child);
      }
      cutValue = graphEdge.weight;
      (_a2 = g2.nodeEdges(child)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var isOutEdge = e8.v === child;
        var other = isOutEdge ? e8.w : e8.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail;
          var otherWeight = g2.edge(e8).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t2, child, other)) {
            var otherCutValue = t2.edgeFromArgs(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    };
    exports.calcCutValue = calcCutValue;
    var initLowLimValues = function(tree, root) {
      if (root === void 0) {
        root = tree.nodes()[0];
      }
      dfsAssignLowLim(tree, {}, 1, root);
    };
    exports.initLowLimValues = initLowLimValues;
    var dfsAssignLowLim = function(tree, visited, nextLim, v2, parent) {
      var _a2;
      var low = nextLim;
      var useNextLim = nextLim;
      var label = tree.node(v2);
      visited[v2] = true;
      (_a2 = tree.neighbors(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(w2) {
        if (!visited[w2]) {
          useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w2, v2);
        }
      });
      label.low = low;
      label.lim = useNextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return useNextLim;
    };
    var leaveEdge = function(tree) {
      return tree.edges().find(function(e8) {
        return tree.edge(e8).cutvalue < 0;
      });
    };
    exports.leaveEdge = leaveEdge;
    var enterEdge = function(t2, g2, edge) {
      var v2 = edge.v;
      var w2 = edge.w;
      if (!g2.hasEdge(v2, w2)) {
        v2 = edge.w;
        w2 = edge.v;
      }
      var vLabel = t2.node(v2);
      var wLabel = t2.node(w2);
      var tailLabel = vLabel;
      var flip2 = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip2 = true;
      }
      var candidates = g2.edges().filter(function(edge2) {
        return flip2 === isDescendant(t2, t2.node(edge2.v), tailLabel) && flip2 !== isDescendant(t2, t2.node(edge2.w), tailLabel);
      });
      return (0, util_2.minBy)(candidates, function(edge2) {
        return (0, util_1.slack)(g2, edge2);
      });
    };
    exports.enterEdge = enterEdge;
    var exchangeEdges = function(t2, g2, e8, f2) {
      var v2 = e8.v;
      var w2 = e8.w;
      t2.removeEdge(v2, w2);
      t2.setEdge(f2.v, f2.w, {});
      (0, exports.initLowLimValues)(t2);
      (0, exports.initCutValues)(t2, g2);
      updateRanks(t2, g2);
    };
    exports.exchangeEdges = exchangeEdges;
    var updateRanks = function(t2, g2) {
      var root = t2.nodes().find(function(v2) {
        var _a2;
        return !((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.parent);
      });
      var vs = preorder3(t2, root);
      vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        var parent = t2.node(v2).parent;
        var edge = g2.edgeFromArgs(v2, parent);
        var flipped = false;
        if (!edge) {
          edge = g2.edgeFromArgs(parent, v2);
          flipped = true;
        }
        g2.node(v2).rank = g2.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    };
    var isTreeEdge = function(tree, u2, v2) {
      return tree.hasEdge(u2, v2);
    };
    var isDescendant = function(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    };
    exports.default = networkSimplex;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/index.js
var require_rank = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util4();
    var feasible_tree_1 = require_feasible_tree();
    var network_simplex_1 = __importDefault(require_network_simplex());
    var rank = function(g2) {
      switch (g2.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g2);
          break;
        case "tight-tree":
          tightTreeRanker(g2);
          break;
        case "longest-path":
          longestPathRanker(g2);
          break;
        default:
          tightTreeRanker(g2);
      }
    };
    var longestPathRanker = util_1.longestPath;
    var tightTreeRanker = function(g2) {
      (0, util_1.longestPathWithLayer)(g2);
      (0, feasible_tree_1.feasibleTreeWithLayer)(g2);
    };
    var networkSimplexRanker = function(g2) {
      (0, network_simplex_1.default)(g2);
    };
    exports.default = rank;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/parent-dummy-chains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dfsBothOrder = function(g2) {
      var _a2;
      var result = {};
      var lim = 0;
      var dfs3 = function(v2) {
        var _a3;
        var low = lim;
        (_a3 = g2.children(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(dfs3);
        result[v2] = { low, lim: lim++ };
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(dfs3);
      return result;
    };
    var findPath = function(g2, postorderNums, v2, w2) {
      var vPath = [];
      var wPath = [];
      var low = Math.min(postorderNums[v2].low, postorderNums[w2].low);
      var lim = Math.max(postorderNums[v2].lim, postorderNums[w2].lim);
      var parent;
      var lca;
      parent = v2;
      do {
        parent = g2.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w2;
      while (parent && parent !== lca) {
        wPath.push(parent);
        parent = g2.parent(parent);
      }
      return { lca, path: vPath.concat(wPath.reverse()) };
    };
    var parentDummyChains = function(g2) {
      var _a2;
      var postorderNums = dfsBothOrder(g2);
      (_a2 = g2.graph().dummyChains) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(startV) {
        var _a3, _b;
        var v2 = startV;
        var node = g2.node(v2);
        var edgeObj = node.edgeObj;
        if (!edgeObj)
          return;
        var pathData = findPath(g2, postorderNums, edgeObj.v, edgeObj.w);
        var path = pathData.path;
        var lca = pathData.lca;
        var pathIdx = 0;
        var pathV = path[pathIdx];
        var ascending = true;
        while (v2 !== edgeObj.w) {
          node = g2.node(v2);
          if (ascending) {
            while (pathV !== lca && ((_a3 = g2.node(pathV)) === null || _a3 === void 0 ? void 0 : _a3.maxRank) < node.rank) {
              pathIdx++;
              pathV = path[pathIdx];
            }
            if (pathV === lca) {
              ascending = false;
            }
          }
          if (!ascending) {
            while (pathIdx < path.length - 1 && ((_b = g2.node(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.minRank) <= node.rank) {
              pathIdx++;
            }
            pathV = path[pathIdx];
          }
          g2.setParent(v2, pathV);
          v2 = g2.successors(v2)[0];
        }
      });
    };
    exports.default = parentDummyChains;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/nesting-graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var run = function(g2) {
      var _a2;
      var root = (0, util_1.addDummyNode)(g2, "root", {}, "_root");
      var depths = treeDepths(g2);
      var maxDepth = Math.max.apply(Math, Object.values(depths));
      if (Math.abs(maxDepth) === Infinity) {
        maxDepth = 1;
      }
      var height = maxDepth - 1;
      var nodeSep = 2 * height + 1;
      g2.graph().nestingRoot = root;
      g2.edges().forEach(function(e8) {
        g2.edge(e8).minlen *= nodeSep;
      });
      var weight = sumWeights(g2) + 1;
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
        dfs3(g2, root, nodeSep, weight, height, depths, child);
      });
      g2.graph().nodeRankFactor = nodeSep;
    };
    var dfs3 = function(g2, root, nodeSep, weight, height, depths, v2) {
      var children = g2.children(v2);
      if (!(children === null || children === void 0 ? void 0 : children.length)) {
        if (v2 !== root) {
          g2.setEdge(root, v2, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      var top = (0, util_1.addBorderNode)(g2, "_bt");
      var bottom = (0, util_1.addBorderNode)(g2, "_bb");
      var label = g2.node(v2);
      g2.setParent(top, v2);
      label.borderTop = top;
      g2.setParent(bottom, v2);
      label.borderBottom = bottom;
      children === null || children === void 0 ? void 0 : children.forEach(function(child) {
        dfs3(g2, root, nodeSep, weight, height, depths, child);
        var childNode = g2.node(child);
        var childTop = childNode.borderTop ? childNode.borderTop : child;
        var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        var thisWeight = childNode.borderTop ? weight : 2 * weight;
        var minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
        g2.setEdge(top, childTop, {
          minlen,
          weight: thisWeight,
          nestingEdge: true
        });
        g2.setEdge(childBottom, bottom, {
          minlen,
          weight: thisWeight,
          nestingEdge: true
        });
      });
      if (!g2.parent(v2)) {
        g2.setEdge(root, top, { weight: 0, minlen: height + depths[v2] });
      }
    };
    var treeDepths = function(g2) {
      var _a2;
      var depths = {};
      var dfs4 = function(v2, depth) {
        var children = g2.children(v2);
        children === null || children === void 0 ? void 0 : children.forEach(function(child) {
          return dfs4(child, depth + 1);
        });
        depths[v2] = depth;
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        return dfs4(v2, 1);
      });
      return depths;
    };
    var sumWeights = function(g2) {
      var result = 0;
      g2.edges().forEach(function(e8) {
        result += g2.edge(e8).weight;
      });
      return result;
    };
    var cleanup = function(g2) {
      var graphLabel = g2.graph();
      graphLabel.nestingRoot && g2.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge.nestingEdge) {
          g2.removeEdgeObj(e8);
        }
      });
    };
    exports.default = { run, cleanup };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/add-border-segments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var addBorderSegments = function(g2) {
      var _a2;
      var dfs3 = function(v2) {
        var children = g2.children(v2);
        var node = g2.node(v2);
        if (children === null || children === void 0 ? void 0 : children.length) {
          children.forEach(function(child) {
            return dfs3(child);
          });
        }
        if (node.hasOwnProperty("minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; rank += 1) {
            addBorderNode(g2, "borderLeft", "_bl", v2, node, rank);
            addBorderNode(g2, "borderRight", "_br", v2, node, rank);
          }
        }
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
        return dfs3(child);
      });
    };
    var addBorderNode = function(g2, prop, prefix, sg, sgNode, rank) {
      var label = { rank, borderType: prop, width: 0, height: 0 };
      var prev = sgNode[prop][rank - 1];
      var curr = (0, util_1.addDummyNode)(g2, "border", label, prefix);
      sgNode[prop][rank] = curr;
      g2.setParent(curr, sg);
      if (prev) {
        g2.setEdge(prev, curr, { weight: 1 });
      }
    };
    exports.default = addBorderSegments;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/coordinate-system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var adjust = function(g2) {
      var _a2;
      var rankDir = (_a2 = g2.graph().rankdir) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g2);
      }
    };
    var undo = function(g2) {
      var _a2;
      var rankDir = (_a2 = g2.graph().rankdir) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g2);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g2);
        swapWidthHeight(g2);
      }
    };
    var swapWidthHeight = function(g2) {
      g2.nodes().forEach(function(v2) {
        swapWidthHeightOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        swapWidthHeightOne(g2.edge(e8));
      });
    };
    var swapWidthHeightOne = function(attrs) {
      var w2 = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w2;
    };
    var reverseY = function(g2) {
      g2.nodes().forEach(function(v2) {
        reverseYOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(point) {
          return reverseYOne(point);
        });
        if (edge.hasOwnProperty("y")) {
          reverseYOne(edge);
        }
      });
    };
    var reverseYOne = function(attrs) {
      if (attrs === null || attrs === void 0 ? void 0 : attrs.y) {
        attrs.y = -attrs.y;
      }
    };
    var swapXY = function(g2) {
      g2.nodes().forEach(function(v2) {
        swapXYOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(point) {
          return swapXYOne(point);
        });
        if (edge.hasOwnProperty("x")) {
          swapXYOne(edge);
        }
      });
    };
    var swapXYOne = function(attrs) {
      var x4 = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x4;
    };
    exports.default = { adjust, undo };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/rgb2arr.js
function rgb2arr(str) {
  return [parseInt(str.substr(1, 2), 16), parseInt(str.substr(3, 2), 16), parseInt(str.substr(5, 2), 16)];
}
var init_rgb2arr = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/rgb2arr.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/arr2rgb.js
function toHex2(value) {
  var x16Value = Math.round(value).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
}
function arr2rgb(arr) {
  return "#" + toHex2(arr[0]) + toHex2(arr[1]) + toHex2(arr[2]);
}
var init_arr2rgb = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/arr2rgb.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-array-like.js
var isArrayLike, is_array_like_default;
var init_is_array_like = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-array-like.js"() {
    isArrayLike = function(value) {
      return value !== null && typeof value !== "function" && isFinite(value.length);
    };
    is_array_like_default = isArrayLike;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/contains.js
var contains, contains_default;
var init_contains = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/contains.js"() {
    init_is_array_like();
    contains = function(arr, value) {
      if (!is_array_like_default(arr)) {
        return false;
      }
      return arr.indexOf(value) > -1;
    };
    contains_default = contains;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/filter.js
var filter, filter_default;
var init_filter = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/filter.js"() {
    init_is_array_like();
    filter = function(arr, func) {
      if (!is_array_like_default(arr)) {
        return arr;
      }
      var result = [];
      for (var index2 = 0; index2 < arr.length; index2++) {
        var value = arr[index2];
        if (func(value, index2)) {
          result.push(value);
        }
      }
      return result;
    };
    filter_default = filter;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/difference.js
var difference, difference_default;
var init_difference = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/difference.js"() {
    init_filter();
    init_contains();
    difference = function(arr, values2) {
      if (values2 === void 0) {
        values2 = [];
      }
      return filter_default(arr, function(value) {
        return !contains_default(values2, value);
      });
    };
    difference_default = difference;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-function.js
var is_function_default2;
var init_is_function = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-function.js"() {
    is_function_default2 = function(value) {
      return typeof value === "function";
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-nil.js
var isNil, is_nil_default2;
var init_is_nil = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-nil.js"() {
    isNil = function(value) {
      return value === null || value === void 0;
    };
    is_nil_default2 = isNil;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-type.js
var toString2, isType, is_type_default;
var init_is_type = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-type.js"() {
    toString2 = {}.toString;
    isType = function(value, type) {
      return toString2.call(value) === "[object " + type + "]";
    };
    is_type_default = isType;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-array.js
var is_array_default2;
var init_is_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-array.js"() {
    init_is_type();
    is_array_default2 = function(value) {
      return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-object.js
var is_object_default2;
var init_is_object = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-object.js"() {
    is_object_default2 = function(value) {
      var type = typeof value;
      return value !== null && type === "object" || type === "function";
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default2(elements)) {
    for (var i2 = 0, len = elements.length; i2 < len; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default2(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default2;
var init_each = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/each.js"() {
    init_is_array();
    init_is_object();
    each_default2 = each;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/keys.js
var keys, keys_default;
var init_keys = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/keys.js"() {
    init_each();
    init_is_function();
    keys = Object.keys ? function(obj) {
      return Object.keys(obj);
    } : function(obj) {
      var result = [];
      each_default2(obj, function(value, key) {
        if (!(is_function_default2(obj) && key === "prototype")) {
          result.push(key);
        }
      });
      return result;
    };
    keys_default = keys;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-match.js
function isMatch(obj, attrs) {
  var _keys = keys_default(attrs);
  var length = _keys.length;
  if (is_nil_default2(obj))
    return !length;
  for (var i2 = 0; i2 < length; i2 += 1) {
    var key = _keys[i2];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default;
var init_is_match = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-match.js"() {
    init_is_nil();
    init_keys();
    is_match_default = isMatch;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-object-like.js
var isObjectLike, is_object_like_default;
var init_is_object_like = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-object-like.js"() {
    isObjectLike = function(value) {
      return typeof value === "object" && value !== null;
    };
    is_object_like_default = isObjectLike;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-plain-object.js
var isPlainObject, is_plain_object_default2;
var init_is_plain_object = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-plain-object.js"() {
    init_is_object_like();
    init_is_type();
    isPlainObject = function(value) {
      if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
        return false;
      }
      if (Object.getPrototypeOf(value) === null) {
        return true;
      }
      var proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    };
    is_plain_object_default2 = isPlainObject;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/find.js
function find2(arr, predicate) {
  if (!is_array_default2(arr))
    return null;
  var _predicate;
  if (is_function_default2(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default2(predicate)) {
    _predicate = function(a3) {
      return is_match_default(a3, predicate);
    };
  }
  if (_predicate) {
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      if (_predicate(arr[i2])) {
        return arr[i2];
      }
    }
  }
  return null;
}
var find_default2;
var init_find2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/find.js"() {
    init_is_function();
    init_is_match();
    init_is_array();
    init_is_plain_object();
    find_default2 = find2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/find-index.js
function findIndex(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  for (var i2 = fromIndex; i2 < arr.length; i2++) {
    if (predicate(arr[i2], i2)) {
      return i2;
    }
  }
  return -1;
}
var find_index_default;
var init_find_index = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/find-index.js"() {
    find_index_default = findIndex;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/first-value.js
var firstValue, first_value_default;
var init_first_value = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/first-value.js"() {
    init_is_nil();
    init_is_array();
    firstValue = function(data, name) {
      var rst = null;
      for (var i2 = 0; i2 < data.length; i2++) {
        var obj = data[i2];
        var value = obj[name];
        if (!is_nil_default2(value)) {
          if (is_array_default2(value)) {
            rst = value[0];
          } else {
            rst = value;
          }
          break;
        }
      }
      return rst;
    };
    first_value_default = firstValue;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/flatten.js
var flatten, flatten_default;
var init_flatten = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/flatten.js"() {
    init_is_array();
    flatten = function(arr) {
      if (!is_array_default2(arr)) {
        return [];
      }
      var rst = [];
      for (var i2 = 0; i2 < arr.length; i2++) {
        rst = rst.concat(arr[i2]);
      }
      return rst;
    };
    flatten_default = flatten;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/flatten-deep.js
var flattenDeep, flatten_deep_default;
var init_flatten_deep = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/flatten-deep.js"() {
    init_is_array();
    flattenDeep = function(arr, result) {
      if (result === void 0) {
        result = [];
      }
      if (!is_array_default2(arr)) {
        result.push(arr);
      } else {
        for (var i2 = 0; i2 < arr.length; i2 += 1) {
          flattenDeep(arr[i2], result);
        }
      }
      return result;
    };
    flatten_deep_default = flattenDeep;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/max.js
var max_default;
var init_max = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/max.js"() {
    init_is_array();
    max_default = function(arr) {
      if (!is_array_default2(arr)) {
        return void 0;
      }
      return arr.reduce(function(prev, curr) {
        return Math.max(prev, curr);
      }, arr[0]);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/min.js
var min_default;
var init_min = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/min.js"() {
    init_is_array();
    min_default = function(arr) {
      if (!is_array_default2(arr)) {
        return void 0;
      }
      return arr.reduce(function(prev, curr) {
        return Math.min(prev, curr);
      }, arr[0]);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-range.js
var getRange, get_range_default;
var init_get_range = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-range.js"() {
    init_is_array();
    init_max();
    init_min();
    getRange = function(values2) {
      var filterValues = values2.filter(function(v2) {
        return !isNaN(v2);
      });
      if (!filterValues.length) {
        return {
          min: 0,
          max: 0
        };
      }
      if (is_array_default2(values2[0])) {
        var tmp = [];
        for (var i2 = 0; i2 < values2.length; i2++) {
          tmp = tmp.concat(values2[i2]);
        }
        filterValues = tmp;
      }
      var max4 = max_default(filterValues);
      var min3 = min_default(filterValues);
      return {
        min: min3,
        max: max4
      };
    };
    get_range_default = getRange;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype, splice, indexOf, pull, pull_default;
var init_pull = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pull.js"() {
    arrPrototype = Array.prototype;
    splice = arrPrototype.splice;
    indexOf = arrPrototype.indexOf;
    pull = function(arr) {
      var values2 = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        values2[_i2 - 1] = arguments[_i2];
      }
      for (var i2 = 0; i2 < values2.length; i2++) {
        var value = values2[i2];
        var fromIndex = -1;
        while ((fromIndex = indexOf.call(arr, value)) > -1) {
          splice.call(arr, fromIndex, 1);
        }
      }
      return arr;
    };
    pull_default = pull;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pull-at.js
var splice2, pullAt, pull_at_default;
var init_pull_at = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pull-at.js"() {
    init_is_array_like();
    splice2 = Array.prototype.splice;
    pullAt = function pullAt2(arr, indexes) {
      if (!is_array_like_default(arr)) {
        return [];
      }
      var length = arr ? indexes.length : 0;
      var last2 = length - 1;
      while (length--) {
        var previous = void 0;
        var index2 = indexes[length];
        if (length === last2 || index2 !== previous) {
          previous = index2;
          splice2.call(arr, index2, 1);
        }
      }
      return arr;
    };
    pull_at_default = pullAt;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/reduce.js
var reduce, reduce_default;
var init_reduce = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/reduce.js"() {
    init_each();
    init_is_array();
    init_is_plain_object();
    reduce = function(arr, fn2, init) {
      if (!is_array_default2(arr) && !is_plain_object_default2(arr)) {
        return arr;
      }
      var result = init;
      each_default2(arr, function(data, i2) {
        result = fn2(result, data, i2);
      });
      return result;
    };
    reduce_default = reduce;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/remove.js
var remove, remove_default2;
var init_remove2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/remove.js"() {
    init_is_array_like();
    init_pull_at();
    remove = function(arr, predicate) {
      var result = [];
      if (!is_array_like_default(arr)) {
        return result;
      }
      var i2 = -1;
      var indexes = [];
      var length = arr.length;
      while (++i2 < length) {
        var value = arr[i2];
        if (predicate(value, i2, arr)) {
          result.push(value);
          indexes.push(i2);
        }
      }
      pull_at_default(arr, indexes);
      return result;
    };
    remove_default2 = remove;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-string.js
var is_string_default2;
var init_is_string = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-string.js"() {
    init_is_type();
    is_string_default2 = function(str) {
      return is_type_default(str, "String");
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/sort-by.js
function sortBy(arr, key) {
  var comparer;
  if (is_function_default2(key)) {
    comparer = function(a3, b2) {
      return key(a3) - key(b2);
    };
  } else {
    var keys_1 = [];
    if (is_string_default2(key)) {
      keys_1.push(key);
    } else if (is_array_default2(key)) {
      keys_1 = key;
    }
    comparer = function(a3, b2) {
      for (var i2 = 0; i2 < keys_1.length; i2 += 1) {
        var prop = keys_1[i2];
        if (a3[prop] > b2[prop]) {
          return 1;
        }
        if (a3[prop] < b2[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }
  arr.sort(comparer);
  return arr;
}
var sort_by_default;
var init_sort_by = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/sort-by.js"() {
    init_is_array();
    init_is_string();
    init_is_function();
    sort_by_default = sortBy;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/uniq.js
function uniq2(arr, cache2) {
  if (cache2 === void 0) {
    cache2 = /* @__PURE__ */ new Map();
  }
  var r2 = [];
  if (Array.isArray(arr)) {
    for (var i2 = 0, len = arr.length; i2 < len; i2++) {
      var item = arr[i2];
      if (!cache2.has(item)) {
        r2.push(item);
        cache2.set(item, true);
      }
    }
  }
  return r2;
}
var init_uniq = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/uniq.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/union.js
var union, union_default;
var init_union = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/union.js"() {
    init_uniq();
    union = function() {
      var sources = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        sources[_i2] = arguments[_i2];
      }
      return uniq2([].concat.apply([], sources));
    };
    union_default = union;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/values-of-key.js
var values_of_key_default;
var init_values_of_key = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/values-of-key.js"() {
    init_is_array();
    init_is_nil();
    values_of_key_default = function(data, name) {
      var rst = [];
      var tmpMap = {};
      for (var i2 = 0; i2 < data.length; i2++) {
        var obj = data[i2];
        var value = obj[name];
        if (!is_nil_default2(value)) {
          if (!is_array_default2(value)) {
            value = [value];
          }
          for (var j2 = 0; j2 < value.length; j2++) {
            var val = value[j2];
            if (!tmpMap[val]) {
              rst.push(val);
              tmpMap[val] = true;
            }
          }
        }
      }
      return rst;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/head.js
function head2(o2) {
  if (is_array_like_default(o2)) {
    return o2[0];
  }
  return void 0;
}
var init_head = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/head.js"() {
    init_is_array_like();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/last.js
function last(o2) {
  if (is_array_like_default(o2)) {
    var arr = o2;
    return arr[arr.length - 1];
  }
  return void 0;
}
var init_last = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/last.js"() {
    init_is_array_like();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/starts-with.js
function startsWith(arr, e8) {
  return is_array_default2(arr) || is_string_default2(arr) ? arr[0] === e8 : false;
}
var starts_with_default;
var init_starts_with = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/starts-with.js"() {
    init_is_array();
    init_is_string();
    starts_with_default = startsWith;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/ends-with.js
function endsWith(arr, e8) {
  return is_array_default2(arr) || is_string_default2(arr) ? arr[arr.length - 1] === e8 : false;
}
var ends_with_default;
var init_ends_with = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/ends-with.js"() {
    init_is_array();
    init_is_string();
    ends_with_default = endsWith;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/every.js
var every, every_default;
var init_every = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/every.js"() {
    every = function(arr, func) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (!func(arr[i2], i2))
          return false;
      }
      return true;
    };
    every_default = every;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/some.js
var some, some_default;
var init_some = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/some.js"() {
    some = function(arr, func) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (func(arr[i2], i2))
          return true;
      }
      return false;
    };
    some_default = some;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group-by.js
function groupBy(data, condition) {
  if (!condition || !is_array_default2(data)) {
    return {};
  }
  var result = {};
  var predicate = is_function_default2(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i2 = 0; i2 < data.length; i2++) {
    var item = data[i2];
    key = predicate(item);
    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
var hasOwnProperty, group_by_default2;
var init_group_by = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group-by.js"() {
    init_is_array();
    init_is_function();
    hasOwnProperty = Object.prototype.hasOwnProperty;
    group_by_default2 = groupBy;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group-to-map.js
function groupToMap(data, condition) {
  if (!condition) {
    return {
      0: data
    };
  }
  if (!is_function_default2(condition)) {
    var paramscondition_1 = is_array_default2(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i2 = 0, l2 = paramscondition_1.length; i2 < l2; i2++) {
        unique += row[paramscondition_1[i2]] && row[paramscondition_1[i2]].toString();
      }
      return unique;
    };
  }
  return group_by_default2(data, condition);
}
var init_group_to_map = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group-to-map.js"() {
    init_is_array();
    init_is_function();
    init_group_by();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group.js
var group_default;
var init_group = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/group.js"() {
    init_group_to_map();
    group_default = function(data, condition) {
      if (!condition) {
        return [data];
      }
      var groups = groupToMap(data, condition);
      var array = [];
      for (var i2 in groups) {
        array.push(groups[i2]);
      }
      return array;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-wrap-behavior.js
function getWrapBehavior(obj, action) {
  return obj["_wrap_" + action];
}
var get_wrap_behavior_default;
var init_get_wrap_behavior = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-wrap-behavior.js"() {
    get_wrap_behavior_default = getWrapBehavior;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/wrap-behavior.js
function wrapBehavior(obj, action) {
  if (obj["_wrap_" + action]) {
    return obj["_wrap_" + action];
  }
  var method = function(e8) {
    obj[action](e8);
  };
  obj["_wrap_" + action] = method;
  return method;
}
var wrap_behavior_default2;
var init_wrap_behavior = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/wrap-behavior.js"() {
    wrap_behavior_default2 = wrapBehavior;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/number2color.js
function numberToColor(num) {
  var color2 = numColorCache[num];
  if (!color2) {
    var str = num.toString(16);
    for (var i2 = str.length; i2 < 6; i2++) {
      str = "0" + str;
    }
    color2 = "#" + str;
    numColorCache[num] = color2;
  }
  return color2;
}
var numColorCache, number2color_default;
var init_number2color = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/number2color.js"() {
    numColorCache = {};
    number2color_default = numberToColor;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/parse-radius.js
function parseRadius(radius) {
  var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
  if (is_array_default2(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}
var parse_radius_default;
var init_parse_radius = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/parse-radius.js"() {
    init_is_array();
    parse_radius_default = parseRadius;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clamp.js
var clamp, clamp_default;
var init_clamp = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clamp.js"() {
    clamp = function(a3, min3, max4) {
      if (a3 < min3) {
        return min3;
      } else if (a3 > max4) {
        return max4;
      }
      return a3;
    };
    clamp_default = clamp;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/fixed-base.js
var fixedBase, fixed_base_default;
var init_fixed_base = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/fixed-base.js"() {
    fixedBase = function(v2, base) {
      var str = base.toString();
      var index2 = str.indexOf(".");
      if (index2 === -1) {
        return Math.round(v2);
      }
      var length = str.substr(index2 + 1).length;
      if (length > 20) {
        length = 20;
      }
      return parseFloat(v2.toFixed(length));
    };
    fixed_base_default = fixedBase;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-number.js
var isNumber, is_number_default2;
var init_is_number = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-number.js"() {
    init_is_type();
    isNumber = function(value) {
      return is_type_default(value, "Number");
    };
    is_number_default2 = isNumber;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-decimal.js
var isDecimal, is_decimal_default;
var init_is_decimal = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-decimal.js"() {
    init_is_number();
    isDecimal = function(num) {
      return is_number_default2(num) && num % 1 !== 0;
    };
    is_decimal_default = isDecimal;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-even.js
var isEven, is_even_default;
var init_is_even = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-even.js"() {
    init_is_number();
    isEven = function(num) {
      return is_number_default2(num) && num % 2 === 0;
    };
    is_even_default = isEven;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-integer.js
var isInteger, is_integer_default;
var init_is_integer = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-integer.js"() {
    init_is_number();
    isInteger = Number.isInteger ? Number.isInteger : function(num) {
      return is_number_default2(num) && num % 1 === 0;
    };
    is_integer_default = isInteger;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-negative.js
var isNegative, is_negative_default;
var init_is_negative = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-negative.js"() {
    init_is_number();
    isNegative = function(num) {
      return is_number_default2(num) && num < 0;
    };
    is_negative_default = isNegative;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-number-equal.js
function isNumberEqual(a3, b2, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a3 - b2) < precision;
}
var PRECISION;
var init_is_number_equal = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-number-equal.js"() {
    PRECISION = 1e-5;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-odd.js
var isOdd, is_odd_default;
var init_is_odd = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-odd.js"() {
    init_is_number();
    isOdd = function(num) {
      return is_number_default2(num) && num % 2 !== 0;
    };
    is_odd_default = isOdd;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-positive.js
var isPositive, is_positive_default;
var init_is_positive = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-positive.js"() {
    init_is_number();
    isPositive = function(num) {
      return is_number_default2(num) && num > 0;
    };
    is_positive_default = isPositive;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/max-by.js
var max_by_default;
var init_max_by = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/max-by.js"() {
    init_is_array();
    init_is_function();
    max_by_default = function(arr, fn2) {
      if (!is_array_default2(arr)) {
        return void 0;
      }
      var maxItem;
      var max4 = -Infinity;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = arr[i2];
        var v2 = is_function_default2(fn2) ? fn2(item) : item[fn2];
        if (v2 > max4) {
          maxItem = item;
          max4 = v2;
        }
      }
      return maxItem;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/min-by.js
var min_by_default;
var init_min_by = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/min-by.js"() {
    init_is_array();
    init_is_function();
    min_by_default = function(arr, fn2) {
      if (!is_array_default2(arr)) {
        return void 0;
      }
      var minItem;
      var min3 = Infinity;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = arr[i2];
        var v2 = is_function_default2(fn2) ? fn2(item) : item[fn2];
        if (v2 < min3) {
          minItem = item;
          min3 = v2;
        }
      }
      return minItem;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/mod.js
var mod, mod_default;
var init_mod = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/mod.js"() {
    mod = function(n2, m3) {
      return (n2 % m3 + m3) % m3;
    };
    mod_default = mod;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE, toDegree, to_degree_default;
var init_to_degree = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-degree.js"() {
    DEGREE = 180 / Math.PI;
    toDegree = function(radian) {
      return DEGREE * radian;
    };
    to_degree_default = toDegree;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-integer.js
var to_integer_default;
var init_to_integer = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-integer.js"() {
    to_integer_default = parseInt;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN, toRadian, to_radian_default;
var init_to_radian = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-radian.js"() {
    RADIAN = Math.PI / 180;
    toRadian = function(degree3) {
      return RADIAN * degree3;
    };
    to_radian_default = toRadian;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/for-in.js
var for_in_default;
var init_for_in = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/for-in.js"() {
    init_each();
    for_in_default = each_default2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has.js
var has_default;
var init_has = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has.js"() {
    has_default = function(obj, key) {
      return obj.hasOwnProperty(key);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has-key.js
var has_key_default;
var init_has_key = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has-key.js"() {
    init_has();
    has_key_default = has_default;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/values.js
var values, values_default;
var init_values = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/values.js"() {
    init_each();
    init_is_function();
    values = Object.values ? function(obj) {
      return Object.values(obj);
    } : function(obj) {
      var result = [];
      each_default2(obj, function(value, key) {
        if (!(is_function_default2(obj) && key === "prototype")) {
          result.push(value);
        }
      });
      return result;
    };
    values_default = values;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has-value.js
var has_value_default;
var init_has_value = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/has-value.js"() {
    init_contains();
    init_values();
    has_value_default = function(obj, value) {
      return contains_default(values_default(obj), value);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-string.js
var to_string_default;
var init_to_string = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-string.js"() {
    init_is_nil();
    to_string_default = function(value) {
      if (is_nil_default2(value))
        return "";
      return value.toString();
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/lower-case.js
var lowerCase, lower_case_default;
var init_lower_case = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/lower-case.js"() {
    init_to_string();
    lowerCase = function(str) {
      return to_string_default(str).toLowerCase();
    };
    lower_case_default = lowerCase;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/lower-first.js
var lowerFirst, lower_first_default;
var init_lower_first = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/lower-first.js"() {
    init_to_string();
    lowerFirst = function(value) {
      var str = to_string_default(value);
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    lower_first_default = lowerFirst;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/substitute.js
function substitute3(str, o2) {
  if (!str || !o2) {
    return str;
  }
  return str.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o2[name] === void 0 ? "" : o2[name];
  });
}
var substitute_default;
var init_substitute = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/substitute.js"() {
    substitute_default = substitute3;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/upper-case.js
var upperCase, upper_case_default;
var init_upper_case = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/upper-case.js"() {
    init_to_string();
    upperCase = function(str) {
      return to_string_default(str).toUpperCase();
    };
    upper_case_default = upperCase;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/upper-first.js
var upperFirst, upper_first_default2;
var init_upper_first = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/upper-first.js"() {
    init_to_string();
    upperFirst = function(value) {
      var str = to_string_default(value);
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    upper_first_default2 = upperFirst;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-type.js
var toString3, getType, get_type_default;
var init_get_type = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get-type.js"() {
    toString3 = {}.toString;
    getType = function(value) {
      return toString3.call(value).replace(/^\[object /, "").replace(/]$/, "");
    };
    get_type_default = getType;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-arguments.js
var isArguments, is_arguments_default;
var init_is_arguments = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-arguments.js"() {
    init_is_type();
    isArguments = function(value) {
      return is_type_default(value, "Arguments");
    };
    is_arguments_default = isArguments;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-boolean.js
var isBoolean, is_boolean_default2;
var init_is_boolean = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-boolean.js"() {
    init_is_type();
    isBoolean = function(value) {
      return is_type_default(value, "Boolean");
    };
    is_boolean_default2 = isBoolean;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-date.js
var isDate, is_date_default;
var init_is_date = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-date.js"() {
    init_is_type();
    isDate = function(value) {
      return is_type_default(value, "Date");
    };
    is_date_default = isDate;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-error.js
var isError, is_error_default;
var init_is_error = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-error.js"() {
    init_is_type();
    isError = function(value) {
      return is_type_default(value, "Error");
    };
    is_error_default = isError;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-finite.js
function is_finite_default(value) {
  return is_number_default2(value) && isFinite(value);
}
var init_is_finite = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-finite.js"() {
    init_is_number();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-null.js
var isNull, is_null_default;
var init_is_null = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-null.js"() {
    isNull = function(value) {
      return value === null;
    };
    is_null_default = isNull;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto, isPrototype, is_prototype_default;
var init_is_prototype = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-prototype.js"() {
    objectProto = Object.prototype;
    isPrototype = function(value) {
      var Ctor = value && value.constructor;
      var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
      return value === proto;
    };
    is_prototype_default = isPrototype;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-reg-exp.js
var isRegExp, is_reg_exp_default;
var init_is_reg_exp = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-reg-exp.js"() {
    init_is_type();
    isRegExp = function(str) {
      return is_type_default(str, "RegExp");
    };
    is_reg_exp_default = isRegExp;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-undefined.js
var isUndefined, is_undefined_default;
var init_is_undefined = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-undefined.js"() {
    isUndefined = function(value) {
      return value === void 0;
    };
    is_undefined_default = isUndefined;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-element.js
var isElement, is_element_default;
var init_is_element = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-element.js"() {
    isElement = function(o2) {
      return o2 instanceof Element || o2 instanceof Document;
    };
    is_element_default = isElement;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/request-animation-frame.js
function requestAnimationFrame2(fn2) {
  var method = window.requestAnimationFrame || // @ts-ignore
  window.webkitRequestAnimationFrame || // @ts-ignore
  window.mozRequestAnimationFrame || // @ts-ignore
  window.msRequestAnimationFrame || function(f2) {
    return setTimeout(f2, 16);
  };
  return method(fn2);
}
var init_request_animation_frame = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/request-animation-frame.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clear-animation-frame.js
function cancelAnimationFrame2(handler) {
  var method = window.cancelAnimationFrame || // @ts-ignore
  window.webkitCancelAnimationFrame || // @ts-ignore
  window.mozCancelAnimationFrame || // @ts-ignore
  window.msCancelAnimationFrame || clearTimeout;
  method(handler);
}
var init_clear_animation_frame = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clear-animation-frame.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/mix.js
function _mix(dist, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist[key] = obj[key];
    }
  }
}
function mix2(dist, src1, src2, src3) {
  if (src1)
    _mix(dist, src1);
  if (src2)
    _mix(dist, src2);
  if (src3)
    _mix(dist, src3);
  return dist;
}
var init_mix = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/mix.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/augment.js
var augment, augment_default;
var init_augment = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/augment.js"() {
    init_mix();
    init_is_function();
    augment = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var c3 = args[0];
      for (var i2 = 1; i2 < args.length; i2++) {
        var obj = args[i2];
        if (is_function_default2(obj)) {
          obj = obj.prototype;
        }
        mix2(c3.prototype, obj);
      }
    };
    augment_default = augment;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clone.js
var clone2, clone_default2;
var init_clone = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/clone.js"() {
    init_is_array();
    clone2 = function(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var rst;
      if (is_array_default2(obj)) {
        rst = [];
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          if (typeof obj[i2] === "object" && obj[i2] != null) {
            rst[i2] = clone2(obj[i2]);
          } else {
            rst[i2] = obj[i2];
          }
        }
      } else {
        rst = {};
        for (var k2 in obj) {
          if (typeof obj[k2] === "object" && obj[k2] != null) {
            rst[k2] = clone2(obj[k2]);
          } else {
            rst[k2] = obj[k2];
          }
        }
      }
      return rst;
    };
    clone_default2 = clone2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/debounce.js
function debounce(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default2;
var init_debounce = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/debounce.js"() {
    debounce_default2 = debounce;
  }
});

// node_modules/flru/dist/flru.mjs
function flru_default(max4) {
  var num, curr, prev;
  var limit = max4 || 1;
  function keep(key, value) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value) {
      if (curr[key] !== void 0) {
        curr[key] = value;
      } else {
        keep(key, value);
      }
    }
  };
}
var init_flru = __esm({
  "node_modules/flru/dist/flru.mjs"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/memoize.js
var memoize_default;
var init_memoize = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/memoize.js"() {
    init_flru();
    init_is_function();
    memoize_default = function(f2, resolver, maxSize) {
      if (maxSize === void 0) {
        maxSize = 128;
      }
      if (!is_function_default2(f2)) {
        throw new TypeError("Expected a function");
      }
      var memoized = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        var key = resolver ? resolver.apply(this, args) : args[0];
        var cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = f2.apply(this, args);
        cache2.set(key, result);
        return result;
      };
      memoized.cache = flru_default(maxSize);
      return memoized;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/deep-mix.js
function hasOwn(object, property) {
  if (Object.hasOwn) {
    return Object.hasOwn(object, property);
  }
  if (object == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
}
function _deepMix(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (hasOwn(src, key)) {
      var value = src[key];
      if (value !== null && is_plain_object_default2(value)) {
        if (!is_plain_object_default2(dist[key])) {
          dist[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist[key], value, level + 1, maxLevel);
        } else {
          dist[key] = src[key];
        }
      } else if (is_array_default2(value)) {
        dist[key] = [];
        dist[key] = dist[key].concat(value);
      } else if (value !== void 0) {
        dist[key] = value;
      }
    }
  }
}
var MAX_MIX_LEVEL, deepMix, deep_mix_default2;
var init_deep_mix = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/deep-mix.js"() {
    init_is_array();
    init_is_plain_object();
    MAX_MIX_LEVEL = 5;
    deepMix = function(rst) {
      var args = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        args[_i2 - 1] = arguments[_i2];
      }
      for (var i2 = 0; i2 < args.length; i2 += 1) {
        _deepMix(rst, args[i2]);
      }
      return rst;
    };
    deep_mix_default2 = deepMix;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/extend.js
var extend, extend_default;
var init_extend = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/extend.js"() {
    init_mix();
    init_is_function();
    extend = function(subclass, superclass, overrides, staticOverrides) {
      if (!is_function_default2(superclass)) {
        overrides = superclass;
        superclass = subclass;
        subclass = function() {
        };
      }
      var create = Object.create ? function(proto, c3) {
        return Object.create(proto, {
          constructor: {
            value: c3
          }
        });
      } : function(proto, c3) {
        function Tmp() {
        }
        Tmp.prototype = proto;
        var o2 = new Tmp();
        o2.constructor = c3;
        return o2;
      };
      var superObj = create(superclass.prototype, subclass);
      subclass.prototype = mix2(superObj, subclass.prototype);
      subclass.superclass = create(superclass.prototype, superclass);
      mix2(superObj, overrides);
      mix2(subclass, staticOverrides);
      return subclass;
    };
    extend_default = extend;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/index-of.js
var indexOf2, index_of_default;
var init_index_of = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/index-of.js"() {
    init_is_array_like();
    indexOf2 = function(arr, obj) {
      if (!is_array_like_default(arr)) {
        return -1;
      }
      var m3 = Array.prototype.indexOf;
      if (m3) {
        return m3.call(arr, obj);
      }
      var index2 = -1;
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2] === obj) {
          index2 = i2;
          break;
        }
      }
      return index2;
    };
    index_of_default = indexOf2;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-empty.js
function isEmpty(value) {
  if (is_nil_default2(value)) {
    return true;
  }
  if (is_array_like_default(value)) {
    return !value.length;
  }
  var type = get_type_default(value);
  if (type === "Map" || type === "Set") {
    return !value.size;
  }
  if (is_prototype_default(value)) {
    return !Object.keys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var hasOwnProperty2, is_empty_default;
var init_is_empty = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-empty.js"() {
    init_is_nil();
    init_is_array_like();
    init_get_type();
    init_is_prototype();
    hasOwnProperty2 = Object.prototype.hasOwnProperty;
    is_empty_default = isEmpty;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-equal.js
var isEqual, is_equal_default2;
var init_is_equal = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-equal.js"() {
    init_is_object_like();
    init_is_array_like();
    init_is_string();
    isEqual = function(value, other) {
      if (value === other) {
        return true;
      }
      if (!value || !other) {
        return false;
      }
      if (is_string_default2(value) || is_string_default2(other)) {
        return false;
      }
      if (is_array_like_default(value) || is_array_like_default(other)) {
        if (value.length !== other.length) {
          return false;
        }
        var rst = true;
        for (var i2 = 0; i2 < value.length; i2++) {
          rst = isEqual(value[i2], other[i2]);
          if (!rst) {
            break;
          }
        }
        return rst;
      }
      if (is_object_like_default(value) || is_object_like_default(other)) {
        var valueKeys = Object.keys(value);
        var otherKeys = Object.keys(other);
        if (valueKeys.length !== otherKeys.length) {
          return false;
        }
        var rst = true;
        for (var i2 = 0; i2 < valueKeys.length; i2++) {
          rst = isEqual(value[valueKeys[i2]], other[valueKeys[i2]]);
          if (!rst) {
            break;
          }
        }
        return rst;
      }
      return false;
    };
    is_equal_default2 = isEqual;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-equal-with.js
var is_equal_with_default;
var init_is_equal_with = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/is-equal-with.js"() {
    init_is_function();
    init_is_equal();
    is_equal_with_default = function(value, other, fn2) {
      if (!is_function_default2(fn2)) {
        return is_equal_default2(value, other);
      }
      return !!fn2(value, other);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/map.js
var map, map_default2;
var init_map = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/map.js"() {
    init_is_array_like();
    map = function(arr, func) {
      if (!is_array_like_default(arr)) {
        return arr;
      }
      var result = [];
      for (var index2 = 0; index2 < arr.length; index2++) {
        var value = arr[index2];
        result.push(func(value, index2));
      }
      return result;
    };
    map_default2 = map;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/map-values.js
var identity, map_values_default;
var init_map_values = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/map-values.js"() {
    init_is_nil();
    init_is_object();
    identity = function(v2) {
      return v2;
    };
    map_values_default = function(object, func) {
      if (func === void 0) {
        func = identity;
      }
      var r2 = {};
      if (is_object_default2(object) && !is_nil_default2(object)) {
        Object.keys(object).forEach(function(key) {
          r2[key] = func(object[key], key);
        });
      }
      return r2;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get.js
var get_default2;
var init_get = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/get.js"() {
    init_is_string();
    get_default2 = function(obj, key, defaultValue) {
      var p2 = 0;
      var keyArr = is_string_default2(key) ? key.split(".") : key;
      while (obj && p2 < keyArr.length) {
        obj = obj[keyArr[p2++]];
      }
      return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/set.js
var set_default;
var init_set = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/set.js"() {
    init_is_object();
    init_is_string();
    init_is_number();
    set_default = function(obj, path, value) {
      var o2 = obj;
      var keyArr = is_string_default2(path) ? path.split(".") : path;
      keyArr.forEach(function(key, idx) {
        if (idx < keyArr.length - 1) {
          if (!is_object_default2(o2[key])) {
            o2[key] = is_number_default2(keyArr[idx + 1]) ? [] : {};
          }
          o2 = o2[key];
        } else {
          o2[key] = value;
        }
      });
      return obj;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pick.js
var hasOwnProperty3, pick_default;
var init_pick = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/pick.js"() {
    init_each();
    init_is_plain_object();
    hasOwnProperty3 = Object.prototype.hasOwnProperty;
    pick_default = function(object, keys2) {
      if (object === null || !is_plain_object_default2(object)) {
        return {};
      }
      var result = {};
      each_default2(keys2, function(key) {
        if (hasOwnProperty3.call(object, key)) {
          result[key] = object[key];
        }
      });
      return result;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/omit.js
var omit_default;
var init_omit = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/omit.js"() {
    init_reduce();
    omit_default = function(obj, keys2) {
      return reduce_default(obj, function(r2, curr, key) {
        if (!keys2.includes(key)) {
          r2[key] = curr;
        }
        return r2;
      }, {});
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/throttle.js
var throttle_default2;
var init_throttle = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/throttle.js"() {
    throttle_default2 = function(func, wait, options) {
      var timeout, context, args, result;
      var previous = 0;
      if (!options)
        options = {};
      var later = function() {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
          context = args = null;
      };
      var throttled = function() {
        var now = Date.now();
        if (!previous && options.leading === false)
          previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout)
            context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
      throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
      };
      return throttled;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-array.js
var to_array_default;
var init_to_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/to-array.js"() {
    init_is_array_like();
    to_array_default = function(value) {
      return is_array_like_default(value) ? Array.prototype.slice.call(value) : [];
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/unique-id.js
var map2, unique_id_default2;
var init_unique_id = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/unique-id.js"() {
    map2 = {};
    unique_id_default2 = function(prefix) {
      prefix = prefix || "g";
      if (!map2[prefix]) {
        map2[prefix] = 1;
      } else {
        map2[prefix] += 1;
      }
      return prefix + map2[prefix];
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/noop.js
var noop_default;
var init_noop = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/noop.js"() {
    noop_default = function() {
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/identity.js
var identity_default;
var init_identity = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/identity.js"() {
    identity_default = function(v2) {
      return v2;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/size.js
function size2(o2) {
  if (is_nil_default2(o2)) {
    return 0;
  }
  if (is_array_like_default(o2)) {
    return o2.length;
  }
  return Object.keys(o2).length;
}
var init_size2 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/size.js"() {
    init_is_nil();
    init_is_array_like();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/cache.js
var default_1, cache_default;
var init_cache = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/cache.js"() {
    default_1 = /** @class */
    function() {
      function default_12() {
        this.map = {};
      }
      default_12.prototype.has = function(key) {
        return this.map[key] !== void 0;
      };
      default_12.prototype.get = function(key, def) {
        var v2 = this.map[key];
        return v2 === void 0 ? def : v2;
      };
      default_12.prototype.set = function(key, value) {
        this.map[key] = value;
      };
      default_12.prototype.clear = function() {
        this.map = {};
      };
      default_12.prototype.delete = function(key) {
        delete this.map[key];
      };
      default_12.prototype.size = function() {
        return Object.keys(this.map).length;
      };
      return default_12;
    }();
    cache_default = default_1;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/index.js
var init_lodash = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/lodash/index.js"() {
    init_contains();
    init_difference();
    init_find2();
    init_find_index();
    init_first_value();
    init_flatten();
    init_flatten_deep();
    init_get_range();
    init_pull();
    init_pull_at();
    init_reduce();
    init_remove2();
    init_sort_by();
    init_union();
    init_uniq();
    init_values_of_key();
    init_head();
    init_last();
    init_starts_with();
    init_ends_with();
    init_filter();
    init_every();
    init_some();
    init_group();
    init_group_by();
    init_group_to_map();
    init_get_wrap_behavior();
    init_wrap_behavior();
    init_number2color();
    init_parse_radius();
    init_clamp();
    init_fixed_base();
    init_is_decimal();
    init_is_even();
    init_is_integer();
    init_is_negative();
    init_is_number_equal();
    init_is_odd();
    init_is_positive();
    init_max();
    init_max_by();
    init_min();
    init_min_by();
    init_mod();
    init_to_degree();
    init_to_integer();
    init_to_radian();
    init_for_in();
    init_has();
    init_has_key();
    init_has_value();
    init_keys();
    init_is_match();
    init_values();
    init_lower_case();
    init_lower_first();
    init_substitute();
    init_upper_case();
    init_upper_first();
    init_get_type();
    init_is_arguments();
    init_is_array();
    init_is_array_like();
    init_is_boolean();
    init_is_date();
    init_is_error();
    init_is_function();
    init_is_finite();
    init_is_nil();
    init_is_null();
    init_is_number();
    init_is_object();
    init_is_object_like();
    init_is_plain_object();
    init_is_prototype();
    init_is_reg_exp();
    init_is_string();
    init_is_type();
    init_is_undefined();
    init_is_element();
    init_request_animation_frame();
    init_clear_animation_frame();
    init_augment();
    init_clone();
    init_debounce();
    init_memoize();
    init_deep_mix();
    init_each();
    init_extend();
    init_index_of();
    init_is_empty();
    init_is_equal();
    init_is_equal_with();
    init_map();
    init_map_values();
    init_mix();
    init_get();
    init_set();
    init_pick();
    init_omit();
    init_throttle();
    init_to_array();
    init_to_string();
    init_unique_id();
    init_noop();
    init_identity();
    init_size2();
    init_cache();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/torgb.js
function createTmp() {
  var i2 = document.createElement("i");
  i2.title = "Web Colour Picker";
  i2.style.display = "none";
  document.body.appendChild(i2);
  return i2;
}
function toRGBString(color2) {
  if (color2[0] === "#" && color2.length === 7) {
    return color2;
  }
  if (!iEl) {
    iEl = createTmp();
  }
  iEl.style.color = color2;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s2) {
    return Number(s2);
  });
  rst = arr2rgb(cArray);
  return rst;
}
var RGB_REG, iEl, toRGB;
var init_torgb = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/torgb.js"() {
    init_lodash();
    init_arr2rgb();
    RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
    toRGB = memoize_default(toRGBString, function(color2) {
      return color2;
    }, 256);
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/gradient.js
function getValue2(start, end2, percent, index2) {
  return start[index2] + (end2[index2] - start[index2]) * percent;
}
function calColor(points, percent) {
  var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 : percent > 1 ? 1 : Number(percent);
  var steps = points.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left = steps * fixedPercent - step;
  var start = points[step];
  var end2 = step === steps ? start : points[step + 1];
  return arr2rgb([getValue2(start, end2, left, 0), getValue2(start, end2, left, 1), getValue2(start, end2, left, 2)]);
}
function gradient(colors) {
  var colorArray = typeof colors === "string" ? colors.split("-") : colors;
  var points = colorArray.map(function(color2) {
    return rgb2arr(color2.indexOf("#") === -1 ? toRGB(color2) : color2);
  });
  return function(percent) {
    return calColor(points, percent);
  };
}
var init_gradient = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/gradient.js"() {
    init_rgb2arr();
    init_arr2rgb();
    init_torgb();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/tocssgradient.js
function isGradientColor(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
}
function toCSSGradient(gradientColor) {
  if (isGradientColor(gradientColor)) {
    var cssColor_1;
    var steps = void 0;
    if (gradientColor[0] === "l") {
      var arr = regexLG.exec(gradientColor);
      var angle = +arr[1] + 90;
      steps = arr[2];
      cssColor_1 = "linear-gradient(" + angle + "deg, ";
    } else if (gradientColor[0] === "r") {
      cssColor_1 = "radial-gradient(";
      var arr = regexRG.exec(gradientColor);
      steps = arr[4];
    }
    var colorStops_1 = steps.match(regexColorStop);
    colorStops_1.forEach(function(item, index2) {
      var itemArr = item.split(":");
      cssColor_1 += itemArr[1] + " " + Number(itemArr[0]) * 100 + "%";
      if (index2 !== colorStops_1.length - 1) {
        cssColor_1 += ", ";
      }
    });
    cssColor_1 += ")";
    return cssColor_1;
  }
  return gradientColor;
}
var regexLG, regexRG, regexColorStop;
var init_tocssgradient = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/tocssgradient.js"() {
    regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
    regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
    regexColorStop = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/color/index.js
var init_color = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/color/index.js"() {
    init_rgb2arr();
    init_gradient();
    init_torgb();
    init_tocssgradient();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/transform.js
function leftTranslate(out, a3, v2) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromTranslation(transMat, v2);
  return mat3_exports.multiply(out, transMat, a3);
}
function leftRotate(out, a3, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromRotation(rotateMat, rad);
  return mat3_exports.multiply(out, rotateMat, a3);
}
function leftScale(out, a3, v2) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromScaling(scaleMat, v2);
  return mat3_exports.multiply(out, scaleMat, a3);
}
function leftMultiply(out, a3, a1) {
  return mat3_exports.multiply(out, a1, a3);
}
function transform6(m3, actions) {
  var matrix = m3 ? [].concat(m3) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0, len = actions.length; i2 < len; i2++) {
    var action = actions[i2];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
      default:
        break;
    }
  }
  return matrix;
}
var init_transform = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/transform.js"() {
    init_esm2();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/direction.js
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
var init_direction = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/direction.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/angle-to.js
function angleTo(v1, v2, direct) {
  var ang = vec2_exports.angle(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
var init_angle_to = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/angle-to.js"() {
    init_esm2();
    init_direction();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/vertical.js
function vertical(out, v2, flag) {
  if (flag) {
    out[0] = v2[1];
    out[1] = -1 * v2[0];
  } else {
    out[0] = -1 * v2[1];
    out[1] = v2[0];
  }
  return out;
}
var init_vertical = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/vertical.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/index.js
var init_matrix = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/matrix/index.js"() {
    init_transform();
    init_angle_to();
    init_direction();
    init_vertical();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/round-path.js
function roundPath(path, round) {
  if (round === "off")
    return [].concat(path);
  var pow = typeof round === "number" && round >= 1 ? Math.pow(10, round) : 1;
  return path.map(function(pi2) {
    var values2 = pi2.slice(1).map(Number).map(function(n2) {
      return round ? Math.round(n2 * pow) / pow : Math.round(n2);
    });
    return [pi2[0]].concat(values2);
  });
}
var init_round_path = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/round-path.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-string.js
function path2String(path, round) {
  if (round === void 0) {
    round = "off";
  }
  return roundPath(path, round).map(function(x4) {
    return x4[0] + x4.slice(1).join(" ");
  }).join("");
}
var init_path_2_string = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-string.js"() {
    init_round_path();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/params-parser.js
var paramsParser;
var init_params_parser = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/params-parser.js"() {
    paramsParser = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      x: 0,
      y: 0,
      qx: null,
      qy: null
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/fix-arc.js
function fixArc(pathArray, allPathCommands, i2) {
  if (pathArray[i2].length > 7) {
    pathArray[i2].shift();
    var pi2 = pathArray[i2];
    var ni2 = i2;
    while (pi2.length) {
      allPathCommands[i2] = "A";
      pathArray.splice(ni2 += 1, 0, ["C"].concat(pi2.splice(0, 6)));
    }
    pathArray.splice(i2, 1);
  }
}
var init_fix_arc = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/fix-arc.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/params-count.js
var paramsCount;
var init_params_count = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/params-count.js"() {
    paramsCount = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-path-array.js
function isPathArray(path) {
  return Array.isArray(path) && path.every(function(seg) {
    var lk = seg[0].toLowerCase();
    return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
  });
}
var init_is_path_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-path-array.js"() {
    init_params_count();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-absolute-array.js
function isAbsoluteArray(path) {
  return isPathArray(path) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
  path.every(function(_a2) {
    var x4 = _a2[0];
    return x4 === x4.toUpperCase();
  });
}
var init_is_absolute_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-absolute-array.js"() {
    init_is_path_array();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-normalized-array.js
function isNormalizedArray(path) {
  return isAbsoluteArray(path) && path.every(function(_a2) {
    var pc = _a2[0];
    return "ACLMQZ".includes(pc);
  });
}
var init_is_normalized_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-normalized-array.js"() {
    init_is_absolute_array();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/finalize-segment.js
function finalizeSegment(path) {
  var pathCommand = path.pathValue[path.segmentStart];
  var LK = pathCommand.toLowerCase();
  var data = path.data;
  while (data.length >= paramsCount[LK]) {
    if (LK === "m" && data.length > 2) {
      path.segments.push([pathCommand].concat(data.splice(0, 2)));
      LK = "l";
      pathCommand = pathCommand === "m" ? "l" : "L";
    } else {
      path.segments.push([pathCommand].concat(data.splice(0, paramsCount[LK])));
    }
    if (!paramsCount[LK]) {
      break;
    }
  }
}
var init_finalize_segment = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/finalize-segment.js"() {
    init_params_count();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-flag.js
function scanFlag(path) {
  var index2 = path.index, pathValue = path.pathValue;
  var code = pathValue.charCodeAt(index2);
  if (code === 48) {
    path.param = 0;
    path.index += 1;
    return;
  }
  if (code === 49) {
    path.param = 1;
    path.index += 1;
    return;
  }
  path.err = '[path-util]: invalid Arc flag "' + pathValue[index2] + '", expecting 0 or 1 at index ' + index2;
}
var init_scan_flag = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-flag.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-digit-start.js
function isDigitStart(code) {
  return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
var init_is_digit_start = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-digit-start.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-param.js
function scanParam(path) {
  var max4 = path.max, pathValue = path.pathValue, start = path.index;
  var index2 = start;
  var zeroFirst = false;
  var hasCeiling = false;
  var hasDecimal = false;
  var hasDot = false;
  var ch;
  if (index2 >= max4) {
    path.err = "[path-util]: Invalid path value at index " + index2 + ', "pathValue" is missing param';
    return;
  }
  ch = pathValue.charCodeAt(index2);
  if (ch === 43 || ch === 45) {
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
  }
  if (!isDigit(ch) && ch !== 46) {
    path.err = "[path-util]: Invalid path value at index " + index2 + ', "' + pathValue[index2] + '" is not a number';
    return;
  }
  if (ch !== 46) {
    zeroFirst = ch === 48;
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
    if (zeroFirst && index2 < max4) {
      if (ch && isDigit(ch)) {
        path.err = "[path-util]: Invalid path value at index " + start + ', "' + pathValue[start] + '" illegal number';
        return;
      }
    }
    while (index2 < max4 && isDigit(pathValue.charCodeAt(index2))) {
      index2 += 1;
      hasCeiling = true;
    }
    ch = pathValue.charCodeAt(index2);
  }
  if (ch === 46) {
    hasDot = true;
    index2 += 1;
    while (isDigit(pathValue.charCodeAt(index2))) {
      index2 += 1;
      hasDecimal = true;
    }
    ch = pathValue.charCodeAt(index2);
  }
  if (ch === 101 || ch === 69) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      path.err = "[path-util]: Invalid path value at index " + index2 + ', "' + pathValue[index2] + '" invalid float exponent';
      return;
    }
    index2 += 1;
    ch = pathValue.charCodeAt(index2);
    if (ch === 43 || ch === 45) {
      index2 += 1;
    }
    if (index2 < max4 && isDigit(pathValue.charCodeAt(index2))) {
      while (index2 < max4 && isDigit(pathValue.charCodeAt(index2))) {
        index2 += 1;
      }
    } else {
      path.err = "[path-util]: Invalid path value at index " + index2 + ', "' + pathValue[index2] + '" invalid integer exponent';
      return;
    }
  }
  path.index = index2;
  path.param = +path.pathValue.slice(start, index2);
}
var init_scan_param = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-param.js"() {
    init_is_digit_start();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-space.js
function isSpace(ch) {
  var specialSpaces = [
    5760,
    6158,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
  // White spaces
  ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && specialSpaces.includes(ch);
}
var init_is_space = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-space.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/skip-spaces.js
function skipSpaces(path) {
  var pathValue = path.pathValue, max4 = path.max;
  while (path.index < max4 && isSpace(pathValue.charCodeAt(path.index))) {
    path.index += 1;
  }
}
var init_skip_spaces = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/skip-spaces.js"() {
    init_is_space();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-path-command.js
function isPathCommand(code) {
  switch (code | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return true;
    default:
      return false;
  }
}
var init_is_path_command = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-path-command.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-arc-command.js
function isArcCommand(code) {
  return (code | 32) === 97;
}
var init_is_arc_command = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/is-arc-command.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-segment.js
function scanSegment(path) {
  var max4 = path.max, pathValue = path.pathValue, index2 = path.index;
  var cmdCode = pathValue.charCodeAt(index2);
  var reqParams = paramsCount[pathValue[index2].toLowerCase()];
  path.segmentStart = index2;
  if (!isPathCommand(cmdCode)) {
    path.err = '[path-util]: Invalid path value "' + pathValue[index2] + '" is not a path command';
    return;
  }
  path.index += 1;
  skipSpaces(path);
  path.data = [];
  if (!reqParams) {
    finalizeSegment(path);
    return;
  }
  for (; ; ) {
    for (var i2 = reqParams; i2 > 0; i2 -= 1) {
      if (isArcCommand(cmdCode) && (i2 === 3 || i2 === 4))
        scanFlag(path);
      else
        scanParam(path);
      if (path.err.length) {
        return;
      }
      path.data.push(path.param);
      skipSpaces(path);
      if (path.index < max4 && pathValue.charCodeAt(path.index) === 44) {
        path.index += 1;
        skipSpaces(path);
      }
    }
    if (path.index >= path.max) {
      break;
    }
    if (!isDigitStart(pathValue.charCodeAt(path.index))) {
      break;
    }
  }
  finalizeSegment(path);
}
var init_scan_segment = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/scan-segment.js"() {
    init_finalize_segment();
    init_params_count();
    init_scan_flag();
    init_scan_param();
    init_skip_spaces();
    init_is_path_command();
    init_is_digit_start();
    init_is_arc_command();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser;
var init_path_parser = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/path-parser.js"() {
    PathParser = /** @class */
    function() {
      function PathParser2(pathString) {
        this.pathValue = pathString;
        this.segments = [];
        this.max = pathString.length;
        this.index = 0;
        this.param = 0;
        this.segmentStart = 0;
        this.data = [];
        this.err = "";
      }
      return PathParser2;
    }();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/parse-path-string.js
function parsePathString2(pathInput) {
  if (isPathArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = new PathParser(pathInput);
  skipSpaces(path);
  while (path.index < path.max && !path.err.length) {
    scanSegment(path);
  }
  return path.err ? path.err : path.segments;
}
var init_parse_path_string = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/parser/parse-path-string.js"() {
    init_is_path_array();
    init_scan_segment();
    init_skip_spaces();
    init_path_parser();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-absolute.js
function path2Absolute(pathInput) {
  if (isAbsoluteArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = parsePathString2(pathInput);
  var x4 = 0;
  var y4 = 0;
  var mx = 0;
  var my = 0;
  return path.map(function(segment) {
    var values2 = segment.slice(1).map(Number);
    var pathCommand = segment[0];
    var absCommand = pathCommand.toUpperCase();
    if (pathCommand === "M") {
      x4 = values2[0], y4 = values2[1];
      mx = x4;
      my = y4;
      return ["M", x4, y4];
    }
    var absoluteSegment;
    if (pathCommand !== absCommand) {
      switch (absCommand) {
        case "A":
          absoluteSegment = [
            absCommand,
            values2[0],
            values2[1],
            values2[2],
            values2[3],
            values2[4],
            values2[5] + x4,
            values2[6] + y4
          ];
          break;
        case "V":
          absoluteSegment = [absCommand, values2[0] + y4];
          break;
        case "H":
          absoluteSegment = [absCommand, values2[0] + x4];
          break;
        default: {
          var absValues = values2.map(function(n2, j2) {
            return n2 + (j2 % 2 ? y4 : x4);
          });
          absoluteSegment = [absCommand].concat(absValues);
        }
      }
    } else {
      absoluteSegment = [absCommand].concat(values2);
    }
    var segLength = absoluteSegment.length;
    switch (absCommand) {
      case "Z":
        x4 = mx;
        y4 = my;
        break;
      case "H":
        x4 = absoluteSegment[1];
        break;
      case "V":
        y4 = absoluteSegment[1];
        break;
      default:
        x4 = absoluteSegment[segLength - 2];
        y4 = absoluteSegment[segLength - 1];
        if (absCommand === "M") {
          mx = x4;
          my = y4;
        }
    }
    return absoluteSegment;
  });
}
var init_path_2_absolute = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-absolute.js"() {
    init_is_absolute_array();
    init_parse_path_string();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/normalize-segment.js
function normalizeSegment(segment, params) {
  var pathCommand = segment[0];
  var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
  var values2 = segment.slice(1).map(Number);
  var result = segment;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  if (pathCommand === "H") {
    result = ["L", segment[1], py1];
  } else if (pathCommand === "V") {
    result = ["L", px1, segment[1]];
  } else if (pathCommand === "S") {
    var x1 = px1 * 2 - px2;
    var y1 = py1 * 2 - py2;
    params.x1 = x1;
    params.y1 = y1;
    result = ["C", x1, y1].concat(values2);
  } else if (pathCommand === "T") {
    var qx = px1 * 2 - params.qx;
    var qy = py1 * 2 - params.qy;
    params.qx = qx;
    params.qy = qy;
    result = ["Q", qx, qy].concat(values2);
  } else if (pathCommand === "Q") {
    var nqx = values2[0], nqy = values2[1];
    params.qx = nqx;
    params.qy = nqy;
  }
  return result;
}
var init_normalize_segment = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/normalize-segment.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/normalize-path.js
function normalizePath(pathInput) {
  if (isNormalizedArray(pathInput)) {
    return [].concat(pathInput);
  }
  var path = path2Absolute(pathInput);
  var params = __assign({}, paramsParser);
  for (var i2 = 0; i2 < path.length; i2 += 1) {
    path[i2] = normalizeSegment(path[i2], params);
    var segment = path[i2];
    var seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  return path;
}
var init_normalize_path = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/normalize-path.js"() {
    init_tslib_es6();
    init_is_normalized_array();
    init_params_parser();
    init_path_2_absolute();
    init_normalize_segment();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-curve-array.js
function isCurveArray(path) {
  return isNormalizedArray(path) && path.every(function(_a2) {
    var pc = _a2[0];
    return "MC".includes(pc);
  });
}
var init_is_curve_array = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-curve-array.js"() {
    init_is_normalized_array();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/rotate-vector.js
function rotateVector(x4, y4, rad) {
  var X2 = x4 * Math.cos(rad) - y4 * Math.sin(rad);
  var Y2 = x4 * Math.sin(rad) + y4 * Math.cos(rad);
  return { x: X2, y: Y2 };
}
var init_rotate_vector = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/rotate-vector.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/arc-2-cubic.js
function arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {
  var x1 = X1;
  var y1 = Y1;
  var rx = RX;
  var ry = RY;
  var x22 = X2;
  var y22 = Y2;
  var d120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  if (!recursive) {
    xy = rotateVector(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotateVector(x22, y22, -rad);
    x22 = xy.x;
    y22 = xy.y;
    var x4 = (x1 - x22) / 2;
    var y4 = (y1 - y22) / 2;
    var h2 = x4 * x4 / (rx * rx) + y4 * y4 / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx *= h2;
      ry *= h2;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k2 = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y4 * y4 - ry2 * x4 * x4) / (rx2 * y4 * y4 + ry2 * x4 * x4)));
    cx = k2 * rx * y4 / ry + (x1 + x22) / 2;
    cy = k2 * -ry * x4 / rx + (y1 + y22) / 2;
    f1 = Math.asin(((y1 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x22 < cx ? Math.PI - f2 : f2;
    if (f1 < 0)
      f1 = Math.PI * 2 + f1;
    if (f2 < 0)
      f2 = Math.PI * 2 + f2;
    if (SF && f1 > f2) {
      f1 -= Math.PI * 2;
    }
    if (!SF && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > d120) {
    var f2old = f2;
    var x2old = x22;
    var y2old = y22;
    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
    x22 = cx + rx * Math.cos(f2);
    y22 = cy + ry * Math.sin(f2);
    res = arcToCubic(x22, y22, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c22 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t2 = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t2;
  var hy = 4 / 3 * ry * t2;
  var m1 = [x1, y1];
  var m22 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x22 + hx * s2, y22 - hy * c22];
  var m4 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return m22.concat(m3, m4, res);
  }
  res = m22.concat(m3, m4, res);
  var newres = [];
  for (var i2 = 0, ii2 = res.length; i2 < ii2; i2 += 1) {
    newres[i2] = i2 % 2 ? rotateVector(res[i2 - 1], res[i2], rad).y : rotateVector(res[i2], res[i2 + 1], rad).x;
  }
  return newres;
}
var init_arc_2_cubic = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/arc-2-cubic.js"() {
    init_rotate_vector();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/quad-2-cubic.js
function quadToCubic(x1, y1, qx, qy, x22, y22) {
  var r13 = 1 / 3;
  var r23 = 2 / 3;
  return [
    r13 * x1 + r23 * qx,
    r13 * y1 + r23 * qy,
    r13 * x22 + r23 * qx,
    r13 * y22 + r23 * qy,
    x22,
    y22
    // x,y
  ];
}
var init_quad_2_cubic = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/quad-2-cubic.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/mid-point.js
function midPoint(a3, b2, t2) {
  var ax = a3[0];
  var ay = a3[1];
  var bx = b2[0];
  var by = b2[1];
  return [ax + (bx - ax) * t2, ay + (by - ay) * t2];
}
var init_mid_point = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/mid-point.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/line-2-cubic.js
var lineToCubic;
var init_line_2_cubic = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/line-2-cubic.js"() {
    init_tslib_es6();
    init_mid_point();
    lineToCubic = function(x1, y1, x22, y22) {
      var t2 = 0.5;
      var mid = midPoint([x1, y1], [x22, y22], t2);
      return __spreadArray(__spreadArray([], mid, true), [x22, y22, x22, y22], false);
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/segment-2-cubic.js
function segmentToCubic(segment, params) {
  var pathCommand = segment[0];
  var values2 = segment.slice(1).map(Number);
  var x4 = values2[0], y4 = values2[1];
  var args;
  var px1 = params.x1, py1 = params.y1, px = params.x, py = params.y;
  if (!"TQ".includes(pathCommand)) {
    params.qx = null;
    params.qy = null;
  }
  switch (pathCommand) {
    case "M":
      params.x = x4;
      params.y = y4;
      return segment;
    case "A":
      args = [px1, py1].concat(values2);
      return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
    case "Q":
      params.qx = x4;
      params.qy = y4;
      args = [px1, py1].concat(values2);
      return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
    case "L":
      return ["C"].concat(lineToCubic(px1, py1, x4, y4));
    case "Z":
      if (px1 === px && py1 === py) {
        return ["C", px1, py1, px, py, px, py];
      }
      return ["C"].concat(lineToCubic(px1, py1, px, py));
    default:
  }
  return segment;
}
var init_segment_2_cubic = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/segment-2-cubic.js"() {
    init_arc_2_cubic();
    init_quad_2_cubic();
    init_line_2_cubic();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-curve.js
function path2Curve(pathInput, needZCommandIndexes) {
  if (needZCommandIndexes === void 0) {
    needZCommandIndexes = false;
  }
  if (isCurveArray(pathInput)) {
    var cloned = [].concat(pathInput);
    if (needZCommandIndexes) {
      return [cloned, []];
    } else {
      return cloned;
    }
  }
  var path = normalizePath(pathInput);
  var params = __assign({}, paramsParser);
  var allPathCommands = [];
  var pathCommand = "";
  var ii2 = path.length;
  var segment;
  var seglen;
  var zCommandIndexes = [];
  for (var i2 = 0; i2 < ii2; i2 += 1) {
    if (path[i2])
      pathCommand = path[i2][0];
    allPathCommands[i2] = pathCommand;
    var curveSegment = segmentToCubic(path[i2], params);
    path[i2] = curveSegment;
    fixArc(path, allPathCommands, i2);
    ii2 = path.length;
    if (pathCommand === "Z") {
      zCommandIndexes.push(i2);
    }
    segment = path[i2];
    seglen = segment.length;
    params.x1 = +segment[seglen - 2];
    params.y1 = +segment[seglen - 1];
    params.x2 = +segment[seglen - 4] || params.x1;
    params.y2 = +segment[seglen - 3] || params.y1;
  }
  if (needZCommandIndexes) {
    return [path, zCommandIndexes];
  } else {
    return path;
  }
}
var init_path_2_curve = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/convert/path-2-curve.js"() {
    init_tslib_es6();
    init_params_parser();
    init_fix_arc();
    init_normalize_path();
    init_is_curve_array();
    init_segment_2_cubic();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/clone-path.js
function clonePath(path) {
  return path.map(function(x4) {
    return Array.isArray(x4) ? [].concat(x4) : x4;
  });
}
var init_clone_path = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/clone-path.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/reverse-curve.js
function reverseCurve(pathArray) {
  var rotatedCurve = pathArray.slice(1).map(function(x4, i2, curveOnly) {
    return !i2 ? pathArray[0].slice(1).concat(x4.slice(1)) : curveOnly[i2 - 1].slice(-2).concat(x4.slice(1));
  }).map(function(x4) {
    return x4.map(function(y4, i2) {
      return x4[x4.length - i2 - 2 * (1 - i2 % 2)];
    });
  }).reverse();
  return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x4) {
    return ["C"].concat(x4.slice(2));
  }));
}
var init_reverse_curve = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/process/reverse-curve.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/distance-square-root.js
function distanceSquareRoot(a3, b2) {
  return Math.sqrt((a3[0] - b2[0]) * (a3[0] - b2[0]) + (a3[1] - b2[1]) * (a3[1] - b2[1]));
}
var init_distance_square_root = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/distance-square-root.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-line-factory.js
function segmentLineFactory(x1, y1, x22, y22, distance6) {
  var length = distanceSquareRoot([x1, y1], [x22, y22]);
  var point = { x: 0, y: 0 };
  if (typeof distance6 === "number") {
    if (distance6 <= 0) {
      point = { x: x1, y: y1 };
    } else if (distance6 >= length) {
      point = { x: x22, y: y22 };
    } else {
      var _a2 = midPoint([x1, y1], [x22, y22], distance6 / length), x4 = _a2[0], y4 = _a2[1];
      point = { x: x4, y: y4 };
    }
  }
  return {
    length,
    point,
    min: {
      x: Math.min(x1, x22),
      y: Math.min(y1, y22)
    },
    max: {
      x: Math.max(x1, x22),
      y: Math.max(y1, y22)
    }
  };
}
var init_segment_line_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-line-factory.js"() {
    init_mid_point();
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-arc-factory.js
function angleBetween(v0, v1) {
  var v0x = v0.x, v0y = v0.y;
  var v1x = v1.x, v1y = v1.y;
  var p2 = v0x * v1x + v0y * v1y;
  var n2 = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
  var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
  var angle = sign * Math.acos(p2 / n2);
  return angle;
}
function getPointAtArcSegmentLength(x1, y1, RX, RY, angle, LAF, SF, x4, y4, t2) {
  var abs3 = Math.abs, sin2 = Math.sin, cos2 = Math.cos, sqrt = Math.sqrt, PI2 = Math.PI;
  var rx = abs3(RX);
  var ry = abs3(RY);
  var xRot = (angle % 360 + 360) % 360;
  var xRotRad = xRot * (PI2 / 180);
  if (x1 === x4 && y1 === y4) {
    return { x: x1, y: y1 };
  }
  if (rx === 0 || ry === 0) {
    return segmentLineFactory(x1, y1, x4, y4, t2).point;
  }
  var dx = (x1 - x4) / 2;
  var dy = (y1 - y4) / 2;
  var transformedPoint = {
    x: cos2(xRotRad) * dx + sin2(xRotRad) * dy,
    y: -sin2(xRotRad) * dx + cos2(xRotRad) * dy
  };
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx *= sqrt(radiiCheck);
    ry *= sqrt(radiiCheck);
  }
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  var center = {
    x: cos2(xRotRad) * transformedCenter.x - sin2(xRotRad) * transformedCenter.y + (x1 + x4) / 2,
    y: sin2(xRotRad) * transformedCenter.x + cos2(xRotRad) * transformedCenter.y + (y1 + y4) / 2
  };
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!SF && sweepAngle > 0) {
    sweepAngle -= 2 * PI2;
  } else if (SF && sweepAngle < 0) {
    sweepAngle += 2 * PI2;
  }
  sweepAngle %= 2 * PI2;
  var alpha = startAngle + sweepAngle * t2;
  var ellipseComponentX = rx * cos2(alpha);
  var ellipseComponentY = ry * sin2(alpha);
  var point = {
    x: cos2(xRotRad) * ellipseComponentX - sin2(xRotRad) * ellipseComponentY + center.x,
    y: sin2(xRotRad) * ellipseComponentX + cos2(xRotRad) * ellipseComponentY + center.y
  };
  return point;
}
function segmentArcFactory(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, distance6, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x4 = X1;
  var y4 = Y1;
  var LENGTH = 0;
  var prev = [x4, y4, LENGTH];
  var cur = [x4, y4];
  var t2 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x4, y: y4 }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x: x4, y: y4 };
  }
  for (var j2 = 0; j2 <= sampleSize; j2 += 1) {
    t2 = j2 / sampleSize;
    _a2 = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, t2), x4 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x4, y: y4 });
    }
    if (length) {
      LENGTH += distanceSquareRoot(cur, [x4, y4]);
    }
    cur = [x4, y4];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x4, y4, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: X2, y: Y2 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
var init_segment_arc_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-arc-factory.js"() {
    init_segment_line_factory();
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x22, y22, t2) {
  var t1 = 1 - t2;
  return {
    x: Math.pow(t1, 3) * x1 + 3 * Math.pow(t1, 2) * t2 * c1x + 3 * t1 * Math.pow(t2, 2) * c2x + Math.pow(t2, 3) * x22,
    y: Math.pow(t1, 3) * y1 + 3 * Math.pow(t1, 2) * t2 * c1y + 3 * t1 * Math.pow(t2, 2) * c2y + Math.pow(t2, 3) * y22
  };
}
function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x22, y22, distance6, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x4 = x1;
  var y4 = y1;
  var LENGTH = 0;
  var prev = [x4, y4, LENGTH];
  var cur = [x4, y4];
  var t2 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x4, y: y4 }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x: x4, y: y4 };
  }
  for (var j2 = 0; j2 <= sampleSize; j2 += 1) {
    t2 = j2 / sampleSize;
    _a2 = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x22, y22, t2), x4 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x4, y: y4 });
    }
    if (length) {
      LENGTH += distanceSquareRoot(cur, [x4, y4]);
    }
    cur = [x4, y4];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x4, y4, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
var init_segment_cubic_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-cubic-factory.js"() {
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-quad-factory.js
function getPointAtQuadSegmentLength(x1, y1, cx, cy, x22, y22, t2) {
  var t1 = 1 - t2;
  return {
    x: Math.pow(t1, 2) * x1 + 2 * t1 * t2 * cx + Math.pow(t2, 2) * x22,
    y: Math.pow(t1, 2) * y1 + 2 * t1 * t2 * cy + Math.pow(t2, 2) * y22
  };
}
function segmentQuadFactory(x1, y1, qx, qy, x22, y22, distance6, options) {
  var _a2;
  var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
  var distanceIsNumber = typeof distance6 === "number";
  var x4 = x1;
  var y4 = y1;
  var LENGTH = 0;
  var prev = [x4, y4, LENGTH];
  var cur = [x4, y4];
  var t2 = 0;
  var POINT = { x: 0, y: 0 };
  var POINTS = [{ x: x4, y: y4 }];
  if (distanceIsNumber && distance6 <= 0) {
    POINT = { x: x4, y: y4 };
  }
  for (var j2 = 0; j2 <= sampleSize; j2 += 1) {
    t2 = j2 / sampleSize;
    _a2 = getPointAtQuadSegmentLength(x1, y1, qx, qy, x22, y22, t2), x4 = _a2.x, y4 = _a2.y;
    if (bbox) {
      POINTS.push({ x: x4, y: y4 });
    }
    if (length) {
      LENGTH += distanceSquareRoot(cur, [x4, y4]);
    }
    cur = [x4, y4];
    if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
      var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
      POINT = {
        x: cur[0] * (1 - dv) + prev[0] * dv,
        y: cur[1] * (1 - dv) + prev[1] * dv
      };
    }
    prev = [x4, y4, LENGTH];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x22, y: y22 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, POINTS.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
var init_segment_quad_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/segment-quad-factory.js"() {
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/path-length-factory.js
function pathLengthFactory(pathInput, distance6, options) {
  var _a2, _b, _c, _d, _e2, _f;
  var path = normalizePath(pathInput);
  var distanceIsNumber = typeof distance6 === "number";
  var isM;
  var data = [];
  var pathCommand;
  var x4 = 0;
  var y4 = 0;
  var mx = 0;
  var my = 0;
  var seg;
  var MIN = [];
  var MAX = [];
  var length = 0;
  var min3 = { x: 0, y: 0 };
  var max4 = min3;
  var point = min3;
  var POINT = min3;
  var LENGTH = 0;
  for (var i2 = 0, ll = path.length; i2 < ll; i2 += 1) {
    seg = path[i2];
    pathCommand = seg[0];
    isM = pathCommand === "M";
    data = !isM ? [x4, y4].concat(seg.slice(1)) : data;
    if (isM) {
      mx = seg[1], my = seg[2];
      min3 = { x: mx, y: my };
      max4 = min3;
      length = 0;
      if (distanceIsNumber && distance6 < 1e-3) {
        POINT = min3;
      }
    } else if (pathCommand === "L") {
      _a2 = segmentLineFactory(data[0], data[1], data[2], data[3], (distance6 || 0) - LENGTH), length = _a2.length, min3 = _a2.min, max4 = _a2.max, point = _a2.point;
    } else if (pathCommand === "A") {
      _b = segmentArcFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], (distance6 || 0) - LENGTH, options || {}), length = _b.length, min3 = _b.min, max4 = _b.max, point = _b.point;
    } else if (pathCommand === "C") {
      _c = segmentCubicFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], (distance6 || 0) - LENGTH, options || {}), length = _c.length, min3 = _c.min, max4 = _c.max, point = _c.point;
    } else if (pathCommand === "Q") {
      _d = segmentQuadFactory(data[0], data[1], data[2], data[3], data[4], data[5], (distance6 || 0) - LENGTH, options || {}), length = _d.length, min3 = _d.min, max4 = _d.max, point = _d.point;
    } else if (pathCommand === "Z") {
      data = [x4, y4, mx, my];
      _e2 = segmentLineFactory(data[0], data[1], data[2], data[3], (distance6 || 0) - LENGTH), length = _e2.length, min3 = _e2.min, max4 = _e2.max, point = _e2.point;
    }
    if (distanceIsNumber && LENGTH < distance6 && LENGTH + length >= distance6) {
      POINT = point;
    }
    MAX.push(max4);
    MIN.push(min3);
    LENGTH += length;
    _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x4 = _f[0], y4 = _f[1];
  }
  if (distanceIsNumber && distance6 >= LENGTH) {
    POINT = { x: x4, y: y4 };
  }
  return {
    length: LENGTH,
    point: POINT,
    min: {
      x: Math.min.apply(null, MIN.map(function(n2) {
        return n2.x;
      })),
      y: Math.min.apply(null, MIN.map(function(n2) {
        return n2.y;
      }))
    },
    max: {
      x: Math.max.apply(null, MAX.map(function(n2) {
        return n2.x;
      })),
      y: Math.max.apply(null, MAX.map(function(n2) {
        return n2.y;
      }))
    }
  };
}
var init_path_length_factory = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/path-length-factory.js"() {
    init_normalize_path();
    init_segment_line_factory();
    init_segment_arc_factory();
    init_segment_cubic_factory();
    init_segment_quad_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-bbox.js
function getPathBBox(path, options) {
  if (!path) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      x2: 0,
      y2: 0,
      cx: 0,
      cy: 0,
      cz: 0
    };
  }
  var _a2 = pathLengthFactory(path, void 0, __assign(__assign({}, options), { length: false })), _b = _a2.min, xMin = _b.x, yMin = _b.y, _c = _a2.max, xMax = _c.x, yMax = _c.y;
  var width = xMax - xMin;
  var height = yMax - yMin;
  return {
    width,
    height,
    x: xMin,
    y: yMin,
    x2: xMax,
    y2: yMax,
    cx: xMin + width / 2,
    cy: yMin + height / 2,
    // an estimted guess
    cz: Math.max(width, height) + Math.min(width, height) / 2
  };
}
var init_get_path_bbox = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-bbox.js"() {
    init_tslib_es6();
    init_path_length_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-total-length.js
function getTotalLength(pathInput, options) {
  return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
}
var init_get_total_length = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-total-length.js"() {
    init_tslib_es6();
    init_path_length_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-bbox-total-length.js
function getPathBBoxTotalLength(path, options) {
  if (!path) {
    return {
      length: 0,
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      x2: 0,
      y2: 0,
      cx: 0,
      cy: 0,
      cz: 0
    };
  }
  var _a2 = pathLengthFactory(path, void 0, __assign(__assign({}, options), { bbox: true, length: true })), length = _a2.length, _b = _a2.min, xMin = _b.x, yMin = _b.y, _c = _a2.max, xMax = _c.x, yMax = _c.y;
  var width = xMax - xMin;
  var height = yMax - yMin;
  return {
    length,
    width,
    height,
    x: xMin,
    y: yMin,
    x2: xMax,
    y2: yMax,
    cx: xMin + width / 2,
    cy: yMin + height / 2,
    // an estimted guess
    cz: Math.max(width, height) + Math.min(width, height) / 2
  };
}
var init_get_path_bbox_total_length = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-bbox-total-length.js"() {
    init_tslib_es6();
    init_path_length_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-rotated-curve.js
function getRotations(a3) {
  var segCount = a3.length;
  var pointCount = segCount - 1;
  return a3.map(function(f2, idx) {
    return a3.map(function(p2, i2) {
      var oldSegIdx = idx + i2;
      var seg;
      if (i2 === 0 || a3[oldSegIdx] && a3[oldSegIdx][0] === "M") {
        seg = a3[oldSegIdx];
        return ["M"].concat(seg.slice(-2));
      }
      if (oldSegIdx >= segCount)
        oldSegIdx -= pointCount;
      return a3[oldSegIdx];
    });
  });
}
function getRotatedCurve(a3, b2) {
  var segCount = a3.length - 1;
  var lineLengths = [];
  var computedIndex = 0;
  var sumLensSqrd = 0;
  var rotations = getRotations(a3);
  rotations.forEach(function(r2, i2) {
    a3.slice(1).forEach(function(s2, j2) {
      sumLensSqrd += distanceSquareRoot(a3[(i2 + j2) % segCount].slice(-2), b2[j2 % segCount].slice(-2));
    });
    lineLengths[i2] = sumLensSqrd;
    sumLensSqrd = 0;
  });
  computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
  return rotations[computedIndex];
}
var init_get_rotated_curve = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-rotated-curve.js"() {
    init_distance_square_root();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-area.js
function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x22, y22) {
  return 3 * ((y22 - y1) * (c1x + c2x) - (x22 - x1) * (c1y + c2y) + c1y * (x1 - c2x) - c1x * (y1 - c2y) + y22 * (c2x + x1 / 3) - x22 * (c2y + y1 / 3)) / 20;
}
function getPathArea(path) {
  var x4 = 0;
  var y4 = 0;
  var len = 0;
  return path2Curve(path).map(function(seg) {
    var _a2;
    switch (seg[0]) {
      case "M":
        x4 = seg[1], y4 = seg[2];
        return 0;
      default:
        var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
        len = getCubicSegArea(x4, y4, c1x, c1y, c2x, c2y, x22, y22);
        _a2 = seg.slice(-2), x4 = _a2[0], y4 = _a2[1];
        return len;
    }
  }).reduce(function(a3, b2) {
    return a3 + b2;
  }, 0);
}
var init_get_path_area = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-path-area.js"() {
    init_path_2_curve();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-draw-direction.js
function getDrawDirection(pathArray) {
  return getPathArea(pathArray) >= 0;
}
var init_get_draw_direction = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-draw-direction.js"() {
    init_get_path_area();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-point-at-length.js
function getPointAtLength(pathInput, distance6, options) {
  return pathLengthFactory(pathInput, distance6, __assign(__assign({}, options), { bbox: false, length: true })).point;
}
var init_get_point_at_length = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-point-at-length.js"() {
    init_tslib_es6();
    init_path_length_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-properties-at-length.js
function getPropertiesAtLength(pathInput, distance6) {
  var pathArray = parsePathString2(pathInput);
  if (typeof pathArray === "string") {
    throw TypeError(pathArray);
  }
  var pathTemp = pathArray.slice();
  var pathLength = getTotalLength(pathTemp);
  var index2 = pathTemp.length - 1;
  var lengthAtSegment = 0;
  var length = 0;
  var segment = pathArray[0];
  var _a2 = segment.slice(-2), x4 = _a2[0], y4 = _a2[1];
  var point = { x: x4, y: y4 };
  if (index2 <= 0 || !distance6 || !Number.isFinite(distance6)) {
    return {
      segment,
      index: 0,
      length,
      point,
      lengthAtSegment
    };
  }
  if (distance6 >= pathLength) {
    pathTemp = pathArray.slice(0, -1);
    lengthAtSegment = getTotalLength(pathTemp);
    length = pathLength - lengthAtSegment;
    return {
      segment: pathArray[index2],
      index: index2,
      length,
      lengthAtSegment
    };
  }
  var segments = [];
  while (index2 > 0) {
    segment = pathTemp[index2];
    pathTemp = pathTemp.slice(0, -1);
    lengthAtSegment = getTotalLength(pathTemp);
    length = pathLength - lengthAtSegment;
    pathLength = lengthAtSegment;
    segments.push({
      segment,
      index: index2,
      length,
      lengthAtSegment
    });
    index2 -= 1;
  }
  return segments.find(function(_a3) {
    var l2 = _a3.lengthAtSegment;
    return l2 <= distance6;
  });
}
var init_get_properties_at_length = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-properties-at-length.js"() {
    init_parse_path_string();
    init_get_total_length();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-properties-at-point.js
function getPropertiesAtPoint(pathInput, point) {
  var path = parsePathString2(pathInput);
  var normalPath = normalizePath(path);
  var pathLength = getTotalLength(path);
  var distanceTo = function(p2) {
    var dx = p2.x - point.x;
    var dy = p2.y - point.y;
    return dx * dx + dy * dy;
  };
  var precision = 8;
  var scan;
  var scanDistance = 0;
  var closest;
  var bestLength = 0;
  var bestDistance = Infinity;
  for (var scanLength = 0; scanLength <= pathLength; scanLength += precision) {
    scan = getPointAtLength(normalPath, scanLength);
    scanDistance = distanceTo(scan);
    if (scanDistance < bestDistance) {
      closest = scan;
      bestLength = scanLength;
      bestDistance = scanDistance;
    }
  }
  precision /= 2;
  var before;
  var after;
  var beforeLength = 0;
  var afterLength = 0;
  var beforeDistance = 0;
  var afterDistance = 0;
  while (precision > 0.5) {
    beforeLength = bestLength - precision;
    before = getPointAtLength(normalPath, beforeLength);
    beforeDistance = distanceTo(before);
    afterLength = bestLength + precision;
    after = getPointAtLength(normalPath, afterLength);
    afterDistance = distanceTo(after);
    if (beforeLength >= 0 && beforeDistance < bestDistance) {
      closest = before;
      bestLength = beforeLength;
      bestDistance = beforeDistance;
    } else if (afterLength <= pathLength && afterDistance < bestDistance) {
      closest = after;
      bestLength = afterLength;
      bestDistance = afterDistance;
    } else {
      precision /= 2;
    }
  }
  var segment = getPropertiesAtLength(path, bestLength);
  var distance6 = Math.sqrt(bestDistance);
  return { closest, distance: distance6, segment };
}
var init_get_properties_at_point = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/get-properties-at-point.js"() {
    init_parse_path_string();
    init_normalize_path();
    init_get_point_at_length();
    init_get_properties_at_length();
    init_get_total_length();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-point-in-stroke.js
function isPointInStroke(pathInput, point) {
  var distance6 = getPropertiesAtPoint(pathInput, point).distance;
  return Math.abs(distance6) < 1e-3;
}
var init_is_point_in_stroke = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/is-point-in-stroke.js"() {
    init_get_properties_at_point();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/equalize-segments.js
function splitCubic(pts, t2) {
  if (t2 === void 0) {
    t2 = 0.5;
  }
  var p0 = pts.slice(0, 2);
  var p1 = pts.slice(2, 4);
  var p2 = pts.slice(4, 6);
  var p3 = pts.slice(6, 8);
  var p4 = midPoint(p0, p1, t2);
  var p5 = midPoint(p1, p2, t2);
  var p6 = midPoint(p2, p3, t2);
  var p7 = midPoint(p4, p5, t2);
  var p8 = midPoint(p5, p6, t2);
  var p9 = midPoint(p7, p8, t2);
  return [
    // @ts-ignore
    ["C"].concat(p4, p7, p9),
    // @ts-ignore
    ["C"].concat(p8, p6, p3)
  ];
}
function getCurveArray(segments) {
  return segments.map(function(segment, i2, pathArray) {
    var segmentData = i2 && pathArray[i2 - 1].slice(-2).concat(segment.slice(1));
    var curveLength = i2 ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
    var subsegs;
    if (i2) {
      subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
    } else {
      subsegs = [segment];
    }
    return {
      s: segment,
      ss: subsegs,
      l: curveLength
    };
  });
}
function equalizeSegments(path1, path2, TL) {
  var c1 = getCurveArray(path1);
  var c22 = getCurveArray(path2);
  var L1 = c1.length;
  var L2 = c22.length;
  var l1 = c1.filter(function(x4) {
    return x4.l;
  }).length;
  var l2 = c22.filter(function(x4) {
    return x4.l;
  }).length;
  var m1 = c1.filter(function(x4) {
    return x4.l;
  }).reduce(function(a3, _a2) {
    var l3 = _a2.l;
    return a3 + l3;
  }, 0) / l1 || 0;
  var m22 = c22.filter(function(x4) {
    return x4.l;
  }).reduce(function(a3, _a2) {
    var l3 = _a2.l;
    return a3 + l3;
  }, 0) / l2 || 0;
  var tl = TL || Math.max(L1, L2);
  var mm = [m1, m22];
  var dif = [tl - L1, tl - L2];
  var canSplit = 0;
  var result = [c1, c22].map(function(x4, i2) {
    return x4.l === tl ? x4.map(function(y4) {
      return y4.s;
    }) : x4.map(function(y4, j2) {
      canSplit = j2 && dif[i2] && y4.l >= mm[i2];
      dif[i2] -= canSplit ? 1 : 0;
      return canSplit ? y4.ss : [y4.s];
    }).flat();
  });
  return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
}
var init_equalize_segments = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/util/equalize-segments.js"() {
    init_mid_point();
    init_segment_cubic_factory();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/types.js
var init_types = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/types.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/path/index.js
var init_path = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/path/index.js"() {
    init_path_2_string();
    init_path_2_curve();
    init_path_2_absolute();
    init_clone_path();
    init_normalize_path();
    init_reverse_curve();
    init_arc_2_cubic();
    init_get_path_bbox();
    init_get_total_length();
    init_get_path_bbox_total_length();
    init_get_rotated_curve();
    init_get_path_area();
    init_get_draw_direction();
    init_get_point_at_length();
    init_is_point_in_stroke();
    init_distance_square_root();
    init_equalize_segments();
    init_types();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/math/is-point-in-polygon.js
function dcmp(x4) {
  if (Math.abs(x4) < tolerance) {
    return 0;
  }
  return x4 < 0 ? -1 : 1;
}
function onSegment2(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isPointInPolygon3(points, x4, y4) {
  var isHit = false;
  var n2 = points.length;
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p2 = points[(i2 + 1) % n2];
    if (onSegment2(p1, p2, [x4, y4])) {
      return true;
    }
    if (dcmp(p1[1] - y4) > 0 !== dcmp(p2[1] - y4) > 0 && dcmp(x4 - (y4 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
var tolerance;
var init_is_point_in_polygon = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/math/is-point-in-polygon.js"() {
    tolerance = 1e-6;
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/math/is-polygons-intersect.js
function getLineIntersect3(p0, p1, p2, p3) {
  var tolerance2 = 1e-3;
  var E2 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point = null;
  if (sqrKross > tolerance2 * sqrLen0 * sqrLen1) {
    var s2 = (E2.x * D1.y - E2.y * D1.x) / kross;
    var t2 = (E2.x * D0.y - E2.y * D0.x) / kross;
    if (isBetween3(s2, 0, 1) && isBetween3(t2, 0, 1)) {
      point = {
        x: p0.x + s2 * D0.x,
        y: p0.y + s2 * D0.y
      };
    }
  }
  return point;
}
function parseToLines(points) {
  var lines = [];
  var count = points.length;
  for (var i2 = 0; i2 < count - 1; i2++) {
    var point = points[i2];
    var next = points[i2 + 1];
    lines.push({
      from: {
        x: point[0],
        y: point[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }
  if (lines.length > 1) {
    var first = points[0];
    var last2 = points[count - 1];
    lines.push({
      from: {
        x: last2[0],
        y: last2[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }
  return lines;
}
function lineIntersectPolygon3(lines, line) {
  var isIntersect = false;
  lines.forEach(function(l2) {
    if (getLineIntersect3(l2.from, l2.to, line.from, line.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getBBox4(points) {
  var xArr = points.map(function(p2) {
    return p2[0];
  });
  var yArr = points.map(function(p2) {
    return p2[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}
function intersectBBox3(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect3(points1, points2) {
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox4(points1);
  var bbox2 = getBBox4(points2);
  if (!intersectBBox3(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  points2.forEach(function(point) {
    if (isPointInPolygon3(points1, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  points1.forEach(function(point) {
    if (isPointInPolygon3(points2, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  lines2.forEach(function(line) {
    if (lineIntersectPolygon3(lines1, line)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
var isBetween3;
var init_is_polygons_intersect = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/math/is-polygons-intersect.js"() {
    init_is_point_in_polygon();
    isBetween3 = function(value, min3, max4) {
      return value >= min3 && value <= max4;
    };
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/math/index.js
var init_math = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/math/index.js"() {
    init_is_point_in_polygon();
    init_is_polygons_intersect();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/dom/create-dom.js
function createDOM(str) {
  var container = document.createElement("div");
  container.innerHTML = str;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}
var init_create_dom = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/dom/create-dom.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/dom/modify-css.js
function modifyCSS2(dom, css) {
  if (!dom)
    return;
  Object.keys(css).forEach(function(key) {
    dom.style[key] = css[key];
  });
  return dom;
}
var init_modify_css = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/dom/modify-css.js"() {
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/dom/index.js
var init_dom = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/dom/index.js"() {
    init_create_dom();
    init_modify_css();
  }
});

// node_modules/@antv/layout/node_modules/@antv/util/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  Cache: () => cache_default,
  angleTo: () => angleTo,
  arcToCubic: () => arcToCubic,
  assign: () => mix2,
  augment: () => augment_default,
  clamp: () => clamp_default,
  clearAnimationFrame: () => cancelAnimationFrame2,
  clone: () => clone_default2,
  clonePath: () => clonePath,
  contains: () => contains_default,
  createDOM: () => createDOM,
  debounce: () => debounce_default2,
  deepMix: () => deep_mix_default2,
  difference: () => difference_default,
  direction: () => direction,
  distanceSquareRoot: () => distanceSquareRoot,
  each: () => each_default2,
  endsWith: () => ends_with_default,
  equalizeSegments: () => equalizeSegments,
  every: () => every_default,
  extend: () => extend_default,
  filter: () => filter_default,
  find: () => find_default2,
  findIndex: () => find_index_default,
  firstValue: () => first_value_default,
  fixedBase: () => fixed_base_default,
  flatten: () => flatten_default,
  flattenDeep: () => flatten_deep_default,
  forIn: () => for_in_default,
  get: () => get_default2,
  getDrawDirection: () => getDrawDirection,
  getPathArea: () => getPathArea,
  getPathBBox: () => getPathBBox,
  getPathBBoxTotalLength: () => getPathBBoxTotalLength,
  getPointAtLength: () => getPointAtLength,
  getRange: () => get_range_default,
  getRotatedCurve: () => getRotatedCurve,
  getTotalLength: () => getTotalLength,
  getType: () => get_type_default,
  getWrapBehavior: () => get_wrap_behavior_default,
  gradient: () => gradient,
  group: () => group_default,
  groupBy: () => group_by_default2,
  groupToMap: () => groupToMap,
  has: () => has_default,
  hasKey: () => has_key_default,
  hasValue: () => has_value_default,
  head: () => head2,
  identity: () => identity_default,
  includes: () => contains_default,
  indexOf: () => index_of_default,
  isArguments: () => is_arguments_default,
  isArray: () => is_array_default2,
  isArrayLike: () => is_array_like_default,
  isBoolean: () => is_boolean_default2,
  isDate: () => is_date_default,
  isDecimal: () => is_decimal_default,
  isElement: () => is_element_default,
  isEmpty: () => is_empty_default,
  isEqual: () => is_equal_default2,
  isEqualWith: () => is_equal_with_default,
  isError: () => is_error_default,
  isEven: () => is_even_default,
  isFinite: () => is_finite_default,
  isFunction: () => is_function_default2,
  isInteger: () => is_integer_default,
  isMatch: () => is_match_default,
  isNegative: () => is_negative_default,
  isNil: () => is_nil_default2,
  isNull: () => is_null_default,
  isNumber: () => is_number_default2,
  isNumberEqual: () => isNumberEqual,
  isObject: () => is_object_default2,
  isObjectLike: () => is_object_like_default,
  isOdd: () => is_odd_default,
  isPlainObject: () => is_plain_object_default2,
  isPointInPolygon: () => isPointInPolygon3,
  isPointInStroke: () => isPointInStroke,
  isPolygonsIntersect: () => isPolygonsIntersect3,
  isPositive: () => is_positive_default,
  isPrototype: () => is_prototype_default,
  isRegExp: () => is_reg_exp_default,
  isString: () => is_string_default2,
  isType: () => is_type_default,
  isUndefined: () => is_undefined_default,
  keys: () => keys_default,
  last: () => last,
  lowerCase: () => lower_case_default,
  lowerFirst: () => lower_first_default,
  map: () => map_default2,
  mapValues: () => map_values_default,
  max: () => max_default,
  maxBy: () => max_by_default,
  memoize: () => memoize_default,
  min: () => min_default,
  minBy: () => min_by_default,
  mix: () => mix2,
  mod: () => mod_default,
  modifyCSS: () => modifyCSS2,
  noop: () => noop_default,
  normalizePath: () => normalizePath,
  number2color: () => number2color_default,
  omit: () => omit_default,
  parseRadius: () => parse_radius_default,
  path2Absolute: () => path2Absolute,
  path2Curve: () => path2Curve,
  path2String: () => path2String,
  pick: () => pick_default,
  pull: () => pull_default,
  pullAt: () => pull_at_default,
  reduce: () => reduce_default,
  remove: () => remove_default2,
  requestAnimationFrame: () => requestAnimationFrame2,
  reverseCurve: () => reverseCurve,
  rgb2arr: () => rgb2arr,
  set: () => set_default,
  size: () => size2,
  some: () => some_default,
  sortBy: () => sort_by_default,
  startsWith: () => starts_with_default,
  substitute: () => substitute_default,
  throttle: () => throttle_default2,
  toArray: () => to_array_default,
  toCSSGradient: () => toCSSGradient,
  toDegree: () => to_degree_default,
  toInteger: () => to_integer_default,
  toRGB: () => toRGB,
  toRadian: () => to_radian_default,
  toString: () => to_string_default,
  transform: () => transform6,
  union: () => union_default,
  uniq: () => uniq2,
  uniqueId: () => unique_id_default2,
  upperCase: () => upper_case_default,
  upperFirst: () => upper_first_default2,
  values: () => values_default,
  valuesOfKey: () => values_of_key_default,
  vertical: () => vertical,
  wrapBehavior: () => wrap_behavior_default2
});
var init_esm3 = __esm({
  "node_modules/@antv/layout/node_modules/@antv/util/esm/index.js"() {
    init_color();
    init_matrix();
    init_path();
    init_lodash();
    init_math();
    init_dom();
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/init-order.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var initOrder = function(g2) {
      var visited = {};
      var simpleNodes = g2.nodes().filter(function(v2) {
        var _a2;
        return !((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length);
      });
      var nodeRanks = simpleNodes.map(function(v2) {
        return g2.node(v2).rank;
      });
      var maxRank = (0, util_1.max)(nodeRanks);
      var layers = [];
      for (var i2 = 0; i2 < maxRank + 1; i2++) {
        layers.push([]);
      }
      var dfs3 = function(v2) {
        var _a2;
        if (visited.hasOwnProperty(v2))
          return;
        visited[v2] = true;
        var node = g2.node(v2);
        if (!isNaN(node.rank)) {
          layers[node.rank].push(v2);
        }
        (_a2 = g2.successors(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          return dfs3(child);
        });
      };
      var orderedVs = simpleNodes.sort(function(a3, b2) {
        return g2.node(a3).rank - g2.node(b2).rank;
      });
      var beforeSort = orderedVs.filter(function(n2) {
        return g2.node(n2).fixorder !== void 0;
      });
      var fixOrderNodes = beforeSort.sort(function(a3, b2) {
        return g2.node(a3).fixorder - g2.node(b2).fixorder;
      });
      fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach(function(n2) {
        if (!isNaN(g2.node(n2).rank)) {
          layers[g2.node(n2).rank].push(n2);
        }
        visited[n2] = true;
      });
      orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach(dfs3);
      return layers;
    };
    exports.default = initOrder;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/cross-count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var twoLayerCrossCount = function(g2, northLayer, southLayer) {
      var southPos = (0, util_1.zipObject)(southLayer, southLayer.map(function(v2, i2) {
        return i2;
      }));
      var unflat = northLayer.map(function(v2) {
        var _a2;
        var unsort = (_a2 = g2.outEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.map(function(e8) {
          return { pos: southPos[e8.w] || 0, weight: g2.edge(e8).weight };
        });
        return unsort === null || unsort === void 0 ? void 0 : unsort.sort(function(a3, b2) {
          return a3.pos - b2.pos;
        });
      });
      var southEntries = unflat.flat().filter(function(entry) {
        return entry !== void 0;
      });
      var firstIndex = 1;
      while (firstIndex < southLayer.length)
        firstIndex <<= 1;
      var treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      var tree = Array(treeSize).fill(0, 0, treeSize);
      var cc2 = 0;
      southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach(function(entry) {
        if (entry) {
          var index2 = entry.pos + firstIndex;
          tree[index2] += entry.weight;
          var weightSum = 0;
          while (index2 > 0) {
            if (index2 % 2) {
              weightSum += tree[index2 + 1];
            }
            index2 = index2 - 1 >> 1;
            tree[index2] += entry.weight;
          }
          cc2 += entry.weight * weightSum;
        }
      });
      return cc2;
    };
    var crossCount = function(g2, layering) {
      var cc2 = 0;
      for (var i2 = 1; i2 < (layering === null || layering === void 0 ? void 0 : layering.length); i2 += 1) {
        cc2 += twoLayerCrossCount(g2, layering[i2 - 1], layering[i2]);
      }
      return cc2;
    };
    exports.default = crossCount;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/build-layer-graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var graph_1 = require_graph();
    var buildLayerGraph = function(g2, rank, relationship) {
      var root = createRootNode(g2);
      var result = new graph_1.Graph({ compound: true }).setGraph({ root }).setDefaultNodeLabel(function(v2) {
        return g2.node(v2);
      });
      g2.nodes().forEach(function(v2) {
        var _a2;
        var node = g2.node(v2);
        var parent = g2.parent(v2);
        if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
          result.setNode(v2);
          result.setParent(v2, parent || root);
          (_a2 = g2[relationship](v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
            var u2 = e8.v === v2 ? e8.w : e8.v;
            var edge = result.edgeFromArgs(u2, v2);
            var weight = edge !== void 0 ? edge.weight : 0;
            result.setEdge(u2, v2, { weight: g2.edge(e8).weight + weight });
          });
          if (node.hasOwnProperty("minRank")) {
            result.setNode(v2, {
              borderLeft: node.borderLeft[rank],
              borderRight: node.borderRight[rank]
            });
          }
        }
      });
      return result;
    };
    var createRootNode = function(g2) {
      var v2;
      while (g2.hasNode(v2 = "_root".concat(Math.random())))
        ;
      return v2;
    };
    exports.default = buildLayerGraph;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/add-subgraph-constraints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var addSubgraphConstraints = function(g2, cg, vs) {
      var prev = {};
      var rootPrev;
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        var child = g2.parent(v2);
        var parent;
        var prevChild;
        while (child) {
          parent = g2.parent(child);
          if (parent) {
            prevChild = prev[parent];
            prev[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    };
    exports.default = addSubgraphConstraints;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/barycenter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var barycenter = function(g2, movable) {
      return movable.map(function(v2) {
        var inV = g2.inEdges(v2);
        if (!(inV === null || inV === void 0 ? void 0 : inV.length)) {
          return { v: v2 };
        }
        {
          var result_1 = { sum: 0, weight: 0 };
          inV === null || inV === void 0 ? void 0 : inV.forEach(function(e8) {
            var edge = g2.edge(e8);
            var nodeU = g2.node(e8.v);
            result_1.sum += edge.weight * nodeU.order;
            result_1.weight += edge.weight;
          });
          return {
            v: v2,
            barycenter: result_1.sum / result_1.weight,
            weight: result_1.weight
          };
        }
      });
    };
    exports.default = barycenter;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/resolve-conflicts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolveConflicts = function(entries, cg) {
      var _a2, _b, _c;
      var mappedEntries = {};
      entries === null || entries === void 0 ? void 0 : entries.forEach(function(entry, i2) {
        mappedEntries[entry.v] = {
          i: i2,
          indegree: 0,
          in: [],
          out: [],
          vs: [entry.v]
        };
        var tmp = mappedEntries[entry.v];
        if (entry.barycenter !== void 0) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      (_a2 = cg.edges()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var entryV = mappedEntries[e8.v];
        var entryW = mappedEntries[e8.w];
        if (entryV !== void 0 && entryW !== void 0) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e8.w]);
        }
      });
      var sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, function(entry) {
        return !entry.indegree;
      });
      return doResolveConflicts(sourceSet);
    };
    var doResolveConflicts = function(sourceSet) {
      var _a2, _b;
      var entries = [];
      var handleIn = function(vEntry) {
        return function(uEntry) {
          if (uEntry.merged)
            return;
          if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      };
      var handleOut = function(vEntry) {
        return function(wEntry) {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      };
      var _loop_1 = function() {
        var entry = sourceSet.pop();
        entries.push(entry);
        (_a2 = entry["in"].reverse()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          return handleIn(entry)(e8);
        });
        (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach(function(e8) {
          return handleOut(entry)(e8);
        });
      };
      while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {
        _loop_1();
      }
      var filtered = entries.filter(function(entry) {
        return !entry.merged;
      });
      var keys2 = [
        "vs",
        "i",
        "barycenter",
        "weight"
      ];
      return filtered.map(function(entry) {
        var picked = {};
        keys2 === null || keys2 === void 0 ? void 0 : keys2.forEach(function(key) {
          if (entry[key] === void 0)
            return;
          picked[key] = entry[key];
        });
        return picked;
      });
    };
    var mergeEntries = function(target, source) {
      var _a2;
      var sum = 0;
      var weight = 0;
      if (target.weight) {
        sum += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = (_a2 = source.vs) === null || _a2 === void 0 ? void 0 : _a2.concat(target.vs);
      target.barycenter = sum / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    };
    exports.default = resolveConflicts;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/sort.js
var require_sort = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var sort = function(entries, biasRight, usePrev, keepNodeOrder) {
      var parts = (0, util_1.partition)(entries, function(entry) {
        var hasFixOrder = entry.hasOwnProperty("fixorder") && !isNaN(entry.fixorder);
        if (keepNodeOrder)
          return !hasFixOrder && entry.hasOwnProperty("barycenter");
        return hasFixOrder || entry.hasOwnProperty("barycenter");
      });
      var sortable = parts.lhs;
      var unsortable = parts.rhs.sort(function(a3, b2) {
        return -a3.i - -b2.i;
      });
      var vs = [];
      var sum = 0;
      var weight = 0;
      var vsIndex = 0;
      sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      sortable === null || sortable === void 0 ? void 0 : sortable.forEach(function(entry) {
        var _a2;
        vsIndex += (_a2 = entry.vs) === null || _a2 === void 0 ? void 0 : _a2.length;
        vs.push(entry.vs);
        sum += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      var result = { vs: vs.flat() };
      if (weight) {
        result.barycenter = sum / weight;
        result.weight = weight;
      }
      return result;
    };
    var consumeUnsortable = function(vs, unsortable, index2) {
      var iindex = index2;
      var last2;
      while (unsortable.length && (last2 = unsortable[unsortable.length - 1]).i <= iindex) {
        unsortable.pop();
        vs === null || vs === void 0 ? void 0 : vs.push(last2.vs);
        iindex++;
      }
      return iindex;
    };
    var compareWithBias = function(bias, usePrev) {
      return function(entryV, entryW) {
        if (entryV.fixorder !== void 0 && entryW.fixorder !== void 0) {
          return entryV.fixorder - entryW.fixorder;
        }
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        }
        if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        if (usePrev && entryV.order !== void 0 && entryW.order !== void 0) {
          if (entryV.order < entryW.order) {
            return -1;
          }
          if (entryV.order > entryW.order) {
            return 1;
          }
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    };
    exports.default = sort;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/sort-subgraph.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var barycenter_1 = __importDefault(require_barycenter());
    var resolve_conflicts_1 = __importDefault(require_resolve_conflicts());
    var sort_1 = __importDefault(require_sort());
    var sortSubgraph = function(g2, v2, cg, biasRight, usePrev, keepNodeOrder) {
      var _a2, _b, _c, _d;
      var movable = g2.children(v2);
      var node = g2.node(v2);
      var bl = node ? node.borderLeft : void 0;
      var br2 = node ? node.borderRight : void 0;
      var subgraphs = {};
      if (bl) {
        movable = movable === null || movable === void 0 ? void 0 : movable.filter(function(w2) {
          return w2 !== bl && w2 !== br2;
        });
      }
      var barycenters = (0, barycenter_1.default)(g2, movable || []);
      barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach(function(entry) {
        var _a3;
        if ((_a3 = g2.children(entry.v)) === null || _a3 === void 0 ? void 0 : _a3.length) {
          var subgraphResult = sortSubgraph(g2, entry.v, cg, biasRight, keepNodeOrder);
          subgraphs[entry.v] = subgraphResult;
          if (subgraphResult.hasOwnProperty("barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      var entries = (0, resolve_conflicts_1.default)(barycenters, cg);
      expandSubgraphs(entries, subgraphs);
      (_a2 = entries.filter(function(e8) {
        return e8.vs.length > 0;
      })) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var node2 = g2.node(e8.vs[0]);
        if (node2) {
          e8.fixorder = node2.fixorder;
          e8.order = node2.order;
        }
      });
      var result = (0, sort_1.default)(entries, biasRight, usePrev, keepNodeOrder);
      if (bl) {
        result.vs = [bl, result.vs, br2].flat();
        if ((_b = g2.predecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {
          var blPred = g2.node(((_c = g2.predecessors(bl)) === null || _c === void 0 ? void 0 : _c[0]) || "");
          var brPred = g2.node(((_d = g2.predecessors(br2)) === null || _d === void 0 ? void 0 : _d[0]) || "");
          if (!result.hasOwnProperty("barycenter")) {
            result.barycenter = 0;
            result.weight = 0;
          }
          result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
          result.weight += 2;
        }
      }
      return result;
    };
    var expandSubgraphs = function(entries, subgraphs) {
      entries === null || entries === void 0 ? void 0 : entries.forEach(function(entry) {
        var _a2;
        var vss = (_a2 = entry.vs) === null || _a2 === void 0 ? void 0 : _a2.map(function(v2) {
          if (subgraphs[v2]) {
            return subgraphs[v2].vs;
          }
          return v2;
        });
        entry.vs = vss.flat();
      });
    };
    var mergeBarycenters = function(target, other) {
      if (target.barycenter !== void 0) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    };
    exports.default = sortSubgraph;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/index.js
var require_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var init_order_1 = __importDefault(require_init_order());
    var cross_count_1 = __importDefault(require_cross_count());
    var build_layer_graph_1 = __importDefault(require_build_layer_graph());
    var add_subgraph_constraints_1 = __importDefault(require_add_subgraph_constraints());
    var sort_subgraph_1 = __importDefault(require_sort_subgraph());
    var util_1 = require_util2();
    var graph_1 = require_graph();
    var util_2 = require_util3();
    var order = function(g2, keepNodeOrder) {
      var mxRank = (0, util_2.maxRank)(g2);
      var range1 = [];
      var range2 = [];
      for (var i2 = 1; i2 < mxRank + 1; i2++)
        range1.push(i2);
      for (var i2 = mxRank - 1; i2 > -1; i2--)
        range2.push(i2);
      var downLayerGraphs = buildLayerGraphs(g2, range1, "inEdges");
      var upLayerGraphs = buildLayerGraphs(g2, range2, "outEdges");
      var layering = (0, init_order_1.default)(g2);
      assignOrder(g2, layering);
      var bestCC = Number.POSITIVE_INFINITY;
      var best;
      for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
        sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, false, keepNodeOrder);
        layering = (0, util_2.buildLayerMatrix)(g2);
        var cc2 = (0, cross_count_1.default)(g2, layering);
        if (cc2 < bestCC) {
          lastBest = 0;
          best = (0, util_1.clone)(layering);
          bestCC = cc2;
        }
      }
      layering = (0, init_order_1.default)(g2);
      assignOrder(g2, layering);
      for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
        sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, true, keepNodeOrder);
        layering = (0, util_2.buildLayerMatrix)(g2);
        var cc2 = (0, cross_count_1.default)(g2, layering);
        if (cc2 < bestCC) {
          lastBest = 0;
          best = (0, util_1.clone)(layering);
          bestCC = cc2;
        }
      }
      assignOrder(g2, best);
    };
    var buildLayerGraphs = function(g2, ranks, relationship) {
      return ranks.map(function(rank) {
        return (0, build_layer_graph_1.default)(g2, rank, relationship);
      });
    };
    var sweepLayerGraphs = function(layerGraphs, biasRight, usePrev, keepNodeOrder) {
      var cg = new graph_1.Graph();
      layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach(function(lg) {
        var _a2;
        var root = lg.graph().root;
        var sorted = (0, sort_subgraph_1.default)(lg, root, cg, biasRight, usePrev, keepNodeOrder);
        for (var i2 = 0; i2 < ((_a2 = sorted.vs) === null || _a2 === void 0 ? void 0 : _a2.length) || 0; i2++) {
          var lnode = lg.node(sorted.vs[i2]);
          if (lnode) {
            lnode.order = i2;
          }
        }
        (0, add_subgraph_constraints_1.default)(lg, cg, sorted.vs);
      });
    };
    var assignOrder = function(g2, layering) {
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          g2.node(v2).order = i2;
        });
      });
    };
    exports.default = order;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/position/bk.js
var require_bk = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/position/bk.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.width = exports.sep = exports.positionX = exports.balance = exports.alignCoordinates = exports.findSmallestWidthAlignment = exports.buildBlockGraph = exports.horizontalCompaction = exports.verticalAlignment = exports.hasConflict = exports.addConflict = exports.findOtherInnerSegmentNode = exports.findType2Conflicts = exports.findType1Conflicts = void 0;
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var util_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var util_2 = require_util3();
    var BlockGraph = (
      /** @class */
      function(_super) {
        __extends15(BlockGraph2, _super);
        function BlockGraph2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return BlockGraph2;
      }(graphlib_1.Graph)
    );
    var findType1Conflicts = function(g2, layering) {
      var conflicts = {};
      var visitLayer = function(prevLayer, layer) {
        var k0 = 0;
        var scanPos = 0;
        var prevLayerLength = prevLayer.length;
        var lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          var _a2;
          var w2 = (0, exports.findOtherInnerSegmentNode)(g2, v2);
          var k1 = w2 ? g2.node(w2).order : prevLayerLength;
          if (w2 || v2 === lastNode) {
            (_a2 = layer.slice(scanPos, i2 + 1)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(scanNode) {
              var _a3;
              (_a3 = g2.predecessors(scanNode)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(u2) {
                var _a4;
                var uLabel = g2.node(u2);
                var uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && ((_a4 = g2.node(scanNode)) === null || _a4 === void 0 ? void 0 : _a4.dummy))) {
                  (0, exports.addConflict)(conflicts, u2, scanNode);
                }
              });
            });
            scanPos = i2 + 1;
            k0 = k1;
          }
        });
        return layer;
      };
      if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
      }
      return conflicts;
    };
    exports.findType1Conflicts = findType1Conflicts;
    var findType2Conflicts = function(g2, layering) {
      var conflicts = {};
      function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var _a2, _b;
        var v2;
        for (var i2 = southPos; i2 < southEnd; i2++) {
          v2 = south[i2];
          if ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) {
            (_b = g2.predecessors(v2)) === null || _b === void 0 ? void 0 : _b.forEach(function(u2) {
              var uNode = g2.node(u2);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                (0, exports.addConflict)(conflicts, u2, v2);
              }
            });
          }
        }
      }
      ;
      function getScannedKey(params) {
        return JSON.stringify(params.slice(1));
      }
      function scanIfNeeded(params, scanCache) {
        var cacheKey = getScannedKey(params);
        if (scanCache.get(cacheKey))
          return;
        scan.apply(void 0, params);
        scanCache.set(cacheKey, true);
      }
      var visitLayer = function(north, south) {
        var prevNorthPos = -1;
        var nextNorthPos;
        var southPos = 0;
        var scanned = /* @__PURE__ */ new Map();
        south === null || south === void 0 ? void 0 : south.forEach(function(v2, southLookahead) {
          var _a2;
          if (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) === "border") {
            var predecessors = g2.predecessors(v2) || [];
            if (predecessors.length) {
              nextNorthPos = g2.node(predecessors[0]).order;
              scanIfNeeded([south, southPos, southLookahead, prevNorthPos, nextNorthPos], scanned);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scanIfNeeded([south, southPos, south.length, nextNorthPos, north.length], scanned);
        });
        return south;
      };
      if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
      }
      return conflicts;
    };
    exports.findType2Conflicts = findType2Conflicts;
    var findOtherInnerSegmentNode = function(g2, v2) {
      var _a2, _b;
      if ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) {
        return (_b = g2.predecessors(v2)) === null || _b === void 0 ? void 0 : _b.find(function(u2) {
          return g2.node(u2).dummy;
        });
      }
    };
    exports.findOtherInnerSegmentNode = findOtherInnerSegmentNode;
    var addConflict = function(conflicts, v2, w2) {
      var vv = v2;
      var ww = w2;
      if (vv > ww) {
        var tmp = vv;
        vv = ww;
        ww = tmp;
      }
      var conflictsV = conflicts[vv];
      if (!conflictsV) {
        conflicts[vv] = conflictsV = {};
      }
      conflictsV[ww] = true;
    };
    exports.addConflict = addConflict;
    var hasConflict = function(conflicts, v2, w2) {
      var vv = v2;
      var ww = w2;
      if (vv > ww) {
        var tmp = v2;
        vv = ww;
        ww = tmp;
      }
      return !!conflicts[vv];
    };
    exports.hasConflict = hasConflict;
    var verticalAlignment = function(g2, layering, conflicts, neighborFn) {
      var root = {};
      var align = {};
      var pos = {};
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, order) {
          root[v2] = v2;
          align[v2] = v2;
          pos[v2] = order;
        });
      });
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var prevIdx = -1;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          var ws = neighborFn(v2);
          if (ws.length) {
            ws = ws.sort(function(a3, b2) {
              return pos[a3] - pos[b2];
            });
            var mp = (ws.length - 1) / 2;
            for (var i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
              var w2 = ws[i2];
              if (align[v2] === v2 && prevIdx < pos[w2] && !(0, exports.hasConflict)(conflicts, v2, w2)) {
                align[w2] = v2;
                align[v2] = root[v2] = root[w2];
                prevIdx = pos[w2];
              }
            }
          }
        });
      });
      return { root, align };
    };
    exports.verticalAlignment = verticalAlignment;
    var horizontalCompaction = function(g2, layering, root, align, reverseSep) {
      var _a2;
      var xs = {};
      var blockG = (0, exports.buildBlockGraph)(g2, layering, root, reverseSep);
      var borderType = reverseSep ? "borderLeft" : "borderRight";
      var iterate = function(setXsFunc, nextNodesFunc) {
        var stack = blockG.nodes();
        var elem = stack.pop();
        var visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      };
      var pass1 = function(elem) {
        xs[elem] = (blockG.inEdges(elem) || []).reduce(function(acc, e8) {
          return Math.max(acc, (xs[e8.v] || 0) + blockG.edge(e8));
        }, 0);
      };
      var pass2 = function(elem) {
        var min3 = (blockG.outEdges(elem) || []).reduce(function(acc, e8) {
          return Math.min(acc, (xs[e8.w] || 0) - blockG.edge(e8));
        }, Number.POSITIVE_INFINITY);
        var node = g2.node(elem);
        if (min3 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min3);
        }
      };
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      (_a2 = Object.values(align)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        xs[v2] = xs[root[v2]];
      });
      return xs;
    };
    exports.horizontalCompaction = horizontalCompaction;
    var buildBlockGraph = function(g2, layering, root, reverseSep) {
      var blockGraph = new BlockGraph();
      var graphLabel = g2.graph();
      var sepFn = (0, exports.sep)(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var u2;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          var vRoot = root[v2];
          blockGraph.setNode(vRoot);
          if (u2) {
            var uRoot = root[u2];
            var prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g2, v2, u2), prevMax || 0));
          }
          u2 = v2;
        });
      });
      return blockGraph;
    };
    exports.buildBlockGraph = buildBlockGraph;
    var findSmallestWidthAlignment = function(g2, xss) {
      return (0, util_2.minBy)(Object.values(xss), function(xs) {
        var _a2;
        var max4 = Number.NEGATIVE_INFINITY;
        var min3 = Number.POSITIVE_INFINITY;
        (_a2 = Object.keys(xs)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
          var x4 = xs[v2];
          var halfWidth = (0, exports.width)(g2, v2) / 2;
          max4 = Math.max(x4 + halfWidth, max4);
          min3 = Math.min(x4 - halfWidth, min3);
        });
        return max4 - min3;
      });
    };
    exports.findSmallestWidthAlignment = findSmallestWidthAlignment;
    function alignCoordinates(xss, alignTo) {
      var alignToVals = Object.values(alignTo);
      var alignToMin = (0, util_1.min)(alignToVals);
      var alignToMax = (0, util_1.max)(alignToVals);
      ["u", "d"].forEach(function(vert) {
        ["l", "r"].forEach(function(horiz) {
          var alignment = vert + horiz;
          var xs = xss[alignment];
          var delta;
          if (xs === alignTo)
            return;
          var xsVals = Object.values(xs);
          delta = horiz === "l" ? alignToMin - (0, util_1.min)(xsVals) : alignToMax - (0, util_1.max)(xsVals);
          if (delta) {
            xss[alignment] = {};
            Object.keys(xs).forEach(function(key) {
              xss[alignment][key] = xs[key] + delta;
            });
          }
        });
      });
    }
    exports.alignCoordinates = alignCoordinates;
    var balance = function(xss, align) {
      var result = {};
      Object.keys(xss.ul).forEach(function(key) {
        if (align) {
          result[key] = xss[align.toLowerCase()][key];
        } else {
          var values2 = Object.values(xss).map(function(x4) {
            return x4[key];
          });
          result[key] = (values2[0] + values2[1]) / 2;
        }
      });
      return result;
    };
    exports.balance = balance;
    var positionX = function(g2) {
      var layering = (0, util_2.buildLayerMatrix)(g2);
      var conflicts = Object.assign((0, exports.findType1Conflicts)(g2, layering), (0, exports.findType2Conflicts)(g2, layering));
      var xss = {};
      var adjustedLayering;
      ["u", "d"].forEach(function(vert) {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach(function(horiz) {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map(function(inner) {
              return Object.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
          var align = (0, exports.verticalAlignment)(g2, adjustedLayering, conflicts, neighborFn);
          var xs = (0, exports.horizontalCompaction)(g2, adjustedLayering, align.root, align.align, horiz === "r");
          if (horiz === "r") {
            Object.keys(xs).forEach(function(key) {
              xs[key] = -xs[key];
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = (0, exports.findSmallestWidthAlignment)(g2, xss);
      alignCoordinates(xss, smallestWidth);
      return (0, exports.balance)(xss, g2.graph().align);
    };
    exports.positionX = positionX;
    var sep = function(nodeSep, edgeSep, reverseSep) {
      return function(g2, v2, w2) {
        var vLabel = g2.node(v2);
        var wLabel = g2.node(w2);
        var sum = 0;
        var delta;
        sum += vLabel.width / 2;
        if (vLabel.hasOwnProperty("labelpos")) {
          switch ((vLabel.labelpos || "").toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += wLabel.width / 2;
        if (wLabel.labelpos) {
          switch ((wLabel.labelpos || "").toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum;
      };
    };
    exports.sep = sep;
    var width = function(g2, v2) {
      return g2.node(v2).width || 0;
    };
    exports.width = width;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/position/index.js
var require_position = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/position/index.js"(exports) {
    "use strict";
    var __spreadArray3 = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
          if (ar2 || !(i2 in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i2);
            ar2[i2] = from[i2];
          }
        }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var bk_1 = require_bk();
    var positionY = function(g2) {
      var layering = (0, util_1.buildLayerMatrix)(g2);
      var rankSep = g2.graph().ranksep;
      var prevY = 0;
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var heights = layer.map(function(v2) {
          return g2.node(v2).height;
        });
        var maxHeight = Math.max.apply(Math, __spreadArray3(__spreadArray3([], heights, false), [0], false));
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          g2.node(v2).y = prevY + maxHeight / 2;
        });
        prevY += maxHeight + rankSep;
      });
    };
    var positionX = function(g2) {
      var layering = (0, util_1.buildLayerMatrix)(g2);
      var conflicts = Object.assign((0, bk_1.findType1Conflicts)(g2, layering), (0, bk_1.findType2Conflicts)(g2, layering));
      var xss = {};
      var adjustedLayering = [];
      ["u", "d"].forEach(function(vert) {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach(function(horiz) {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map(function(inner) {
              return Object.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
          var align = (0, bk_1.verticalAlignment)(g2, adjustedLayering, conflicts, neighborFn);
          var xs = (0, bk_1.horizontalCompaction)(g2, adjustedLayering, align.root, align.align, horiz === "r");
          if (horiz === "r") {
            Object.keys(xs).forEach(function(xsKey) {
              return xs[xsKey] = -xs[xsKey];
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = (0, bk_1.findSmallestWidthAlignment)(g2, xss);
      smallestWidth && (0, bk_1.alignCoordinates)(xss, smallestWidth);
      return (0, bk_1.balance)(xss, g2.graph().align);
    };
    var position = function(g2) {
      var _a2;
      var ng = (0, util_1.asNonCompoundGraph)(g2);
      positionY(ng);
      var xs = positionX(ng);
      (_a2 = Object.keys(xs)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(key) {
        ng.node(key).x = xs[key];
      });
    };
    exports.default = position;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/init-data-order.js
var require_init_data_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/init-data-order.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var initDataOrder = function(g2, nodeOrder) {
      var simpleNodes = g2.nodes().filter(function(v2) {
        var _a2;
        return !((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length);
      });
      var ranks = simpleNodes.map(function(v2) {
        return g2.node(v2).rank;
      });
      var maxRank = Math.max.apply(Math, ranks);
      var layers = [];
      for (var i2 = 0; i2 < maxRank + 1; i2++) {
        layers[i2] = [];
      }
      nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach(function(n2) {
        var node = g2.node(n2);
        if (!node || (node === null || node === void 0 ? void 0 : node.dummy)) {
          return;
        }
        if (!isNaN(node.rank)) {
          node.fixorder = layers[node.rank].length;
          layers[node.rank].push(n2);
        }
      });
    };
    exports.default = initDataOrder;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/layout.js
var require_layout = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/layout.js"(exports) {
    "use strict";
    var __assign14 = exports && exports.__assign || function() {
      __assign14 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign14.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var acyclic_1 = __importDefault(require_acyclic());
    var normalize_1 = __importDefault(require_normalize());
    var rank_1 = __importDefault(require_rank());
    var util_1 = require_util3();
    var parent_dummy_chains_1 = __importDefault(require_parent_dummy_chains());
    var nesting_graph_1 = __importDefault(require_nesting_graph());
    var add_border_segments_1 = __importDefault(require_add_border_segments());
    var coordinate_system_1 = __importDefault(require_coordinate_system());
    var order_1 = __importDefault(require_order());
    var position_1 = __importDefault(require_position());
    var init_data_order_1 = __importDefault(require_init_data_order());
    var graph_1 = require_graph();
    var layout2 = function(g2, opts) {
      var time = opts && opts.debugTiming ? util_1.time : util_1.notime;
      time("layout", function() {
        if (opts && !opts.keepNodeOrder && opts.prevGraph) {
          time("  inheritOrder", function() {
            inheritOrder(g2, opts.prevGraph);
          });
        }
        var layoutGraph = time("  buildLayoutGraph", function() {
          return buildLayoutGraph(g2);
        });
        if (!(opts && opts.edgeLabelSpace === false)) {
          time("  makeSpaceForEdgeLabels", function() {
            makeSpaceForEdgeLabels(layoutGraph);
          });
        }
        try {
          time("  runLayout", function() {
            runLayout(layoutGraph, time, opts);
          });
        } catch (e8) {
          if (e8.message === "Not possible to find intersection inside of the rectangle") {
            console.error("The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\n", e8);
            return;
          }
          throw e8;
        }
        time("  updateInputGraph", function() {
          updateInputGraph(g2, layoutGraph);
        });
      });
    };
    var runLayout = function(g2, time, opts) {
      time("    removeSelfEdges", function() {
        removeSelfEdges(g2);
      });
      time("    acyclic", function() {
        acyclic_1.default.run(g2);
      });
      time("    nestingGraph.run", function() {
        nesting_graph_1.default.run(g2);
      });
      time("    rank", function() {
        (0, rank_1.default)((0, util_1.asNonCompoundGraph)(g2));
      });
      time("    injectEdgeLabelProxies", function() {
        injectEdgeLabelProxies(g2);
      });
      time("    removeEmptyRanks", function() {
        (0, util_1.removeEmptyRanks)(g2);
      });
      time("    nestingGraph.cleanup", function() {
        nesting_graph_1.default.cleanup(g2);
      });
      time("    normalizeRanks", function() {
        (0, util_1.normalizeRanks)(g2);
      });
      time("    assignRankMinMax", function() {
        assignRankMinMax(g2);
      });
      time("    removeEdgeLabelProxies", function() {
        removeEdgeLabelProxies(g2);
      });
      time("    normalize.run", function() {
        normalize_1.default.run(g2);
      });
      time("    parentDummyChains", function() {
        (0, parent_dummy_chains_1.default)(g2);
      });
      time("    addBorderSegments", function() {
        (0, add_border_segments_1.default)(g2);
      });
      if (opts && opts.keepNodeOrder) {
        time("    initDataOrder", function() {
          (0, init_data_order_1.default)(g2, opts.nodeOrder);
        });
      }
      time("    order", function() {
        (0, order_1.default)(g2, opts === null || opts === void 0 ? void 0 : opts.keepNodeOrder);
      });
      time("    insertSelfEdges", function() {
        insertSelfEdges(g2);
      });
      time("    adjustCoordinateSystem", function() {
        coordinate_system_1.default.adjust(g2);
      });
      time("    position", function() {
        (0, position_1.default)(g2);
      });
      time("    positionSelfEdges", function() {
        positionSelfEdges(g2);
      });
      time("    removeBorderNodes", function() {
        removeBorderNodes(g2);
      });
      time("    normalize.undo", function() {
        normalize_1.default.undo(g2);
      });
      time("    fixupEdgeLabelCoords", function() {
        fixupEdgeLabelCoords(g2);
      });
      time("    undoCoordinateSystem", function() {
        coordinate_system_1.default.undo(g2);
      });
      time("    translateGraph", function() {
        translateGraph(g2);
      });
      time("    assignNodeIntersects", function() {
        assignNodeIntersects(g2);
      });
      time("    reversePoints", function() {
        reversePointsForReversedEdges(g2);
      });
      time("    acyclic.undo", function() {
        acyclic_1.default.undo(g2);
      });
    };
    var inheritOrder = function(currG, prevG) {
      currG.nodes().forEach(function(n2) {
        var node = currG.node(n2);
        var prevNode = prevG.node(n2);
        if (prevNode !== void 0) {
          node.fixorder = prevNode._order;
          delete prevNode._order;
        } else {
          delete node.fixorder;
        }
      });
    };
    var updateInputGraph = function(inputGraph, layoutGraph) {
      inputGraph.nodes().forEach(function(v2) {
        var _a2;
        var inputLabel = inputGraph.node(v2);
        if (inputLabel) {
          var layoutLabel = layoutGraph.node(v2);
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          inputLabel._order = layoutLabel.order;
          inputLabel._rank = layoutLabel.rank;
          if ((_a2 = layoutGraph.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      inputGraph.edges().forEach(function(e8) {
        var inputLabel = inputGraph.edge(e8);
        var layoutLabel = layoutGraph.edge(e8);
        inputLabel.points = layoutLabel ? layoutLabel.points : [];
        if (layoutLabel && layoutLabel.hasOwnProperty("x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    };
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height", "layer", "fixorder"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    var buildLayoutGraph = function(inputGraph) {
      var g2 = new graph_1.Graph({ multigraph: true, compound: true });
      var graph = canonicalize(inputGraph.graph());
      var pickedProperties = {};
      graphAttrs === null || graphAttrs === void 0 ? void 0 : graphAttrs.forEach(function(key) {
        if (graph[key] !== void 0)
          pickedProperties[key] = graph[key];
      });
      g2.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), pickedProperties));
      inputGraph.nodes().forEach(function(v2) {
        var node = canonicalize(inputGraph.node(v2));
        var defaultNode = __assign14(__assign14({}, nodeDefaults), node);
        var defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs);
        g2.setNode(v2, defaultAttrs);
        g2.setParent(v2, inputGraph.parent(v2));
      });
      inputGraph.edges().forEach(function(e8) {
        var edge = canonicalize(inputGraph.edge(e8));
        var pickedProperties2 = {};
        edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach(function(key) {
          if (edge[key] !== void 0)
            pickedProperties2[key] = edge[key];
        });
        g2.setEdgeObj(e8, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties2));
      });
      return g2;
    };
    var makeSpaceForEdgeLabels = function(g2) {
      var graph = g2.graph();
      if (!graph.ranksep)
        graph.ranksep = 0;
      graph.ranksep /= 2;
      g2.nodes().forEach(function(n2) {
        var node = g2.node(n2);
        if (!isNaN(node.layer)) {
          if (!node.layer)
            node.layer = 0;
        }
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        edge.minlen *= 2;
        if (((_a2 = edge.labelpos) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    };
    var injectEdgeLabelProxies = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge.width && edge.height) {
          var v2 = g2.node(e8.v);
          var w2 = g2.node(e8.w);
          var label = {
            e: e8,
            rank: (w2.rank - v2.rank) / 2 + v2.rank
          };
          (0, util_1.addDummyNode)(g2, "edge-proxy", label, "_ep");
        }
      });
    };
    var assignRankMinMax = function(g2) {
      var maxRank = 0;
      g2.nodes().forEach(function(v2) {
        var _a2, _b;
        var node = g2.node(v2);
        if (node.borderTop) {
          node.minRank = (_a2 = g2.node(node.borderTop)) === null || _a2 === void 0 ? void 0 : _a2.rank;
          node.maxRank = (_b = g2.node(node.borderBottom)) === null || _b === void 0 ? void 0 : _b.rank;
          maxRank = Math.max(maxRank, node.maxRank || -Infinity);
        }
      });
      g2.graph().maxRank = maxRank;
    };
    var removeEdgeLabelProxies = function(g2) {
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.dummy === "edge-proxy") {
          g2.edge(node.e).labelRank = node.rank;
          g2.removeNode(v2);
        }
      });
    };
    var translateGraph = function(g2) {
      var minX;
      var maxX = 0;
      var minY;
      var maxY = 0;
      var graphLabel = g2.graph();
      var marginX = graphLabel.marginx || 0;
      var marginY = graphLabel.marginy || 0;
      var getExtremes = function(attrs) {
        if (!attrs)
          return;
        var x4 = attrs.x;
        var y4 = attrs.y;
        var w2 = attrs.width;
        var h2 = attrs.height;
        if (!isNaN(x4) && !isNaN(w2)) {
          if (minX === void 0) {
            minX = x4 - w2 / 2;
          }
          minX = Math.min(minX, x4 - w2 / 2);
          maxX = Math.max(maxX, x4 + w2 / 2);
        }
        if (!isNaN(y4) && !isNaN(h2)) {
          if (minY === void 0) {
            minY = y4 - h2 / 2;
          }
          minY = Math.min(minY, y4 - h2 / 2);
          maxY = Math.max(maxY, y4 + h2 / 2);
        }
      };
      g2.nodes().forEach(function(v2) {
        getExtremes(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty("x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node) {
          node.x -= minX;
          node.y -= minY;
        }
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(p2) {
          p2.x -= minX;
          p2.y -= minY;
        });
        if (edge.hasOwnProperty("x")) {
          edge.x -= minX;
        }
        if (edge.hasOwnProperty("y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY - minY + marginY;
    };
    var assignNodeIntersects = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        var nodeV = g2.node(e8.v);
        var nodeW = g2.node(e8.w);
        var p1;
        var p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift((0, util_1.intersectRect)(nodeV, p1));
        edge.points.push((0, util_1.intersectRect)(nodeW, p2));
      });
    };
    var fixupEdgeLabelCoords = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty("x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    };
    var reversePointsForReversedEdges = function(g2) {
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        if (edge.reversed) {
          (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.reverse();
        }
      });
    };
    var removeBorderNodes = function(g2) {
      g2.nodes().forEach(function(v2) {
        var _a2, _b, _c;
        if ((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length) {
          var node = g2.node(v2);
          var t2 = g2.node(node.borderTop);
          var b2 = g2.node(node.borderBottom);
          var l2 = g2.node(node.borderLeft[((_b = node.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);
          var r2 = g2.node(node.borderRight[((_c = node.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);
          node.width = Math.abs((r2 === null || r2 === void 0 ? void 0 : r2.x) - (l2 === null || l2 === void 0 ? void 0 : l2.x)) || 10;
          node.height = Math.abs((b2 === null || b2 === void 0 ? void 0 : b2.y) - (t2 === null || t2 === void 0 ? void 0 : t2.y)) || 10;
          node.x = ((l2 === null || l2 === void 0 ? void 0 : l2.x) || 0) + node.width / 2;
          node.y = ((t2 === null || t2 === void 0 ? void 0 : t2.y) || 0) + node.height / 2;
        }
      });
      g2.nodes().forEach(function(v2) {
        var _a2;
        if (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) === "border") {
          g2.removeNode(v2);
        }
      });
    };
    var removeSelfEdges = function(g2) {
      g2.edges().forEach(function(e8) {
        if (e8.v === e8.w) {
          var node = g2.node(e8.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e: e8, label: g2.edge(e8) });
          g2.removeEdgeObj(e8);
        }
      });
    };
    var insertSelfEdges = function(g2) {
      var layers = (0, util_1.buildLayerMatrix)(g2);
      layers === null || layers === void 0 ? void 0 : layers.forEach(function(layer) {
        var orderShift = 0;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          var _a2;
          var node = g2.node(v2);
          node.order = i2 + orderShift;
          (_a2 = node.selfEdges) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(selfEdge) {
            (0, util_1.addDummyNode)(g2, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i2 + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    };
    var positionSelfEdges = function(g2) {
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.dummy === "selfedge") {
          var selfNode = g2.node(node.e.v);
          var x4 = selfNode.x + selfNode.width / 2;
          var y4 = selfNode.y;
          var dx = node.x - x4;
          var dy = selfNode.height / 2;
          g2.setEdgeObj(node.e, node.label);
          g2.removeNode(v2);
          node.label.points = [
            { x: x4 + 2 * dx / 3, y: y4 - dy },
            { x: x4 + 5 * dx / 6, y: y4 - dy },
            { y: y4, x: x4 + dx },
            { x: x4 + 5 * dx / 6, y: y4 + dy },
            { x: x4 + 2 * dx / 3, y: y4 + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    };
    var selectNumberAttrs = function(obj, attrs) {
      var pickedProperties = {};
      attrs === null || attrs === void 0 ? void 0 : attrs.forEach(function(key) {
        if (obj[key] === void 0)
          return;
        pickedProperties[key] = +obj[key];
      });
      return pickedProperties;
    };
    var canonicalize = function(attrs) {
      if (attrs === void 0) {
        attrs = {};
      }
      var newAttrs = {};
      Object.keys(attrs).forEach(function(k2) {
        newAttrs[k2.toLowerCase()] = attrs[k2];
      });
      return newAttrs;
    };
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var layout_1 = __importDefault(require_layout());
    var util_1 = require_util3();
    exports.default = {
      layout: layout_1.default,
      util: {
        time: util_1.time,
        notime: util_1.notime
      }
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre.js
var require_dagre2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DagreLayout = void 0;
    var index_1 = __importDefault(require_dagre());
    var util_1 = require_util2();
    var base_1 = require_base();
    var graph_1 = require_graph();
    var DagreLayout2 = (
      /** @class */
      function(_super) {
        __extends15(DagreLayout3, _super);
        function DagreLayout3(options) {
          var _this = _super.call(this) || this;
          _this.rankdir = "TB";
          _this.nodesep = 50;
          _this.ranksep = 50;
          _this.controlPoints = false;
          _this.sortByCombo = false;
          _this.edgeLabelSpace = true;
          _this.radial = false;
          _this.nodes = [];
          _this.edges = [];
          _this.onLayoutEnd = function() {
          };
          _this.layoutNode = function(nodeId) {
            var self2 = _this;
            var nodes = self2.nodes;
            var node = nodes.find(function(node2) {
              return node2.id === nodeId;
            });
            if (node) {
              var layout2 = node.layout !== false;
              return layout2;
            }
            return true;
          };
          _this.updateCfg(options);
          return _this;
        }
        DagreLayout3.prototype.getDefaultCfg = function() {
          return {
            rankdir: "TB",
            align: void 0,
            nodeSize: void 0,
            nodesepFunc: void 0,
            ranksepFunc: void 0,
            nodesep: 50,
            ranksep: 50,
            controlPoints: false,
            radial: false,
            focusNode: null
            // radial 为 true 时生效，关注的节点
          };
        };
        DagreLayout3.prototype.execute = function() {
          var _this = this;
          var _a2, _b, _c, _d;
          var self2 = this;
          var nodes = self2.nodes, nodeSize = self2.nodeSize, rankdir = self2.rankdir, combos = self2.combos, begin = self2.begin, radial = self2.radial, _e2 = self2.comboEdges, comboEdges = _e2 === void 0 ? [] : _e2, _f = self2.vedges, vedges = _f === void 0 ? [] : _f;
          if (!nodes)
            return;
          var edges = self2.edges || [];
          var g2 = new graph_1.Graph({
            multigraph: true,
            compound: true
          });
          self2.nodeMap = {};
          var nodeComboMap = {};
          nodes.forEach(function(node) {
            self2.nodeMap[node.id] = node;
            if (!node.comboId)
              return;
            nodeComboMap[node.comboId] = nodeComboMap[node.comboId] || [];
            nodeComboMap[node.comboId].push(node.id);
          });
          var sortedNodes = [];
          var visitedMap = {};
          if ((_a2 = self2.nodeOrder) === null || _a2 === void 0 ? void 0 : _a2.length) {
            self2.nodeOrder.forEach(function(id) {
              visitedMap[id] = true;
              sortedNodes.push(self2.nodeMap[id]);
            });
            nodes.forEach(function(node) {
              if (!visitedMap[node.id])
                sortedNodes.push(node);
            });
          } else {
            sortedNodes = nodes;
          }
          var nodeSizeFunc;
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  return d2.size;
                }
                if ((0, util_1.isObject)(d2.size)) {
                  return [d2.size.width || 40, d2.size.height || 40];
                }
                return [d2.size, d2.size];
              }
              return [40, 40];
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            nodeSizeFunc = function() {
              return nodeSize;
            };
          } else {
            nodeSizeFunc = function() {
              return [nodeSize, nodeSize];
            };
          }
          var ranksepfunc = (0, util_1.getFunc)(self2.ranksep, 50, self2.ranksepFunc);
          var nodesepfunc = (0, util_1.getFunc)(self2.nodesep, 50, self2.nodesepFunc);
          var horisep = nodesepfunc;
          var vertisep = ranksepfunc;
          if (rankdir === "LR" || rankdir === "RL") {
            horisep = ranksepfunc;
            vertisep = nodesepfunc;
          }
          g2.setDefaultEdgeLabel(function() {
            return {};
          });
          g2.setGraph(self2);
          var comboMap = {};
          if (this.sortByCombo && combos) {
            combos.forEach(function(combo) {
              comboMap[combo.id] = combo;
              if (combo.collapsed) {
                var size3 = nodeSizeFunc(combo);
                var verti = vertisep(combo);
                var hori = horisep(combo);
                var width = size3[0] + 2 * hori;
                var height = size3[1] + 2 * verti;
                g2.setNode(combo.id, { width, height });
              }
              if (!combo.parentId)
                return;
              if (!comboMap[combo.parentId]) {
                g2.setNode(combo.parentId, {});
              }
              g2.setParent(combo.id, combo.parentId);
            });
          }
          sortedNodes.filter(function(node) {
            return node.layout !== false;
          }).forEach(function(node) {
            var size3 = nodeSizeFunc(node);
            var verti = vertisep(node);
            var hori = horisep(node);
            var width = size3[0] + 2 * hori;
            var height = size3[1] + 2 * verti;
            var layer = node.layer;
            if ((0, util_1.isNumber)(layer)) {
              g2.setNode(node.id, { width, height, layer });
            } else {
              g2.setNode(node.id, { width, height });
            }
            if (_this.sortByCombo && node.comboId) {
              if (!comboMap[node.comboId]) {
                comboMap[node.comboId] = { id: node.comboId };
                g2.setNode(node.comboId, {});
              }
              g2.setParent(node.id, node.comboId);
            }
          });
          edges.forEach(function(edge) {
            var source = (0, util_1.getEdgeTerminal)(edge, "source");
            var target = (0, util_1.getEdgeTerminal)(edge, "target");
            if (_this.layoutNode(source) && _this.layoutNode(target)) {
              g2.setEdge(source, target, {
                weight: edge.weight || 1
              });
            }
          });
          (_b = comboEdges === null || comboEdges === void 0 ? void 0 : comboEdges.concat(vedges || [])) === null || _b === void 0 ? void 0 : _b.forEach(function(comboEdge) {
            var _a3, _b2;
            var source = comboEdge.source, target = comboEdge.target;
            var sources = ((_a3 = comboMap[source]) === null || _a3 === void 0 ? void 0 : _a3.collapsed) ? [source] : nodeComboMap[source] || [source];
            var targets = ((_b2 = comboMap[target]) === null || _b2 === void 0 ? void 0 : _b2.collapsed) ? [target] : nodeComboMap[target] || [target];
            sources.forEach(function(s2) {
              targets.forEach(function(t2) {
                g2.setEdge(s2, t2, {
                  weight: comboEdge.weight || 1
                });
              });
            });
          });
          var prevGraph = void 0;
          if ((_c = self2.preset) === null || _c === void 0 ? void 0 : _c.nodes) {
            prevGraph = new graph_1.Graph({
              multigraph: true,
              compound: true
            });
            self2.preset.nodes.forEach(function(node) {
              prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);
            });
          }
          index_1.default.layout(g2, {
            prevGraph,
            edgeLabelSpace: self2.edgeLabelSpace,
            keepNodeOrder: Boolean(!!self2.nodeOrder),
            nodeOrder: self2.nodeOrder
          });
          var dBegin = [0, 0];
          if (begin) {
            var minX_1 = Infinity;
            var minY_1 = Infinity;
            g2.nodes().forEach(function(node) {
              var coord = g2.node(node);
              if (minX_1 > coord.x)
                minX_1 = coord.x;
              if (minY_1 > coord.y)
                minY_1 = coord.y;
            });
            g2.edges().forEach(function(edge) {
              var _a3;
              var coord = g2.edge(edge);
              (_a3 = coord.points) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(point) {
                if (minX_1 > point.x)
                  minX_1 = point.x;
                if (minY_1 > point.y)
                  minY_1 = point.y;
              });
            });
            dBegin[0] = begin[0] - minX_1;
            dBegin[1] = begin[1] - minY_1;
          }
          var isHorizontal = rankdir === "LR" || rankdir === "RL";
          if (radial) {
            var _g = this, focusNode = _g.focusNode, ranksep = _g.ranksep, getRadialPos_1 = _g.getRadialPos;
            var focusId = (0, util_1.isString)(focusNode) ? focusNode : focusNode === null || focusNode === void 0 ? void 0 : focusNode.id;
            var focusLayer_1 = focusId ? (_d = g2.node(focusId)) === null || _d === void 0 ? void 0 : _d._rank : 0;
            var layers_1 = [];
            var dim_1 = isHorizontal ? "y" : "x";
            var sizeDim_1 = isHorizontal ? "height" : "width";
            var min_1 = Infinity;
            var max_1 = -Infinity;
            g2.nodes().forEach(function(node) {
              var coord = g2.node(node);
              if (!self2.nodeMap[node])
                return;
              var currentNodesep = nodesepfunc(self2.nodeMap[node]);
              if (focusLayer_1 === 0) {
                if (!layers_1[coord._rank]) {
                  layers_1[coord._rank] = {
                    nodes: [],
                    totalWidth: 0,
                    maxSize: -Infinity
                  };
                }
                layers_1[coord._rank].nodes.push(node);
                layers_1[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
                if (layers_1[coord._rank].maxSize < Math.max(coord.width, coord.height)) {
                  layers_1[coord._rank].maxSize = Math.max(coord.width, coord.height);
                }
              } else {
                var diffLayer = coord._rank - focusLayer_1;
                if (diffLayer === 0) {
                  if (!layers_1[diffLayer]) {
                    layers_1[diffLayer] = {
                      nodes: [],
                      totalWidth: 0,
                      maxSize: -Infinity
                    };
                  }
                  layers_1[diffLayer].nodes.push(node);
                  layers_1[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
                  if (layers_1[diffLayer].maxSize < Math.max(coord.width, coord.height)) {
                    layers_1[diffLayer].maxSize = Math.max(coord.width, coord.height);
                  }
                } else {
                  var diffLayerAbs = Math.abs(diffLayer);
                  if (!layers_1[diffLayerAbs]) {
                    layers_1[diffLayerAbs] = {
                      left: [],
                      right: [],
                      totalWidth: 0,
                      maxSize: -Infinity
                    };
                  }
                  layers_1[diffLayerAbs].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
                  if (layers_1[diffLayerAbs].maxSize < Math.max(coord.width, coord.height)) {
                    layers_1[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);
                  }
                  if (diffLayer < 0) {
                    layers_1[diffLayerAbs].left.push(node);
                  } else {
                    layers_1[diffLayerAbs].right.push(node);
                  }
                }
              }
              var leftPos = coord[dim_1] - coord[sizeDim_1] / 2 - currentNodesep;
              var rightPos = coord[dim_1] + coord[sizeDim_1] / 2 + currentNodesep;
              if (leftPos < min_1)
                min_1 = leftPos;
              if (rightPos > max_1)
                max_1 = rightPos;
            });
            var radius_1 = ranksep || 50;
            var radiusMap_1 = {};
            var rangeLength_1 = (max_1 - min_1) / 0.9;
            var range_1 = [
              (min_1 + max_1 - rangeLength_1) * 0.5,
              (min_1 + max_1 + rangeLength_1) * 0.5
            ];
            var processNodes_1 = function(layerNodes, radius, propsMaxRanksep, arcRange) {
              if (propsMaxRanksep === void 0) {
                propsMaxRanksep = -Infinity;
              }
              if (arcRange === void 0) {
                arcRange = [0, 1];
              }
              var maxRanksep = propsMaxRanksep;
              layerNodes.forEach(function(node) {
                var coord = g2.node(node);
                radiusMap_1[node] = radius;
                var _a3 = getRadialPos_1(coord[dim_1], range_1, rangeLength_1, radius, arcRange), newX = _a3.x, newY = _a3.y;
                if (!self2.nodeMap[node])
                  return;
                self2.nodeMap[node].x = newX + dBegin[0];
                self2.nodeMap[node].y = newY + dBegin[1];
                self2.nodeMap[node]._order = coord._order;
                var currentNodeRanksep = ranksepfunc(self2.nodeMap[node]);
                if (maxRanksep < currentNodeRanksep)
                  maxRanksep = currentNodeRanksep;
              });
              return maxRanksep;
            };
            var isFirstLevel_1 = true;
            var lastLayerMaxNodeSize_1 = 0;
            layers_1.forEach(function(layerNodes) {
              var _a3, _b2, _c2, _d2, _e3, _f2, _g2;
              if (!((_a3 = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.nodes) === null || _a3 === void 0 ? void 0 : _a3.length) && !((_b2 = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.left) === null || _b2 === void 0 ? void 0 : _b2.length) && !((_c2 = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.right) === null || _c2 === void 0 ? void 0 : _c2.length)) {
                return;
              }
              if (isFirstLevel_1 && layerNodes.nodes.length === 1) {
                var nodeId = layerNodes.nodes[0];
                if (!self2.nodeMap[nodeId])
                  return;
                self2.nodeMap[nodeId].x = dBegin[0];
                self2.nodeMap[nodeId].y = dBegin[1];
                radiusMap_1[layerNodes.nodes[0]] = 0;
                radius_1 = ranksepfunc(self2.nodeMap[nodeId]);
                isFirstLevel_1 = false;
                return;
              }
              radius_1 = Math.max(radius_1, layerNodes.totalWidth / (2 * Math.PI));
              var maxRanksep = -Infinity;
              if (focusLayer_1 === 0 || ((_d2 = layerNodes.nodes) === null || _d2 === void 0 ? void 0 : _d2.length)) {
                maxRanksep = processNodes_1(layerNodes.nodes, radius_1, maxRanksep, [0, 1]);
              } else {
                var leftRatio = ((_e3 = layerNodes.left) === null || _e3 === void 0 ? void 0 : _e3.length) / (((_f2 = layerNodes.left) === null || _f2 === void 0 ? void 0 : _f2.length) + ((_g2 = layerNodes.right) === null || _g2 === void 0 ? void 0 : _g2.length));
                maxRanksep = processNodes_1(layerNodes.left, radius_1, maxRanksep, [
                  0,
                  leftRatio
                ]);
                maxRanksep = processNodes_1(layerNodes.right, radius_1, maxRanksep, [
                  leftRatio + 0.05,
                  1
                ]);
              }
              radius_1 += maxRanksep;
              isFirstLevel_1 = false;
              lastLayerMaxNodeSize_1 - layerNodes.maxSize;
            });
            g2.edges().forEach(function(edge) {
              var _a3, _b2, _c2;
              var coord = g2.edge(edge);
              var i2 = edges.findIndex(function(it2) {
                var source = (0, util_1.getEdgeTerminal)(it2, "source");
                var target = (0, util_1.getEdgeTerminal)(it2, "target");
                return source === edge.v && target === edge.w;
              });
              if (i2 <= -1)
                return;
              if (self2.edgeLabelSpace && self2.controlPoints && edges[i2].type !== "loop") {
                var otherDim_1 = dim_1 === "x" ? "y" : "x";
                var controlPoints = (_a3 = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a3 === void 0 ? void 0 : _a3.slice(1, coord.points.length - 1);
                var newControlPoints_1 = [];
                var sourceOtherDimValue_1 = (_b2 = g2.node(edge.v)) === null || _b2 === void 0 ? void 0 : _b2[otherDim_1];
                var otherDimDist_1 = sourceOtherDimValue_1 - ((_c2 = g2.node(edge.w)) === null || _c2 === void 0 ? void 0 : _c2[otherDim_1]);
                var sourceRadius_1 = radiusMap_1[edge.v];
                var radiusDist_1 = sourceRadius_1 - radiusMap_1[edge.w];
                controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.forEach(function(point) {
                  var cRadius = (point[otherDim_1] - sourceOtherDimValue_1) / otherDimDist_1 * radiusDist_1 + sourceRadius_1;
                  var newPos = getRadialPos_1(point[dim_1], range_1, rangeLength_1, cRadius);
                  newControlPoints_1.push({
                    x: newPos.x + dBegin[0],
                    y: newPos.y + dBegin[1]
                  });
                });
                edges[i2].controlPoints = newControlPoints_1;
              }
            });
          } else {
            var layerCoords_1 = /* @__PURE__ */ new Set();
            var isInvert = rankdir === "BT" || rankdir === "RL";
            var layerCoordSort = isInvert ? function(a3, b2) {
              return b2 - a3;
            } : function(a3, b2) {
              return a3 - b2;
            };
            g2.nodes().forEach(function(node) {
              var coord = g2.node(node);
              if (!coord)
                return;
              var ndata = _this.nodeMap[node];
              if (!ndata) {
                ndata = combos === null || combos === void 0 ? void 0 : combos.find(function(it2) {
                  return it2.id === node;
                });
              }
              if (!ndata)
                return;
              ndata.x = coord.x + dBegin[0];
              ndata.y = coord.y + dBegin[1];
              ndata._order = coord._order;
              layerCoords_1.add(isHorizontal ? ndata.x : ndata.y);
            });
            var layerCoordsArr_1 = Array.from(layerCoords_1).sort(layerCoordSort);
            var isDifferentLayer_1 = isHorizontal ? function(point1, point2) {
              return point1.x !== point2.x;
            } : function(point1, point2) {
              return point1.y !== point2.y;
            };
            var filterControlPointsOutOfBoundary_1 = isHorizontal ? function(ps, point1, point2) {
              var max4 = Math.max(point1.y, point2.y);
              var min3 = Math.min(point1.y, point2.y);
              return ps.filter(function(point) {
                return point.y <= max4 && point.y >= min3;
              });
            } : function(ps, point1, point2) {
              var max4 = Math.max(point1.x, point2.x);
              var min3 = Math.min(point1.x, point2.x);
              return ps.filter(function(point) {
                return point.x <= max4 && point.x >= min3;
              });
            };
            g2.edges().forEach(function(edge) {
              var _a3;
              var coord = g2.edge(edge);
              var i2 = edges.findIndex(function(it2) {
                var source = (0, util_1.getEdgeTerminal)(it2, "source");
                var target = (0, util_1.getEdgeTerminal)(it2, "target");
                return source === edge.v && target === edge.w;
              });
              if (i2 <= -1)
                return;
              if (self2.edgeLabelSpace && self2.controlPoints && edges[i2].type !== "loop") {
                (_a3 = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(point) {
                  point.x += dBegin[0];
                  point.y += dBegin[1];
                });
                var sourceNode = self2.nodeMap[edge.v];
                var targetNode = self2.nodeMap[edge.w];
                edges[i2].controlPoints = getControlPoints14(coord === null || coord === void 0 ? void 0 : coord.points, sourceNode, targetNode, layerCoordsArr_1, isHorizontal, isDifferentLayer_1, filterControlPointsOutOfBoundary_1);
              }
            });
          }
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        DagreLayout3.prototype.getRadialPos = function(dimValue, range, rangeLength, radius, arcRange) {
          if (arcRange === void 0) {
            arcRange = [0, 1];
          }
          var dimRatio = (dimValue - range[0]) / rangeLength;
          dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0];
          var angle = dimRatio * 2 * Math.PI;
          return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius
          };
        };
        DagreLayout3.prototype.getType = function() {
          return "dagre";
        };
        return DagreLayout3;
      }(base_1.Base)
    );
    exports.DagreLayout = DagreLayout2;
    var getControlPoints14 = function(points, sourceNode, targetNode, layerCoordsArr, isHorizontal, isDifferentLayer, filterControlPointsOutOfBoundary) {
      var controlPoints = (points === null || points === void 0 ? void 0 : points.slice(1, points.length - 1)) || [];
      if (sourceNode && targetNode) {
        var sourceX = sourceNode.x, sourceY = sourceNode.y;
        var targetX = targetNode.x, targetY = targetNode.y;
        if (isHorizontal) {
          sourceX = sourceNode.y;
          sourceY = sourceNode.x;
          targetX = targetNode.y;
          targetY = targetNode.x;
        }
        if (targetY !== sourceY && sourceX !== targetX) {
          var sourceLayer = layerCoordsArr.indexOf(sourceY);
          var sourceNextLayerCoord = layerCoordsArr[sourceLayer + 1];
          if (sourceNextLayerCoord) {
            var firstControlPoint = controlPoints[0];
            var insertStartControlPoint = isHorizontal ? {
              x: (sourceY + sourceNextLayerCoord) / 2,
              y: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.y) || targetX
            } : {
              x: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.x) || targetX,
              y: (sourceY + sourceNextLayerCoord) / 2
            };
            if (!firstControlPoint || isDifferentLayer(firstControlPoint, insertStartControlPoint)) {
              controlPoints.unshift(insertStartControlPoint);
            }
          }
          var targetLayer = layerCoordsArr.indexOf(targetY);
          var layerDiff = Math.abs(targetLayer - sourceLayer);
          if (layerDiff === 1) {
            controlPoints = filterControlPointsOutOfBoundary(controlPoints, sourceNode, targetNode);
            if (!controlPoints.length) {
              controlPoints.push(isHorizontal ? {
                x: (sourceY + targetY) / 2,
                y: sourceX
              } : {
                x: sourceX,
                y: (sourceY + targetY) / 2
              });
            }
          } else if (layerDiff > 1) {
            var targetLastLayerCoord = layerCoordsArr[targetLayer - 1];
            if (targetLastLayerCoord) {
              var lastControlPoints = controlPoints[controlPoints.length - 1];
              var insertEndControlPoint = isHorizontal ? {
                x: (targetY + targetLastLayerCoord) / 2,
                y: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.y) || targetX
              } : {
                x: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.x) || sourceX,
                y: (targetY + targetLastLayerCoord) / 2
              };
              if (!lastControlPoints || isDifferentLayer(lastControlPoints, insertEndControlPoint)) {
                controlPoints.push(insertEndControlPoint);
              }
            }
          }
        }
      }
      return controlPoints;
    };
  }
});

// node_modules/dagre-compound/dist/dagre-compound.es5.js
var dagre_compound_es5_exports = {};
__export(dagre_compound_es5_exports, {
  BRIDGE_GRAPH_NAME: () => o,
  GraphType: () => u,
  HierarchyNodeType: () => c2,
  InclusionType: () => a2,
  LAYOUT_CONFIG: () => e,
  NodeType: () => i,
  ROOT_NAME: () => r,
  buildGraph: () => rc,
  flatGraph: () => oc,
  getEdges: () => ic,
  mergeConfig: () => n
});
function n(n2 = {}, t2 = e) {
  var r2, o2, i2, a3;
  const u2 = JSON.parse(JSON.stringify(t2)), c3 = (null === (r2 = null == n2 ? void 0 : n2.graph) || void 0 === r2 ? void 0 : r2.meta) || {}, s2 = (null === (o2 = null == n2 ? void 0 : n2.subScene) || void 0 === o2 ? void 0 : o2.meta) || {}, d2 = (null === (i2 = null == n2 ? void 0 : n2.nodeSize) || void 0 === i2 ? void 0 : i2.meta) || {}, f2 = (null === (a3 = null == n2 ? void 0 : n2.nodeSize) || void 0 === a3 ? void 0 : a3.node) || {}, h2 = u2.nodeSize.bridge;
  return { graph: { meta: Object.assign(u2.graph.meta, c3) }, subScene: { meta: Object.assign(u2.subScene.meta, s2) }, nodeSize: { meta: Object.assign(u2.nodeSize.meta, d2), node: Object.assign(u2.nodeSize.node, f2), bridge: h2 } };
}
function t(e8) {
  return `◬${e8}◬`;
}
function d(e8, n2) {
  return e8(n2 = { exports: {} }, n2.exports), n2.exports;
}
function m2(e8) {
  var n2 = -1, t2 = null == e8 ? 0 : e8.length;
  for (this.clear(); ++n2 < t2; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function de(e8) {
  var n2 = -1, t2 = null == e8 ? 0 : e8.length;
  for (this.clear(); ++n2 < t2; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function me(e8) {
  var n2 = -1, t2 = null == e8 ? 0 : e8.length;
  for (this.clear(); ++n2 < t2; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function _e(e8) {
  var n2 = this.__data__ = new w(e8);
  this.size = n2.size;
}
function mt(e8) {
  var n2 = -1, t2 = null == e8 ? 0 : e8.length;
  for (this.__data__ = new we(); ++n2 < t2; )
    this.add(e8[n2]);
}
function Vt(e8, n2) {
  if ("function" != typeof e8 || null != n2 && "function" != typeof n2)
    throw new TypeError("Expected a function");
  var t2 = function() {
    var r2 = arguments, o2 = n2 ? n2.apply(this, r2) : r2[0], i2 = t2.cache;
    if (i2.has(o2))
      return i2.get(o2);
    var a3 = e8.apply(this, r2);
    return t2.cache = i2.set(o2, a3) || i2, a3;
  };
  return t2.cache = new (Vt.Cache || we)(), t2;
}
function vo(e8) {
  this._isDirected = !ho.has(e8, "directed") || e8.directed, this._isMultigraph = !!ho.has(e8, "multigraph") && e8.multigraph, this._isCompound = !!ho.has(e8, "compound") && e8.compound, this._label = void 0, this._defaultNodeLabelFn = ho.constant(void 0), this._defaultEdgeLabelFn = ho.constant(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children["\0"] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
}
function po(e8, n2) {
  e8[n2] ? e8[n2]++ : e8[n2] = 1;
}
function go(e8, n2) {
  --e8[n2] || delete e8[n2];
}
function yo(e8, n2, t2, r2) {
  var o2 = "" + n2, i2 = "" + t2;
  if (!e8 && o2 > i2) {
    var a3 = o2;
    o2 = i2, i2 = a3;
  }
  return o2 + "" + i2 + "" + (ho.isUndefined(r2) ? "\0" : r2);
}
function bo(e8, n2, t2, r2) {
  var o2 = "" + n2, i2 = "" + t2;
  if (!e8 && o2 > i2) {
    var a3 = o2;
    o2 = i2, i2 = a3;
  }
  var u2 = { v: o2, w: i2 };
  return r2 && (u2.name = r2), u2;
}
function mo(e8, n2) {
  return yo(e8, n2.v, n2.w, n2.name);
}
function _o(e8) {
  return ho.map(e8.nodes(), function(n2) {
    var t2 = e8.node(n2), r2 = e8.parent(n2), o2 = { v: n2 };
    return ho.isUndefined(t2) || (o2.value = t2), ho.isUndefined(r2) || (o2.parent = r2), o2;
  });
}
function jo(e8) {
  return ho.map(e8.edges(), function(n2) {
    var t2 = e8.edge(n2), r2 = { v: n2.v, w: n2.w };
    return ho.isUndefined(n2.name) || (r2.name = n2.name), ho.isUndefined(t2) || (r2.value = t2), r2;
  });
}
function Oo() {
  this._arr = [], this._keyIndices = {};
}
function Lo(e8) {
  var n2 = {}, t2 = {}, r2 = [];
  if (ho.each(e8.sinks(), function o2(i2) {
    if (ho.has(t2, i2))
      throw new Ro();
    ho.has(n2, i2) || (t2[i2] = true, n2[i2] = true, ho.each(e8.predecessors(i2), o2), delete t2[i2], r2.push(i2));
  }), ho.size(n2) !== e8.nodeCount())
    throw new Ro();
  return r2;
}
function Ro() {
}
function Do(e8, n2, t2, r2, o2, i2) {
  ho.has(r2, n2) || (r2[n2] = true, t2 || i2.push(n2), ho.each(o2(n2), function(n3) {
    Do(e8, n3, t2, r2, o2, i2);
  }), t2 && i2.push(n2));
}
function qi() {
  var e8 = {};
  e8._next = e8._prev = e8, this._sentinel = e8;
}
function Yi(e8) {
  e8._prev._next = e8._next, e8._next._prev = e8._prev, delete e8._next, delete e8._prev;
}
function Ji(e8, n2) {
  if ("_next" !== e8 && "_prev" !== e8)
    return n2;
}
function Zi(e8, n2, t2, r2, o2) {
  var i2 = o2 ? [] : void 0;
  return Hi.forEach(e8.inEdges(r2.v), function(r3) {
    var a3 = e8.edge(r3), u2 = e8.node(r3.v);
    o2 && i2.push({ v: r3.v, w: r3.w }), u2.out -= a3, ea(n2, t2, u2);
  }), Hi.forEach(e8.outEdges(r2.v), function(r3) {
    var o3 = e8.edge(r3), i3 = r3.w, a3 = e8.node(i3);
    a3.in -= o3, ea(n2, t2, a3);
  }), e8.removeNode(r2.v), i2;
}
function ea(e8, n2, t2) {
  t2.out ? t2.in ? e8[t2.out - t2.in + n2].enqueue(t2) : e8[e8.length - 1].enqueue(t2) : e8[0].enqueue(t2);
}
function oa(e8, n2, t2, r2) {
  var o2;
  do {
    o2 = Hi.uniqueId(r2);
  } while (e8.hasNode(o2));
  return t2.dummy = n2, e8.setNode(o2, t2), o2;
}
function ia(e8) {
  return Hi.max(Hi.map(e8.nodes(), function(n2) {
    var t2 = e8.node(n2).rank;
    if (!Hi.isUndefined(t2))
      return t2;
  }));
}
function ha(e8, n2) {
  return Hi.forEach(e8.nodes(), function t2(r2) {
    Hi.forEach(n2.nodeEdges(r2), function(o2) {
      var i2 = o2.v, a3 = r2 === i2 ? o2.w : i2;
      e8.hasNode(a3) || da(n2, o2) || (e8.setNode(a3, {}), e8.setEdge(r2, a3, {}), t2(a3));
    });
  }), e8.nodeCount();
}
function la(e8, n2) {
  return Hi.minBy(n2.edges(), function(t2) {
    if (e8.hasNode(t2.v) !== e8.hasNode(t2.w))
      return da(n2, t2);
  });
}
function va(e8, n2, t2) {
  Hi.forEach(e8.nodes(), function(e9) {
    n2.node(e9).rank += t2;
  });
}
function Ea(e8) {
  e8 = ma(e8), ga(e8);
  var n2, t2 = fa(e8);
  for (xa(t2), _a(t2, e8); n2 = Oa(t2); )
    Ia(t2, e8, n2, ka(t2, e8, n2));
}
function _a(e8, n2) {
  var t2 = ba(e8, e8.nodes());
  t2 = t2.slice(0, t2.length - 1), Hi.forEach(t2, function(t3) {
    !function(e9, n3, t4) {
      var r2 = e9.node(t4).parent;
      e9.edge(t4, r2).cutvalue = ja(e9, n3, t4);
    }(e8, n2, t3);
  });
}
function ja(e8, n2, t2) {
  var r2 = e8.node(t2).parent, o2 = true, i2 = n2.edge(t2, r2), a3 = 0;
  return i2 || (o2 = false, i2 = n2.edge(r2, t2)), a3 = i2.weight, Hi.forEach(n2.nodeEdges(t2), function(i3) {
    var u2, c3, s2 = i3.v === t2, d2 = s2 ? i3.w : i3.v;
    if (d2 !== r2) {
      var f2 = s2 === o2, h2 = n2.edge(i3).weight;
      if (a3 += f2 ? h2 : -h2, u2 = t2, c3 = d2, e8.hasEdge(u2, c3)) {
        var l2 = e8.edge(t2, d2).cutvalue;
        a3 += f2 ? -l2 : l2;
      }
    }
  }), a3;
}
function xa(e8, n2) {
  arguments.length < 2 && (n2 = e8.nodes()[0]), Na(e8, {}, 1, n2);
}
function Na(e8, n2, t2, r2, o2) {
  var i2 = t2, a3 = e8.node(r2);
  return n2[r2] = true, Hi.forEach(e8.neighbors(r2), function(o3) {
    Hi.has(n2, o3) || (t2 = Na(e8, n2, t2, o3, r2));
  }), a3.low = i2, a3.lim = t2++, o2 ? a3.parent = o2 : delete a3.parent, t2;
}
function Oa(e8) {
  return Hi.find(e8.edges(), function(n2) {
    return e8.edge(n2).cutvalue < 0;
  });
}
function ka(e8, n2, t2) {
  var r2 = t2.v, o2 = t2.w;
  n2.hasEdge(r2, o2) || (r2 = t2.w, o2 = t2.v);
  var i2 = e8.node(r2), a3 = e8.node(o2), u2 = i2, c3 = false;
  i2.lim > a3.lim && (u2 = a3, c3 = true);
  var s2 = Hi.filter(n2.edges(), function(n3) {
    return c3 === Sa(e8, e8.node(n3.v), u2) && c3 !== Sa(e8, e8.node(n3.w), u2);
  });
  return Hi.minBy(s2, function(e9) {
    return pa(n2, e9);
  });
}
function Ia(e8, n2, t2, r2) {
  var o2 = t2.v, i2 = t2.w;
  e8.removeEdge(o2, i2), e8.setEdge(r2.v, r2.w, {}), xa(e8), _a(e8, n2), function(e9, n3) {
    var t3 = Hi.find(e9.nodes(), function(e10) {
      return !n3.node(e10).parent;
    }), r3 = ya(e9, t3);
    r3 = r3.slice(1), Hi.forEach(r3, function(t4) {
      var r4 = e9.node(t4).parent, o3 = n3.edge(t4, r4), i3 = false;
      o3 || (o3 = n3.edge(r4, t4), i3 = true), n3.node(t4).rank = n3.node(r4).rank + (i3 ? o3.minlen : -o3.minlen);
    });
  }(e8, n2);
}
function Sa(e8, n2, t2) {
  return t2.low <= n2.lim && n2.lim <= t2.lim;
}
function Ba(e8) {
  wa(e8);
}
function Ra(e8, n2, t2, r2, o2, i2, a3) {
  var u2 = e8.children(a3);
  if (u2.length) {
    var c3 = ra.addBorderNode(e8, "_bt"), s2 = ra.addBorderNode(e8, "_bb"), d2 = e8.node(a3);
    e8.setParent(c3, a3), d2.borderTop = c3, e8.setParent(s2, a3), d2.borderBottom = s2, Hi.forEach(u2, function(u3) {
      Ra(e8, n2, t2, r2, o2, i2, u3);
      var d3 = e8.node(u3), f2 = d3.borderTop ? d3.borderTop : u3, h2 = d3.borderBottom ? d3.borderBottom : u3, l2 = d3.borderTop ? r2 : 2 * r2, v2 = f2 !== h2 ? 1 : o2 - i2[a3] + 1;
      e8.setEdge(c3, f2, { weight: l2, minlen: v2, nestingEdge: true }), e8.setEdge(h2, s2, { weight: l2, minlen: v2, nestingEdge: true });
    }), e8.parent(a3) || e8.setEdge(n2, c3, { weight: 0, minlen: o2 + i2[a3] });
  } else
    a3 !== n2 && e8.setEdge(n2, a3, { weight: 0, minlen: t2 });
}
function Da(e8, n2, t2, r2, o2, i2) {
  var a3 = { width: 0, height: 0, rank: i2, borderType: n2 }, u2 = o2[n2][i2 - 1], c3 = ra.addDummyNode(e8, "border", a3, t2);
  o2[n2][i2] = c3, e8.setParent(c3, r2), u2 && e8.setEdge(u2, c3, { weight: 1 });
}
function za(e8) {
  Hi.forEach(e8.nodes(), function(n2) {
    Fa(e8.node(n2));
  }), Hi.forEach(e8.edges(), function(n2) {
    Fa(e8.edge(n2));
  });
}
function Fa(e8) {
  var n2 = e8.width;
  e8.width = e8.height, e8.height = n2;
}
function Ua(e8) {
  e8.y = -e8.y;
}
function Va(e8) {
  var n2 = e8.x;
  e8.x = e8.y, e8.y = n2;
}
function Wa(e8, n2, t2) {
  for (var r2 = Hi.zipObject(t2, Hi.map(t2, function(e9, n3) {
    return n3;
  })), o2 = Hi.flatten(Hi.map(n2, function(n3) {
    return Hi.sortBy(Hi.map(e8.outEdges(n3), function(n4) {
      return { pos: r2[n4.w], weight: e8.edge(n4).weight };
    }), "pos");
  }), true), i2 = 1; i2 < t2.length; )
    i2 <<= 1;
  var a3 = 2 * i2 - 1;
  i2 -= 1;
  var u2 = Hi.map(new Array(a3), function() {
    return 0;
  }), c3 = 0;
  return Hi.forEach(o2.forEach(function(e9) {
    var n3 = e9.pos + i2;
    u2[n3] += e9.weight;
    for (var t3 = 0; n3 > 0; )
      n3 % 2 && (t3 += u2[n3 + 1]), u2[n3 = n3 - 1 >> 1] += e9.weight;
    c3 += e9.weight * t3;
  })), c3;
}
function Xa(e8, n2, t2) {
  for (var r2; n2.length && (r2 = Hi.last(n2)).i <= t2; )
    n2.pop(), e8.push(r2.vs), t2++;
  return t2;
}
function ru(e8, n2, t2) {
  return Hi.map(n2, function(n3) {
    return Za(e8, n3, t2);
  });
}
function ou(e8, n2) {
  var t2 = new nu();
  Hi.forEach(e8, function(e9) {
    var r2 = e9.graph().root, o2 = Ka(e9, r2, t2, n2);
    Hi.forEach(o2.vs, function(n3, t3) {
      e9.node(n3).order = t3;
    }), eu(e9, t2, o2.vs);
  });
}
function iu(e8, n2) {
  Hi.forEach(n2, function(n3) {
    Hi.forEach(n3, function(n4, t2) {
      e8.node(n4).order = t2;
    });
  });
}
function cu(e8, n2) {
  var t2 = {};
  return Hi.reduce(n2, function(n3, r2) {
    var o2 = 0, i2 = 0, a3 = n3.length, u2 = Hi.last(r2);
    return Hi.forEach(r2, function(n4, c3) {
      var s2 = function(e9, n5) {
        if (e9.node(n5).dummy)
          return Hi.find(e9.predecessors(n5), function(n6) {
            return e9.node(n6).dummy;
          });
      }(e8, n4), d2 = s2 ? e8.node(s2).order : a3;
      (s2 || n4 === u2) && (Hi.forEach(r2.slice(i2, c3 + 1), function(n5) {
        Hi.forEach(e8.predecessors(n5), function(r3) {
          var i3 = e8.node(r3), a4 = i3.order;
          !(a4 < o2 || d2 < a4) || i3.dummy && e8.node(n5).dummy || du(t2, r3, n5);
        });
      }), i2 = c3 + 1, o2 = d2);
    }), r2;
  }), t2;
}
function su(e8, n2) {
  var t2 = {};
  function r2(n3, r3, o2, i2, a3) {
    var u2;
    Hi.forEach(Hi.range(r3, o2), function(r4) {
      u2 = n3[r4], e8.node(u2).dummy && Hi.forEach(e8.predecessors(u2), function(n4) {
        var r5 = e8.node(n4);
        r5.dummy && (r5.order < i2 || r5.order > a3) && du(t2, n4, u2);
      });
    });
  }
  return Hi.reduce(n2, function(n3, t3) {
    var o2, i2 = -1, a3 = 0;
    return Hi.forEach(t3, function(u2, c3) {
      if ("border" === e8.node(u2).dummy) {
        var s2 = e8.predecessors(u2);
        s2.length && (o2 = e8.node(s2[0]).order, r2(t3, a3, c3, i2, o2), a3 = c3, i2 = o2);
      }
      r2(t3, a3, t3.length, o2, n3.length);
    }), t3;
  }), t2;
}
function du(e8, n2, t2) {
  if (n2 > t2) {
    var r2 = n2;
    n2 = t2, t2 = r2;
  }
  var o2 = e8[n2];
  o2 || (e8[n2] = o2 = {}), o2[t2] = true;
}
function fu(e8, n2, t2) {
  if (n2 > t2) {
    var r2 = n2;
    n2 = t2, t2 = r2;
  }
  return Hi.has(e8[n2], t2);
}
function hu(e8, n2, t2, r2) {
  var o2 = {}, i2 = {}, a3 = {};
  return Hi.forEach(n2, function(e9) {
    Hi.forEach(e9, function(e10, n3) {
      o2[e10] = e10, i2[e10] = e10, a3[e10] = n3;
    });
  }), Hi.forEach(n2, function(e9) {
    var n3 = -1;
    Hi.forEach(e9, function(e10) {
      var u2 = r2(e10);
      if (u2.length)
        for (var c3 = ((u2 = Hi.sortBy(u2, function(e11) {
          return a3[e11];
        })).length - 1) / 2, s2 = Math.floor(c3), d2 = Math.ceil(c3); s2 <= d2; ++s2) {
          var f2 = u2[s2];
          i2[e10] === e10 && n3 < a3[f2] && !fu(t2, e10, f2) && (i2[f2] = e10, i2[e10] = o2[e10] = o2[f2], n3 = a3[f2]);
        }
    });
  }), { root: o2, align: i2 };
}
function lu(e8, n2, t2, r2, o2) {
  var i2 = {}, a3 = function(e9, n3, t3, r3) {
    var o3 = new au(), i3 = e9.graph(), a4 = function(e10, n4, t4) {
      return function(r4, o4, i4) {
        var a5, u3 = r4.node(o4), c4 = r4.node(i4), s2 = 0;
        if (s2 += u3.width / 2, Hi.has(u3, "labelpos"))
          switch (u3.labelpos.toLowerCase()) {
            case "l":
              a5 = -u3.width / 2;
              break;
            case "r":
              a5 = u3.width / 2;
          }
        if (a5 && (s2 += t4 ? a5 : -a5), a5 = 0, s2 += (u3.dummy ? n4 : e10) / 2, s2 += (c4.dummy ? n4 : e10) / 2, s2 += c4.width / 2, Hi.has(c4, "labelpos"))
          switch (c4.labelpos.toLowerCase()) {
            case "l":
              a5 = c4.width / 2;
              break;
            case "r":
              a5 = -c4.width / 2;
          }
        return a5 && (s2 += t4 ? a5 : -a5), a5 = 0, s2;
      };
    }(i3.nodesep, i3.edgesep, r3);
    return Hi.forEach(n3, function(n4) {
      var r4;
      Hi.forEach(n4, function(n5) {
        var i4 = t3[n5];
        if (o3.setNode(i4), r4) {
          var u3 = t3[r4], c4 = o3.edge(u3, i4);
          o3.setEdge(u3, i4, Math.max(a4(e9, n5, r4), c4 || 0));
        }
        r4 = n5;
      });
    }), o3;
  }(e8, n2, t2, o2), u2 = o2 ? "borderLeft" : "borderRight";
  function c3(e9, n3) {
    for (var t3 = a3.nodes(), r3 = t3.pop(), o3 = {}; r3; )
      o3[r3] ? e9(r3) : (o3[r3] = true, t3.push(r3), t3 = t3.concat(n3(r3))), r3 = t3.pop();
  }
  return c3(function(e9) {
    i2[e9] = a3.inEdges(e9).reduce(function(e10, n3) {
      return Math.max(e10, i2[n3.v] + a3.edge(n3));
    }, 0);
  }, a3.predecessors.bind(a3)), c3(function(n3) {
    var t3 = a3.outEdges(n3).reduce(function(e9, n4) {
      return Math.min(e9, i2[n4.w] - a3.edge(n4));
    }, Number.POSITIVE_INFINITY), r3 = e8.node(n3);
    t3 !== Number.POSITIVE_INFINITY && r3.borderType !== u2 && (i2[n3] = Math.max(i2[n3], t3));
  }, a3.successors.bind(a3)), Hi.forEach(r2, function(e9) {
    i2[e9] = i2[t2[e9]];
  }), i2;
}
function vu(e8, n2) {
  return Hi.minBy(Hi.values(n2), function(n3) {
    var t2 = Number.NEGATIVE_INFINITY, r2 = Number.POSITIVE_INFINITY;
    return Hi.forIn(n3, function(n4, o2) {
      var i2 = function(e9, n5) {
        return e9.node(n5).width;
      }(e8, o2) / 2;
      t2 = Math.max(n4 + i2, t2), r2 = Math.min(n4 - i2, r2);
    }), t2 - r2;
  });
}
function pu(e8, n2) {
  var t2 = Hi.values(n2), r2 = Hi.min(t2), o2 = Hi.max(t2);
  Hi.forEach(["u", "d"], function(t3) {
    Hi.forEach(["l", "r"], function(i2) {
      var a3, u2 = t3 + i2, c3 = e8[u2];
      if (c3 !== n2) {
        var s2 = Hi.values(c3);
        (a3 = "l" === i2 ? r2 - Hi.min(s2) : o2 - Hi.max(s2)) && (e8[u2] = Hi.mapValues(c3, function(e9) {
          return e9 + a3;
        }));
      }
    });
  });
}
function gu(e8, n2) {
  return Hi.mapValues(e8.ul, function(t2, r2) {
    if (n2)
      return e8[n2.toLowerCase()][r2];
    var o2 = Hi.sortBy(Hi.map(e8, r2));
    return (o2[1] + o2[2]) / 2;
  });
}
function Gu(e8, n2) {
  return Hi.mapValues(Hi.pick(e8, n2), Number);
}
function Bu(e8) {
  var n2 = {};
  return Hi.forEach(e8, function(e9, t2) {
    n2[t2.toLowerCase()] = e9;
  }), n2;
}
function zu(e8) {
  const n2 = new Pu();
  return e8.nodes.map((e9) => new Du(e9)).forEach((e9) => {
    n2.nodes[e9.name] = e9, e9.inputs.forEach((t2) => {
      !function(e10, n3, t3) {
        t3.name !== n3.name && e10.edges.push(Object.assign(Object.assign({}, t3.attr), { v: t3.name, w: n3.name }));
      }(n2, e9, t2);
    });
  }), n2;
}
function Vu(e8, n2 = {}) {
  return new Fu(e8, n2);
}
function $u(e8, n2) {
  return new Uu(e8, n2);
}
function Hu(e8, n2, t2) {
  const r2 = t2 || {}, o2 = new Ru.Graph(r2);
  return o2.setGraph({ name: e8, rankdir: r2.rankdir, type: n2, align: r2.align }), o2;
}
function qu(e8, n2) {
  const { rankDirection: t2, align: r2 } = n2, o2 = new Wu({ rankdir: t2, align: r2 });
  return function(e9, n3) {
    Object.keys(n3.nodes).forEach((t3) => {
      const r3 = n3.nodes[t3], o3 = r3.path;
      let i2 = e9.root;
      i2.depth = Math.max(o3.length, i2.depth);
      for (let n4 = 0; n4 < o3.length && (i2.depth = Math.max(i2.depth, o3.length - n4), i2.cardinality += r3.cardinality, n4 !== o3.length - 1); n4++) {
        const t4 = o3[n4];
        let a3 = e9.node(t4);
        a3 || (a3 = Vu(t4, e9.graphOptions), a3.path = r3.path.slice(0, n4 + 1), a3.parentNode = i2, e9.setNode(t4, a3), i2.metaGraph.setNode(t4, a3)), i2 = a3;
      }
      e9.setNode(r3.name, r3), r3.parentNode = i2, i2.metaGraph.setNode(r3.name, r3);
    });
  }(o2, e8), function(e9, n3) {
    const t3 = e9.getNodeMap();
    let r3 = [], o3 = [];
    const i2 = (e10, n4) => {
      let t4 = 0;
      for (; e10; )
        n4[t4++] = e10.name, e10 = e10.parentNode;
      return t4 - 1;
    };
    n3.edges.forEach((a3) => {
      r3 = [], o3 = [];
      let u2 = i2(n3.nodes[a3.v], r3), c3 = i2(n3.nodes[a3.w], o3);
      for (; r3[u2] === o3[c3]; )
        if (u2--, c3--, u2 < 0 || c3 < 0)
          throw Error("No difference found between ancestor paths.");
      const s2 = t3[r3[u2 + 1]], d2 = r3[u2], f2 = o3[c3];
      let h2 = s2.metaGraph.edge(d2, f2);
      h2 || (h2 = $u(d2, f2), s2.metaGraph.setEdge(d2, f2, h2)), h2.addBaseEdge(a3, e9);
    });
  }(o2, e8), o2;
}
function Yu(e8, n2, t2, r2) {
  (t2 ? e8.inEdges(n2.name) : e8.outEdges(n2.name)).forEach((n3) => {
    const t3 = e8.edge(n3);
    r2.push(t3);
  });
}
function Zu(e8, t2) {
  e8.node.isGroupNode && function(e9, t3) {
    const r2 = n(t3);
    e9.coreGraph.nodes().map((n2) => e9.coreGraph.node(n2)).forEach((e10) => {
      var n2, o2, a3, u2, c3, s2;
      const { height: d2, width: f2 } = e10;
      switch (e10.node.type) {
        case i.NODE:
          Object.assign(e10, r2.nodeSize.node), e10.height = d2 || r2.nodeSize.node.height, e10.width = f2 || r2.nodeSize.node.width;
          break;
        case i.BRIDGE:
          Object.assign(e10, r2.nodeSize.bridge);
          break;
        case i.META:
          if (e10.expanded) {
            Zu(e10, t3);
          } else
            Object.assign(e10, r2.nodeSize.meta), e10.height = r2.nodeSize.meta.height, e10.width = r2.nodeSize.meta.width;
          break;
        default:
          throw Error("Unrecognized node type: " + e10.node.type);
      }
      if (!e10.expanded) {
        const r3 = e10.attr;
        !function(e11, n3 = false) {
          if (e11.coreBox.width = e11.width, e11.coreBox.height = e11.height, !n3) {
            const n4 = `${e11.displayName}`.length, t4 = 3;
            e11.width = Math.max(e11.coreBox.width, n4 * t4);
          }
        }(e10, t3 && (0 === e10.node.type && !!(null === (o2 = null === (n2 = null == t3 ? void 0 : t3.nodeSize) || void 0 === n2 ? void 0 : n2.meta) || void 0 === o2 ? void 0 : o2.width) || 1 === e10.node.type && (!!(null === (u2 = null === (a3 = null == t3 ? void 0 : t3.nodeSize) || void 0 === a3 ? void 0 : a3.node) || void 0 === u2 ? void 0 : u2.width) || !!r3.width) || 2 === e10.node.type && !!(null === (s2 = null === (c3 = null == t3 ? void 0 : t3.nodeSize) || void 0 === c3 ? void 0 : c3.bridge) || void 0 === s2 ? void 0 : s2.width)));
      }
    });
  }(e8, t2), e8.node.type === i.META && function(e9, t3) {
    const r2 = n(t3), o2 = r2.subScene.meta;
    Object.assign(e9, o2);
    const { nodeSep: a3, rankSep: u2, edgeSep: c3, align: s2 } = r2.graph.meta, d2 = { nodesep: a3, ranksep: u2, edgesep: c3, align: s2 };
    Object.assign(e9.coreBox, function(e10, n2) {
      const { ranksep: t4, nodesep: r3, edgesep: o3, align: a4 } = n2;
      Object.assign(e10.graph(), { ranksep: t4, nodesep: r3, edgesep: o3, align: a4 });
      const u3 = [];
      if (e10.nodes().forEach((n3) => {
        e10.node(n3).node.type !== i.BRIDGE && u3.push(n3);
      }), !u3.length)
        return { width: 0, height: 0 };
      Tu(e10);
      let c4 = 1 / 0, s3 = 1 / 0, d3 = -1 / 0, f3 = -1 / 0;
      return u3.forEach((n3) => {
        const t5 = e10.node(n3), r4 = 0.5 * t5.width, o4 = t5.x - r4, i2 = t5.x + r4;
        c4 = o4 < c4 ? o4 : c4, d3 = i2 > d3 ? i2 : d3;
        const a5 = 0.5 * t5.height, u4 = t5.y - a5, h3 = t5.y + a5;
        s3 = u4 < s3 ? u4 : s3, f3 = h3 > f3 ? h3 : f3;
      }), e10.edges().forEach((n3) => {
        const t5 = e10.edge(n3), r4 = e10.node(t5.metaEdge.v), o4 = e10.node(t5.metaEdge.w);
        if (3 === t5.points.length && function(e11) {
          let n4 = ec(e11[0], e11[1]);
          for (let t6 = 1; t6 < e11.length - 1; t6++) {
            const r5 = ec(e11[t6], e11[t6 + 1]);
            if (Math.abs(r5 - n4) > 1)
              return false;
            n4 = r5;
          }
          return true;
        }(t5.points)) {
          if (null != r4) {
            const e11 = r4.expanded ? r4.x : nc(r4);
            t5.points[0].x = e11;
          }
          if (null != o4) {
            const e11 = o4.expanded ? o4.x : nc(o4);
            t5.points[2].x = e11;
          }
          t5.points = [t5.points[0], t5.points[1]];
        }
        const i2 = t5.points[t5.points.length - 2];
        null != o4 && (t5.points[t5.points.length - 1] = tc(i2, o4));
        const a5 = t5.points[1];
        null != r4 && (t5.points[0] = tc(a5, r4)), t5.points.forEach((e11) => {
          c4 = e11.x < c4 ? e11.x : c4, d3 = e11.x > d3 ? e11.x : d3, s3 = e11.y < s3 ? e11.y : s3, f3 = e11.y > f3 ? e11.y : f3;
        });
      }), e10.nodes().forEach((n3) => {
        const t5 = e10.node(n3);
        t5.x -= c4, t5.y -= s3;
      }), e10.edges().forEach((n3) => {
        e10.edge(n3).points.forEach((e11) => {
          e11.x -= c4, e11.y -= s3;
        });
      }), { width: d3 - c4, height: f3 - s3 };
    }(e9.coreGraph, d2));
    let f2 = 0;
    e9.coreGraph.nodeCount() > 0 && f2++;
    const h2 = f2 <= 1 ? 0 : f2;
    e9.coreBox.width += h2 + h2, e9.coreBox.height = o2.labelHeight + e9.coreBox.height, e9.width = e9.coreBox.width + o2.paddingLeft + o2.paddingRight, e9.height = e9.paddingTop + e9.coreBox.height + e9.paddingBottom;
  }(e8, t2);
}
function ec(e8, n2) {
  const t2 = n2.x - e8.x, r2 = n2.y - e8.y;
  return 180 * Math.atan(r2 / t2) / Math.PI;
}
function nc(e8) {
  if (e8.expanded)
    return e8.x;
  return e8.x - e8.width / 2 + 0 + e8.coreBox.width / 2;
}
function tc(e8, n2) {
  const t2 = n2.expanded ? n2.x : nc(n2), r2 = n2.y, o2 = e8.x - t2, i2 = e8.y - r2;
  let a3, u2, c3 = n2.expanded ? n2.width : n2.coreBox.width, s2 = n2.expanded ? n2.height : n2.coreBox.height;
  return Math.abs(i2) * c3 / 2 > Math.abs(o2) * s2 / 2 ? (i2 < 0 && (s2 = -s2), a3 = 0 === i2 ? 0 : s2 / 2 * o2 / i2, u2 = s2 / 2) : (o2 < 0 && (c3 = -c3), a3 = c3 / 2, u2 = 0 === o2 ? 0 : c3 / 2 * i2 / o2), { x: t2 + a3, y: r2 + u2 };
}
function rc(n2, t2, r2) {
  var o2, i2, a3, u2;
  const c3 = n2.nodes.filter((e8, n3, t3) => t3.findIndex((n4) => n4.id === e8.id) !== n3).map((e8) => e8.id);
  if (c3.length)
    throw new Error(`Duplicated ids found: ${c3.join(", ")}`);
  const s2 = function(e8) {
    const n3 = { nodes: [] }, t3 = e8.compound, r3 = Object.keys(t3 || {}), o3 = /* @__PURE__ */ new Map(), i3 = (e9, n4 = []) => {
      if (o3.has(e9))
        return o3.get(e9);
      for (let o4 = 0; o4 < r3.length; o4++) {
        let a5 = r3[o4];
        if (t3 && -1 !== t3[a5].indexOf(e9))
          return n4.unshift(a5), i3(a5, n4);
      }
      return 0 === n4.length && o3.set(e9, n4), n4;
    }, a4 = (n4) => e8.edges.filter((e9) => e9.w === n4).map((e9) => ({ name: e9.v }));
    return e8.nodes.forEach((e9) => {
      const t4 = e9.id, r4 = [...i3(t4), t4];
      let o4 = a4(t4);
      n3.nodes.push({ name: t4, path: r4, inputs: o4, width: e9.width, height: e9.height, attr: Object.assign({}, e9) });
    }), n3;
  }(n2), d2 = function(e8, n3) {
    const t3 = (e9, n4) => {
      for (let t4 of n4.values())
        if (t4.includes(e9))
          return true;
      return false;
    }, r3 = (e9, n4 = []) => {
      if (0 === Object.keys(e9).length)
        return [...new Set(n4)];
      const o3 = new Map(Object.keys(e9).map((n5) => [n5, e9[n5]])), i3 = {};
      for (let [e10, r4] of o3)
        t3(e10, o3) ? i3[e10] = r4 : n4 = n4.concat(e10, r4);
      return r3(i3, n4);
    };
    return r3(e8).filter((e9) => n3.includes(e9));
  }(n2.compound || {}, (null == t2 ? void 0 : t2.expanded) || []), f2 = function(e8, n3) {
    return function(e9) {
      return new Ju(e9);
    }(qu(zu(e8), n3));
  }(s2, { rankDirection: (null === (i2 = null === (o2 = null == r2 ? void 0 : r2.graph) || void 0 === o2 ? void 0 : o2.meta) || void 0 === i2 ? void 0 : i2.rankDir) || (null == t2 ? void 0 : t2.rankDirection) || e.graph.meta.rankDir, align: (null === (u2 = null === (a3 = null == r2 ? void 0 : r2.graph) || void 0 === a3 ? void 0 : a3.meta) || void 0 === u2 ? void 0 : u2.align) || e.graph.meta.align });
  return function(e8, n3) {
    n3.forEach((n4) => {
      const t3 = e8.getRenderInfoNodes().find((e9) => e9.displayName === n4);
      let r3 = t3 && t3.node && t3.node.name || "";
      const o3 = e8.getRenderNodeByName(r3);
      if (!o3)
        throw new Error(`No nodes found: ${r3}`);
      o3.expanded = true, e8.buildSubHierarchy(r3);
    });
  }(f2, d2), Zu(f2.root, r2), ac(f2.root);
}
function oc(e8, n2 = false) {
  const t2 = JSON.parse(JSON.stringify(e8)), o2 = { nodes: [t2], edges: [...t2.edges] };
  return t2.nodes.forEach(function e9(n3) {
    (0 === n3.type || 1 === n3.type) && o2.nodes.push(n3), 0 === n3.type && (o2.edges = o2.edges.concat(n3.edges)), Array.isArray(n3.nodes) && n3.nodes.forEach(e9);
  }), n2 && o2.nodes.forEach((e9) => {
    const n3 = o2.nodes.find((n4) => n4.id === e9.parentNodeName);
    if (n3) {
      const t3 = n3.x - n3.width / 2 + n3.paddingLeft, o3 = n3.y - n3.height / 2 + n3.labelHeight + n3.paddingTop;
      n3.id !== r && (e9.x += t3, e9.y += o3), 0 === e9.type && e9.edges.forEach((n4) => {
        n4.points.forEach((n5) => {
          n5.x += e9.x - e9.width / 2 + e9.paddingLeft, n5.y += e9.y - e9.height / 2 + e9.labelHeight + e9.paddingTop;
        });
      });
    }
  }), o2;
}
function ic(e8, n2, t2, o2) {
  var i2, a3;
  let u2 = [];
  const c3 = (null === (i2 = t2.find((n3) => n3.id === e8)) || void 0 === i2 ? void 0 : i2.path) || [], s2 = (null === (a3 = t2.find((e9) => e9.id === n2)) || void 0 === a3 ? void 0 : a3.path) || [], d2 = [r, ...c3].slice(0, c3.length).reverse(), f2 = [r, ...s2].slice(0, s2.length);
  return d2.forEach((r2) => {
    const i3 = t2.find((e9) => e9.id === r2);
    u2 = u2.concat(i3.edges.filter((t3) => t3.baseEdgeList.some((t4) => t4.v === ((null == o2 ? void 0 : o2.v) || e8) && t4.w === ((null == o2 ? void 0 : o2.w) || n2))));
  }), f2.filter((e9) => !d2.includes(e9)).forEach((r2) => {
    const i3 = t2.find((e9) => e9.id === r2);
    u2 = u2.concat(i3.edges.filter((t3) => t3.baseEdgeList.some((t4) => t4.v === ((null == o2 ? void 0 : o2.v) || e8) && t4.w === ((null == o2 ? void 0 : o2.w) || n2))));
  }), u2;
}
function ac(e8) {
  const n2 = e8.coreGraph.nodes().map((n3) => e8.coreGraph.node(n3));
  return Object.assign(Object.assign({}, uc(e8)), { expanded: e8.expanded, nodes: e8.expanded ? (t2 = n2, t2.map((e9) => e9.node.type === i.META ? ac(e9) : uc(e9))) : [], edges: e8.expanded ? cc(e8) : [] });
  var t2;
}
function uc(e8) {
  return { id: e8.node.name, name: e8.node.name, type: e8.node.type, cardinality: e8.node.cardinality, attr: e8.attr, parentNodeName: e8.node.parentNode ? e8.node.parentNode.name : null, coreBox: Object.assign({}, e8.coreBox), x: e8.x, y: e8.y, width: e8.width, height: e8.height, radius: e8.radius, labelHeight: e8.labelHeight, labelOffset: e8.labelOffset, outboxWidth: e8.outboxWidth, paddingLeft: e8.paddingLeft, paddingTop: e8.paddingTop, paddingRight: e8.paddingRight, paddingBottom: e8.paddingBottom, path: e8.node.path };
}
function cc(e8) {
  return e8.coreGraph.edges().map((n2) => ({ renderInfoEdge: e8.coreGraph.edge(n2), edge: n2 })).filter(({ renderInfoEdge: e9 }) => e9.metaEdge).map(({ edge: n2, renderInfoEdge: t2 }) => {
    const r2 = function(e9, n3) {
      const t3 = n3.points.map((e10) => Object.assign({}, e10));
      if (n3.adjoiningMetaEdge) {
        const r3 = n3.adjoiningMetaEdge.points, o2 = n3.metaEdge.inbound, i2 = o2 ? r3[r3.length - 1] : r3[0], a3 = t3[o2 ? 0 : t3.length - 1], u2 = e9.x - e9.width / 2, c3 = e9.y - e9.height / 2, s2 = i2.x - u2, d2 = i2.y - c3, f2 = -e9.paddingLeft, h2 = -(e9.paddingTop + e9.labelHeight);
        a3.x = s2 + f2, a3.y = d2 + h2;
      }
      return t3;
    }(e8, t2);
    return { adjoiningEdge: t2.adjoiningMetaEdge ? { w: t2.adjoiningMetaEdge.metaEdge.w, v: t2.adjoiningMetaEdge.metaEdge.v } : null, inbound: t2.metaEdge.inbound, w: n2.w, v: n2.v, points: r2, weight: t2.weight, baseEdgeList: t2.metaEdge.baseEdgeList, parentNodeName: e8.node.name };
  });
}
var e, r, o, i, a2, u, c2, s, f, h, l, v, p, g, y3, b, w, E, _, j, x3, N, O, k, I, S, M, C, G, B, A, L, R, T, D, P, z, F, U, V, $, H, W, q, Y, J, X, K, Q, Z, ee, ne, te, re, oe, ie, ae, ue, ce, se, fe, he, le, ve, pe, ge, ye, be, we, Ee, je, xe, Ne, Oe, ke, Ie, Se, Me, Ce, Ge, Be, Ae, Le, Re, Te, De, Pe, ze, Fe, Ue, Ve, $e, He, We, qe, Ye, Je, Xe, Ke, Qe, Ze, en, nn, tn, rn, on, an, un, cn, sn, dn, fn, hn, ln, vn, pn, gn, yn, bn, mn, wn, En, _n, jn, xn, Nn, On, kn, In, Sn, Mn, Cn, Gn, Bn, An, Ln, Rn, Tn, Dn, Pn, zn, Fn, Un, Vn, $n, Hn, Wn, qn, Yn, Jn, Xn, Kn, Qn, Zn, et, nt, tt, rt, ot, it, at, ut, ct, st, dt, ft, ht, lt, vt, pt, gt, yt, bt, wt, Et, _t, jt, xt, Nt, Ot, kt, It, St, Mt, Ct, Gt, Bt, At, Lt, Rt, Tt, Dt, Pt, zt, Ft, Ut, $t, Ht, Wt, qt, Yt, Jt, Xt, Kt, Qt, Zt, er, nr, tr, rr, or, ir, ar, ur, cr, sr, dr, fr, hr, lr, vr, pr, gr, yr, br, mr, wr, Er, _r, jr, xr, Nr, Or, kr, Ir, Sr, Mr, Cr, Gr, Br, Ar, Lr, Rr, Tr, Dr, Pr, zr, Fr, Ur, Vr, $r, Hr, Wr, qr, Yr, Jr, Xr, Kr, Qr, Zr, eo, no, to, ro, oo, io, ao, uo, co, so, fo, ho, lo, wo, Eo, xo, No, ko, Io, So, Mo, Co, Go, Bo, Ao, To, Po, zo, Fo, Uo, Vo, $o, Ho, Wo, qo, Yo, Jo, Xo, Ko, Qo, Zo, ei, ni, ti, ri, oi, ii, ai, ui, ci, si, di, fi, hi, li, vi, pi, gi, yi, bi, mi, wi, Ei, _i, ji, xi, Ni, Oi, ki, Ii, Si, Mi, Ci, Gi, Bi, Ai, Li, Ri, Ti, Di, Pi, zi, Fi, Ui, Vi, $i, Hi, Wi, Xi, Ki, Qi, na, ta, ra, aa, ua, ca, sa, da, fa, pa, ga, ya, ba, ma, wa, Ma, Ca, Ga, Aa, La, Ta, Pa, $a, Ha, qa, Ya, Ja, Ka, Qa, Za, eu, nu, tu, au, uu, yu, bu, mu, wu, Eu, _u, ju, xu, Nu, Ou, ku, Iu, Su, Mu, Cu, Au, Lu, Ru, Tu, Du, Pu, Fu, Uu, Wu, Ju, Xu, Ku, Qu;
var init_dagre_compound_es5 = __esm({
  "node_modules/dagre-compound/dist/dagre-compound.es5.js"() {
    e = { graph: { meta: { rankDir: "TB", nodeSep: 50, rankSep: 50, edgeSep: 5, align: void 0 } }, subScene: { meta: { paddingTop: 20, paddingBottom: 20, paddingLeft: 20, paddingRight: 20, labelHeight: 20 } }, nodeSize: { meta: { width: 100, maxLabelWidth: 0, height: 20 }, node: { width: 80, height: 20, labelOffset: 10, maxLabelWidth: 40 }, bridge: { width: 5, height: 5, radius: 2, labelOffset: 0 } } };
    r = t("ROOT");
    o = t("BRIDGE_GRAPH");
    !function(e8) {
      e8[e8.META = 0] = "META", e8[e8.NODE = 1] = "NODE", e8[e8.BRIDGE = 2] = "BRIDGE";
    }(i || (i = {})), function(e8) {
      e8[e8.INCLUDE = 0] = "INCLUDE", e8[e8.EXCLUDE = 1] = "EXCLUDE", e8[e8.UNSPECIFIED = 2] = "UNSPECIFIED";
    }(a2 || (a2 = {})), function(e8) {
      e8[e8.META = 0] = "META", e8[e8.CORE = 1] = "CORE", e8[e8.BRIDGE = 2] = "BRIDGE";
    }(u || (u = {})), function(e8) {
      e8[e8.META = 0] = "META", e8[e8.OP = 1] = "OP", e8[e8.SERIES = 2] = "SERIES";
    }(c2 || (c2 = {}));
    s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    f = function() {
      this.__data__ = [], this.size = 0;
    };
    h = function(e8, n2) {
      return e8 === n2 || e8 != e8 && n2 != n2;
    };
    l = function(e8, n2) {
      for (var t2 = e8.length; t2--; )
        if (h(e8[t2][0], n2))
          return t2;
      return -1;
    };
    v = Array.prototype.splice;
    p = function(e8) {
      var n2 = this.__data__, t2 = l(n2, e8);
      return !(t2 < 0) && (t2 == n2.length - 1 ? n2.pop() : v.call(n2, t2, 1), --this.size, true);
    };
    g = function(e8) {
      var n2 = this.__data__, t2 = l(n2, e8);
      return t2 < 0 ? void 0 : n2[t2][1];
    };
    y3 = function(e8) {
      return l(this.__data__, e8) > -1;
    };
    b = function(e8, n2) {
      var t2 = this.__data__, r2 = l(t2, e8);
      return r2 < 0 ? (++this.size, t2.push([e8, n2])) : t2[r2][1] = n2, this;
    };
    m2.prototype.clear = f, m2.prototype.delete = p, m2.prototype.get = g, m2.prototype.has = y3, m2.prototype.set = b;
    w = m2;
    E = function() {
      this.__data__ = new w(), this.size = 0;
    };
    _ = function(e8) {
      var n2 = this.__data__, t2 = n2.delete(e8);
      return this.size = n2.size, t2;
    };
    j = function(e8) {
      return this.__data__.get(e8);
    };
    x3 = function(e8) {
      return this.__data__.has(e8);
    };
    N = "object" == typeof s && s && s.Object === Object && s;
    O = "object" == typeof self && self && self.Object === Object && self;
    k = N || O || Function("return this")();
    I = k.Symbol;
    S = Object.prototype;
    M = S.hasOwnProperty;
    C = S.toString;
    G = I ? I.toStringTag : void 0;
    B = function(e8) {
      var n2 = M.call(e8, G), t2 = e8[G];
      try {
        e8[G] = void 0;
        var r2 = true;
      } catch (e9) {
      }
      var o2 = C.call(e8);
      return r2 && (n2 ? e8[G] = t2 : delete e8[G]), o2;
    };
    A = Object.prototype.toString;
    L = function(e8) {
      return A.call(e8);
    };
    R = I ? I.toStringTag : void 0;
    T = function(e8) {
      return null == e8 ? void 0 === e8 ? "[object Undefined]" : "[object Null]" : R && R in Object(e8) ? B(e8) : L(e8);
    };
    D = function(e8) {
      var n2 = typeof e8;
      return null != e8 && ("object" == n2 || "function" == n2);
    };
    z = function(e8) {
      if (!D(e8))
        return false;
      var n2 = T(e8);
      return "[object Function]" == n2 || "[object GeneratorFunction]" == n2 || "[object AsyncFunction]" == n2 || "[object Proxy]" == n2;
    };
    F = k["__core-js_shared__"];
    U = (P = /[^.]+$/.exec(F && F.keys && F.keys.IE_PROTO || "")) ? "Symbol(src)_1." + P : "";
    V = function(e8) {
      return !!U && U in e8;
    };
    $ = Function.prototype.toString;
    H = function(e8) {
      if (null != e8) {
        try {
          return $.call(e8);
        } catch (e9) {
        }
        try {
          return e8 + "";
        } catch (e9) {
        }
      }
      return "";
    };
    W = /^\[object .+?Constructor\]$/;
    q = Function.prototype;
    Y = Object.prototype;
    J = q.toString;
    X = Y.hasOwnProperty;
    K = RegExp("^" + J.call(X).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    Q = function(e8) {
      return !(!D(e8) || V(e8)) && (z(e8) ? K : W).test(H(e8));
    };
    Z = function(e8, n2) {
      return null == e8 ? void 0 : e8[n2];
    };
    ee = function(e8, n2) {
      var t2 = Z(e8, n2);
      return Q(t2) ? t2 : void 0;
    };
    ne = ee(k, "Map");
    te = ee(Object, "create");
    re = function() {
      this.__data__ = te ? te(null) : {}, this.size = 0;
    };
    oe = function(e8) {
      var n2 = this.has(e8) && delete this.__data__[e8];
      return this.size -= n2 ? 1 : 0, n2;
    };
    ie = Object.prototype.hasOwnProperty;
    ae = function(e8) {
      var n2 = this.__data__;
      if (te) {
        var t2 = n2[e8];
        return "__lodash_hash_undefined__" === t2 ? void 0 : t2;
      }
      return ie.call(n2, e8) ? n2[e8] : void 0;
    };
    ue = Object.prototype.hasOwnProperty;
    ce = function(e8) {
      var n2 = this.__data__;
      return te ? void 0 !== n2[e8] : ue.call(n2, e8);
    };
    se = function(e8, n2) {
      var t2 = this.__data__;
      return this.size += this.has(e8) ? 0 : 1, t2[e8] = te && void 0 === n2 ? "__lodash_hash_undefined__" : n2, this;
    };
    de.prototype.clear = re, de.prototype.delete = oe, de.prototype.get = ae, de.prototype.has = ce, de.prototype.set = se;
    fe = de;
    he = function() {
      this.size = 0, this.__data__ = { hash: new fe(), map: new (ne || w)(), string: new fe() };
    };
    le = function(e8) {
      var n2 = typeof e8;
      return "string" == n2 || "number" == n2 || "symbol" == n2 || "boolean" == n2 ? "__proto__" !== e8 : null === e8;
    };
    ve = function(e8, n2) {
      var t2 = e8.__data__;
      return le(n2) ? t2["string" == typeof n2 ? "string" : "hash"] : t2.map;
    };
    pe = function(e8) {
      var n2 = ve(this, e8).delete(e8);
      return this.size -= n2 ? 1 : 0, n2;
    };
    ge = function(e8) {
      return ve(this, e8).get(e8);
    };
    ye = function(e8) {
      return ve(this, e8).has(e8);
    };
    be = function(e8, n2) {
      var t2 = ve(this, e8), r2 = t2.size;
      return t2.set(e8, n2), this.size += t2.size == r2 ? 0 : 1, this;
    };
    me.prototype.clear = he, me.prototype.delete = pe, me.prototype.get = ge, me.prototype.has = ye, me.prototype.set = be;
    we = me;
    Ee = function(e8, n2) {
      var t2 = this.__data__;
      if (t2 instanceof w) {
        var r2 = t2.__data__;
        if (!ne || r2.length < 199)
          return r2.push([e8, n2]), this.size = ++t2.size, this;
        t2 = this.__data__ = new we(r2);
      }
      return t2.set(e8, n2), this.size = t2.size, this;
    };
    _e.prototype.clear = E, _e.prototype.delete = _, _e.prototype.get = j, _e.prototype.has = x3, _e.prototype.set = Ee;
    je = _e;
    xe = function(e8, n2) {
      for (var t2 = -1, r2 = null == e8 ? 0 : e8.length; ++t2 < r2 && false !== n2(e8[t2], t2, e8); )
        ;
      return e8;
    };
    Ne = function() {
      try {
        var e8 = ee(Object, "defineProperty");
        return e8({}, "", {}), e8;
      } catch (e9) {
      }
    }();
    Oe = function(e8, n2, t2) {
      "__proto__" == n2 && Ne ? Ne(e8, n2, { configurable: true, enumerable: true, value: t2, writable: true }) : e8[n2] = t2;
    };
    ke = Object.prototype.hasOwnProperty;
    Ie = function(e8, n2, t2) {
      var r2 = e8[n2];
      ke.call(e8, n2) && h(r2, t2) && (void 0 !== t2 || n2 in e8) || Oe(e8, n2, t2);
    };
    Se = function(e8, n2, t2, r2) {
      var o2 = !t2;
      t2 || (t2 = {});
      for (var i2 = -1, a3 = n2.length; ++i2 < a3; ) {
        var u2 = n2[i2], c3 = r2 ? r2(t2[u2], e8[u2], u2, t2, e8) : void 0;
        void 0 === c3 && (c3 = e8[u2]), o2 ? Oe(t2, u2, c3) : Ie(t2, u2, c3);
      }
      return t2;
    };
    Me = function(e8, n2) {
      for (var t2 = -1, r2 = Array(e8); ++t2 < e8; )
        r2[t2] = n2(t2);
      return r2;
    };
    Ce = function(e8) {
      return null != e8 && "object" == typeof e8;
    };
    Ge = function(e8) {
      return Ce(e8) && "[object Arguments]" == T(e8);
    };
    Be = Object.prototype;
    Ae = Be.hasOwnProperty;
    Le = Be.propertyIsEnumerable;
    Re = Ge(function() {
      return arguments;
    }()) ? Ge : function(e8) {
      return Ce(e8) && Ae.call(e8, "callee") && !Le.call(e8, "callee");
    };
    Te = Array.isArray;
    De = function() {
      return false;
    };
    Pe = d(function(e8, n2) {
      var t2 = n2 && !n2.nodeType && n2, r2 = t2 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t2 ? k.Buffer : void 0, i2 = (o2 ? o2.isBuffer : void 0) || De;
      e8.exports = i2;
    });
    ze = /^(?:0|[1-9]\d*)$/;
    Fe = function(e8, n2) {
      var t2 = typeof e8;
      return !!(n2 = null == n2 ? 9007199254740991 : n2) && ("number" == t2 || "symbol" != t2 && ze.test(e8)) && e8 > -1 && e8 % 1 == 0 && e8 < n2;
    };
    Ue = function(e8) {
      return "number" == typeof e8 && e8 > -1 && e8 % 1 == 0 && e8 <= 9007199254740991;
    };
    Ve = {};
    Ve["[object Float32Array]"] = Ve["[object Float64Array]"] = Ve["[object Int8Array]"] = Ve["[object Int16Array]"] = Ve["[object Int32Array]"] = Ve["[object Uint8Array]"] = Ve["[object Uint8ClampedArray]"] = Ve["[object Uint16Array]"] = Ve["[object Uint32Array]"] = true, Ve["[object Arguments]"] = Ve["[object Array]"] = Ve["[object ArrayBuffer]"] = Ve["[object Boolean]"] = Ve["[object DataView]"] = Ve["[object Date]"] = Ve["[object Error]"] = Ve["[object Function]"] = Ve["[object Map]"] = Ve["[object Number]"] = Ve["[object Object]"] = Ve["[object RegExp]"] = Ve["[object Set]"] = Ve["[object String]"] = Ve["[object WeakMap]"] = false;
    $e = function(e8) {
      return Ce(e8) && Ue(e8.length) && !!Ve[T(e8)];
    };
    He = function(e8) {
      return function(n2) {
        return e8(n2);
      };
    };
    We = d(function(e8, n2) {
      var t2 = n2 && !n2.nodeType && n2, r2 = t2 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t2 && N.process, i2 = function() {
        try {
          var e9 = r2 && r2.require && r2.require("util").types;
          return e9 || o2 && o2.binding && o2.binding("util");
        } catch (e10) {
        }
      }();
      e8.exports = i2;
    });
    qe = We && We.isTypedArray;
    Ye = qe ? He(qe) : $e;
    Je = Object.prototype.hasOwnProperty;
    Xe = function(e8, n2) {
      var t2 = Te(e8), r2 = !t2 && Re(e8), o2 = !t2 && !r2 && Pe(e8), i2 = !t2 && !r2 && !o2 && Ye(e8), a3 = t2 || r2 || o2 || i2, u2 = a3 ? Me(e8.length, String) : [], c3 = u2.length;
      for (var s2 in e8)
        !n2 && !Je.call(e8, s2) || a3 && ("length" == s2 || o2 && ("offset" == s2 || "parent" == s2) || i2 && ("buffer" == s2 || "byteLength" == s2 || "byteOffset" == s2) || Fe(s2, c3)) || u2.push(s2);
      return u2;
    };
    Ke = Object.prototype;
    Qe = function(e8) {
      var n2 = e8 && e8.constructor;
      return e8 === ("function" == typeof n2 && n2.prototype || Ke);
    };
    Ze = function(e8, n2) {
      return function(t2) {
        return e8(n2(t2));
      };
    };
    en = Ze(Object.keys, Object);
    nn = Object.prototype.hasOwnProperty;
    tn = function(e8) {
      if (!Qe(e8))
        return en(e8);
      var n2 = [];
      for (var t2 in Object(e8))
        nn.call(e8, t2) && "constructor" != t2 && n2.push(t2);
      return n2;
    };
    rn = function(e8) {
      return null != e8 && Ue(e8.length) && !z(e8);
    };
    on = function(e8) {
      return rn(e8) ? Xe(e8) : tn(e8);
    };
    an = function(e8, n2) {
      return e8 && Se(n2, on(n2), e8);
    };
    un = function(e8) {
      var n2 = [];
      if (null != e8)
        for (var t2 in Object(e8))
          n2.push(t2);
      return n2;
    };
    cn = Object.prototype.hasOwnProperty;
    sn = function(e8) {
      if (!D(e8))
        return un(e8);
      var n2 = Qe(e8), t2 = [];
      for (var r2 in e8)
        ("constructor" != r2 || !n2 && cn.call(e8, r2)) && t2.push(r2);
      return t2;
    };
    dn = function(e8) {
      return rn(e8) ? Xe(e8, true) : sn(e8);
    };
    fn = function(e8, n2) {
      return e8 && Se(n2, dn(n2), e8);
    };
    hn = d(function(e8, n2) {
      var t2 = n2 && !n2.nodeType && n2, r2 = t2 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t2 ? k.Buffer : void 0, i2 = o2 ? o2.allocUnsafe : void 0;
      e8.exports = function(e9, n3) {
        if (n3)
          return e9.slice();
        var t3 = e9.length, r3 = i2 ? i2(t3) : new e9.constructor(t3);
        return e9.copy(r3), r3;
      };
    });
    ln = function(e8, n2) {
      var t2 = -1, r2 = e8.length;
      for (n2 || (n2 = Array(r2)); ++t2 < r2; )
        n2[t2] = e8[t2];
      return n2;
    };
    vn = function(e8, n2) {
      for (var t2 = -1, r2 = null == e8 ? 0 : e8.length, o2 = 0, i2 = []; ++t2 < r2; ) {
        var a3 = e8[t2];
        n2(a3, t2, e8) && (i2[o2++] = a3);
      }
      return i2;
    };
    pn = function() {
      return [];
    };
    gn = Object.prototype.propertyIsEnumerable;
    yn = Object.getOwnPropertySymbols;
    bn = yn ? function(e8) {
      return null == e8 ? [] : (e8 = Object(e8), vn(yn(e8), function(n2) {
        return gn.call(e8, n2);
      }));
    } : pn;
    mn = function(e8, n2) {
      return Se(e8, bn(e8), n2);
    };
    wn = function(e8, n2) {
      for (var t2 = -1, r2 = n2.length, o2 = e8.length; ++t2 < r2; )
        e8[o2 + t2] = n2[t2];
      return e8;
    };
    En = Ze(Object.getPrototypeOf, Object);
    _n = Object.getOwnPropertySymbols ? function(e8) {
      for (var n2 = []; e8; )
        wn(n2, bn(e8)), e8 = En(e8);
      return n2;
    } : pn;
    jn = function(e8, n2) {
      return Se(e8, _n(e8), n2);
    };
    xn = function(e8, n2, t2) {
      var r2 = n2(e8);
      return Te(e8) ? r2 : wn(r2, t2(e8));
    };
    Nn = function(e8) {
      return xn(e8, on, bn);
    };
    On = function(e8) {
      return xn(e8, dn, _n);
    };
    kn = ee(k, "DataView");
    In = ee(k, "Promise");
    Sn = ee(k, "Set");
    Mn = ee(k, "WeakMap");
    Cn = H(kn);
    Gn = H(ne);
    Bn = H(In);
    An = H(Sn);
    Ln = H(Mn);
    Rn = T;
    (kn && "[object DataView]" != Rn(new kn(new ArrayBuffer(1))) || ne && "[object Map]" != Rn(new ne()) || In && "[object Promise]" != Rn(In.resolve()) || Sn && "[object Set]" != Rn(new Sn()) || Mn && "[object WeakMap]" != Rn(new Mn())) && (Rn = function(e8) {
      var n2 = T(e8), t2 = "[object Object]" == n2 ? e8.constructor : void 0, r2 = t2 ? H(t2) : "";
      if (r2)
        switch (r2) {
          case Cn:
            return "[object DataView]";
          case Gn:
            return "[object Map]";
          case Bn:
            return "[object Promise]";
          case An:
            return "[object Set]";
          case Ln:
            return "[object WeakMap]";
        }
      return n2;
    });
    Tn = Rn;
    Dn = Object.prototype.hasOwnProperty;
    Pn = function(e8) {
      var n2 = e8.length, t2 = new e8.constructor(n2);
      return n2 && "string" == typeof e8[0] && Dn.call(e8, "index") && (t2.index = e8.index, t2.input = e8.input), t2;
    };
    zn = k.Uint8Array;
    Fn = function(e8) {
      var n2 = new e8.constructor(e8.byteLength);
      return new zn(n2).set(new zn(e8)), n2;
    };
    Un = function(e8, n2) {
      var t2 = n2 ? Fn(e8.buffer) : e8.buffer;
      return new e8.constructor(t2, e8.byteOffset, e8.byteLength);
    };
    Vn = /\w*$/;
    $n = function(e8) {
      var n2 = new e8.constructor(e8.source, Vn.exec(e8));
      return n2.lastIndex = e8.lastIndex, n2;
    };
    Hn = I ? I.prototype : void 0;
    Wn = Hn ? Hn.valueOf : void 0;
    qn = function(e8) {
      return Wn ? Object(Wn.call(e8)) : {};
    };
    Yn = function(e8, n2) {
      var t2 = n2 ? Fn(e8.buffer) : e8.buffer;
      return new e8.constructor(t2, e8.byteOffset, e8.length);
    };
    Jn = function(e8, n2, t2) {
      var r2 = e8.constructor;
      switch (n2) {
        case "[object ArrayBuffer]":
          return Fn(e8);
        case "[object Boolean]":
        case "[object Date]":
          return new r2(+e8);
        case "[object DataView]":
          return Un(e8, t2);
        case "[object Float32Array]":
        case "[object Float64Array]":
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object Int32Array]":
        case "[object Uint8Array]":
        case "[object Uint8ClampedArray]":
        case "[object Uint16Array]":
        case "[object Uint32Array]":
          return Yn(e8, t2);
        case "[object Map]":
          return new r2();
        case "[object Number]":
        case "[object String]":
          return new r2(e8);
        case "[object RegExp]":
          return $n(e8);
        case "[object Set]":
          return new r2();
        case "[object Symbol]":
          return qn(e8);
      }
    };
    Xn = Object.create;
    Kn = function() {
      function e8() {
      }
      return function(n2) {
        if (!D(n2))
          return {};
        if (Xn)
          return Xn(n2);
        e8.prototype = n2;
        var t2 = new e8();
        return e8.prototype = void 0, t2;
      };
    }();
    Qn = function(e8) {
      return "function" != typeof e8.constructor || Qe(e8) ? {} : Kn(En(e8));
    };
    Zn = function(e8) {
      return Ce(e8) && "[object Map]" == Tn(e8);
    };
    et = We && We.isMap;
    nt = et ? He(et) : Zn;
    tt = function(e8) {
      return Ce(e8) && "[object Set]" == Tn(e8);
    };
    rt = We && We.isSet;
    ot = rt ? He(rt) : tt;
    it = {};
    it["[object Arguments]"] = it["[object Array]"] = it["[object ArrayBuffer]"] = it["[object DataView]"] = it["[object Boolean]"] = it["[object Date]"] = it["[object Float32Array]"] = it["[object Float64Array]"] = it["[object Int8Array]"] = it["[object Int16Array]"] = it["[object Int32Array]"] = it["[object Map]"] = it["[object Number]"] = it["[object Object]"] = it["[object RegExp]"] = it["[object Set]"] = it["[object String]"] = it["[object Symbol]"] = it["[object Uint8Array]"] = it["[object Uint8ClampedArray]"] = it["[object Uint16Array]"] = it["[object Uint32Array]"] = true, it["[object Error]"] = it["[object Function]"] = it["[object WeakMap]"] = false;
    at = function e2(n2, t2, r2, o2, i2, a3) {
      var u2, c3 = 1 & t2, s2 = 2 & t2, d2 = 4 & t2;
      if (r2 && (u2 = i2 ? r2(n2, o2, i2, a3) : r2(n2)), void 0 !== u2)
        return u2;
      if (!D(n2))
        return n2;
      var f2 = Te(n2);
      if (f2) {
        if (u2 = Pn(n2), !c3)
          return ln(n2, u2);
      } else {
        var h2 = Tn(n2), l2 = "[object Function]" == h2 || "[object GeneratorFunction]" == h2;
        if (Pe(n2))
          return hn(n2, c3);
        if ("[object Object]" == h2 || "[object Arguments]" == h2 || l2 && !i2) {
          if (u2 = s2 || l2 ? {} : Qn(n2), !c3)
            return s2 ? jn(n2, fn(u2, n2)) : mn(n2, an(u2, n2));
        } else {
          if (!it[h2])
            return i2 ? n2 : {};
          u2 = Jn(n2, h2, c3);
        }
      }
      a3 || (a3 = new je());
      var v2 = a3.get(n2);
      if (v2)
        return v2;
      a3.set(n2, u2), ot(n2) ? n2.forEach(function(o3) {
        u2.add(e2(o3, t2, r2, o3, n2, a3));
      }) : nt(n2) && n2.forEach(function(o3, i3) {
        u2.set(i3, e2(o3, t2, r2, i3, n2, a3));
      });
      var p2 = f2 ? void 0 : (d2 ? s2 ? On : Nn : s2 ? dn : on)(n2);
      return xe(p2 || n2, function(o3, i3) {
        p2 && (o3 = n2[i3 = o3]), Ie(u2, i3, e2(o3, t2, r2, i3, n2, a3));
      }), u2;
    };
    ut = function(e8) {
      return at(e8, 4);
    };
    ct = function(e8) {
      return function() {
        return e8;
      };
    };
    st = function(e8) {
      return function(n2, t2, r2) {
        for (var o2 = -1, i2 = Object(n2), a3 = r2(n2), u2 = a3.length; u2--; ) {
          var c3 = a3[e8 ? u2 : ++o2];
          if (false === t2(i2[c3], c3, i2))
            break;
        }
        return n2;
      };
    }();
    dt = function(e8, n2) {
      return e8 && st(e8, n2, on);
    };
    ft = function(e8, n2) {
      return function(t2, r2) {
        if (null == t2)
          return t2;
        if (!rn(t2))
          return e8(t2, r2);
        for (var o2 = t2.length, i2 = n2 ? o2 : -1, a3 = Object(t2); (n2 ? i2-- : ++i2 < o2) && false !== r2(a3[i2], i2, a3); )
          ;
        return t2;
      };
    }(dt);
    ht = function(e8) {
      return e8;
    };
    lt = function(e8) {
      return "function" == typeof e8 ? e8 : ht;
    };
    vt = function(e8, n2) {
      return (Te(e8) ? xe : ft)(e8, lt(n2));
    };
    pt = vt;
    gt = function(e8, n2) {
      var t2 = [];
      return ft(e8, function(e9, r2, o2) {
        n2(e9, r2, o2) && t2.push(e9);
      }), t2;
    };
    yt = function(e8) {
      return this.__data__.set(e8, "__lodash_hash_undefined__"), this;
    };
    bt = function(e8) {
      return this.__data__.has(e8);
    };
    mt.prototype.add = mt.prototype.push = yt, mt.prototype.has = bt;
    wt = mt;
    Et = function(e8, n2) {
      for (var t2 = -1, r2 = null == e8 ? 0 : e8.length; ++t2 < r2; )
        if (n2(e8[t2], t2, e8))
          return true;
      return false;
    };
    _t = function(e8, n2) {
      return e8.has(n2);
    };
    jt = function(e8, n2, t2, r2, o2, i2) {
      var a3 = 1 & t2, u2 = e8.length, c3 = n2.length;
      if (u2 != c3 && !(a3 && c3 > u2))
        return false;
      var s2 = i2.get(e8), d2 = i2.get(n2);
      if (s2 && d2)
        return s2 == n2 && d2 == e8;
      var f2 = -1, h2 = true, l2 = 2 & t2 ? new wt() : void 0;
      for (i2.set(e8, n2), i2.set(n2, e8); ++f2 < u2; ) {
        var v2 = e8[f2], p2 = n2[f2];
        if (r2)
          var g2 = a3 ? r2(p2, v2, f2, n2, e8, i2) : r2(v2, p2, f2, e8, n2, i2);
        if (void 0 !== g2) {
          if (g2)
            continue;
          h2 = false;
          break;
        }
        if (l2) {
          if (!Et(n2, function(e9, n3) {
            if (!_t(l2, n3) && (v2 === e9 || o2(v2, e9, t2, r2, i2)))
              return l2.push(n3);
          })) {
            h2 = false;
            break;
          }
        } else if (v2 !== p2 && !o2(v2, p2, t2, r2, i2)) {
          h2 = false;
          break;
        }
      }
      return i2.delete(e8), i2.delete(n2), h2;
    };
    xt = function(e8) {
      var n2 = -1, t2 = Array(e8.size);
      return e8.forEach(function(e9, r2) {
        t2[++n2] = [r2, e9];
      }), t2;
    };
    Nt = function(e8) {
      var n2 = -1, t2 = Array(e8.size);
      return e8.forEach(function(e9) {
        t2[++n2] = e9;
      }), t2;
    };
    Ot = I ? I.prototype : void 0;
    kt = Ot ? Ot.valueOf : void 0;
    It = function(e8, n2, t2, r2, o2, i2, a3) {
      switch (t2) {
        case "[object DataView]":
          if (e8.byteLength != n2.byteLength || e8.byteOffset != n2.byteOffset)
            return false;
          e8 = e8.buffer, n2 = n2.buffer;
        case "[object ArrayBuffer]":
          return !(e8.byteLength != n2.byteLength || !i2(new zn(e8), new zn(n2)));
        case "[object Boolean]":
        case "[object Date]":
        case "[object Number]":
          return h(+e8, +n2);
        case "[object Error]":
          return e8.name == n2.name && e8.message == n2.message;
        case "[object RegExp]":
        case "[object String]":
          return e8 == n2 + "";
        case "[object Map]":
          var u2 = xt;
        case "[object Set]":
          var c3 = 1 & r2;
          if (u2 || (u2 = Nt), e8.size != n2.size && !c3)
            return false;
          var s2 = a3.get(e8);
          if (s2)
            return s2 == n2;
          r2 |= 2, a3.set(e8, n2);
          var d2 = jt(u2(e8), u2(n2), r2, o2, i2, a3);
          return a3.delete(e8), d2;
        case "[object Symbol]":
          if (kt)
            return kt.call(e8) == kt.call(n2);
      }
      return false;
    };
    St = Object.prototype.hasOwnProperty;
    Mt = function(e8, n2, t2, r2, o2, i2) {
      var a3 = 1 & t2, u2 = Nn(e8), c3 = u2.length;
      if (c3 != Nn(n2).length && !a3)
        return false;
      for (var s2 = c3; s2--; ) {
        var d2 = u2[s2];
        if (!(a3 ? d2 in n2 : St.call(n2, d2)))
          return false;
      }
      var f2 = i2.get(e8), h2 = i2.get(n2);
      if (f2 && h2)
        return f2 == n2 && h2 == e8;
      var l2 = true;
      i2.set(e8, n2), i2.set(n2, e8);
      for (var v2 = a3; ++s2 < c3; ) {
        var p2 = e8[d2 = u2[s2]], g2 = n2[d2];
        if (r2)
          var y4 = a3 ? r2(g2, p2, d2, n2, e8, i2) : r2(p2, g2, d2, e8, n2, i2);
        if (!(void 0 === y4 ? p2 === g2 || o2(p2, g2, t2, r2, i2) : y4)) {
          l2 = false;
          break;
        }
        v2 || (v2 = "constructor" == d2);
      }
      if (l2 && !v2) {
        var b2 = e8.constructor, m3 = n2.constructor;
        b2 == m3 || !("constructor" in e8) || !("constructor" in n2) || "function" == typeof b2 && b2 instanceof b2 && "function" == typeof m3 && m3 instanceof m3 || (l2 = false);
      }
      return i2.delete(e8), i2.delete(n2), l2;
    };
    Ct = Object.prototype.hasOwnProperty;
    Gt = function(e8, n2, t2, r2, o2, i2) {
      var a3 = Te(e8), u2 = Te(n2), c3 = a3 ? "[object Array]" : Tn(e8), s2 = u2 ? "[object Array]" : Tn(n2), d2 = "[object Object]" == (c3 = "[object Arguments]" == c3 ? "[object Object]" : c3), f2 = "[object Object]" == (s2 = "[object Arguments]" == s2 ? "[object Object]" : s2), h2 = c3 == s2;
      if (h2 && Pe(e8)) {
        if (!Pe(n2))
          return false;
        a3 = true, d2 = false;
      }
      if (h2 && !d2)
        return i2 || (i2 = new je()), a3 || Ye(e8) ? jt(e8, n2, t2, r2, o2, i2) : It(e8, n2, c3, t2, r2, o2, i2);
      if (!(1 & t2)) {
        var l2 = d2 && Ct.call(e8, "__wrapped__"), v2 = f2 && Ct.call(n2, "__wrapped__");
        if (l2 || v2) {
          var p2 = l2 ? e8.value() : e8, g2 = v2 ? n2.value() : n2;
          return i2 || (i2 = new je()), o2(p2, g2, t2, r2, i2);
        }
      }
      return !!h2 && (i2 || (i2 = new je()), Mt(e8, n2, t2, r2, o2, i2));
    };
    Bt = function e3(n2, t2, r2, o2, i2) {
      return n2 === t2 || (null == n2 || null == t2 || !Ce(n2) && !Ce(t2) ? n2 != n2 && t2 != t2 : Gt(n2, t2, r2, o2, e3, i2));
    };
    At = function(e8, n2, t2, r2) {
      var o2 = t2.length, i2 = o2, a3 = !r2;
      if (null == e8)
        return !i2;
      for (e8 = Object(e8); o2--; ) {
        var u2 = t2[o2];
        if (a3 && u2[2] ? u2[1] !== e8[u2[0]] : !(u2[0] in e8))
          return false;
      }
      for (; ++o2 < i2; ) {
        var c3 = (u2 = t2[o2])[0], s2 = e8[c3], d2 = u2[1];
        if (a3 && u2[2]) {
          if (void 0 === s2 && !(c3 in e8))
            return false;
        } else {
          var f2 = new je();
          if (r2)
            var h2 = r2(s2, d2, c3, e8, n2, f2);
          if (!(void 0 === h2 ? Bt(d2, s2, 3, r2, f2) : h2))
            return false;
        }
      }
      return true;
    };
    Lt = function(e8) {
      return e8 == e8 && !D(e8);
    };
    Rt = function(e8) {
      for (var n2 = on(e8), t2 = n2.length; t2--; ) {
        var r2 = n2[t2], o2 = e8[r2];
        n2[t2] = [r2, o2, Lt(o2)];
      }
      return n2;
    };
    Tt = function(e8, n2) {
      return function(t2) {
        return null != t2 && (t2[e8] === n2 && (void 0 !== n2 || e8 in Object(t2)));
      };
    };
    Dt = function(e8) {
      var n2 = Rt(e8);
      return 1 == n2.length && n2[0][2] ? Tt(n2[0][0], n2[0][1]) : function(t2) {
        return t2 === e8 || At(t2, e8, n2);
      };
    };
    Pt = function(e8) {
      return "symbol" == typeof e8 || Ce(e8) && "[object Symbol]" == T(e8);
    };
    zt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    Ft = /^\w*$/;
    Ut = function(e8, n2) {
      if (Te(e8))
        return false;
      var t2 = typeof e8;
      return !("number" != t2 && "symbol" != t2 && "boolean" != t2 && null != e8 && !Pt(e8)) || (Ft.test(e8) || !zt.test(e8) || null != n2 && e8 in Object(n2));
    };
    Vt.Cache = we;
    $t = Vt;
    Ht = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    Wt = /\\(\\)?/g;
    qt = function(e8) {
      var n2 = $t(e8, function(e9) {
        return 500 === t2.size && t2.clear(), e9;
      }), t2 = n2.cache;
      return n2;
    }(function(e8) {
      var n2 = [];
      return 46 === e8.charCodeAt(0) && n2.push(""), e8.replace(Ht, function(e9, t2, r2, o2) {
        n2.push(r2 ? o2.replace(Wt, "$1") : t2 || e9);
      }), n2;
    });
    Yt = function(e8, n2) {
      for (var t2 = -1, r2 = null == e8 ? 0 : e8.length, o2 = Array(r2); ++t2 < r2; )
        o2[t2] = n2(e8[t2], t2, e8);
      return o2;
    };
    Jt = I ? I.prototype : void 0;
    Xt = Jt ? Jt.toString : void 0;
    Kt = function e4(n2) {
      if ("string" == typeof n2)
        return n2;
      if (Te(n2))
        return Yt(n2, e4) + "";
      if (Pt(n2))
        return Xt ? Xt.call(n2) : "";
      var t2 = n2 + "";
      return "0" == t2 && 1 / n2 == -Infinity ? "-0" : t2;
    };
    Qt = function(e8) {
      return null == e8 ? "" : Kt(e8);
    };
    Zt = function(e8, n2) {
      return Te(e8) ? e8 : Ut(e8, n2) ? [e8] : qt(Qt(e8));
    };
    er = function(e8) {
      if ("string" == typeof e8 || Pt(e8))
        return e8;
      var n2 = e8 + "";
      return "0" == n2 && 1 / e8 == -Infinity ? "-0" : n2;
    };
    nr = function(e8, n2) {
      for (var t2 = 0, r2 = (n2 = Zt(n2, e8)).length; null != e8 && t2 < r2; )
        e8 = e8[er(n2[t2++])];
      return t2 && t2 == r2 ? e8 : void 0;
    };
    tr = function(e8, n2, t2) {
      var r2 = null == e8 ? void 0 : nr(e8, n2);
      return void 0 === r2 ? t2 : r2;
    };
    rr = function(e8, n2) {
      return null != e8 && n2 in Object(e8);
    };
    or = function(e8, n2, t2) {
      for (var r2 = -1, o2 = (n2 = Zt(n2, e8)).length, i2 = false; ++r2 < o2; ) {
        var a3 = er(n2[r2]);
        if (!(i2 = null != e8 && t2(e8, a3)))
          break;
        e8 = e8[a3];
      }
      return i2 || ++r2 != o2 ? i2 : !!(o2 = null == e8 ? 0 : e8.length) && Ue(o2) && Fe(a3, o2) && (Te(e8) || Re(e8));
    };
    ir = function(e8, n2) {
      return null != e8 && or(e8, n2, rr);
    };
    ar = function(e8, n2) {
      return Ut(e8) && Lt(n2) ? Tt(er(e8), n2) : function(t2) {
        var r2 = tr(t2, e8);
        return void 0 === r2 && r2 === n2 ? ir(t2, e8) : Bt(n2, r2, 3);
      };
    };
    ur = function(e8) {
      return function(n2) {
        return null == n2 ? void 0 : n2[e8];
      };
    };
    cr = function(e8) {
      return function(n2) {
        return nr(n2, e8);
      };
    };
    sr = function(e8) {
      return Ut(e8) ? ur(er(e8)) : cr(e8);
    };
    dr = function(e8) {
      return "function" == typeof e8 ? e8 : null == e8 ? ht : "object" == typeof e8 ? Te(e8) ? ar(e8[0], e8[1]) : Dt(e8) : sr(e8);
    };
    fr = function(e8, n2) {
      return (Te(e8) ? vn : gt)(e8, dr(n2));
    };
    hr = Object.prototype.hasOwnProperty;
    lr = function(e8, n2) {
      return null != e8 && hr.call(e8, n2);
    };
    vr = function(e8, n2) {
      return null != e8 && or(e8, n2, lr);
    };
    pr = Object.prototype.hasOwnProperty;
    gr = function(e8) {
      if (null == e8)
        return true;
      if (rn(e8) && (Te(e8) || "string" == typeof e8 || "function" == typeof e8.splice || Pe(e8) || Ye(e8) || Re(e8)))
        return !e8.length;
      var n2 = Tn(e8);
      if ("[object Map]" == n2 || "[object Set]" == n2)
        return !e8.size;
      if (Qe(e8))
        return !tn(e8).length;
      for (var t2 in e8)
        if (pr.call(e8, t2))
          return false;
      return true;
    };
    yr = function(e8) {
      return void 0 === e8;
    };
    br = function(e8, n2) {
      var t2 = -1, r2 = rn(e8) ? Array(e8.length) : [];
      return ft(e8, function(e9, o2, i2) {
        r2[++t2] = n2(e9, o2, i2);
      }), r2;
    };
    mr = function(e8, n2) {
      return (Te(e8) ? Yt : br)(e8, dr(n2));
    };
    wr = function(e8, n2, t2, r2) {
      var o2 = -1, i2 = null == e8 ? 0 : e8.length;
      for (r2 && i2 && (t2 = e8[++o2]); ++o2 < i2; )
        t2 = n2(t2, e8[o2], o2, e8);
      return t2;
    };
    Er = function(e8, n2, t2, r2, o2) {
      return o2(e8, function(e9, o3, i2) {
        t2 = r2 ? (r2 = false, e9) : n2(t2, e9, o3, i2);
      }), t2;
    };
    _r = function(e8, n2, t2) {
      var r2 = Te(e8) ? wr : Er, o2 = arguments.length < 3;
      return r2(e8, dr(n2), t2, o2, ft);
    };
    jr = function(e8) {
      return "string" == typeof e8 || !Te(e8) && Ce(e8) && "[object String]" == T(e8);
    };
    xr = ur("length");
    Nr = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
    Or = function(e8) {
      return Nr.test(e8);
    };
    kr = "[\\ud800-\\udfff]";
    Ir = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]";
    Sr = "\\ud83c[\\udffb-\\udfff]";
    Mr = "[^\\ud800-\\udfff]";
    Cr = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    Gr = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    Br = "(?:" + Ir + "|" + Sr + ")?";
    Ar = "[\\ufe0e\\ufe0f]?" + Br + ("(?:\\u200d(?:" + [Mr, Cr, Gr].join("|") + ")[\\ufe0e\\ufe0f]?" + Br + ")*");
    Lr = "(?:" + [Mr + Ir + "?", Ir, Cr, Gr, kr].join("|") + ")";
    Rr = RegExp(Sr + "(?=" + Sr + ")|" + Lr + Ar, "g");
    Tr = function(e8) {
      for (var n2 = Rr.lastIndex = 0; Rr.test(e8); )
        ++n2;
      return n2;
    };
    Dr = function(e8) {
      return Or(e8) ? Tr(e8) : xr(e8);
    };
    Pr = function(e8) {
      if (null == e8)
        return 0;
      if (rn(e8))
        return jr(e8) ? Dr(e8) : e8.length;
      var n2 = Tn(e8);
      return "[object Map]" == n2 || "[object Set]" == n2 ? e8.size : tn(e8).length;
    };
    zr = function(e8, n2, t2) {
      var r2 = Te(e8), o2 = r2 || Pe(e8) || Ye(e8);
      if (n2 = dr(n2), null == t2) {
        var i2 = e8 && e8.constructor;
        t2 = o2 ? r2 ? new i2() : [] : D(e8) && z(i2) ? Kn(En(e8)) : {};
      }
      return (o2 ? xe : dt)(e8, function(e9, r3, o3) {
        return n2(t2, e9, r3, o3);
      }), t2;
    };
    Fr = I ? I.isConcatSpreadable : void 0;
    Ur = function(e8) {
      return Te(e8) || Re(e8) || !!(Fr && e8 && e8[Fr]);
    };
    Vr = function e5(n2, t2, r2, o2, i2) {
      var a3 = -1, u2 = n2.length;
      for (r2 || (r2 = Ur), i2 || (i2 = []); ++a3 < u2; ) {
        var c3 = n2[a3];
        t2 > 0 && r2(c3) ? t2 > 1 ? e5(c3, t2 - 1, r2, o2, i2) : wn(i2, c3) : o2 || (i2[i2.length] = c3);
      }
      return i2;
    };
    $r = function(e8, n2, t2) {
      switch (t2.length) {
        case 0:
          return e8.call(n2);
        case 1:
          return e8.call(n2, t2[0]);
        case 2:
          return e8.call(n2, t2[0], t2[1]);
        case 3:
          return e8.call(n2, t2[0], t2[1], t2[2]);
      }
      return e8.apply(n2, t2);
    };
    Hr = Math.max;
    Wr = function(e8, n2, t2) {
      return n2 = Hr(void 0 === n2 ? e8.length - 1 : n2, 0), function() {
        for (var r2 = arguments, o2 = -1, i2 = Hr(r2.length - n2, 0), a3 = Array(i2); ++o2 < i2; )
          a3[o2] = r2[n2 + o2];
        o2 = -1;
        for (var u2 = Array(n2 + 1); ++o2 < n2; )
          u2[o2] = r2[o2];
        return u2[n2] = t2(a3), $r(e8, this, u2);
      };
    };
    qr = Ne ? function(e8, n2) {
      return Ne(e8, "toString", { configurable: true, enumerable: false, value: ct(n2), writable: true });
    } : ht;
    Yr = Date.now;
    Jr = function(e8) {
      var n2 = 0, t2 = 0;
      return function() {
        var r2 = Yr(), o2 = 16 - (r2 - t2);
        if (t2 = r2, o2 > 0) {
          if (++n2 >= 800)
            return arguments[0];
        } else
          n2 = 0;
        return e8.apply(void 0, arguments);
      };
    }(qr);
    Xr = function(e8, n2) {
      return Jr(Wr(e8, n2, ht), e8 + "");
    };
    Kr = function(e8, n2, t2, r2) {
      for (var o2 = e8.length, i2 = t2 + (r2 ? 1 : -1); r2 ? i2-- : ++i2 < o2; )
        if (n2(e8[i2], i2, e8))
          return i2;
      return -1;
    };
    Qr = function(e8) {
      return e8 != e8;
    };
    Zr = function(e8, n2, t2) {
      for (var r2 = t2 - 1, o2 = e8.length; ++r2 < o2; )
        if (e8[r2] === n2)
          return r2;
      return -1;
    };
    eo = function(e8, n2, t2) {
      return n2 == n2 ? Zr(e8, n2, t2) : Kr(e8, Qr, t2);
    };
    no = function(e8, n2) {
      return !!(null == e8 ? 0 : e8.length) && eo(e8, n2, 0) > -1;
    };
    to = function(e8, n2, t2) {
      for (var r2 = -1, o2 = null == e8 ? 0 : e8.length; ++r2 < o2; )
        if (t2(n2, e8[r2]))
          return true;
      return false;
    };
    ro = function() {
    };
    oo = Sn && 1 / Nt(new Sn([, -0]))[1] == 1 / 0 ? function(e8) {
      return new Sn(e8);
    } : ro;
    io = function(e8, n2, t2) {
      var r2 = -1, o2 = no, i2 = e8.length, a3 = true, u2 = [], c3 = u2;
      if (t2)
        a3 = false, o2 = to;
      else if (i2 >= 200) {
        var s2 = n2 ? null : oo(e8);
        if (s2)
          return Nt(s2);
        a3 = false, o2 = _t, c3 = new wt();
      } else
        c3 = n2 ? [] : u2;
      e:
        for (; ++r2 < i2; ) {
          var d2 = e8[r2], f2 = n2 ? n2(d2) : d2;
          if (d2 = t2 || 0 !== d2 ? d2 : 0, a3 && f2 == f2) {
            for (var h2 = c3.length; h2--; )
              if (c3[h2] === f2)
                continue e;
            n2 && c3.push(f2), u2.push(d2);
          } else
            o2(c3, f2, t2) || (c3 !== u2 && c3.push(f2), u2.push(d2));
        }
      return u2;
    };
    ao = function(e8) {
      return Ce(e8) && rn(e8);
    };
    uo = Xr(function(e8) {
      return io(Vr(e8, 1, ao, true));
    });
    co = function(e8, n2) {
      return Yt(n2, function(n3) {
        return e8[n3];
      });
    };
    fo = function(e8) {
      return null == e8 ? [] : co(e8, on(e8));
    };
    try {
      so = { clone: ut, constant: ct, each: pt, filter: fr, has: vr, isArray: Te, isEmpty: gr, isFunction: z, isUndefined: yr, keys: on, map: mr, reduce: _r, size: Pr, transform: zr, union: uo, values: fo };
    } catch (e8) {
    }
    so || (so = window._);
    ho = so;
    lo = vo;
    vo.prototype._nodeCount = 0, vo.prototype._edgeCount = 0, vo.prototype.isDirected = function() {
      return this._isDirected;
    }, vo.prototype.isMultigraph = function() {
      return this._isMultigraph;
    }, vo.prototype.isCompound = function() {
      return this._isCompound;
    }, vo.prototype.setGraph = function(e8) {
      return this._label = e8, this;
    }, vo.prototype.graph = function() {
      return this._label;
    }, vo.prototype.setDefaultNodeLabel = function(e8) {
      return ho.isFunction(e8) || (e8 = ho.constant(e8)), this._defaultNodeLabelFn = e8, this;
    }, vo.prototype.nodeCount = function() {
      return this._nodeCount;
    }, vo.prototype.nodes = function() {
      return ho.keys(this._nodes);
    }, vo.prototype.sources = function() {
      var e8 = this;
      return ho.filter(this.nodes(), function(n2) {
        return ho.isEmpty(e8._in[n2]);
      });
    }, vo.prototype.sinks = function() {
      var e8 = this;
      return ho.filter(this.nodes(), function(n2) {
        return ho.isEmpty(e8._out[n2]);
      });
    }, vo.prototype.setNodes = function(e8, n2) {
      var t2 = arguments, r2 = this;
      return ho.each(e8, function(e9) {
        t2.length > 1 ? r2.setNode(e9, n2) : r2.setNode(e9);
      }), this;
    }, vo.prototype.setNode = function(e8, n2) {
      return ho.has(this._nodes, e8) ? (arguments.length > 1 && (this._nodes[e8] = n2), this) : (this._nodes[e8] = arguments.length > 1 ? n2 : this._defaultNodeLabelFn(e8), this._isCompound && (this._parent[e8] = "\0", this._children[e8] = {}, this._children["\0"][e8] = true), this._in[e8] = {}, this._preds[e8] = {}, this._out[e8] = {}, this._sucs[e8] = {}, ++this._nodeCount, this);
    }, vo.prototype.node = function(e8) {
      return this._nodes[e8];
    }, vo.prototype.hasNode = function(e8) {
      return ho.has(this._nodes, e8);
    }, vo.prototype.removeNode = function(e8) {
      var n2 = this;
      if (ho.has(this._nodes, e8)) {
        var t2 = function(e9) {
          n2.removeEdge(n2._edgeObjs[e9]);
        };
        delete this._nodes[e8], this._isCompound && (this._removeFromParentsChildList(e8), delete this._parent[e8], ho.each(this.children(e8), function(e9) {
          n2.setParent(e9);
        }), delete this._children[e8]), ho.each(ho.keys(this._in[e8]), t2), delete this._in[e8], delete this._preds[e8], ho.each(ho.keys(this._out[e8]), t2), delete this._out[e8], delete this._sucs[e8], --this._nodeCount;
      }
      return this;
    }, vo.prototype.setParent = function(e8, n2) {
      if (!this._isCompound)
        throw new Error("Cannot set parent in a non-compound graph");
      if (ho.isUndefined(n2))
        n2 = "\0";
      else {
        for (var t2 = n2 += ""; !ho.isUndefined(t2); t2 = this.parent(t2))
          if (t2 === e8)
            throw new Error("Setting " + n2 + " as parent of " + e8 + " would create a cycle");
        this.setNode(n2);
      }
      return this.setNode(e8), this._removeFromParentsChildList(e8), this._parent[e8] = n2, this._children[n2][e8] = true, this;
    }, vo.prototype._removeFromParentsChildList = function(e8) {
      delete this._children[this._parent[e8]][e8];
    }, vo.prototype.parent = function(e8) {
      if (this._isCompound) {
        var n2 = this._parent[e8];
        if ("\0" !== n2)
          return n2;
      }
    }, vo.prototype.children = function(e8) {
      if (ho.isUndefined(e8) && (e8 = "\0"), this._isCompound) {
        var n2 = this._children[e8];
        if (n2)
          return ho.keys(n2);
      } else {
        if ("\0" === e8)
          return this.nodes();
        if (this.hasNode(e8))
          return [];
      }
    }, vo.prototype.predecessors = function(e8) {
      var n2 = this._preds[e8];
      if (n2)
        return ho.keys(n2);
    }, vo.prototype.successors = function(e8) {
      var n2 = this._sucs[e8];
      if (n2)
        return ho.keys(n2);
    }, vo.prototype.neighbors = function(e8) {
      var n2 = this.predecessors(e8);
      if (n2)
        return ho.union(n2, this.successors(e8));
    }, vo.prototype.isLeaf = function(e8) {
      return 0 === (this.isDirected() ? this.successors(e8) : this.neighbors(e8)).length;
    }, vo.prototype.filterNodes = function(e8) {
      var n2 = new this.constructor({ directed: this._isDirected, multigraph: this._isMultigraph, compound: this._isCompound });
      n2.setGraph(this.graph());
      var t2 = this;
      ho.each(this._nodes, function(t3, r3) {
        e8(r3) && n2.setNode(r3, t3);
      }), ho.each(this._edgeObjs, function(e9) {
        n2.hasNode(e9.v) && n2.hasNode(e9.w) && n2.setEdge(e9, t2.edge(e9));
      });
      var r2 = {};
      function o2(e9) {
        var i2 = t2.parent(e9);
        return void 0 === i2 || n2.hasNode(i2) ? (r2[e9] = i2, i2) : i2 in r2 ? r2[i2] : o2(i2);
      }
      return this._isCompound && ho.each(n2.nodes(), function(e9) {
        n2.setParent(e9, o2(e9));
      }), n2;
    }, vo.prototype.setDefaultEdgeLabel = function(e8) {
      return ho.isFunction(e8) || (e8 = ho.constant(e8)), this._defaultEdgeLabelFn = e8, this;
    }, vo.prototype.edgeCount = function() {
      return this._edgeCount;
    }, vo.prototype.edges = function() {
      return ho.values(this._edgeObjs);
    }, vo.prototype.setPath = function(e8, n2) {
      var t2 = this, r2 = arguments;
      return ho.reduce(e8, function(e9, o2) {
        return r2.length > 1 ? t2.setEdge(e9, o2, n2) : t2.setEdge(e9, o2), o2;
      }), this;
    }, vo.prototype.setEdge = function() {
      var e8, n2, t2, r2, o2 = false, i2 = arguments[0];
      "object" == typeof i2 && null !== i2 && "v" in i2 ? (e8 = i2.v, n2 = i2.w, t2 = i2.name, 2 === arguments.length && (r2 = arguments[1], o2 = true)) : (e8 = i2, n2 = arguments[1], t2 = arguments[3], arguments.length > 2 && (r2 = arguments[2], o2 = true)), e8 = "" + e8, n2 = "" + n2, ho.isUndefined(t2) || (t2 = "" + t2);
      var a3 = yo(this._isDirected, e8, n2, t2);
      if (ho.has(this._edgeLabels, a3))
        return o2 && (this._edgeLabels[a3] = r2), this;
      if (!ho.isUndefined(t2) && !this._isMultigraph)
        throw new Error("Cannot set a named edge when isMultigraph = false");
      this.setNode(e8), this.setNode(n2), this._edgeLabels[a3] = o2 ? r2 : this._defaultEdgeLabelFn(e8, n2, t2);
      var u2 = bo(this._isDirected, e8, n2, t2);
      return e8 = u2.v, n2 = u2.w, Object.freeze(u2), this._edgeObjs[a3] = u2, po(this._preds[n2], e8), po(this._sucs[e8], n2), this._in[n2][a3] = u2, this._out[e8][a3] = u2, this._edgeCount++, this;
    }, vo.prototype.edge = function(e8, n2, t2) {
      var r2 = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t2);
      return this._edgeLabels[r2];
    }, vo.prototype.hasEdge = function(e8, n2, t2) {
      var r2 = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t2);
      return ho.has(this._edgeLabels, r2);
    }, vo.prototype.removeEdge = function(e8, n2, t2) {
      var r2 = 1 === arguments.length ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t2), o2 = this._edgeObjs[r2];
      return o2 && (e8 = o2.v, n2 = o2.w, delete this._edgeLabels[r2], delete this._edgeObjs[r2], go(this._preds[n2], e8), go(this._sucs[e8], n2), delete this._in[n2][r2], delete this._out[e8][r2], this._edgeCount--), this;
    }, vo.prototype.inEdges = function(e8, n2) {
      var t2 = this._in[e8];
      if (t2) {
        var r2 = ho.values(t2);
        return n2 ? ho.filter(r2, function(e9) {
          return e9.v === n2;
        }) : r2;
      }
    }, vo.prototype.outEdges = function(e8, n2) {
      var t2 = this._out[e8];
      if (t2) {
        var r2 = ho.values(t2);
        return n2 ? ho.filter(r2, function(e9) {
          return e9.w === n2;
        }) : r2;
      }
    }, vo.prototype.nodeEdges = function(e8, n2) {
      var t2 = this.inEdges(e8, n2);
      if (t2)
        return t2.concat(this.outEdges(e8, n2));
    };
    wo = { Graph: lo, version: "2.1.8" };
    Eo = { write: function(e8) {
      var n2 = { options: { directed: e8.isDirected(), multigraph: e8.isMultigraph(), compound: e8.isCompound() }, nodes: _o(e8), edges: jo(e8) };
      ho.isUndefined(e8.graph()) || (n2.value = ho.clone(e8.graph()));
      return n2;
    }, read: function(e8) {
      var n2 = new lo(e8.options).setGraph(e8.value);
      return ho.each(e8.nodes, function(e9) {
        n2.setNode(e9.v, e9.value), e9.parent && n2.setParent(e9.v, e9.parent);
      }), ho.each(e8.edges, function(e9) {
        n2.setEdge({ v: e9.v, w: e9.w, name: e9.name }, e9.value);
      }), n2;
    } };
    xo = function(e8) {
      var n2, t2 = {}, r2 = [];
      function o2(r3) {
        ho.has(t2, r3) || (t2[r3] = true, n2.push(r3), ho.each(e8.successors(r3), o2), ho.each(e8.predecessors(r3), o2));
      }
      return ho.each(e8.nodes(), function(e9) {
        n2 = [], o2(e9), n2.length && r2.push(n2);
      }), r2;
    };
    No = Oo;
    Oo.prototype.size = function() {
      return this._arr.length;
    }, Oo.prototype.keys = function() {
      return this._arr.map(function(e8) {
        return e8.key;
      });
    }, Oo.prototype.has = function(e8) {
      return ho.has(this._keyIndices, e8);
    }, Oo.prototype.priority = function(e8) {
      var n2 = this._keyIndices[e8];
      if (void 0 !== n2)
        return this._arr[n2].priority;
    }, Oo.prototype.min = function() {
      if (0 === this.size())
        throw new Error("Queue underflow");
      return this._arr[0].key;
    }, Oo.prototype.add = function(e8, n2) {
      var t2 = this._keyIndices;
      if (e8 = String(e8), !ho.has(t2, e8)) {
        var r2 = this._arr, o2 = r2.length;
        return t2[e8] = o2, r2.push({ key: e8, priority: n2 }), this._decrease(o2), true;
      }
      return false;
    }, Oo.prototype.removeMin = function() {
      this._swap(0, this._arr.length - 1);
      var e8 = this._arr.pop();
      return delete this._keyIndices[e8.key], this._heapify(0), e8.key;
    }, Oo.prototype.decrease = function(e8, n2) {
      var t2 = this._keyIndices[e8];
      if (n2 > this._arr[t2].priority)
        throw new Error("New priority is greater than current priority. Key: " + e8 + " Old: " + this._arr[t2].priority + " New: " + n2);
      this._arr[t2].priority = n2, this._decrease(t2);
    }, Oo.prototype._heapify = function(e8) {
      var n2 = this._arr, t2 = 2 * e8, r2 = t2 + 1, o2 = e8;
      t2 < n2.length && (o2 = n2[t2].priority < n2[o2].priority ? t2 : o2, r2 < n2.length && (o2 = n2[r2].priority < n2[o2].priority ? r2 : o2), o2 !== e8 && (this._swap(e8, o2), this._heapify(o2)));
    }, Oo.prototype._decrease = function(e8) {
      for (var n2, t2 = this._arr, r2 = t2[e8].priority; 0 !== e8 && !(t2[n2 = e8 >> 1].priority < r2); )
        this._swap(e8, n2), e8 = n2;
    }, Oo.prototype._swap = function(e8, n2) {
      var t2 = this._arr, r2 = this._keyIndices, o2 = t2[e8], i2 = t2[n2];
      t2[e8] = i2, t2[n2] = o2, r2[i2.key] = e8, r2[o2.key] = n2;
    };
    ko = function(e8, n2, t2, r2) {
      return function(e9, n3, t3, r3) {
        var o2, i2, a3 = {}, u2 = new No(), c3 = function(e10) {
          var n4 = e10.v !== o2 ? e10.v : e10.w, r4 = a3[n4], c4 = t3(e10), s2 = i2.distance + c4;
          if (c4 < 0)
            throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + e10 + " Weight: " + c4);
          s2 < r4.distance && (r4.distance = s2, r4.predecessor = o2, u2.decrease(n4, s2));
        };
        e9.nodes().forEach(function(e10) {
          var t4 = e10 === n3 ? 0 : Number.POSITIVE_INFINITY;
          a3[e10] = { distance: t4 }, u2.add(e10, t4);
        });
        for (; u2.size() > 0 && (o2 = u2.removeMin(), (i2 = a3[o2]).distance !== Number.POSITIVE_INFINITY); )
          r3(o2).forEach(c3);
        return a3;
      }(e8, String(n2), t2 || Io, r2 || function(n3) {
        return e8.outEdges(n3);
      });
    };
    Io = ho.constant(1);
    So = function(e8, n2, t2) {
      return ho.transform(e8.nodes(), function(r2, o2) {
        r2[o2] = ko(e8, o2, n2, t2);
      }, {});
    };
    Mo = function(e8) {
      var n2 = 0, t2 = [], r2 = {}, o2 = [];
      function i2(a3) {
        var u2 = r2[a3] = { onStack: true, lowlink: n2, index: n2++ };
        if (t2.push(a3), e8.successors(a3).forEach(function(e9) {
          ho.has(r2, e9) ? r2[e9].onStack && (u2.lowlink = Math.min(u2.lowlink, r2[e9].index)) : (i2(e9), u2.lowlink = Math.min(u2.lowlink, r2[e9].lowlink));
        }), u2.lowlink === u2.index) {
          var c3, s2 = [];
          do {
            c3 = t2.pop(), r2[c3].onStack = false, s2.push(c3);
          } while (a3 !== c3);
          o2.push(s2);
        }
      }
      return e8.nodes().forEach(function(e9) {
        ho.has(r2, e9) || i2(e9);
      }), o2;
    };
    Co = function(e8) {
      return ho.filter(Mo(e8), function(n2) {
        return n2.length > 1 || 1 === n2.length && e8.hasEdge(n2[0], n2[0]);
      });
    };
    Go = function(e8, n2, t2) {
      return function(e9, n3, t3) {
        var r2 = {}, o2 = e9.nodes();
        return o2.forEach(function(e10) {
          r2[e10] = {}, r2[e10][e10] = { distance: 0 }, o2.forEach(function(n4) {
            e10 !== n4 && (r2[e10][n4] = { distance: Number.POSITIVE_INFINITY });
          }), t3(e10).forEach(function(t4) {
            var o3 = t4.v === e10 ? t4.w : t4.v, i2 = n3(t4);
            r2[e10][o3] = { distance: i2, predecessor: e10 };
          });
        }), o2.forEach(function(e10) {
          var n4 = r2[e10];
          o2.forEach(function(t4) {
            var i2 = r2[t4];
            o2.forEach(function(t5) {
              var r3 = i2[e10], o3 = n4[t5], a3 = i2[t5], u2 = r3.distance + o3.distance;
              u2 < a3.distance && (a3.distance = u2, a3.predecessor = o3.predecessor);
            });
          });
        }), r2;
      }(e8, n2 || Bo, t2 || function(n3) {
        return e8.outEdges(n3);
      });
    };
    Bo = ho.constant(1);
    Ao = Lo;
    Lo.CycleException = Ro, Ro.prototype = new Error();
    To = function(e8, n2, t2) {
      ho.isArray(n2) || (n2 = [n2]);
      var r2 = (e8.isDirected() ? e8.successors : e8.neighbors).bind(e8), o2 = [], i2 = {};
      return ho.each(n2, function(n3) {
        if (!e8.hasNode(n3))
          throw new Error("Graph does not have node: " + n3);
        Do(e8, n3, "post" === t2, i2, r2, o2);
      }), o2;
    };
    zo = { Graph: wo.Graph, json: Eo, alg: { components: xo, dijkstra: ko, dijkstraAll: So, findCycles: Co, floydWarshall: Go, isAcyclic: function(e8) {
      try {
        Ao(e8);
      } catch (e9) {
        if (e9 instanceof Ao.CycleException)
          return false;
        throw e9;
      }
      return true;
    }, postorder: function(e8, n2) {
      return To(e8, n2, "post");
    }, preorder: function(e8, n2) {
      return To(e8, n2, "pre");
    }, prim: function(e8, n2) {
      var t2, r2 = new lo(), o2 = {}, i2 = new No();
      function a3(e9) {
        var r3 = e9.v === t2 ? e9.w : e9.v, a4 = i2.priority(r3);
        if (void 0 !== a4) {
          var u3 = n2(e9);
          u3 < a4 && (o2[r3] = t2, i2.decrease(r3, u3));
        }
      }
      if (0 === e8.nodeCount())
        return r2;
      ho.each(e8.nodes(), function(e9) {
        i2.add(e9, Number.POSITIVE_INFINITY), r2.setNode(e9);
      }), i2.decrease(e8.nodes()[0], 0);
      var u2 = false;
      for (; i2.size() > 0; ) {
        if (t2 = i2.removeMin(), ho.has(o2, t2))
          r2.setEdge(t2, o2[t2]);
        else {
          if (u2)
            throw new Error("Input graph is not connected: " + e8);
          u2 = true;
        }
        e8.nodeEdges(t2).forEach(a3);
      }
      return r2;
    }, tarjan: Mo, topsort: Ao }, version: wo.version };
    try {
      Po = zo;
    } catch (e8) {
    }
    Po || (Po = window.graphlib);
    Fo = Po;
    Uo = function(e8) {
      return at(e8, 5);
    };
    Vo = function(e8, n2, t2) {
      if (!D(t2))
        return false;
      var r2 = typeof n2;
      return !!("number" == r2 ? rn(t2) && Fe(n2, t2.length) : "string" == r2 && n2 in t2) && h(t2[n2], e8);
    };
    $o = Object.prototype;
    Ho = $o.hasOwnProperty;
    Wo = Xr(function(e8, n2) {
      e8 = Object(e8);
      var t2 = -1, r2 = n2.length, o2 = r2 > 2 ? n2[2] : void 0;
      for (o2 && Vo(n2[0], n2[1], o2) && (r2 = 1); ++t2 < r2; )
        for (var i2 = n2[t2], a3 = dn(i2), u2 = -1, c3 = a3.length; ++u2 < c3; ) {
          var s2 = a3[u2], d2 = e8[s2];
          (void 0 === d2 || h(d2, $o[s2]) && !Ho.call(e8, s2)) && (e8[s2] = i2[s2]);
        }
      return e8;
    });
    qo = function(e8) {
      return function(n2, t2, r2) {
        var o2 = Object(n2);
        if (!rn(n2)) {
          var i2 = dr(t2);
          n2 = on(n2), t2 = function(e9) {
            return i2(o2[e9], e9, o2);
          };
        }
        var a3 = e8(n2, t2, r2);
        return a3 > -1 ? o2[i2 ? n2[a3] : a3] : void 0;
      };
    };
    Yo = /^\s+|\s+$/g;
    Jo = /^[-+]0x[0-9a-f]+$/i;
    Xo = /^0b[01]+$/i;
    Ko = /^0o[0-7]+$/i;
    Qo = parseInt;
    Zo = function(e8) {
      if ("number" == typeof e8)
        return e8;
      if (Pt(e8))
        return NaN;
      if (D(e8)) {
        var n2 = "function" == typeof e8.valueOf ? e8.valueOf() : e8;
        e8 = D(n2) ? n2 + "" : n2;
      }
      if ("string" != typeof e8)
        return 0 === e8 ? e8 : +e8;
      e8 = e8.replace(Yo, "");
      var t2 = Xo.test(e8);
      return t2 || Ko.test(e8) ? Qo(e8.slice(2), t2 ? 2 : 8) : Jo.test(e8) ? NaN : +e8;
    };
    ei = function(e8) {
      return e8 ? Infinity === (e8 = Zo(e8)) || -Infinity === e8 ? 17976931348623157e292 * (e8 < 0 ? -1 : 1) : e8 == e8 ? e8 : 0 : 0 === e8 ? e8 : 0;
    };
    ni = function(e8) {
      var n2 = ei(e8), t2 = n2 % 1;
      return n2 == n2 ? t2 ? n2 - t2 : n2 : 0;
    };
    ti = Math.max;
    ri = qo(function(e8, n2, t2) {
      var r2 = null == e8 ? 0 : e8.length;
      if (!r2)
        return -1;
      var o2 = null == t2 ? 0 : ni(t2);
      return o2 < 0 && (o2 = ti(r2 + o2, 0)), Kr(e8, dr(n2), o2);
    });
    oi = function(e8) {
      return (null == e8 ? 0 : e8.length) ? Vr(e8, 1) : [];
    };
    ii = function(e8, n2) {
      return null == e8 ? e8 : st(e8, lt(n2), dn);
    };
    ai = function(e8) {
      var n2 = null == e8 ? 0 : e8.length;
      return n2 ? e8[n2 - 1] : void 0;
    };
    ui = function(e8, n2) {
      var t2 = {};
      return n2 = dr(n2), dt(e8, function(e9, r2, o2) {
        Oe(t2, r2, n2(e9, r2, o2));
      }), t2;
    };
    ci = function(e8, n2, t2) {
      for (var r2 = -1, o2 = e8.length; ++r2 < o2; ) {
        var i2 = e8[r2], a3 = n2(i2);
        if (null != a3 && (void 0 === u2 ? a3 == a3 && !Pt(a3) : t2(a3, u2)))
          var u2 = a3, c3 = i2;
      }
      return c3;
    };
    si = function(e8, n2) {
      return e8 > n2;
    };
    di = function(e8) {
      return e8 && e8.length ? ci(e8, ht, si) : void 0;
    };
    fi = function(e8, n2, t2) {
      (void 0 !== t2 && !h(e8[n2], t2) || void 0 === t2 && !(n2 in e8)) && Oe(e8, n2, t2);
    };
    hi = Function.prototype;
    li = Object.prototype;
    vi = hi.toString;
    pi = li.hasOwnProperty;
    gi = vi.call(Object);
    yi = function(e8) {
      if (!Ce(e8) || "[object Object]" != T(e8))
        return false;
      var n2 = En(e8);
      if (null === n2)
        return true;
      var t2 = pi.call(n2, "constructor") && n2.constructor;
      return "function" == typeof t2 && t2 instanceof t2 && vi.call(t2) == gi;
    };
    bi = function(e8, n2) {
      if (("constructor" !== n2 || "function" != typeof e8[n2]) && "__proto__" != n2)
        return e8[n2];
    };
    mi = function(e8) {
      return Se(e8, dn(e8));
    };
    wi = function(e8, n2, t2, r2, o2, i2, a3) {
      var u2 = bi(e8, t2), c3 = bi(n2, t2), s2 = a3.get(c3);
      if (s2)
        fi(e8, t2, s2);
      else {
        var d2 = i2 ? i2(u2, c3, t2 + "", e8, n2, a3) : void 0, f2 = void 0 === d2;
        if (f2) {
          var h2 = Te(c3), l2 = !h2 && Pe(c3), v2 = !h2 && !l2 && Ye(c3);
          d2 = c3, h2 || l2 || v2 ? Te(u2) ? d2 = u2 : ao(u2) ? d2 = ln(u2) : l2 ? (f2 = false, d2 = hn(c3, true)) : v2 ? (f2 = false, d2 = Yn(c3, true)) : d2 = [] : yi(c3) || Re(c3) ? (d2 = u2, Re(u2) ? d2 = mi(u2) : D(u2) && !z(u2) || (d2 = Qn(c3))) : f2 = false;
        }
        f2 && (a3.set(c3, d2), o2(d2, c3, r2, i2, a3), a3.delete(c3)), fi(e8, t2, d2);
      }
    };
    Ei = function e6(n2, t2, r2, o2, i2) {
      n2 !== t2 && st(t2, function(a3, u2) {
        if (i2 || (i2 = new je()), D(a3))
          wi(n2, t2, u2, r2, e6, o2, i2);
        else {
          var c3 = o2 ? o2(bi(n2, u2), a3, u2 + "", n2, t2, i2) : void 0;
          void 0 === c3 && (c3 = a3), fi(n2, u2, c3);
        }
      }, dn);
    };
    _i = function(e8) {
      return Xr(function(n2, t2) {
        var r2 = -1, o2 = t2.length, i2 = o2 > 1 ? t2[o2 - 1] : void 0, a3 = o2 > 2 ? t2[2] : void 0;
        for (i2 = e8.length > 3 && "function" == typeof i2 ? (o2--, i2) : void 0, a3 && Vo(t2[0], t2[1], a3) && (i2 = o2 < 3 ? void 0 : i2, o2 = 1), n2 = Object(n2); ++r2 < o2; ) {
          var u2 = t2[r2];
          u2 && e8(n2, u2, r2, i2);
        }
        return n2;
      });
    }(function(e8, n2, t2) {
      Ei(e8, n2, t2);
    });
    ji = function(e8, n2) {
      return e8 < n2;
    };
    xi = function(e8) {
      return e8 && e8.length ? ci(e8, ht, ji) : void 0;
    };
    Ni = function(e8, n2) {
      return e8 && e8.length ? ci(e8, dr(n2), ji) : void 0;
    };
    Oi = function() {
      return k.Date.now();
    };
    ki = function(e8, n2, t2, r2) {
      if (!D(e8))
        return e8;
      for (var o2 = -1, i2 = (n2 = Zt(n2, e8)).length, a3 = i2 - 1, u2 = e8; null != u2 && ++o2 < i2; ) {
        var c3 = er(n2[o2]), s2 = t2;
        if ("__proto__" === c3 || "constructor" === c3 || "prototype" === c3)
          return e8;
        if (o2 != a3) {
          var d2 = u2[c3];
          void 0 === (s2 = r2 ? r2(d2, c3, u2) : void 0) && (s2 = D(d2) ? d2 : Fe(n2[o2 + 1]) ? [] : {});
        }
        Ie(u2, c3, s2), u2 = u2[c3];
      }
      return e8;
    };
    Ii = function(e8, n2, t2) {
      for (var r2 = -1, o2 = n2.length, i2 = {}; ++r2 < o2; ) {
        var a3 = n2[r2], u2 = nr(e8, a3);
        t2(u2, a3) && ki(i2, Zt(a3, e8), u2);
      }
      return i2;
    };
    Si = function(e8, n2) {
      return Ii(e8, n2, function(n3, t2) {
        return ir(e8, t2);
      });
    };
    Mi = function(e8) {
      return Jr(Wr(e8, void 0, oi), e8 + "");
    }(function(e8, n2) {
      return null == e8 ? {} : Si(e8, n2);
    });
    Ci = Math.ceil;
    Gi = Math.max;
    Bi = function(e8, n2, t2, r2) {
      for (var o2 = -1, i2 = Gi(Ci((n2 - e8) / (t2 || 1)), 0), a3 = Array(i2); i2--; )
        a3[r2 ? i2 : ++o2] = e8, e8 += t2;
      return a3;
    };
    Ai = function(e8) {
      return function(n2, t2, r2) {
        return r2 && "number" != typeof r2 && Vo(n2, t2, r2) && (t2 = r2 = void 0), n2 = ei(n2), void 0 === t2 ? (t2 = n2, n2 = 0) : t2 = ei(t2), r2 = void 0 === r2 ? n2 < t2 ? 1 : -1 : ei(r2), Bi(n2, t2, r2, e8);
      };
    }();
    Li = function(e8, n2) {
      var t2 = e8.length;
      for (e8.sort(n2); t2--; )
        e8[t2] = e8[t2].value;
      return e8;
    };
    Ri = function(e8, n2) {
      if (e8 !== n2) {
        var t2 = void 0 !== e8, r2 = null === e8, o2 = e8 == e8, i2 = Pt(e8), a3 = void 0 !== n2, u2 = null === n2, c3 = n2 == n2, s2 = Pt(n2);
        if (!u2 && !s2 && !i2 && e8 > n2 || i2 && a3 && c3 && !u2 && !s2 || r2 && a3 && c3 || !t2 && c3 || !o2)
          return 1;
        if (!r2 && !i2 && !s2 && e8 < n2 || s2 && t2 && o2 && !r2 && !i2 || u2 && t2 && o2 || !a3 && o2 || !c3)
          return -1;
      }
      return 0;
    };
    Ti = function(e8, n2, t2) {
      for (var r2 = -1, o2 = e8.criteria, i2 = n2.criteria, a3 = o2.length, u2 = t2.length; ++r2 < a3; ) {
        var c3 = Ri(o2[r2], i2[r2]);
        if (c3)
          return r2 >= u2 ? c3 : c3 * ("desc" == t2[r2] ? -1 : 1);
      }
      return e8.index - n2.index;
    };
    Di = function(e8, n2, t2) {
      n2 = n2.length ? Yt(n2, function(e9) {
        return Te(e9) ? function(n3) {
          return nr(n3, 1 === e9.length ? e9[0] : e9);
        } : e9;
      }) : [ht];
      var r2 = -1;
      n2 = Yt(n2, He(dr));
      var o2 = br(e8, function(e9, t3, o3) {
        return { criteria: Yt(n2, function(n3) {
          return n3(e9);
        }), index: ++r2, value: e9 };
      });
      return Li(o2, function(e9, n3) {
        return Ti(e9, n3, t2);
      });
    };
    Pi = Xr(function(e8, n2) {
      if (null == e8)
        return [];
      var t2 = n2.length;
      return t2 > 1 && Vo(e8, n2[0], n2[1]) ? n2 = [] : t2 > 2 && Vo(n2[0], n2[1], n2[2]) && (n2 = [n2[0]]), Di(e8, Vr(n2, 1), []);
    });
    zi = 0;
    Fi = function(e8) {
      var n2 = ++zi;
      return Qt(e8) + n2;
    };
    Ui = function(e8, n2, t2) {
      for (var r2 = -1, o2 = e8.length, i2 = n2.length, a3 = {}; ++r2 < o2; ) {
        var u2 = r2 < i2 ? n2[r2] : void 0;
        t2(a3, e8[r2], u2);
      }
      return a3;
    };
    $i = function(e8, n2) {
      return Ui(e8 || [], n2 || [], Ie);
    };
    try {
      Vi = { cloneDeep: Uo, constant: ct, defaults: Wo, each: pt, filter: fr, find: ri, flatten: oi, forEach: vt, forIn: ii, has: vr, isUndefined: yr, last: ai, map: mr, mapValues: ui, max: di, merge: _i, min: xi, minBy: Ni, now: Oi, pick: Mi, range: Ai, reduce: _r, sortBy: Pi, uniqueId: Fi, values: fo, zipObject: $i };
    } catch (e8) {
    }
    Vi || (Vi = window._);
    Hi = Vi;
    Wi = qi;
    qi.prototype.dequeue = function() {
      var e8 = this._sentinel, n2 = e8._prev;
      if (n2 !== e8)
        return Yi(n2), n2;
    }, qi.prototype.enqueue = function(e8) {
      var n2 = this._sentinel;
      e8._prev && e8._next && Yi(e8), e8._next = n2._next, n2._next._prev = e8, n2._next = e8, e8._prev = n2;
    }, qi.prototype.toString = function() {
      for (var e8 = [], n2 = this._sentinel, t2 = n2._prev; t2 !== n2; )
        e8.push(JSON.stringify(t2, Ji)), t2 = t2._prev;
      return "[" + e8.join(", ") + "]";
    };
    Xi = Fo.Graph;
    Ki = function(e8, n2) {
      if (e8.nodeCount() <= 1)
        return [];
      var t2 = function(e9, n3) {
        var t3 = new Xi(), r3 = 0, o2 = 0;
        Hi.forEach(e9.nodes(), function(e10) {
          t3.setNode(e10, { v: e10, in: 0, out: 0 });
        }), Hi.forEach(e9.edges(), function(e10) {
          var i3 = t3.edge(e10.v, e10.w) || 0, a4 = n3(e10), u2 = i3 + a4;
          t3.setEdge(e10.v, e10.w, u2), o2 = Math.max(o2, t3.node(e10.v).out += a4), r3 = Math.max(r3, t3.node(e10.w).in += a4);
        });
        var i2 = Hi.range(o2 + r3 + 3).map(function() {
          return new Wi();
        }), a3 = r3 + 1;
        return Hi.forEach(t3.nodes(), function(e10) {
          ea(i2, a3, t3.node(e10));
        }), { graph: t3, buckets: i2, zeroIdx: a3 };
      }(e8, n2 || Qi), r2 = function(e9, n3, t3) {
        var r3, o2 = [], i2 = n3[n3.length - 1], a3 = n3[0];
        for (; e9.nodeCount(); ) {
          for (; r3 = a3.dequeue(); )
            Zi(e9, n3, t3, r3);
          for (; r3 = i2.dequeue(); )
            Zi(e9, n3, t3, r3);
          if (e9.nodeCount()) {
            for (var u2 = n3.length - 2; u2 > 0; --u2)
              if (r3 = n3[u2].dequeue()) {
                o2 = o2.concat(Zi(e9, n3, t3, r3, true));
                break;
              }
          }
        }
        return o2;
      }(t2.graph, t2.buckets, t2.zeroIdx);
      return Hi.flatten(Hi.map(r2, function(n3) {
        return e8.outEdges(n3.v, n3.w);
      }), true);
    };
    Qi = Hi.constant(1);
    na = { run: function(e8) {
      var n2 = "greedy" === e8.graph().acyclicer ? Ki(e8, function(e9) {
        return function(n3) {
          return e9.edge(n3).weight;
        };
      }(e8)) : function(e9) {
        var n3 = [], t2 = {}, r2 = {};
        function o2(i2) {
          Hi.has(r2, i2) || (r2[i2] = true, t2[i2] = true, Hi.forEach(e9.outEdges(i2), function(e10) {
            Hi.has(t2, e10.w) ? n3.push(e10) : o2(e10.w);
          }), delete t2[i2]);
        }
        return Hi.forEach(e9.nodes(), o2), n3;
      }(e8);
      Hi.forEach(n2, function(n3) {
        var t2 = e8.edge(n3);
        e8.removeEdge(n3), t2.forwardName = n3.name, t2.reversed = true, e8.setEdge(n3.w, n3.v, t2, Hi.uniqueId("rev"));
      });
    }, undo: function(e8) {
      Hi.forEach(e8.edges(), function(n2) {
        var t2 = e8.edge(n2);
        if (t2.reversed) {
          e8.removeEdge(n2);
          var r2 = t2.forwardName;
          delete t2.reversed, delete t2.forwardName, e8.setEdge(n2.w, n2.v, t2, r2);
        }
      });
    } };
    ta = Fo.Graph;
    ra = { addDummyNode: oa, simplify: function(e8) {
      var n2 = new ta().setGraph(e8.graph());
      return Hi.forEach(e8.nodes(), function(t2) {
        n2.setNode(t2, e8.node(t2));
      }), Hi.forEach(e8.edges(), function(t2) {
        var r2 = n2.edge(t2.v, t2.w) || { weight: 0, minlen: 1 }, o2 = e8.edge(t2);
        n2.setEdge(t2.v, t2.w, { weight: r2.weight + o2.weight, minlen: Math.max(r2.minlen, o2.minlen) });
      }), n2;
    }, asNonCompoundGraph: function(e8) {
      var n2 = new ta({ multigraph: e8.isMultigraph() }).setGraph(e8.graph());
      return Hi.forEach(e8.nodes(), function(t2) {
        e8.children(t2).length || n2.setNode(t2, e8.node(t2));
      }), Hi.forEach(e8.edges(), function(t2) {
        n2.setEdge(t2, e8.edge(t2));
      }), n2;
    }, successorWeights: function(e8) {
      var n2 = Hi.map(e8.nodes(), function(n3) {
        var t2 = {};
        return Hi.forEach(e8.outEdges(n3), function(n4) {
          t2[n4.w] = (t2[n4.w] || 0) + e8.edge(n4).weight;
        }), t2;
      });
      return Hi.zipObject(e8.nodes(), n2);
    }, predecessorWeights: function(e8) {
      var n2 = Hi.map(e8.nodes(), function(n3) {
        var t2 = {};
        return Hi.forEach(e8.inEdges(n3), function(n4) {
          t2[n4.v] = (t2[n4.v] || 0) + e8.edge(n4).weight;
        }), t2;
      });
      return Hi.zipObject(e8.nodes(), n2);
    }, intersectRect: function(e8, n2) {
      var t2, r2, o2 = e8.x, i2 = e8.y, a3 = n2.x - o2, u2 = n2.y - i2, c3 = e8.width / 2, s2 = e8.height / 2;
      if (!a3 && !u2)
        throw new Error("Not possible to find intersection inside of the rectangle");
      Math.abs(u2) * c3 > Math.abs(a3) * s2 ? (u2 < 0 && (s2 = -s2), t2 = s2 * a3 / u2, r2 = s2) : (a3 < 0 && (c3 = -c3), t2 = c3, r2 = c3 * u2 / a3);
      return { x: o2 + t2, y: i2 + r2 };
    }, buildLayerMatrix: function(e8) {
      var n2 = Hi.map(Hi.range(ia(e8) + 1), function() {
        return [];
      });
      return Hi.forEach(e8.nodes(), function(t2) {
        var r2 = e8.node(t2), o2 = r2.rank;
        Hi.isUndefined(o2) || (n2[o2][r2.order] = t2);
      }), n2;
    }, normalizeRanks: function(e8) {
      var n2 = Hi.min(Hi.map(e8.nodes(), function(n3) {
        return e8.node(n3).rank;
      }));
      Hi.forEach(e8.nodes(), function(t2) {
        var r2 = e8.node(t2);
        Hi.has(r2, "rank") && (r2.rank -= n2);
      });
    }, removeEmptyRanks: function(e8) {
      var n2 = Hi.min(Hi.map(e8.nodes(), function(n3) {
        return e8.node(n3).rank;
      })), t2 = [];
      Hi.forEach(e8.nodes(), function(r3) {
        var o3 = e8.node(r3).rank - n2;
        t2[o3] || (t2[o3] = []), t2[o3].push(r3);
      });
      var r2 = 0, o2 = e8.graph().nodeRankFactor;
      Hi.forEach(t2, function(n3, t3) {
        Hi.isUndefined(n3) && t3 % o2 != 0 ? --r2 : r2 && Hi.forEach(n3, function(n4) {
          e8.node(n4).rank += r2;
        });
      });
    }, addBorderNode: function(e8, n2, t2, r2) {
      var o2 = { width: 0, height: 0 };
      arguments.length >= 4 && (o2.rank = t2, o2.order = r2);
      return oa(e8, "border", o2, n2);
    }, maxRank: ia, partition: function(e8, n2) {
      var t2 = { lhs: [], rhs: [] };
      return Hi.forEach(e8, function(e9) {
        n2(e9) ? t2.lhs.push(e9) : t2.rhs.push(e9);
      }), t2;
    }, time: function(e8, n2) {
      var t2 = Hi.now();
      try {
        return n2();
      } finally {
        console.log(e8 + " time: " + (Hi.now() - t2) + "ms");
      }
    }, notime: function(e8, n2) {
      return n2();
    } };
    aa = { run: function(e8) {
      e8.graph().dummyChains = [], Hi.forEach(e8.edges(), function(n2) {
        !function(e9, n3) {
          var t2, r2, o2, i2 = n3.v, a3 = e9.node(i2).rank, u2 = n3.w, c3 = e9.node(u2).rank, s2 = n3.name, d2 = e9.edge(n3), f2 = d2.labelRank;
          if (c3 === a3 + 1)
            return;
          for (e9.removeEdge(n3), o2 = 0, ++a3; a3 < c3; ++o2, ++a3)
            d2.points = [], r2 = { width: 0, height: 0, edgeLabel: d2, edgeObj: n3, rank: a3 }, t2 = ra.addDummyNode(e9, "edge", r2, "_d"), a3 === f2 && (r2.width = d2.width, r2.height = d2.height, r2.dummy = "edge-label", r2.labelpos = d2.labelpos), e9.setEdge(i2, t2, { weight: d2.weight }, s2), 0 === o2 && e9.graph().dummyChains.push(t2), i2 = t2;
          e9.setEdge(i2, u2, { weight: d2.weight }, s2);
        }(e8, n2);
      });
    }, undo: function(e8) {
      Hi.forEach(e8.graph().dummyChains, function(n2) {
        var t2, r2 = e8.node(n2), o2 = r2.edgeLabel;
        for (e8.setEdge(r2.edgeObj, o2); r2.dummy; )
          t2 = e8.successors(n2)[0], e8.removeNode(n2), o2.points.push({ x: r2.x, y: r2.y }), "edge-label" === r2.dummy && (o2.x = r2.x, o2.y = r2.y, o2.width = r2.width, o2.height = r2.height), n2 = t2, r2 = e8.node(n2);
      });
    } };
    ua = function(e8) {
      var n2 = {};
      Hi.forEach(e8.sources(), function t2(r2) {
        var o2 = e8.node(r2);
        if (Hi.has(n2, r2))
          return o2.rank;
        n2[r2] = true;
        var i2 = Hi.min(Hi.map(e8.outEdges(r2), function(n3) {
          return t2(n3.w) - e8.edge(n3).minlen;
        }));
        return i2 !== Number.POSITIVE_INFINITY && null != i2 || (i2 = 0), o2.rank = i2;
      });
    };
    ca = function(e8, n2) {
      return e8.node(n2.w).rank - e8.node(n2.v).rank - e8.edge(n2).minlen;
    };
    sa = Fo.Graph;
    da = ca;
    fa = function(e8) {
      var n2, t2, r2 = new sa({ directed: false }), o2 = e8.nodes()[0], i2 = e8.nodeCount();
      r2.setNode(o2, {});
      for (; ha(r2, e8) < i2; )
        n2 = la(r2, e8), t2 = r2.hasNode(n2.v) ? da(e8, n2) : -da(e8, n2), va(r2, e8, t2);
      return r2;
    };
    pa = ca;
    ga = ua;
    ya = Fo.alg.preorder;
    ba = Fo.alg.postorder;
    ma = ra.simplify;
    wa = Ea;
    Ea.initLowLimValues = xa, Ea.initCutValues = _a, Ea.calcCutValue = ja, Ea.leaveEdge = Oa, Ea.enterEdge = ka, Ea.exchangeEdges = Ia;
    Ma = ua;
    Ca = function(e8) {
      switch (e8.graph().ranker) {
        case "network-simplex":
          Ba(e8);
          break;
        case "tight-tree":
          !function(e9) {
            Ma(e9), fa(e9);
          }(e8);
          break;
        case "longest-path":
          Ga(e8);
          break;
        default:
          Ba(e8);
      }
    };
    Ga = Ma;
    Aa = function(e8) {
      var n2 = function(e9) {
        var n3 = {}, t2 = 0;
        function r2(o2) {
          var i2 = t2;
          Hi.forEach(e9.children(o2), r2), n3[o2] = { low: i2, lim: t2++ };
        }
        return Hi.forEach(e9.children(), r2), n3;
      }(e8);
      Hi.forEach(e8.graph().dummyChains, function(t2) {
        for (var r2 = e8.node(t2), o2 = r2.edgeObj, i2 = function(e9, n3, t3, r3) {
          var o3, i3, a4 = [], u3 = [], c4 = Math.min(n3[t3].low, n3[r3].low), s3 = Math.max(n3[t3].lim, n3[r3].lim);
          o3 = t3;
          do {
            o3 = e9.parent(o3), a4.push(o3);
          } while (o3 && (n3[o3].low > c4 || s3 > n3[o3].lim));
          i3 = o3, o3 = r3;
          for (; (o3 = e9.parent(o3)) !== i3; )
            u3.push(o3);
          return { path: a4.concat(u3.reverse()), lca: i3 };
        }(e8, n2, o2.v, o2.w), a3 = i2.path, u2 = i2.lca, c3 = 0, s2 = a3[c3], d2 = true; t2 !== o2.w; ) {
          if (r2 = e8.node(t2), d2) {
            for (; (s2 = a3[c3]) !== u2 && e8.node(s2).maxRank < r2.rank; )
              c3++;
            s2 === u2 && (d2 = false);
          }
          if (!d2) {
            for (; c3 < a3.length - 1 && e8.node(s2 = a3[c3 + 1]).minRank <= r2.rank; )
              c3++;
            s2 = a3[c3];
          }
          e8.setParent(t2, s2), t2 = e8.successors(t2)[0];
        }
      });
    };
    La = { run: function(e8) {
      var n2 = ra.addDummyNode(e8, "root", {}, "_root"), t2 = function(e9) {
        var n3 = {};
        function t3(r3, o3) {
          var i3 = e9.children(r3);
          i3 && i3.length && Hi.forEach(i3, function(e10) {
            t3(e10, o3 + 1);
          }), n3[r3] = o3;
        }
        return Hi.forEach(e9.children(), function(e10) {
          t3(e10, 1);
        }), n3;
      }(e8), r2 = Hi.max(Hi.values(t2)) - 1, o2 = 2 * r2 + 1;
      e8.graph().nestingRoot = n2, Hi.forEach(e8.edges(), function(n3) {
        e8.edge(n3).minlen *= o2;
      });
      var i2 = function(e9) {
        return Hi.reduce(e9.edges(), function(n3, t3) {
          return n3 + e9.edge(t3).weight;
        }, 0);
      }(e8) + 1;
      Hi.forEach(e8.children(), function(a3) {
        Ra(e8, n2, o2, i2, r2, t2, a3);
      }), e8.graph().nodeRankFactor = o2;
    }, cleanup: function(e8) {
      var n2 = e8.graph();
      e8.removeNode(n2.nestingRoot), delete n2.nestingRoot, Hi.forEach(e8.edges(), function(n3) {
        e8.edge(n3).nestingEdge && e8.removeEdge(n3);
      });
    } };
    Ta = function(e8) {
      Hi.forEach(e8.children(), function n2(t2) {
        var r2 = e8.children(t2), o2 = e8.node(t2);
        if (r2.length && Hi.forEach(r2, n2), Hi.has(o2, "minRank")) {
          o2.borderLeft = [], o2.borderRight = [];
          for (var i2 = o2.minRank, a3 = o2.maxRank + 1; i2 < a3; ++i2)
            Da(e8, "borderLeft", "_bl", t2, o2, i2), Da(e8, "borderRight", "_br", t2, o2, i2);
        }
      });
    };
    Pa = { adjust: function(e8) {
      var n2 = e8.graph().rankdir.toLowerCase();
      "lr" !== n2 && "rl" !== n2 || za(e8);
    }, undo: function(e8) {
      var n2 = e8.graph().rankdir.toLowerCase();
      "bt" !== n2 && "rl" !== n2 || function(e9) {
        Hi.forEach(e9.nodes(), function(n3) {
          Ua(e9.node(n3));
        }), Hi.forEach(e9.edges(), function(n3) {
          var t2 = e9.edge(n3);
          Hi.forEach(t2.points, Ua), Hi.has(t2, "y") && Ua(t2);
        });
      }(e8);
      "lr" !== n2 && "rl" !== n2 || (!function(e9) {
        Hi.forEach(e9.nodes(), function(n3) {
          Va(e9.node(n3));
        }), Hi.forEach(e9.edges(), function(n3) {
          var t2 = e9.edge(n3);
          Hi.forEach(t2.points, Va), Hi.has(t2, "x") && Va(t2);
        });
      }(e8), za(e8));
    } };
    $a = function(e8) {
      var n2 = {}, t2 = Hi.filter(e8.nodes(), function(n3) {
        return !e8.children(n3).length;
      }), r2 = Hi.max(Hi.map(t2, function(n3) {
        return e8.node(n3).rank;
      })), o2 = Hi.map(Hi.range(r2 + 1), function() {
        return [];
      });
      function i2(t3) {
        if (!Hi.has(n2, t3)) {
          n2[t3] = true;
          var r3 = e8.node(t3);
          o2[r3.rank].push(t3), Hi.forEach(e8.successors(t3), i2);
        }
      }
      var a3 = Hi.sortBy(t2, function(n3) {
        return e8.node(n3).rank;
      });
      return Hi.forEach(a3, i2), o2;
    };
    Ha = function(e8, n2) {
      for (var t2 = 0, r2 = 1; r2 < n2.length; ++r2)
        t2 += Wa(e8, n2[r2 - 1], n2[r2]);
      return t2;
    };
    qa = function(e8, n2) {
      return Hi.map(n2, function(n3) {
        var t2 = e8.inEdges(n3);
        if (t2.length) {
          var r2 = Hi.reduce(t2, function(n4, t3) {
            var r3 = e8.edge(t3), o2 = e8.node(t3.v);
            return { sum: n4.sum + r3.weight * o2.order, weight: n4.weight + r3.weight };
          }, { sum: 0, weight: 0 });
          return { v: n3, barycenter: r2.sum / r2.weight, weight: r2.weight };
        }
        return { v: n3 };
      });
    };
    Ya = function(e8, n2) {
      var t2 = {};
      return Hi.forEach(e8, function(e9, n3) {
        var r2 = t2[e9.v] = { indegree: 0, in: [], out: [], vs: [e9.v], i: n3 };
        Hi.isUndefined(e9.barycenter) || (r2.barycenter = e9.barycenter, r2.weight = e9.weight);
      }), Hi.forEach(n2.edges(), function(e9) {
        var n3 = t2[e9.v], r2 = t2[e9.w];
        Hi.isUndefined(n3) || Hi.isUndefined(r2) || (r2.indegree++, n3.out.push(t2[e9.w]));
      }), function(e9) {
        var n3 = [];
        function t3(e10) {
          return function(n4) {
            n4.merged || (Hi.isUndefined(n4.barycenter) || Hi.isUndefined(e10.barycenter) || n4.barycenter >= e10.barycenter) && function(e11, n5) {
              var t4 = 0, r3 = 0;
              e11.weight && (t4 += e11.barycenter * e11.weight, r3 += e11.weight);
              n5.weight && (t4 += n5.barycenter * n5.weight, r3 += n5.weight);
              e11.vs = n5.vs.concat(e11.vs), e11.barycenter = t4 / r3, e11.weight = r3, e11.i = Math.min(n5.i, e11.i), n5.merged = true;
            }(e10, n4);
          };
        }
        function r2(n4) {
          return function(t4) {
            t4.in.push(n4), 0 == --t4.indegree && e9.push(t4);
          };
        }
        for (; e9.length; ) {
          var o2 = e9.pop();
          n3.push(o2), Hi.forEach(o2.in.reverse(), t3(o2)), Hi.forEach(o2.out, r2(o2));
        }
        return Hi.map(Hi.filter(n3, function(e10) {
          return !e10.merged;
        }), function(e10) {
          return Hi.pick(e10, ["vs", "i", "barycenter", "weight"]);
        });
      }(Hi.filter(t2, function(e9) {
        return !e9.indegree;
      }));
    };
    Ja = function(e8, n2) {
      var t2 = ra.partition(e8, function(e9) {
        return Hi.has(e9, "barycenter");
      }), r2 = t2.lhs, o2 = Hi.sortBy(t2.rhs, function(e9) {
        return -e9.i;
      }), i2 = [], a3 = 0, u2 = 0, c3 = 0;
      r2.sort((s2 = !!n2, function(e9, n3) {
        return e9.barycenter < n3.barycenter ? -1 : e9.barycenter > n3.barycenter ? 1 : s2 ? n3.i - e9.i : e9.i - n3.i;
      })), c3 = Xa(i2, o2, c3), Hi.forEach(r2, function(e9) {
        c3 += e9.vs.length, i2.push(e9.vs), a3 += e9.barycenter * e9.weight, u2 += e9.weight, c3 = Xa(i2, o2, c3);
      });
      var s2;
      var d2 = { vs: Hi.flatten(i2, true) };
      u2 && (d2.barycenter = a3 / u2, d2.weight = u2);
      return d2;
    };
    Ka = function e7(n2, t2, r2, o2) {
      var i2 = n2.children(t2), a3 = n2.node(t2), u2 = a3 ? a3.borderLeft : void 0, c3 = a3 ? a3.borderRight : void 0, s2 = {};
      u2 && (i2 = Hi.filter(i2, function(e8) {
        return e8 !== u2 && e8 !== c3;
      }));
      var d2 = qa(n2, i2);
      Hi.forEach(d2, function(t3) {
        if (n2.children(t3.v).length) {
          var i3 = e7(n2, t3.v, r2, o2);
          s2[t3.v] = i3, Hi.has(i3, "barycenter") && (a4 = t3, u3 = i3, Hi.isUndefined(a4.barycenter) ? (a4.barycenter = u3.barycenter, a4.weight = u3.weight) : (a4.barycenter = (a4.barycenter * a4.weight + u3.barycenter * u3.weight) / (a4.weight + u3.weight), a4.weight += u3.weight));
        }
        var a4, u3;
      });
      var f2 = Ya(d2, r2);
      !function(e8, n3) {
        Hi.forEach(e8, function(e9) {
          e9.vs = Hi.flatten(e9.vs.map(function(e10) {
            return n3[e10] ? n3[e10].vs : e10;
          }), true);
        });
      }(f2, s2);
      var h2 = Ja(f2, o2);
      if (u2 && (h2.vs = Hi.flatten([u2, h2.vs, c3], true), n2.predecessors(u2).length)) {
        var l2 = n2.node(n2.predecessors(u2)[0]), v2 = n2.node(n2.predecessors(c3)[0]);
        Hi.has(h2, "barycenter") || (h2.barycenter = 0, h2.weight = 0), h2.barycenter = (h2.barycenter * h2.weight + l2.order + v2.order) / (h2.weight + 2), h2.weight += 2;
      }
      return h2;
    };
    Qa = Fo.Graph;
    Za = function(e8, n2, t2) {
      var r2 = function(e9) {
        var n3;
        for (; e9.hasNode(n3 = Hi.uniqueId("_root")); )
          ;
        return n3;
      }(e8), o2 = new Qa({ compound: true }).setGraph({ root: r2 }).setDefaultNodeLabel(function(n3) {
        return e8.node(n3);
      });
      return Hi.forEach(e8.nodes(), function(i2) {
        var a3 = e8.node(i2), u2 = e8.parent(i2);
        (a3.rank === n2 || a3.minRank <= n2 && n2 <= a3.maxRank) && (o2.setNode(i2), o2.setParent(i2, u2 || r2), Hi.forEach(e8[t2](i2), function(n3) {
          var t3 = n3.v === i2 ? n3.w : n3.v, r3 = o2.edge(t3, i2), a4 = Hi.isUndefined(r3) ? 0 : r3.weight;
          o2.setEdge(t3, i2, { weight: e8.edge(n3).weight + a4 });
        }), Hi.has(a3, "minRank") && o2.setNode(i2, { borderLeft: a3.borderLeft[n2], borderRight: a3.borderRight[n2] }));
      }), o2;
    };
    eu = function(e8, n2, t2) {
      var r2, o2 = {};
      Hi.forEach(t2, function(t3) {
        for (var i2, a3, u2 = e8.parent(t3); u2; ) {
          if ((i2 = e8.parent(u2)) ? (a3 = o2[i2], o2[i2] = u2) : (a3 = r2, r2 = u2), a3 && a3 !== u2)
            return void n2.setEdge(a3, u2);
          u2 = i2;
        }
      });
    };
    nu = Fo.Graph;
    tu = function(e8) {
      var n2 = ra.maxRank(e8), t2 = ru(e8, Hi.range(1, n2 + 1), "inEdges"), r2 = ru(e8, Hi.range(n2 - 1, -1, -1), "outEdges"), o2 = $a(e8);
      iu(e8, o2);
      for (var i2, a3 = Number.POSITIVE_INFINITY, u2 = 0, c3 = 0; c3 < 4; ++u2, ++c3) {
        ou(u2 % 2 ? t2 : r2, u2 % 4 >= 2), o2 = ra.buildLayerMatrix(e8);
        var s2 = Ha(e8, o2);
        s2 < a3 && (c3 = 0, i2 = Hi.cloneDeep(o2), a3 = s2);
      }
      iu(e8, i2);
    };
    au = Fo.Graph;
    uu = function(e8) {
      var n2, t2 = ra.buildLayerMatrix(e8), r2 = Hi.merge(cu(e8, t2), su(e8, t2)), o2 = {};
      Hi.forEach(["u", "d"], function(i3) {
        n2 = "u" === i3 ? t2 : Hi.values(t2).reverse(), Hi.forEach(["l", "r"], function(t3) {
          "r" === t3 && (n2 = Hi.map(n2, function(e9) {
            return Hi.values(e9).reverse();
          }));
          var a3 = ("u" === i3 ? e8.predecessors : e8.successors).bind(e8), u2 = hu(e8, n2, r2, a3), c3 = lu(e8, n2, u2.root, u2.align, "r" === t3);
          "r" === t3 && (c3 = Hi.mapValues(c3, function(e9) {
            return -e9;
          })), o2[i3 + t3] = c3;
        });
      });
      var i2 = vu(e8, o2);
      return pu(o2, i2), gu(o2, e8.graph().align);
    };
    yu = uu;
    bu = function(e8) {
      (function(e9) {
        var n2 = ra.buildLayerMatrix(e9), t2 = e9.graph().ranksep, r2 = 0;
        Hi.forEach(n2, function(n3) {
          var o2 = Hi.max(Hi.map(n3, function(n4) {
            return e9.node(n4).height;
          }));
          Hi.forEach(n3, function(n4) {
            e9.node(n4).y = r2 + o2 / 2;
          }), r2 += o2 + t2;
        });
      })(e8 = ra.asNonCompoundGraph(e8)), Hi.forEach(yu(e8), function(n2, t2) {
        e8.node(t2).x = n2;
      });
    };
    mu = ra.normalizeRanks;
    wu = ra.removeEmptyRanks;
    Eu = ra;
    _u = Fo.Graph;
    ju = function(e8, n2) {
      var t2 = n2 && n2.debugTiming ? Eu.time : Eu.notime;
      t2("layout", function() {
        var n3 = t2("  buildLayoutGraph", function() {
          return function(e9) {
            var n4 = new _u({ multigraph: true, compound: true }), t3 = Bu(e9.graph());
            return n4.setGraph(Hi.merge({}, Nu, Gu(t3, xu), Hi.pick(t3, Ou))), Hi.forEach(e9.nodes(), function(t4) {
              var r2 = Bu(e9.node(t4));
              n4.setNode(t4, Hi.defaults(Gu(r2, ku), Iu)), n4.setParent(t4, e9.parent(t4));
            }), Hi.forEach(e9.edges(), function(t4) {
              var r2 = Bu(e9.edge(t4));
              n4.setEdge(t4, Hi.merge({}, Mu, Gu(r2, Su), Hi.pick(r2, Cu)));
            }), n4;
          }(e8);
        });
        t2("  runLayout", function() {
          !function(e9, n4) {
            n4("    makeSpaceForEdgeLabels", function() {
              !function(e10) {
                var n5 = e10.graph();
                n5.ranksep /= 2, Hi.forEach(e10.edges(), function(t3) {
                  var r2 = e10.edge(t3);
                  r2.minlen *= 2, "c" !== r2.labelpos.toLowerCase() && ("TB" === n5.rankdir || "BT" === n5.rankdir ? r2.width += r2.labeloffset : r2.height += r2.labeloffset);
                });
              }(e9);
            }), n4("    removeSelfEdges", function() {
              !function(e10) {
                Hi.forEach(e10.edges(), function(n5) {
                  if (n5.v === n5.w) {
                    var t3 = e10.node(n5.v);
                    t3.selfEdges || (t3.selfEdges = []), t3.selfEdges.push({ e: n5, label: e10.edge(n5) }), e10.removeEdge(n5);
                  }
                });
              }(e9);
            }), n4("    acyclic", function() {
              na.run(e9);
            }), n4("    nestingGraph.run", function() {
              La.run(e9);
            }), n4("    rank", function() {
              Ca(Eu.asNonCompoundGraph(e9));
            }), n4("    injectEdgeLabelProxies", function() {
              !function(e10) {
                Hi.forEach(e10.edges(), function(n5) {
                  var t3 = e10.edge(n5);
                  if (t3.width && t3.height) {
                    var r2 = e10.node(n5.v), o2 = { rank: (e10.node(n5.w).rank - r2.rank) / 2 + r2.rank, e: n5 };
                    Eu.addDummyNode(e10, "edge-proxy", o2, "_ep");
                  }
                });
              }(e9);
            }), n4("    removeEmptyRanks", function() {
              wu(e9);
            }), n4("    nestingGraph.cleanup", function() {
              La.cleanup(e9);
            }), n4("    normalizeRanks", function() {
              mu(e9);
            }), n4("    assignRankMinMax", function() {
              !function(e10) {
                var n5 = 0;
                Hi.forEach(e10.nodes(), function(t3) {
                  var r2 = e10.node(t3);
                  r2.borderTop && (r2.minRank = e10.node(r2.borderTop).rank, r2.maxRank = e10.node(r2.borderBottom).rank, n5 = Hi.max(n5, r2.maxRank));
                }), e10.graph().maxRank = n5;
              }(e9);
            }), n4("    removeEdgeLabelProxies", function() {
              !function(e10) {
                Hi.forEach(e10.nodes(), function(n5) {
                  var t3 = e10.node(n5);
                  "edge-proxy" === t3.dummy && (e10.edge(t3.e).labelRank = t3.rank, e10.removeNode(n5));
                });
              }(e9);
            }), n4("    normalize.run", function() {
              aa.run(e9);
            }), n4("    parentDummyChains", function() {
              Aa(e9);
            }), n4("    addBorderSegments", function() {
              Ta(e9);
            }), n4("    order", function() {
              tu(e9);
            }), n4("    insertSelfEdges", function() {
              !function(e10) {
                var n5 = Eu.buildLayerMatrix(e10);
                Hi.forEach(n5, function(n6) {
                  var t3 = 0;
                  Hi.forEach(n6, function(n7, r2) {
                    var o2 = e10.node(n7);
                    o2.order = r2 + t3, Hi.forEach(o2.selfEdges, function(n8) {
                      Eu.addDummyNode(e10, "selfedge", { width: n8.label.width, height: n8.label.height, rank: o2.rank, order: r2 + ++t3, e: n8.e, label: n8.label }, "_se");
                    }), delete o2.selfEdges;
                  });
                });
              }(e9);
            }), n4("    adjustCoordinateSystem", function() {
              Pa.adjust(e9);
            }), n4("    position", function() {
              bu(e9);
            }), n4("    positionSelfEdges", function() {
              !function(e10) {
                Hi.forEach(e10.nodes(), function(n5) {
                  var t3 = e10.node(n5);
                  if ("selfedge" === t3.dummy) {
                    var r2 = e10.node(t3.e.v), o2 = r2.x + r2.width / 2, i2 = r2.y, a3 = t3.x - o2, u2 = r2.height / 2;
                    e10.setEdge(t3.e, t3.label), e10.removeNode(n5), t3.label.points = [{ x: o2 + 2 * a3 / 3, y: i2 - u2 }, { x: o2 + 5 * a3 / 6, y: i2 - u2 }, { x: o2 + a3, y: i2 }, { x: o2 + 5 * a3 / 6, y: i2 + u2 }, { x: o2 + 2 * a3 / 3, y: i2 + u2 }], t3.label.x = t3.x, t3.label.y = t3.y;
                  }
                });
              }(e9);
            }), n4("    removeBorderNodes", function() {
              !function(e10) {
                Hi.forEach(e10.nodes(), function(n5) {
                  if (e10.children(n5).length) {
                    var t3 = e10.node(n5), r2 = e10.node(t3.borderTop), o2 = e10.node(t3.borderBottom), i2 = e10.node(Hi.last(t3.borderLeft)), a3 = e10.node(Hi.last(t3.borderRight));
                    t3.width = Math.abs(a3.x - i2.x), t3.height = Math.abs(o2.y - r2.y), t3.x = i2.x + t3.width / 2, t3.y = r2.y + t3.height / 2;
                  }
                }), Hi.forEach(e10.nodes(), function(n5) {
                  "border" === e10.node(n5).dummy && e10.removeNode(n5);
                });
              }(e9);
            }), n4("    normalize.undo", function() {
              aa.undo(e9);
            }), n4("    fixupEdgeLabelCoords", function() {
              !function(e10) {
                Hi.forEach(e10.edges(), function(n5) {
                  var t3 = e10.edge(n5);
                  if (Hi.has(t3, "x"))
                    switch ("l" !== t3.labelpos && "r" !== t3.labelpos || (t3.width -= t3.labeloffset), t3.labelpos) {
                      case "l":
                        t3.x -= t3.width / 2 + t3.labeloffset;
                        break;
                      case "r":
                        t3.x += t3.width / 2 + t3.labeloffset;
                    }
                });
              }(e9);
            }), n4("    undoCoordinateSystem", function() {
              Pa.undo(e9);
            }), n4("    translateGraph", function() {
              !function(e10) {
                var n5 = Number.POSITIVE_INFINITY, t3 = 0, r2 = Number.POSITIVE_INFINITY, o2 = 0, i2 = e10.graph(), a3 = i2.marginx || 0, u2 = i2.marginy || 0;
                function c3(e11) {
                  var i3 = e11.x, a4 = e11.y, u3 = e11.width, c4 = e11.height;
                  n5 = Math.min(n5, i3 - u3 / 2), t3 = Math.max(t3, i3 + u3 / 2), r2 = Math.min(r2, a4 - c4 / 2), o2 = Math.max(o2, a4 + c4 / 2);
                }
                Hi.forEach(e10.nodes(), function(n6) {
                  c3(e10.node(n6));
                }), Hi.forEach(e10.edges(), function(n6) {
                  var t4 = e10.edge(n6);
                  Hi.has(t4, "x") && c3(t4);
                }), n5 -= a3, r2 -= u2, Hi.forEach(e10.nodes(), function(t4) {
                  var o3 = e10.node(t4);
                  o3.x -= n5, o3.y -= r2;
                }), Hi.forEach(e10.edges(), function(t4) {
                  var o3 = e10.edge(t4);
                  Hi.forEach(o3.points, function(e11) {
                    e11.x -= n5, e11.y -= r2;
                  }), Hi.has(o3, "x") && (o3.x -= n5), Hi.has(o3, "y") && (o3.y -= r2);
                }), i2.width = t3 - n5 + a3, i2.height = o2 - r2 + u2;
              }(e9);
            }), n4("    assignNodeIntersects", function() {
              !function(e10) {
                Hi.forEach(e10.edges(), function(n5) {
                  var t3, r2, o2 = e10.edge(n5), i2 = e10.node(n5.v), a3 = e10.node(n5.w);
                  o2.points ? (t3 = o2.points[0], r2 = o2.points[o2.points.length - 1]) : (o2.points = [], t3 = a3, r2 = i2), o2.points.unshift(Eu.intersectRect(i2, t3)), o2.points.push(Eu.intersectRect(a3, r2));
                });
              }(e9);
            }), n4("    reversePoints", function() {
              !function(e10) {
                Hi.forEach(e10.edges(), function(n5) {
                  var t3 = e10.edge(n5);
                  t3.reversed && t3.points.reverse();
                });
              }(e9);
            }), n4("    acyclic.undo", function() {
              na.undo(e9);
            });
          }(n3, t2);
        }), t2("  updateInputGraph", function() {
          !function(e9, n4) {
            Hi.forEach(e9.nodes(), function(t3) {
              var r2 = e9.node(t3), o2 = n4.node(t3);
              r2 && (r2.x = o2.x, r2.y = o2.y, n4.children(t3).length && (r2.width = o2.width, r2.height = o2.height));
            }), Hi.forEach(e9.edges(), function(t3) {
              var r2 = e9.edge(t3), o2 = n4.edge(t3);
              r2.points = o2.points, Hi.has(o2, "x") && (r2.x = o2.x, r2.y = o2.y);
            }), e9.graph().width = n4.graph().width, e9.graph().height = n4.graph().height;
          }(e8, n3);
        });
      });
    };
    xu = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    Nu = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    Ou = ["acyclicer", "ranker", "rankdir", "align"];
    ku = ["width", "height"];
    Iu = { width: 0, height: 0 };
    Su = ["minlen", "weight", "width", "height", "labeloffset"];
    Mu = { minlen: 1, weight: 1, width: 0, height: 0, labeloffset: 10, labelpos: "r" };
    Cu = ["labelpos"];
    Au = Fo.Graph;
    Lu = { graphlib: Fo, layout: ju, debug: { debugOrdering: function(e8) {
      var n2 = ra.buildLayerMatrix(e8), t2 = new Au({ compound: true, multigraph: true }).setGraph({});
      return Hi.forEach(e8.nodes(), function(n3) {
        t2.setNode(n3, { label: n3 }), t2.setParent(n3, "layer" + e8.node(n3).rank);
      }), Hi.forEach(e8.edges(), function(e9) {
        t2.setEdge(e9.v, e9.w, {}, e9.name);
      }), Hi.forEach(n2, function(e9, n3) {
        var r2 = "layer" + n3;
        t2.setNode(r2, { rank: "same" }), Hi.reduce(e9, function(e10, n4) {
          return t2.setEdge(e10, n4, { style: "invis" }), n4;
        });
      }), t2;
    } }, util: { time: ra.time, notime: ra.notime }, version: "0.8.5" };
    Ru = Lu.graphlib;
    Tu = Lu.layout;
    Du = class {
      constructor(e8) {
        this.cardinality = 1, this.include = a2.UNSPECIFIED, this.isGroupNode = false, this.parentNode = null, this.type = i.NODE, this.name = e8.name, this.attr = e8.attr || {}, this.inputs = e8.inputs, this.path = e8.path || [], this.width = e8.width, this.height = e8.height;
      }
    };
    Pu = class {
      constructor() {
        this.nodes = {}, this.edges = [], this.nodes = {}, this.edges = [];
      }
    };
    Fu = class {
      constructor(e8, n2 = {}) {
        this.attr = null, this.bridgeGraph = null, this.cardinality = 0, this.depth = 1, this.include = a2.UNSPECIFIED, this.isGroupNode = true, this.parentNode = null, this.type = i.META, this.path = [], this.name = e8, this.metaGraph = Hu(e8, u.META, n2);
      }
      getFirstChild() {
        return this.metaGraph.node(this.metaGraph.nodes()[0]);
      }
      getChildren() {
        return this.metaGraph.nodes().map((e8) => this.metaGraph.node(e8));
      }
      leaves() {
        let e8, n2 = [], t2 = [this];
        for (; t2.length; ) {
          let r2 = t2.shift();
          r2.isGroupNode ? (e8 = r2.metaGraph, e8.nodes().forEach((n3) => t2.push(e8.node(n3)))) : n2.push(r2.name);
        }
        return n2;
      }
    };
    Uu = class {
      constructor(e8, n2) {
        this.v = e8, this.w = n2, this.baseEdgeList = [], this.inbound = null, this.name = null;
      }
      addBaseEdge(e8, n2) {
        this.baseEdgeList.push(e8);
      }
    };
    Wu = class {
      constructor(e8 = {}) {
        this.graphOptions = e8, this.index = {}, this.graphOptions.compound = true, this.root = Vu(r, this.graphOptions), this.index[r] = this.root;
      }
      getNodeMap() {
        return this.index;
      }
      node(e8) {
        return this.index[e8];
      }
      setNode(e8, n2) {
        this.index[e8] = n2;
      }
      getBridgeGraph(e8) {
        const n2 = this.index[e8];
        if (!n2)
          throw Error("Could not find node in hierarchy: " + e8);
        if (!("metaGraph" in n2))
          return null;
        const t2 = n2;
        if (t2.bridgeGraph)
          return t2.bridgeGraph;
        const r2 = Hu(o, u.BRIDGE, this.graphOptions);
        if (t2.bridgeGraph = r2, !n2.parentNode || !("metaGraph" in n2.parentNode))
          return r2;
        const i2 = n2.parentNode;
        return [i2.metaGraph, this.getBridgeGraph(i2.name)].forEach((n3) => {
          n3.edges().filter((n4) => n4.v === e8 || n4.w === e8).forEach((t3) => {
            const o2 = t3.w === e8;
            n3.edge(t3).baseEdgeList.forEach((n4) => {
              const [i3, a3] = o2 ? [n4.w, t3.v] : [n4.v, t3.w], u2 = this.getChildName(e8, i3), c3 = { v: o2 ? a3 : u2, w: o2 ? u2 : a3 };
              let s2 = r2.edge(c3);
              s2 || (s2 = $u(c3.v, c3.w), s2.inbound = o2, r2.setEdge(c3.v, c3.w, s2)), s2.addBaseEdge(n4, this);
            });
          });
        }), r2;
      }
      getChildName(e8, n2) {
        let t2 = this.index[n2];
        for (; t2; ) {
          if (t2.parentNode && t2.parentNode.name === e8)
            return t2.name;
          t2 = t2.parentNode;
        }
        throw Error("Could not find immediate child for descendant: " + n2);
      }
      getPredecessors(e8) {
        const n2 = this.index[e8];
        if (!n2)
          throw Error("Could not find node with name: " + e8);
        return this.getOneWayEdges(n2, true);
      }
      getSuccessors(e8) {
        const n2 = this.index[e8];
        if (!n2)
          throw Error("Could not find node with name: " + e8);
        return this.getOneWayEdges(n2, false);
      }
      getOneWayEdges(e8, n2) {
        const t2 = [];
        if (!e8.parentNode || !e8.parentNode.isGroupNode)
          return t2;
        const r2 = e8.parentNode, o2 = r2.metaGraph, i2 = this.getBridgeGraph(r2.name);
        return Yu(o2, e8, n2, t2), Yu(i2, e8, n2, t2), t2;
      }
    };
    Ju = class {
      constructor(e8) {
        this.hierarchy = e8, this.index = {}, this.hasSubHierarchy = {}, this.root = new Qu(this.hierarchy.root, this.hierarchy.graphOptions), this.index[e8.root.name] = this.root, this.buildSubHierarchy(e8.root.name), this.root.expanded = true;
      }
      getRenderInfoNodes() {
        return Object.values(this.index);
      }
      getSubHierarchy() {
        return this.hasSubHierarchy;
      }
      buildSubHierarchy(e8) {
        if (e8 in this.hasSubHierarchy)
          return;
        this.hasSubHierarchy[e8] = true;
        const n2 = this.index[e8];
        if (n2.node.type !== i.META)
          return;
        const t2 = n2, r2 = t2.node.metaGraph, o2 = t2.coreGraph;
        r2.nodes().forEach((e9) => {
          const n3 = this.getOrCreateRenderNodeByName(e9);
          o2.setNode(e9, n3);
        }), r2.edges().forEach((e9) => {
          const n3 = r2.edge(e9), t3 = new Ku(n3);
          o2.setEdge(e9.v, e9.w, t3);
        });
        const u2 = t2.node.parentNode;
        if (!u2)
          return;
        const c3 = this.getRenderNodeByName(u2.name), s2 = (e9, ...n3) => n3.concat([e9 ? "IN" : "OUT"]).join("~~"), d2 = this.hierarchy.getBridgeGraph(e8);
        d2.edges().forEach((n3) => {
          const t3 = d2.edge(n3), f2 = !!r2.node(n3.w), [h2, l2] = f2 ? [n3.w, n3.v] : [n3.v, n3.w], v2 = (n4) => {
            const t4 = f2 ? { v: n4, w: e8 } : { v: e8, w: n4 };
            return c3.coreGraph.edge(t4);
          };
          let p2 = v2(l2);
          p2 || (p2 = v2(s2(f2, l2, u2.name)));
          const g2 = s2(f2, e8), y4 = s2(f2, l2, e8);
          let b2 = o2.node(y4);
          if (!b2) {
            let e9 = o2.node(g2);
            if (!e9) {
              const n5 = { name: g2, type: i.BRIDGE, isGroupNode: false, cardinality: 0, parentNode: null, include: a2.UNSPECIFIED, inbound: f2, attr: {} };
              e9 = new Xu(n5), this.index[g2] = e9, o2.setNode(g2, e9);
            }
            const n4 = { name: y4, type: i.BRIDGE, isGroupNode: false, cardinality: 1, parentNode: null, include: a2.UNSPECIFIED, inbound: f2, attr: {} };
            b2 = new Xu(n4), this.index[y4] = b2, o2.setNode(y4, b2), o2.setParent(y4, g2), e9.node.cardinality++;
          }
          const m3 = new Ku(t3);
          m3.adjoiningMetaEdge = p2, f2 ? o2.setEdge(y4, h2, m3) : o2.setEdge(h2, y4, m3);
        });
      }
      getOrCreateRenderNodeByName(e8) {
        if (!e8)
          return null;
        if (e8 in this.index)
          return this.index[e8];
        const n2 = this.getNodeByName(e8);
        return n2 ? (this.index[e8] = n2.isGroupNode ? new Qu(n2, this.hierarchy.graphOptions) : new Xu(n2), this.index[e8]) : null;
      }
      getRenderNodeByName(e8) {
        return this.index[e8];
      }
      getNodeByName(e8) {
        return this.hierarchy.node(e8);
      }
    };
    Xu = class {
      constructor(e8) {
        this.node = e8, this.expanded = false, this.x = 0, this.y = 0, this.coreBox = { width: 0, height: 0 }, this.outboxWidth = 0, this.labelOffset = 0, this.radius = 0, this.labelHeight = 0, this.paddingTop = 0, this.paddingLeft = 0, this.paddingRight = 0, this.paddingBottom = 0, this.width = e8.width || 0, this.height = e8.height || 0, this.displayName = e8.name, this.attr = e8.attr;
      }
    };
    Ku = class {
      constructor(e8) {
        this.metaEdge = e8, this.adjoiningMetaEdge = null, this.weight = 1, this.points = [];
      }
    };
    Qu = class extends Xu {
      constructor(e8, n2) {
        super(e8);
        const t2 = e8.metaGraph.graph();
        n2.compound = true, this.coreGraph = Hu(t2.name, u.CORE, n2);
      }
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagreCompound.js
var require_dagreCompound = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagreCompound.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __assign14 = exports && exports.__assign || function() {
      __assign14 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign14.apply(this, arguments);
    };
    var __spreadArray3 = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
          if (ar2 || !(i2 in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i2);
            ar2[i2] = from[i2];
          }
        }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DagreCompoundLayout = void 0;
    var base_1 = require_base();
    var dagre_compound_1 = (init_dagre_compound_es5(), __toCommonJS(dagre_compound_es5_exports));
    var util_1 = require_util2();
    var DagreCompoundLayout2 = (
      /** @class */
      function(_super) {
        __extends15(DagreCompoundLayout3, _super);
        function DagreCompoundLayout3(options) {
          var _this = _super.call(this) || this;
          _this.rankdir = "TB";
          _this.nodesep = 50;
          _this.edgesep = 5;
          _this.ranksep = 50;
          _this.controlPoints = true;
          _this.anchorPoint = true;
          _this.nodes = [];
          _this.edges = [];
          _this.combos = [];
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        DagreCompoundLayout3.prototype.getDefaultCfg = function() {
          return {
            rankdir: "TB",
            align: void 0,
            begin: void 0,
            nodeSize: void 0,
            nodesep: 50,
            ranksep: 50,
            controlPoints: true,
            anchorPoint: true
            // 是否使用布局计算的锚点
          };
        };
        DagreCompoundLayout3.prototype.init = function(data) {
          var hiddenNodes = data.hiddenNodes || [];
          var hiddenEdges = data.hiddenEdges || [];
          var hiddenCombos = data.hiddenCombos || [];
          this.nodes = this.getDataByOrder((data.nodes || []).concat(hiddenNodes));
          this.edges = this.getDataByOrder((data.edges || []).concat(hiddenEdges));
          this.combos = (data.combos || []).concat(hiddenCombos.map(function(hc) {
            return __assign14(__assign14({}, hc), { collapsed: true });
          }));
        };
        DagreCompoundLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges;
          if (!nodes)
            return;
          var _a2 = self2.getLayoutConfig(), graphDef = _a2.graphDef, graphOption = _a2.graphOption, graphSettings = _a2.graphSettings;
          var renderInfo = (0, dagre_compound_1.buildGraph)(graphDef, graphOption, graphSettings);
          var flattenedRenderInfo = (0, dagre_compound_1.flatGraph)(renderInfo, true);
          this.updatePosition(flattenedRenderInfo);
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        DagreCompoundLayout3.prototype.getNodePath = function(nodeId) {
          var self2 = this;
          var nodes = self2.nodes, combos = self2.combos;
          var targetNode = nodes.find(function(n2) {
            return n2.id === nodeId;
          });
          var findPath = function(comboId, fullPath) {
            if (fullPath === void 0) {
              fullPath = [];
            }
            var combo = combos.find(function(c3) {
              return c3.id === comboId;
            });
            if (combo) {
              fullPath.unshift(comboId);
              if (combo.parentId) {
                return findPath(combo.parentId, fullPath);
              }
              return fullPath;
            }
            return fullPath;
          };
          if (targetNode && targetNode.comboId) {
            return findPath(targetNode.comboId, [nodeId]);
          }
          return [nodeId];
        };
        DagreCompoundLayout3.prototype.getLayoutConfig = function() {
          var _a2, _b, _c;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges, combos = self2.combos, nodeSize = self2.nodeSize, rankdir = self2.rankdir, align = self2.align, edgesep = self2.edgesep, nodesep = self2.nodesep, ranksep = self2.ranksep, settings = self2.settings;
          var compound = (combos || []).reduce(function(pre, cur) {
            var matchedNodes = nodes.filter(function(n2) {
              return n2.comboId === cur.id;
            }).map(function(n2) {
              return n2.id;
            });
            var matchedCombos = (combos || []).filter(function(n2) {
              return n2.parentId === cur.id;
            }).map(function(n2) {
              return n2.id;
            });
            if (matchedNodes.length || matchedCombos.length) {
              pre[cur.id] = __spreadArray3(__spreadArray3([], matchedNodes, true), matchedCombos, true);
            }
            return pre;
          }, {});
          var nodeSizeFunc;
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2 && d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  return d2.size;
                }
                if ((0, util_1.isObject)(d2.size)) {
                  return [d2.size.width || 40, d2.size.height || 40];
                }
                return [d2.size, d2.size];
              }
              return [40, 40];
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            nodeSizeFunc = function() {
              return nodeSize;
            };
          } else {
            nodeSizeFunc = function() {
              return [nodeSize, nodeSize];
            };
          }
          var comboSizeFunc = function(d2) {
            if (d2 && d2.size) {
              if ((0, util_1.isArray)(d2.size)) {
                return d2.size;
              }
              return [d2.size, d2.size];
            }
            return [80, 40];
          };
          var _d = comboSizeFunc(combos === null || combos === void 0 ? void 0 : combos[0]), metaWidth = _d[0], metaHeight = _d[1];
          var subSceneMeta = (_b = (_a2 = self2.graphSettings) === null || _a2 === void 0 ? void 0 : _a2.subScene) === null || _b === void 0 ? void 0 : _b.meta;
          var _e2 = ((_c = combos.find(function(c3) {
            return !c3.collapsed;
          })) === null || _c === void 0 ? void 0 : _c.padding) || [20, 20, 20, 20], paddingTop = _e2[0], paddingRight = _e2[1], paddingBottom = _e2[2], paddingLeft = _e2[3];
          var graphDef = {
            compound,
            nodes: __spreadArray3([], (nodes || []).map(function(n2) {
              var size3 = nodeSizeFunc(n2);
              var width = size3[0];
              var height = size3[1];
              return __assign14(__assign14({}, n2), { width, height });
            }), true),
            edges: __spreadArray3([], (edges || []).map(function(e8) {
              return __assign14(__assign14({}, e8), { v: e8.source, w: e8.target });
            }), true)
          };
          var graphOption = {
            expanded: (combos || []).filter(function(c3) {
              return !c3.collapsed;
            }).map(function(c3) {
              return c3.id;
            })
          };
          var graphMetaConfig = {
            graph: {
              meta: {
                align,
                rankDir: rankdir,
                nodeSep: nodesep,
                edgeSep: edgesep,
                rankSep: ranksep
              }
            },
            subScene: {
              meta: {
                paddingTop: paddingTop || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop) || 20,
                paddingRight: paddingRight || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight) || 20,
                paddingBottom: paddingBottom || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom) || 20,
                paddingLeft: paddingLeft || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft) || 20,
                labelHeight: 0
              }
            },
            nodeSize: {
              meta: {
                width: metaWidth,
                height: metaHeight
              }
            }
          };
          var graphSettings = (0, dagre_compound_1.mergeConfig)(settings, __assign14({}, (0, dagre_compound_1.mergeConfig)(graphMetaConfig, dagre_compound_1.LAYOUT_CONFIG)));
          self2.graphSettings = graphSettings;
          return {
            graphDef,
            graphOption,
            graphSettings
          };
        };
        DagreCompoundLayout3.prototype.updatePosition = function(flattenedGraph) {
          var nodes = flattenedGraph.nodes, edges = flattenedGraph.edges;
          this.updateNodePosition(nodes, edges);
          this.updateEdgePosition(nodes, edges);
        };
        DagreCompoundLayout3.prototype.getBegin = function(flattenedNodes, flattenedEdges) {
          var self2 = this;
          var begin = self2.begin;
          var dBegin = [0, 0];
          if (begin) {
            var minX_1 = Infinity;
            var minY_1 = Infinity;
            flattenedNodes.forEach(function(node) {
              if (minX_1 > node.x)
                minX_1 = node.x;
              if (minY_1 > node.y)
                minY_1 = node.y;
            });
            flattenedEdges.forEach(function(edge) {
              edge.points.forEach(function(point) {
                if (minX_1 > point.x)
                  minX_1 = point.x;
                if (minY_1 > point.y)
                  minY_1 = point.y;
              });
            });
            dBegin[0] = begin[0] - minX_1;
            dBegin[1] = begin[1] - minY_1;
          }
          return dBegin;
        };
        DagreCompoundLayout3.prototype.updateNodePosition = function(flattenedNodes, flattenedEdges) {
          var self2 = this;
          var combos = self2.combos, nodes = self2.nodes, edges = self2.edges, anchorPoint = self2.anchorPoint, graphSettings = self2.graphSettings;
          var dBegin = this.getBegin(flattenedNodes, flattenedEdges);
          flattenedNodes.forEach(function(node) {
            var _a2;
            var x4 = node.x, y4 = node.y, id = node.id, type = node.type, coreBox = node.coreBox;
            if (type === dagre_compound_1.HierarchyNodeType.META && id !== dagre_compound_1.ROOT_NAME) {
              var i2 = combos.findIndex(function(item) {
                return item.id === id;
              });
              var subSceneMeta = (_a2 = graphSettings === null || graphSettings === void 0 ? void 0 : graphSettings.subScene) === null || _a2 === void 0 ? void 0 : _a2.meta;
              combos[i2].offsetX = x4 + dBegin[0];
              combos[i2].offsetY = y4 + dBegin[1];
              combos[i2].fixSize = [coreBox.width, coreBox.height];
              combos[i2].fixCollapseSize = [coreBox.width, coreBox.height];
              if (!node.expanded) {
                combos[i2].padding = [0, 0, 0, 0];
              } else {
                combos[i2].padding = [
                  subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop,
                  subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight,
                  subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom,
                  subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft
                ];
              }
            } else if (type === dagre_compound_1.HierarchyNodeType.OP) {
              var i2 = nodes.findIndex(function(item) {
                return item.id === id;
              });
              nodes[i2].x = x4 + dBegin[0];
              nodes[i2].y = y4 + dBegin[1];
              if (anchorPoint) {
                var anchorPoints_1 = [];
                var outEdges = flattenedEdges.filter(function(e8) {
                  return e8.v === id;
                });
                var inEdges = flattenedEdges.filter(function(e8) {
                  return e8.w === id;
                });
                if (outEdges.length > 0) {
                  outEdges.forEach(function(outEdge) {
                    var firstPoint = outEdge.points[0];
                    var anchorPointX = (firstPoint.x - x4) / node.width + 0.5;
                    var anchorPointY = (firstPoint.y - y4) / node.height + 0.5;
                    anchorPoints_1.push([anchorPointX, anchorPointY]);
                    outEdge.baseEdgeList.forEach(function(baseEdge) {
                      var edge = edges.find(function(e8) {
                        return e8.source === baseEdge.v && e8.target === baseEdge.w;
                      });
                      if (edge) {
                        edge.sourceAnchor = anchorPoints_1.length - 1;
                      }
                    });
                  });
                }
                if (inEdges.length > 0) {
                  inEdges.forEach(function(inEdge) {
                    var lastPoint = inEdge.points[inEdge.points.length - 1];
                    var anchorPointX = (lastPoint.x - x4) / node.width + 0.5;
                    var anchorPointY = (lastPoint.y - y4) / node.height + 0.5;
                    anchorPoints_1.push([anchorPointX, anchorPointY]);
                    inEdge.baseEdgeList.forEach(function(baseEdge) {
                      var edge = edges.find(function(e8) {
                        return e8.source === baseEdge.v && e8.target === baseEdge.w;
                      });
                      if (edge) {
                        edge.targetAnchor = anchorPoints_1.length - 1;
                      }
                    });
                  });
                }
                nodes[i2].anchorPoints = anchorPoints_1.length > 0 ? anchorPoints_1 : nodes[i2].anchorPoints || [];
              }
            }
          });
        };
        DagreCompoundLayout3.prototype.updateEdgePosition = function(flattenedNodes, flattenedEdges) {
          var self2 = this;
          var combos = self2.combos, edges = self2.edges, controlPoints = self2.controlPoints;
          var dBegin = this.getBegin(flattenedNodes, flattenedEdges);
          if (controlPoints) {
            combos.forEach(function(combo) {
              combo.inEdges = [];
              combo.outEdges = [];
            });
            edges.forEach(function(sourceEdge) {
              var _a2, _b, _c, _d;
              var sourceNode = flattenedNodes.find(function(v2) {
                return v2.id === sourceEdge.source;
              });
              var targetNode = flattenedNodes.find(function(v2) {
                return v2.id === sourceEdge.target;
              });
              var points = [];
              var sortedEdges = [];
              if (sourceNode && targetNode) {
                sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes);
              } else if (!sourceNode || !targetNode) {
                var sourceNodePath = self2.getNodePath(sourceEdge.source);
                var targetNodePath = self2.getNodePath(sourceEdge.target);
                var lastExistingSource_1 = sourceNodePath.reverse().slice(!sourceNode ? 1 : 0).find(function(parentId) {
                  return flattenedNodes.find(function(fNode) {
                    return fNode.id === parentId;
                  });
                });
                var lastExistingTarget_1 = targetNodePath.reverse().slice(!targetNode ? 1 : 0).find(function(parentId) {
                  return flattenedNodes.find(function(fNode) {
                    return fNode.id === parentId;
                  });
                });
                sourceNode = flattenedNodes.find(function(v2) {
                  return v2.id === lastExistingSource_1;
                });
                targetNode = flattenedNodes.find(function(v2) {
                  return v2.id === lastExistingTarget_1;
                });
                sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes, { v: sourceEdge.source, w: sourceEdge.target });
              }
              points = sortedEdges.reduce(function(pre, cur) {
                return __spreadArray3(__spreadArray3([], pre, true), cur.points.map(function(p2) {
                  return __assign14(__assign14({}, p2), { x: p2.x + dBegin[0], y: p2.y + dBegin[1] });
                }), true);
              }, []);
              points = points.slice(1, -1);
              sourceEdge.controlPoints = points;
              if ((targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === dagre_compound_1.NodeType.META) {
                var i2 = combos.findIndex(function(item) {
                  return item.id === (targetNode === null || targetNode === void 0 ? void 0 : targetNode.id);
                });
                if (!combos[i2] || ((_a2 = combos[i2].inEdges) === null || _a2 === void 0 ? void 0 : _a2.some(function(inEdge) {
                  return inEdge.source === sourceNode.id && inEdge.target === targetNode.id;
                }))) {
                  return;
                }
                (_b = combos[i2].inEdges) === null || _b === void 0 ? void 0 : _b.push({
                  source: sourceNode.id,
                  target: targetNode.id,
                  controlPoints: points
                });
              }
              if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === dagre_compound_1.NodeType.META) {
                var i2 = combos.findIndex(function(item) {
                  return item.id === (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id);
                });
                if (!combos[i2] || ((_c = combos[i2].outEdges) === null || _c === void 0 ? void 0 : _c.some(function(oedge) {
                  return oedge.source === sourceNode.id && oedge.target === targetNode.id;
                }))) {
                  return;
                }
                (_d = combos[i2].outEdges) === null || _d === void 0 ? void 0 : _d.push({
                  source: sourceNode.id,
                  target: targetNode.id,
                  controlPoints: points
                });
              }
            });
          }
        };
        DagreCompoundLayout3.prototype.getType = function() {
          return "dagreCompound";
        };
        DagreCompoundLayout3.prototype.getDataByOrder = function(list) {
          if (list.every(function(n2) {
            return n2.layoutOrder !== void 0;
          })) {
          } else {
            list.forEach(function(n2, i2) {
              n2.layoutOrder = i2;
            });
          }
          return list.sort(function(pre, cur) {
            return pre.layoutOrder - cur.layoutOrder;
          });
        };
        return DagreCompoundLayout3;
      }(base_1.Base)
    );
    exports.DagreCompoundLayout = DagreCompoundLayout2;
  }
});

// node_modules/is-any-array/lib-esm/index.js
function isAnyArray(value) {
  const tag = toString4.call(value);
  return tag.endsWith("Array]") && !tag.includes("Big");
}
var toString4;
var init_lib_esm = __esm({
  "node_modules/is-any-array/lib-esm/index.js"() {
    toString4 = Object.prototype.toString;
  }
});

// node_modules/ml-array-max/lib-es6/index.js
function max(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var maxValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] > maxValue)
      maxValue = input[i2];
  }
  return maxValue;
}
var init_lib_es6 = __esm({
  "node_modules/ml-array-max/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-min/lib-es6/index.js
function min(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var minValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] < minValue)
      minValue = input[i2];
  }
  return minValue;
}
var init_lib_es62 = __esm({
  "node_modules/ml-array-min/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-rescale/lib-es6/index.js
function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  } else if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var output;
  if (options.output !== void 0) {
    if (!isAnyArray(options.output)) {
      throw new TypeError("output option must be an array if specified");
    }
    output = options.output;
  } else {
    output = new Array(input.length);
  }
  var currentMin = min(input);
  var currentMax = max(input);
  if (currentMin === currentMax) {
    throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");
  }
  var _options$min = options.min, minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min, _options$max = options.max, maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;
  if (minValue >= maxValue) {
    throw new RangeError("min option must be smaller than max option");
  }
  var factor = (maxValue - minValue) / (currentMax - currentMin);
  for (var i2 = 0; i2 < input.length; i2++) {
    output[i2] = (input[i2] - currentMin) * factor + minValue;
  }
  return output;
}
var init_lib_es63 = __esm({
  "node_modules/ml-array-rescale/lib-es6/index.js"() {
    init_lib_esm();
    init_lib_es6();
    init_lib_es62();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/inspect.js
function inspectMatrix() {
  return inspectMatrixWithOptions(this);
}
function inspectMatrixWithOptions(matrix, options = {}) {
  const { maxRows = 15, maxColumns = 10, maxNumSize = 8 } = options;
  return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
}
function inspectData(matrix, maxRows, maxColumns, maxNumSize) {
  const { rows, columns } = matrix;
  const maxI = Math.min(rows, maxRows);
  const maxJ = Math.min(columns, maxColumns);
  const result = [];
  for (let i2 = 0; i2 < maxI; i2++) {
    let line = [];
    for (let j2 = 0; j2 < maxJ; j2++) {
      line.push(formatNumber(matrix.get(i2, j2), maxNumSize));
    }
    result.push(`${line.join(" ")}`);
  }
  if (maxJ !== columns) {
    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
  }
  if (maxI !== rows) {
    result.push(`... ${rows - maxRows} more rows`);
  }
  return result.join(`
${indentData}`);
}
function formatNumber(num, maxNumSize) {
  const numStr = String(num);
  if (numStr.length <= maxNumSize) {
    return numStr.padEnd(maxNumSize, " ");
  }
  const precise = num.toPrecision(maxNumSize - 2);
  if (precise.length <= maxNumSize) {
    return precise;
  }
  const exponential = num.toExponential(maxNumSize - 2);
  const eIndex = exponential.indexOf("e");
  const e8 = exponential.slice(eIndex);
  return exponential.slice(0, maxNumSize - e8.length) + e8;
}
var indent, indentData;
var init_inspect = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/inspect.js"() {
    indent = " ".repeat(2);
    indentData = " ".repeat(4);
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/mathOperations.js
function installMathOperations(AbstractMatrix2, Matrix2) {
  AbstractMatrix2.prototype.add = function add2(value) {
    if (typeof value === "number")
      return this.addS(value);
    return this.addM(value);
  };
  AbstractMatrix2.prototype.addS = function addS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) + value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.addM = function addM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) + matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.add = function add2(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.add(value);
  };
  AbstractMatrix2.prototype.sub = function sub(value) {
    if (typeof value === "number")
      return this.subS(value);
    return this.subM(value);
  };
  AbstractMatrix2.prototype.subS = function subS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) - value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.subM = function subM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) - matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.sub = function sub(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sub(value);
  };
  AbstractMatrix2.prototype.subtract = AbstractMatrix2.prototype.sub;
  AbstractMatrix2.prototype.subtractS = AbstractMatrix2.prototype.subS;
  AbstractMatrix2.prototype.subtractM = AbstractMatrix2.prototype.subM;
  AbstractMatrix2.subtract = AbstractMatrix2.sub;
  AbstractMatrix2.prototype.mul = function mul(value) {
    if (typeof value === "number")
      return this.mulS(value);
    return this.mulM(value);
  };
  AbstractMatrix2.prototype.mulS = function mulS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) * value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.mulM = function mulM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) * matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.mul = function mul(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.mul(value);
  };
  AbstractMatrix2.prototype.multiply = AbstractMatrix2.prototype.mul;
  AbstractMatrix2.prototype.multiplyS = AbstractMatrix2.prototype.mulS;
  AbstractMatrix2.prototype.multiplyM = AbstractMatrix2.prototype.mulM;
  AbstractMatrix2.multiply = AbstractMatrix2.mul;
  AbstractMatrix2.prototype.div = function div(value) {
    if (typeof value === "number")
      return this.divS(value);
    return this.divM(value);
  };
  AbstractMatrix2.prototype.divS = function divS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) / value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.divM = function divM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) / matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.div = function div(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.div(value);
  };
  AbstractMatrix2.prototype.divide = AbstractMatrix2.prototype.div;
  AbstractMatrix2.prototype.divideS = AbstractMatrix2.prototype.divS;
  AbstractMatrix2.prototype.divideM = AbstractMatrix2.prototype.divM;
  AbstractMatrix2.divide = AbstractMatrix2.div;
  AbstractMatrix2.prototype.mod = function mod2(value) {
    if (typeof value === "number")
      return this.modS(value);
    return this.modM(value);
  };
  AbstractMatrix2.prototype.modS = function modS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) % value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.modM = function modM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) % matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.mod = function mod2(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.mod(value);
  };
  AbstractMatrix2.prototype.modulus = AbstractMatrix2.prototype.mod;
  AbstractMatrix2.prototype.modulusS = AbstractMatrix2.prototype.modS;
  AbstractMatrix2.prototype.modulusM = AbstractMatrix2.prototype.modM;
  AbstractMatrix2.modulus = AbstractMatrix2.mod;
  AbstractMatrix2.prototype.and = function and(value) {
    if (typeof value === "number")
      return this.andS(value);
    return this.andM(value);
  };
  AbstractMatrix2.prototype.andS = function andS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) & value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.andM = function andM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) & matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.and = function and(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.and(value);
  };
  AbstractMatrix2.prototype.or = function or2(value) {
    if (typeof value === "number")
      return this.orS(value);
    return this.orM(value);
  };
  AbstractMatrix2.prototype.orS = function orS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) | value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.orM = function orM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) | matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.or = function or2(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.or(value);
  };
  AbstractMatrix2.prototype.xor = function xor(value) {
    if (typeof value === "number")
      return this.xorS(value);
    return this.xorM(value);
  };
  AbstractMatrix2.prototype.xorS = function xorS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) ^ value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.xorM = function xorM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) ^ matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.xor = function xor(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.xor(value);
  };
  AbstractMatrix2.prototype.leftShift = function leftShift(value) {
    if (typeof value === "number")
      return this.leftShiftS(value);
    return this.leftShiftM(value);
  };
  AbstractMatrix2.prototype.leftShiftS = function leftShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) << value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.leftShiftM = function leftShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) << matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.leftShift = function leftShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.leftShift(value);
  };
  AbstractMatrix2.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
    if (typeof value === "number")
      return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
  };
  AbstractMatrix2.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >> value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >> matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.signPropagatingRightShift(value);
  };
  AbstractMatrix2.prototype.rightShift = function rightShift(value) {
    if (typeof value === "number")
      return this.rightShiftS(value);
    return this.rightShiftM(value);
  };
  AbstractMatrix2.prototype.rightShiftS = function rightShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >>> value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.rightShiftM = function rightShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >>> matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.rightShift = function rightShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.rightShift(value);
  };
  AbstractMatrix2.prototype.zeroFillRightShift = AbstractMatrix2.prototype.rightShift;
  AbstractMatrix2.prototype.zeroFillRightShiftS = AbstractMatrix2.prototype.rightShiftS;
  AbstractMatrix2.prototype.zeroFillRightShiftM = AbstractMatrix2.prototype.rightShiftM;
  AbstractMatrix2.zeroFillRightShift = AbstractMatrix2.rightShift;
  AbstractMatrix2.prototype.not = function not() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, ~this.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.not = function not(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.not();
  };
  AbstractMatrix2.prototype.abs = function abs3() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.abs(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.abs = function abs3(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.abs();
  };
  AbstractMatrix2.prototype.acos = function acos() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.acos(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.acos = function acos(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.acos();
  };
  AbstractMatrix2.prototype.acosh = function acosh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.acosh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.acosh = function acosh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.acosh();
  };
  AbstractMatrix2.prototype.asin = function asin() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.asin(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.asin = function asin(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.asin();
  };
  AbstractMatrix2.prototype.asinh = function asinh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.asinh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.asinh = function asinh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.asinh();
  };
  AbstractMatrix2.prototype.atan = function atan() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.atan(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.atan = function atan(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.atan();
  };
  AbstractMatrix2.prototype.atanh = function atanh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.atanh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.atanh = function atanh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.atanh();
  };
  AbstractMatrix2.prototype.cbrt = function cbrt() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cbrt(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cbrt = function cbrt(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cbrt();
  };
  AbstractMatrix2.prototype.ceil = function ceil() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.ceil(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.ceil = function ceil(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.ceil();
  };
  AbstractMatrix2.prototype.clz32 = function clz32() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.clz32(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.clz32 = function clz32(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.clz32();
  };
  AbstractMatrix2.prototype.cos = function cos2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cos(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cos = function cos2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cos();
  };
  AbstractMatrix2.prototype.cosh = function cosh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cosh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cosh = function cosh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cosh();
  };
  AbstractMatrix2.prototype.exp = function exp() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.exp(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.exp = function exp(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.exp();
  };
  AbstractMatrix2.prototype.expm1 = function expm1() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.expm1(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.expm1 = function expm1(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.expm1();
  };
  AbstractMatrix2.prototype.floor = function floor() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.floor(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.floor = function floor(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.floor();
  };
  AbstractMatrix2.prototype.fround = function fround() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.fround(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.fround = function fround(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.fround();
  };
  AbstractMatrix2.prototype.log = function log() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log = function log(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log();
  };
  AbstractMatrix2.prototype.log1p = function log1p() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log1p(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log1p = function log1p(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log1p();
  };
  AbstractMatrix2.prototype.log10 = function log10() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log10(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log10 = function log10(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log10();
  };
  AbstractMatrix2.prototype.log2 = function log2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log2(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log2 = function log2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log2();
  };
  AbstractMatrix2.prototype.round = function round() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.round(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.round = function round(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.round();
  };
  AbstractMatrix2.prototype.sign = function sign() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sign(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sign = function sign(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sign();
  };
  AbstractMatrix2.prototype.sin = function sin2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sin(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sin = function sin2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sin();
  };
  AbstractMatrix2.prototype.sinh = function sinh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sinh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sinh = function sinh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sinh();
  };
  AbstractMatrix2.prototype.sqrt = function sqrt() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sqrt(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sqrt = function sqrt(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sqrt();
  };
  AbstractMatrix2.prototype.tan = function tan() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.tan(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.tan = function tan(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.tan();
  };
  AbstractMatrix2.prototype.tanh = function tanh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.tanh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.tanh = function tanh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.tanh();
  };
  AbstractMatrix2.prototype.trunc = function trunc() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.trunc(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.trunc = function trunc(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.trunc();
  };
  AbstractMatrix2.pow = function pow(matrix, arg0) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.pow(arg0);
  };
  AbstractMatrix2.prototype.pow = function pow(value) {
    if (typeof value === "number")
      return this.powS(value);
    return this.powM(value);
  };
  AbstractMatrix2.prototype.powS = function powS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.pow(this.get(i2, j2), value));
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.powM = function powM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.pow(this.get(i2, j2), matrix.get(i2, j2)));
      }
    }
    return this;
  };
}
var init_mathOperations = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/mathOperations.js"() {
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/util.js
function checkRowIndex(matrix, index2, outer) {
  let max4 = outer ? matrix.rows : matrix.rows - 1;
  if (index2 < 0 || index2 > max4) {
    throw new RangeError("Row index out of range");
  }
}
function checkColumnIndex(matrix, index2, outer) {
  let max4 = outer ? matrix.columns : matrix.columns - 1;
  if (index2 < 0 || index2 > max4) {
    throw new RangeError("Column index out of range");
  }
}
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      "vector size must be the same as the number of columns"
    );
  }
  return vector;
}
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError("vector size must be the same as the number of rows");
  }
  return vector;
}
function checkIndices(matrix, rowIndices, columnIndices) {
  return {
    row: checkRowIndices(matrix, rowIndices),
    column: checkColumnIndices(matrix, columnIndices)
  };
}
function checkRowIndices(matrix, rowIndices) {
  if (typeof rowIndices !== "object") {
    throw new TypeError("unexpected type for row indices");
  }
  let rowOut = rowIndices.some((r2) => {
    return r2 < 0 || r2 >= matrix.rows;
  });
  if (rowOut) {
    throw new RangeError("row indices are out of range");
  }
  if (!Array.isArray(rowIndices))
    rowIndices = Array.from(rowIndices);
  return rowIndices;
}
function checkColumnIndices(matrix, columnIndices) {
  if (typeof columnIndices !== "object") {
    throw new TypeError("unexpected type for column indices");
  }
  let columnOut = columnIndices.some((c3) => {
    return c3 < 0 || c3 >= matrix.columns;
  });
  if (columnOut) {
    throw new RangeError("column indices are out of range");
  }
  if (!Array.isArray(columnIndices))
    columnIndices = Array.from(columnIndices);
  return columnIndices;
}
function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError("expected 4 arguments");
  }
  checkNumber("startRow", startRow);
  checkNumber("endRow", endRow);
  checkNumber("startColumn", startColumn);
  checkNumber("endColumn", endColumn);
  if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {
    throw new RangeError("Submatrix indices are out of range");
  }
}
function newArray(length, value = 0) {
  let array = [];
  for (let i2 = 0; i2 < length; i2++) {
    array.push(value);
  }
  return array;
}
function checkNumber(name, value) {
  if (typeof value !== "number") {
    throw new TypeError(`${name} must be a number`);
  }
}
var init_util2 = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/util.js"() {
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/stat.js
function sumByRow(matrix) {
  let sum = newArray(matrix.rows);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[i2] += matrix.get(i2, j2);
    }
  }
  return sum;
}
function sumByColumn(matrix) {
  let sum = newArray(matrix.columns);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[j2] += matrix.get(i2, j2);
    }
  }
  return sum;
}
function sumAll(matrix) {
  let v2 = 0;
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      v2 += matrix.get(i2, j2);
    }
  }
  return v2;
}
function productByRow(matrix) {
  let sum = newArray(matrix.rows, 1);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[i2] *= matrix.get(i2, j2);
    }
  }
  return sum;
}
function productByColumn(matrix) {
  let sum = newArray(matrix.columns, 1);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[j2] *= matrix.get(i2, j2);
    }
  }
  return sum;
}
function productAll(matrix) {
  let v2 = 1;
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      v2 *= matrix.get(i2, j2);
    }
  }
  return v2;
}
function varianceByRow(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];
  for (let i2 = 0; i2 < rows; i2++) {
    let sum1 = 0;
    let sum2 = 0;
    let x4 = 0;
    for (let j2 = 0; j2 < cols; j2++) {
      x4 = matrix.get(i2, j2) - mean[i2];
      sum1 += x4;
      sum2 += x4 * x4;
    }
    if (unbiased) {
      variance.push((sum2 - sum1 * sum1 / cols) / (cols - 1));
    } else {
      variance.push((sum2 - sum1 * sum1 / cols) / cols);
    }
  }
  return variance;
}
function varianceByColumn(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];
  for (let j2 = 0; j2 < cols; j2++) {
    let sum1 = 0;
    let sum2 = 0;
    let x4 = 0;
    for (let i2 = 0; i2 < rows; i2++) {
      x4 = matrix.get(i2, j2) - mean[j2];
      sum1 += x4;
      sum2 += x4 * x4;
    }
    if (unbiased) {
      variance.push((sum2 - sum1 * sum1 / rows) / (rows - 1));
    } else {
      variance.push((sum2 - sum1 * sum1 / rows) / rows);
    }
  }
  return variance;
}
function varianceAll(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const size3 = rows * cols;
  let sum1 = 0;
  let sum2 = 0;
  let x4 = 0;
  for (let i2 = 0; i2 < rows; i2++) {
    for (let j2 = 0; j2 < cols; j2++) {
      x4 = matrix.get(i2, j2) - mean;
      sum1 += x4;
      sum2 += x4 * x4;
    }
  }
  if (unbiased) {
    return (sum2 - sum1 * sum1 / size3) / (size3 - 1);
  } else {
    return (sum2 - sum1 * sum1 / size3) / size3;
  }
}
function centerByRow(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean[i2]);
    }
  }
}
function centerByColumn(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean[j2]);
    }
  }
}
function centerAll(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean);
    }
  }
}
function getScaleByRow(matrix) {
  const scale3 = [];
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    let sum = 0;
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / (matrix.columns - 1);
    }
    scale3.push(Math.sqrt(sum));
  }
  return scale3;
}
function scaleByRow(matrix, scale3) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale3[i2]);
    }
  }
}
function getScaleByColumn(matrix) {
  const scale3 = [];
  for (let j2 = 0; j2 < matrix.columns; j2++) {
    let sum = 0;
    for (let i2 = 0; i2 < matrix.rows; i2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / (matrix.rows - 1);
    }
    scale3.push(Math.sqrt(sum));
  }
  return scale3;
}
function scaleByColumn(matrix, scale3) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale3[j2]);
    }
  }
}
function getScaleAll(matrix) {
  const divider = matrix.size - 1;
  let sum = 0;
  for (let j2 = 0; j2 < matrix.columns; j2++) {
    for (let i2 = 0; i2 < matrix.rows; i2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / divider;
    }
  }
  return Math.sqrt(sum);
}
function scaleAll(matrix, scale3) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale3);
    }
  }
}
var init_stat = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/stat.js"() {
    init_util2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/matrix.js
function compareNumbers(a3, b2) {
  return a3 - b2;
}
var AbstractMatrix, Matrix;
var init_matrix2 = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/matrix.js"() {
    init_lib_es63();
    init_inspect();
    init_mathOperations();
    init_stat();
    init_util2();
    AbstractMatrix = class {
      static from1DArray(newRows, newColumns, newData) {
        let length = newRows * newColumns;
        if (length !== newData.length) {
          throw new RangeError("data length does not match given dimensions");
        }
        let newMatrix = new Matrix(newRows, newColumns);
        for (let row = 0; row < newRows; row++) {
          for (let column = 0; column < newColumns; column++) {
            newMatrix.set(row, column, newData[row * newColumns + column]);
          }
        }
        return newMatrix;
      }
      static rowVector(newData) {
        let vector = new Matrix(1, newData.length);
        for (let i2 = 0; i2 < newData.length; i2++) {
          vector.set(0, i2, newData[i2]);
        }
        return vector;
      }
      static columnVector(newData) {
        let vector = new Matrix(newData.length, 1);
        for (let i2 = 0; i2 < newData.length; i2++) {
          vector.set(i2, 0, newData[i2]);
        }
        return vector;
      }
      static zeros(rows, columns) {
        return new Matrix(rows, columns);
      }
      static ones(rows, columns) {
        return new Matrix(rows, columns).fill(1);
      }
      static rand(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { random = Math.random } = options;
        let matrix = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix.set(i2, j2, random());
          }
        }
        return matrix;
      }
      static randInt(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max4 = 1e3, random = Math.random } = options;
        if (!Number.isInteger(min3))
          throw new TypeError("min must be an integer");
        if (!Number.isInteger(max4))
          throw new TypeError("max must be an integer");
        if (min3 >= max4)
          throw new RangeError("min must be smaller than max");
        let interval = max4 - min3;
        let matrix = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            let value = min3 + Math.round(random() * interval);
            matrix.set(i2, j2, value);
          }
        }
        return matrix;
      }
      static eye(rows, columns, value) {
        if (columns === void 0)
          columns = rows;
        if (value === void 0)
          value = 1;
        let min3 = Math.min(rows, columns);
        let matrix = this.zeros(rows, columns);
        for (let i2 = 0; i2 < min3; i2++) {
          matrix.set(i2, i2, value);
        }
        return matrix;
      }
      static diag(data, rows, columns) {
        let l2 = data.length;
        if (rows === void 0)
          rows = l2;
        if (columns === void 0)
          columns = rows;
        let min3 = Math.min(l2, rows, columns);
        let matrix = this.zeros(rows, columns);
        for (let i2 = 0; i2 < min3; i2++) {
          matrix.set(i2, i2, data[i2]);
        }
        return matrix;
      }
      static min(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i2, j2, Math.min(matrix1.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return result;
      }
      static max(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new this(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i2, j2, Math.max(matrix1.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return result;
      }
      static checkMatrix(value) {
        return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
      }
      static isMatrix(value) {
        return value != null && value.klass === "Matrix";
      }
      get size() {
        return this.rows * this.columns;
      }
      apply(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            callback.call(this, i2, j2);
          }
        }
        return this;
      }
      to1DArray() {
        let array = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            array.push(this.get(i2, j2));
          }
        }
        return array;
      }
      to2DArray() {
        let copy = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          copy.push([]);
          for (let j2 = 0; j2 < this.columns; j2++) {
            copy[i2].push(this.get(i2, j2));
          }
        }
        return copy;
      }
      toJSON() {
        return this.to2DArray();
      }
      isRowVector() {
        return this.rows === 1;
      }
      isColumnVector() {
        return this.columns === 1;
      }
      isVector() {
        return this.rows === 1 || this.columns === 1;
      }
      isSquare() {
        return this.rows === this.columns;
      }
      isSymmetric() {
        if (this.isSquare()) {
          for (let i2 = 0; i2 < this.rows; i2++) {
            for (let j2 = 0; j2 <= i2; j2++) {
              if (this.get(i2, j2) !== this.get(j2, i2)) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      isEchelonForm() {
        let i2 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isEchelonForm = true;
        let checked = false;
        while (i2 < this.rows && isEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i2, j2) === 0) {
              j2++;
            } else if (this.get(i2, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isEchelonForm = false;
              checked = true;
            }
          }
          i2++;
        }
        return isEchelonForm;
      }
      isReducedEchelonForm() {
        let i2 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isReducedEchelonForm = true;
        let checked = false;
        while (i2 < this.rows && isReducedEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i2, j2) === 0) {
              j2++;
            } else if (this.get(i2, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isReducedEchelonForm = false;
              checked = true;
            }
          }
          for (let k2 = j2 + 1; k2 < this.rows; k2++) {
            if (this.get(i2, k2) !== 0) {
              isReducedEchelonForm = false;
            }
          }
          i2++;
        }
        return isReducedEchelonForm;
      }
      echelonForm() {
        let result = this.clone();
        let h2 = 0;
        let k2 = 0;
        while (h2 < result.rows && k2 < result.columns) {
          let iMax = h2;
          for (let i2 = h2; i2 < result.rows; i2++) {
            if (result.get(i2, k2) > result.get(iMax, k2)) {
              iMax = i2;
            }
          }
          if (result.get(iMax, k2) === 0) {
            k2++;
          } else {
            result.swapRows(h2, iMax);
            let tmp = result.get(h2, k2);
            for (let j2 = k2; j2 < result.columns; j2++) {
              result.set(h2, j2, result.get(h2, j2) / tmp);
            }
            for (let i2 = h2 + 1; i2 < result.rows; i2++) {
              let factor = result.get(i2, k2) / result.get(h2, k2);
              result.set(i2, k2, 0);
              for (let j2 = k2 + 1; j2 < result.columns; j2++) {
                result.set(i2, j2, result.get(i2, j2) - result.get(h2, j2) * factor);
              }
            }
            h2++;
            k2++;
          }
        }
        return result;
      }
      reducedEchelonForm() {
        let result = this.echelonForm();
        let m3 = result.columns;
        let n2 = result.rows;
        let h2 = n2 - 1;
        while (h2 >= 0) {
          if (result.maxRow(h2) === 0) {
            h2--;
          } else {
            let p2 = 0;
            let pivot = false;
            while (p2 < n2 && pivot === false) {
              if (result.get(h2, p2) === 1) {
                pivot = true;
              } else {
                p2++;
              }
            }
            for (let i2 = 0; i2 < h2; i2++) {
              let factor = result.get(i2, p2);
              for (let j2 = p2; j2 < m3; j2++) {
                let tmp = result.get(i2, j2) - factor * result.get(h2, j2);
                result.set(i2, j2, tmp);
              }
            }
            h2--;
          }
        }
        return result;
      }
      set() {
        throw new Error("set method is unimplemented");
      }
      get() {
        throw new Error("get method is unimplemented");
      }
      repeat(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { rows = 1, columns = 1 } = options;
        if (!Number.isInteger(rows) || rows <= 0) {
          throw new TypeError("rows must be a positive integer");
        }
        if (!Number.isInteger(columns) || columns <= 0) {
          throw new TypeError("columns must be a positive integer");
        }
        let matrix = new Matrix(this.rows * rows, this.columns * columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix.setSubMatrix(this, this.rows * i2, this.columns * j2);
          }
        }
        return matrix;
      }
      fill(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, value);
          }
        }
        return this;
      }
      neg() {
        return this.mulS(-1);
      }
      getRow(index2) {
        checkRowIndex(this, index2);
        let row = [];
        for (let i2 = 0; i2 < this.columns; i2++) {
          row.push(this.get(index2, i2));
        }
        return row;
      }
      getRowVector(index2) {
        return Matrix.rowVector(this.getRow(index2));
      }
      setRow(index2, array) {
        checkRowIndex(this, index2);
        array = checkRowVector(this, array);
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.set(index2, i2, array[i2]);
        }
        return this;
      }
      swapRows(row1, row2) {
        checkRowIndex(this, row1);
        checkRowIndex(this, row2);
        for (let i2 = 0; i2 < this.columns; i2++) {
          let temp = this.get(row1, i2);
          this.set(row1, i2, this.get(row2, i2));
          this.set(row2, i2, temp);
        }
        return this;
      }
      getColumn(index2) {
        checkColumnIndex(this, index2);
        let column = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          column.push(this.get(i2, index2));
        }
        return column;
      }
      getColumnVector(index2) {
        return Matrix.columnVector(this.getColumn(index2));
      }
      setColumn(index2, array) {
        checkColumnIndex(this, index2);
        array = checkColumnVector(this, array);
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.set(i2, index2, array[i2]);
        }
        return this;
      }
      swapColumns(column1, column2) {
        checkColumnIndex(this, column1);
        checkColumnIndex(this, column2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          let temp = this.get(i2, column1);
          this.set(i2, column1, this.get(i2, column2));
          this.set(i2, column2, temp);
        }
        return this;
      }
      addRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + vector[j2]);
          }
        }
        return this;
      }
      subRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - vector[j2]);
          }
        }
        return this;
      }
      mulRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * vector[j2]);
          }
        }
        return this;
      }
      divRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / vector[j2]);
          }
        }
        return this;
      }
      addColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + vector[i2]);
          }
        }
        return this;
      }
      subColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - vector[i2]);
          }
        }
        return this;
      }
      mulColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * vector[i2]);
          }
        }
        return this;
      }
      divColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / vector[i2]);
          }
        }
        return this;
      }
      mulRow(index2, value) {
        checkRowIndex(this, index2);
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.set(index2, i2, this.get(index2, i2) * value);
        }
        return this;
      }
      mulColumn(index2, value) {
        checkColumnIndex(this, index2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.set(i2, index2, this.get(i2, index2) * value);
        }
        return this;
      }
      max() {
        let v2 = this.get(0, 0);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) > v2) {
              v2 = this.get(i2, j2);
            }
          }
        }
        return v2;
      }
      maxIndex() {
        let v2 = this.get(0, 0);
        let idx = [0, 0];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) > v2) {
              v2 = this.get(i2, j2);
              idx[0] = i2;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      min() {
        let v2 = this.get(0, 0);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) < v2) {
              v2 = this.get(i2, j2);
            }
          }
        }
        return v2;
      }
      minIndex() {
        let v2 = this.get(0, 0);
        let idx = [0, 0];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) < v2) {
              v2 = this.get(i2, j2);
              idx[0] = i2;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      maxRow(row) {
        checkRowIndex(this, row);
        let v2 = this.get(row, 0);
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) > v2) {
            v2 = this.get(row, i2);
          }
        }
        return v2;
      }
      maxRowIndex(row) {
        checkRowIndex(this, row);
        let v2 = this.get(row, 0);
        let idx = [row, 0];
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) > v2) {
            v2 = this.get(row, i2);
            idx[1] = i2;
          }
        }
        return idx;
      }
      minRow(row) {
        checkRowIndex(this, row);
        let v2 = this.get(row, 0);
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) < v2) {
            v2 = this.get(row, i2);
          }
        }
        return v2;
      }
      minRowIndex(row) {
        checkRowIndex(this, row);
        let v2 = this.get(row, 0);
        let idx = [row, 0];
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) < v2) {
            v2 = this.get(row, i2);
            idx[1] = i2;
          }
        }
        return idx;
      }
      maxColumn(column) {
        checkColumnIndex(this, column);
        let v2 = this.get(0, column);
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) > v2) {
            v2 = this.get(i2, column);
          }
        }
        return v2;
      }
      maxColumnIndex(column) {
        checkColumnIndex(this, column);
        let v2 = this.get(0, column);
        let idx = [0, column];
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) > v2) {
            v2 = this.get(i2, column);
            idx[0] = i2;
          }
        }
        return idx;
      }
      minColumn(column) {
        checkColumnIndex(this, column);
        let v2 = this.get(0, column);
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) < v2) {
            v2 = this.get(i2, column);
          }
        }
        return v2;
      }
      minColumnIndex(column) {
        checkColumnIndex(this, column);
        let v2 = this.get(0, column);
        let idx = [0, column];
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) < v2) {
            v2 = this.get(i2, column);
            idx[0] = i2;
          }
        }
        return idx;
      }
      diag() {
        let min3 = Math.min(this.rows, this.columns);
        let diag = [];
        for (let i2 = 0; i2 < min3; i2++) {
          diag.push(this.get(i2, i2));
        }
        return diag;
      }
      norm(type = "frobenius") {
        let result = 0;
        if (type === "max") {
          return this.max();
        } else if (type === "frobenius") {
          for (let i2 = 0; i2 < this.rows; i2++) {
            for (let j2 = 0; j2 < this.columns; j2++) {
              result = result + this.get(i2, j2) * this.get(i2, j2);
            }
          }
          return Math.sqrt(result);
        } else {
          throw new RangeError(`unknown norm type: ${type}`);
        }
      }
      cumulativeSum() {
        let sum = 0;
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            sum += this.get(i2, j2);
            this.set(i2, j2, sum);
          }
        }
        return this;
      }
      dot(vector2) {
        if (AbstractMatrix.isMatrix(vector2))
          vector2 = vector2.to1DArray();
        let vector1 = this.to1DArray();
        if (vector1.length !== vector2.length) {
          throw new RangeError("vectors do not have the same size");
        }
        let dot = 0;
        for (let i2 = 0; i2 < vector1.length; i2++) {
          dot += vector1[i2] * vector2[i2];
        }
        return dot;
      }
      mmul(other) {
        other = Matrix.checkMatrix(other);
        let m3 = this.rows;
        let n2 = this.columns;
        let p2 = other.columns;
        let result = new Matrix(m3, p2);
        let Bcolj = new Float64Array(n2);
        for (let j2 = 0; j2 < p2; j2++) {
          for (let k2 = 0; k2 < n2; k2++) {
            Bcolj[k2] = other.get(k2, j2);
          }
          for (let i2 = 0; i2 < m3; i2++) {
            let s2 = 0;
            for (let k2 = 0; k2 < n2; k2++) {
              s2 += this.get(i2, k2) * Bcolj[k2];
            }
            result.set(i2, j2, s2);
          }
        }
        return result;
      }
      strassen2x2(other) {
        other = Matrix.checkMatrix(other);
        let result = new Matrix(2, 2);
        const a11 = this.get(0, 0);
        const b11 = other.get(0, 0);
        const a12 = this.get(0, 1);
        const b12 = other.get(0, 1);
        const a21 = this.get(1, 0);
        const b21 = other.get(1, 0);
        const a22 = this.get(1, 1);
        const b22 = other.get(1, 1);
        const m1 = (a11 + a22) * (b11 + b22);
        const m22 = (a21 + a22) * b11;
        const m3 = a11 * (b12 - b22);
        const m4 = a22 * (b21 - b11);
        const m5 = (a11 + a12) * b22;
        const m6 = (a21 - a11) * (b11 + b12);
        const m7 = (a12 - a22) * (b21 + b22);
        const c00 = m1 + m4 - m5 + m7;
        const c01 = m3 + m5;
        const c10 = m22 + m4;
        const c11 = m1 - m22 + m3 + m6;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        return result;
      }
      strassen3x3(other) {
        other = Matrix.checkMatrix(other);
        let result = new Matrix(3, 3);
        const a00 = this.get(0, 0);
        const a01 = this.get(0, 1);
        const a02 = this.get(0, 2);
        const a10 = this.get(1, 0);
        const a11 = this.get(1, 1);
        const a12 = this.get(1, 2);
        const a20 = this.get(2, 0);
        const a21 = this.get(2, 1);
        const a22 = this.get(2, 2);
        const b00 = other.get(0, 0);
        const b01 = other.get(0, 1);
        const b02 = other.get(0, 2);
        const b10 = other.get(1, 0);
        const b11 = other.get(1, 1);
        const b12 = other.get(1, 2);
        const b20 = other.get(2, 0);
        const b21 = other.get(2, 1);
        const b22 = other.get(2, 2);
        const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
        const m22 = (a00 - a10) * (-b01 + b11);
        const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
        const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
        const m5 = (a10 + a11) * (-b00 + b01);
        const m6 = a00 * b00;
        const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
        const m8 = (-a00 + a20) * (b02 - b12);
        const m9 = (a20 + a21) * (-b00 + b02);
        const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
        const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
        const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
        const m13 = (a02 - a22) * (b11 - b21);
        const m14 = a02 * b20;
        const m15 = (a21 + a22) * (-b20 + b21);
        const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
        const m17 = (a02 - a12) * (b12 - b22);
        const m18 = (a11 + a12) * (-b20 + b22);
        const m19 = a01 * b10;
        const m20 = a12 * b21;
        const m21 = a10 * b02;
        const m222 = a20 * b01;
        const m23 = a22 * b22;
        const c00 = m6 + m14 + m19;
        const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
        const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
        const c10 = m22 + m3 + m4 + m6 + m14 + m16 + m17;
        const c11 = m22 + m4 + m5 + m6 + m20;
        const c12 = m14 + m16 + m17 + m18 + m21;
        const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
        const c21 = m12 + m13 + m14 + m15 + m222;
        const c22 = m6 + m7 + m8 + m9 + m23;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(0, 2, c02);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        result.set(1, 2, c12);
        result.set(2, 0, c20);
        result.set(2, 1, c21);
        result.set(2, 2, c22);
        return result;
      }
      mmulStrassen(y4) {
        y4 = Matrix.checkMatrix(y4);
        let x4 = this.clone();
        let r1 = x4.rows;
        let c1 = x4.columns;
        let r2 = y4.rows;
        let c22 = y4.columns;
        if (c1 !== r2) {
          console.warn(
            `Multiplying ${r1} x ${c1} and ${r2} x ${c22} matrix: dimensions do not match.`
          );
        }
        function embed(mat, rows, cols) {
          let r4 = mat.rows;
          let c4 = mat.columns;
          if (r4 === rows && c4 === cols) {
            return mat;
          } else {
            let resultat = AbstractMatrix.zeros(rows, cols);
            resultat = resultat.setSubMatrix(mat, 0, 0);
            return resultat;
          }
        }
        let r3 = Math.max(r1, r2);
        let c3 = Math.max(c1, c22);
        x4 = embed(x4, r3, c3);
        y4 = embed(y4, r3, c3);
        function blockMult(a3, b2, rows, cols) {
          if (rows <= 512 || cols <= 512) {
            return a3.mmul(b2);
          }
          if (rows % 2 === 1 && cols % 2 === 1) {
            a3 = embed(a3, rows + 1, cols + 1);
            b2 = embed(b2, rows + 1, cols + 1);
          } else if (rows % 2 === 1) {
            a3 = embed(a3, rows + 1, cols);
            b2 = embed(b2, rows + 1, cols);
          } else if (cols % 2 === 1) {
            a3 = embed(a3, rows, cols + 1);
            b2 = embed(b2, rows, cols + 1);
          }
          let halfRows = parseInt(a3.rows / 2, 10);
          let halfCols = parseInt(a3.columns / 2, 10);
          let a11 = a3.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let b11 = b2.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let a12 = a3.subMatrix(0, halfRows - 1, halfCols, a3.columns - 1);
          let b12 = b2.subMatrix(0, halfRows - 1, halfCols, b2.columns - 1);
          let a21 = a3.subMatrix(halfRows, a3.rows - 1, 0, halfCols - 1);
          let b21 = b2.subMatrix(halfRows, b2.rows - 1, 0, halfCols - 1);
          let a22 = a3.subMatrix(halfRows, a3.rows - 1, halfCols, a3.columns - 1);
          let b22 = b2.subMatrix(halfRows, b2.rows - 1, halfCols, b2.columns - 1);
          let m1 = blockMult(
            AbstractMatrix.add(a11, a22),
            AbstractMatrix.add(b11, b22),
            halfRows,
            halfCols
          );
          let m22 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
          let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
          let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
          let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
          let m6 = blockMult(
            AbstractMatrix.sub(a21, a11),
            AbstractMatrix.add(b11, b12),
            halfRows,
            halfCols
          );
          let m7 = blockMult(
            AbstractMatrix.sub(a12, a22),
            AbstractMatrix.add(b21, b22),
            halfRows,
            halfCols
          );
          let c11 = AbstractMatrix.add(m1, m4);
          c11.sub(m5);
          c11.add(m7);
          let c12 = AbstractMatrix.add(m3, m5);
          let c21 = AbstractMatrix.add(m22, m4);
          let c222 = AbstractMatrix.sub(m1, m22);
          c222.add(m3);
          c222.add(m6);
          let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
          resultat = resultat.setSubMatrix(c11, 0, 0);
          resultat = resultat.setSubMatrix(c12, c11.rows, 0);
          resultat = resultat.setSubMatrix(c21, 0, c11.columns);
          resultat = resultat.setSubMatrix(c222, c11.rows, c11.columns);
          return resultat.subMatrix(0, rows - 1, 0, cols - 1);
        }
        return blockMult(x4, y4, r3, c3);
      }
      scaleRows(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max4 = 1 } = options;
        if (!Number.isFinite(min3))
          throw new TypeError("min must be a number");
        if (!Number.isFinite(max4))
          throw new TypeError("max must be a number");
        if (min3 >= max4)
          throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const row = this.getRow(i2);
          rescale(row, { min: min3, max: max4, output: row });
          newMatrix.setRow(i2, row);
        }
        return newMatrix;
      }
      scaleColumns(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min3 = 0, max: max4 = 1 } = options;
        if (!Number.isFinite(min3))
          throw new TypeError("min must be a number");
        if (!Number.isFinite(max4))
          throw new TypeError("max must be a number");
        if (min3 >= max4)
          throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let i2 = 0; i2 < this.columns; i2++) {
          const column = this.getColumn(i2);
          rescale(column, {
            min: min3,
            max: max4,
            output: column
          });
          newMatrix.setColumn(i2, column);
        }
        return newMatrix;
      }
      flipRows() {
        const middle = Math.ceil(this.columns / 2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < middle; j2++) {
            let first = this.get(i2, j2);
            let last2 = this.get(i2, this.columns - 1 - j2);
            this.set(i2, j2, last2);
            this.set(i2, this.columns - 1 - j2, first);
          }
        }
        return this;
      }
      flipColumns() {
        const middle = Math.ceil(this.rows / 2);
        for (let j2 = 0; j2 < this.columns; j2++) {
          for (let i2 = 0; i2 < middle; i2++) {
            let first = this.get(i2, j2);
            let last2 = this.get(this.rows - 1 - i2, j2);
            this.set(i2, j2, last2);
            this.set(this.rows - 1 - i2, j2, first);
          }
        }
        return this;
      }
      kroneckerProduct(other) {
        other = Matrix.checkMatrix(other);
        let m3 = this.rows;
        let n2 = this.columns;
        let p2 = other.rows;
        let q2 = other.columns;
        let result = new Matrix(m3 * p2, n2 * q2);
        for (let i2 = 0; i2 < m3; i2++) {
          for (let j2 = 0; j2 < n2; j2++) {
            for (let k2 = 0; k2 < p2; k2++) {
              for (let l2 = 0; l2 < q2; l2++) {
                result.set(p2 * i2 + k2, q2 * j2 + l2, this.get(i2, j2) * other.get(k2, l2));
              }
            }
          }
        }
        return result;
      }
      transpose() {
        let result = new Matrix(this.columns, this.rows);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            result.set(j2, i2, this.get(i2, j2));
          }
        }
        return result;
      }
      sortRows(compareFunction = compareNumbers) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.setRow(i2, this.getRow(i2).sort(compareFunction));
        }
        return this;
      }
      sortColumns(compareFunction = compareNumbers) {
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.setColumn(i2, this.getColumn(i2).sort(compareFunction));
        }
        return this;
      }
      subMatrix(startRow, endRow, startColumn, endColumn) {
        checkRange(this, startRow, endRow, startColumn, endColumn);
        let newMatrix = new Matrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1
        );
        for (let i2 = startRow; i2 <= endRow; i2++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            newMatrix.set(i2 - startRow, j2 - startColumn, this.get(i2, j2));
          }
        }
        return newMatrix;
      }
      subMatrixRow(indices, startColumn, endColumn) {
        if (startColumn === void 0)
          startColumn = 0;
        if (endColumn === void 0)
          endColumn = this.columns - 1;
        if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
        for (let i2 = 0; i2 < indices.length; i2++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            if (indices[i2] < 0 || indices[i2] >= this.rows) {
              throw new RangeError(`Row index out of range: ${indices[i2]}`);
            }
            newMatrix.set(i2, j2 - startColumn, this.get(indices[i2], j2));
          }
        }
        return newMatrix;
      }
      subMatrixColumn(indices, startRow, endRow) {
        if (startRow === void 0)
          startRow = 0;
        if (endRow === void 0)
          endRow = this.rows - 1;
        if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
        for (let i2 = 0; i2 < indices.length; i2++) {
          for (let j2 = startRow; j2 <= endRow; j2++) {
            if (indices[i2] < 0 || indices[i2] >= this.columns) {
              throw new RangeError(`Column index out of range: ${indices[i2]}`);
            }
            newMatrix.set(j2 - startRow, i2, this.get(j2, indices[i2]));
          }
        }
        return newMatrix;
      }
      setSubMatrix(matrix, startRow, startColumn) {
        matrix = Matrix.checkMatrix(matrix);
        let endRow = startRow + matrix.rows - 1;
        let endColumn = startColumn + matrix.columns - 1;
        checkRange(this, startRow, endRow, startColumn, endColumn);
        for (let i2 = 0; i2 < matrix.rows; i2++) {
          for (let j2 = 0; j2 < matrix.columns; j2++) {
            this.set(startRow + i2, startColumn + j2, matrix.get(i2, j2));
          }
        }
        return this;
      }
      selection(rowIndices, columnIndices) {
        let indices = checkIndices(this, rowIndices, columnIndices);
        let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
        for (let i2 = 0; i2 < indices.row.length; i2++) {
          let rowIndex = indices.row[i2];
          for (let j2 = 0; j2 < indices.column.length; j2++) {
            let columnIndex = indices.column[j2];
            newMatrix.set(i2, j2, this.get(rowIndex, columnIndex));
          }
        }
        return newMatrix;
      }
      trace() {
        let min3 = Math.min(this.rows, this.columns);
        let trace = 0;
        for (let i2 = 0; i2 < min3; i2++) {
          trace += this.get(i2, i2);
        }
        return trace;
      }
      clone() {
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            newMatrix.set(row, column, this.get(row, column));
          }
        }
        return newMatrix;
      }
      sum(by) {
        switch (by) {
          case "row":
            return sumByRow(this);
          case "column":
            return sumByColumn(this);
          case void 0:
            return sumAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      product(by) {
        switch (by) {
          case "row":
            return productByRow(this);
          case "column":
            return productByColumn(this);
          case void 0:
            return productAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      mean(by) {
        const sum = this.sum(by);
        switch (by) {
          case "row": {
            for (let i2 = 0; i2 < this.rows; i2++) {
              sum[i2] /= this.columns;
            }
            return sum;
          }
          case "column": {
            for (let i2 = 0; i2 < this.columns; i2++) {
              sum[i2] /= this.rows;
            }
            return sum;
          }
          case void 0:
            return sum / this.size;
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      variance(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { unbiased = true, mean = this.mean(by) } = options;
        if (typeof unbiased !== "boolean") {
          throw new TypeError("unbiased must be a boolean");
        }
        switch (by) {
          case "row": {
            if (!Array.isArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByRow(this, unbiased, mean);
          }
          case "column": {
            if (!Array.isArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByColumn(this, unbiased, mean);
          }
          case void 0: {
            if (typeof mean !== "number") {
              throw new TypeError("mean must be a number");
            }
            return varianceAll(this, unbiased, mean);
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      standardDeviation(by, options) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        const variance = this.variance(by, options);
        if (by === void 0) {
          return Math.sqrt(variance);
        } else {
          for (let i2 = 0; i2 < variance.length; i2++) {
            variance[i2] = Math.sqrt(variance[i2]);
          }
          return variance;
        }
      }
      center(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { center = this.mean(by) } = options;
        switch (by) {
          case "row": {
            if (!Array.isArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByRow(this, center);
            return this;
          }
          case "column": {
            if (!Array.isArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByColumn(this, center);
            return this;
          }
          case void 0: {
            if (typeof center !== "number") {
              throw new TypeError("center must be a number");
            }
            centerAll(this, center);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      scale(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        let scale3 = options.scale;
        switch (by) {
          case "row": {
            if (scale3 === void 0) {
              scale3 = getScaleByRow(this);
            } else if (!Array.isArray(scale3)) {
              throw new TypeError("scale must be an array");
            }
            scaleByRow(this, scale3);
            return this;
          }
          case "column": {
            if (scale3 === void 0) {
              scale3 = getScaleByColumn(this);
            } else if (!Array.isArray(scale3)) {
              throw new TypeError("scale must be an array");
            }
            scaleByColumn(this, scale3);
            return this;
          }
          case void 0: {
            if (scale3 === void 0) {
              scale3 = getScaleAll(this);
            } else if (typeof scale3 !== "number") {
              throw new TypeError("scale must be a number");
            }
            scaleAll(this, scale3);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      toString(options) {
        return inspectMatrixWithOptions(this, options);
      }
    };
    AbstractMatrix.prototype.klass = "Matrix";
    if (typeof Symbol !== "undefined") {
      AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
    }
    AbstractMatrix.random = AbstractMatrix.rand;
    AbstractMatrix.randomInt = AbstractMatrix.randInt;
    AbstractMatrix.diagonal = AbstractMatrix.diag;
    AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
    AbstractMatrix.identity = AbstractMatrix.eye;
    AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
    AbstractMatrix.prototype.tensorProduct = AbstractMatrix.prototype.kroneckerProduct;
    Matrix = class extends AbstractMatrix {
      constructor(nRows, nColumns) {
        super();
        if (Matrix.isMatrix(nRows)) {
          return nRows.clone();
        } else if (Number.isInteger(nRows) && nRows > 0) {
          this.data = [];
          if (Number.isInteger(nColumns) && nColumns > 0) {
            for (let i2 = 0; i2 < nRows; i2++) {
              this.data.push(new Float64Array(nColumns));
            }
          } else {
            throw new TypeError("nColumns must be a positive integer");
          }
        } else if (Array.isArray(nRows)) {
          const arrayData = nRows;
          nRows = arrayData.length;
          nColumns = arrayData[0].length;
          if (typeof nColumns !== "number" || nColumns === 0) {
            throw new TypeError(
              "Data must be a 2D array with at least one element"
            );
          }
          this.data = [];
          for (let i2 = 0; i2 < nRows; i2++) {
            if (arrayData[i2].length !== nColumns) {
              throw new RangeError("Inconsistent array dimensions");
            }
            this.data.push(Float64Array.from(arrayData[i2]));
          }
        } else {
          throw new TypeError(
            "First argument must be a positive number or an array"
          );
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
      removeRow(index2) {
        checkRowIndex(this, index2);
        if (this.rows === 1) {
          throw new RangeError("A matrix cannot have less than one row");
        }
        this.data.splice(index2, 1);
        this.rows -= 1;
        return this;
      }
      addRow(index2, array) {
        if (array === void 0) {
          array = index2;
          index2 = this.rows;
        }
        checkRowIndex(this, index2, true);
        array = Float64Array.from(checkRowVector(this, array, true));
        this.data.splice(index2, 0, array);
        this.rows += 1;
        return this;
      }
      removeColumn(index2) {
        checkColumnIndex(this, index2);
        if (this.columns === 1) {
          throw new RangeError("A matrix cannot have less than one column");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          const newRow = new Float64Array(this.columns - 1);
          for (let j2 = 0; j2 < index2; j2++) {
            newRow[j2] = this.data[i2][j2];
          }
          for (let j2 = index2 + 1; j2 < this.columns; j2++) {
            newRow[j2 - 1] = this.data[i2][j2];
          }
          this.data[i2] = newRow;
        }
        this.columns -= 1;
        return this;
      }
      addColumn(index2, array) {
        if (typeof array === "undefined") {
          array = index2;
          index2 = this.columns;
        }
        checkColumnIndex(this, index2, true);
        array = checkColumnVector(this, array);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const newRow = new Float64Array(this.columns + 1);
          let j2 = 0;
          for (; j2 < index2; j2++) {
            newRow[j2] = this.data[i2][j2];
          }
          newRow[j2++] = array[i2];
          for (; j2 < this.columns + 1; j2++) {
            newRow[j2] = this.data[i2][j2 - 1];
          }
          this.data[i2] = newRow;
        }
        this.columns += 1;
        return this;
      }
    };
    installMathOperations(AbstractMatrix, Matrix);
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/base.js
var BaseView;
var init_base = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/base.js"() {
    init_matrix2();
    BaseView = class extends AbstractMatrix {
      constructor(matrix, rows, columns) {
        super();
        this.matrix = matrix;
        this.rows = rows;
        this.columns = columns;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/column.js
var MatrixColumnView;
var init_column = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/column.js"() {
    init_util2();
    init_base();
    MatrixColumnView = class extends BaseView {
      constructor(matrix, column) {
        checkColumnIndex(matrix, column);
        super(matrix, matrix.rows, 1);
        this.column = column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }
      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/columnSelection.js
var MatrixColumnSelectionView;
var init_columnSelection = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/columnSelection.js"() {
    init_util2();
    init_base();
    MatrixColumnSelectionView = class extends BaseView {
      constructor(matrix, columnIndices) {
        columnIndices = checkColumnIndices(matrix, columnIndices);
        super(matrix, matrix.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/flipColumn.js
var MatrixFlipColumnView;
var init_flipColumn = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/flipColumn.js"() {
    init_base();
    MatrixFlipColumnView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/flipRow.js
var MatrixFlipRowView;
var init_flipRow = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/flipRow.js"() {
    init_base();
    MatrixFlipRowView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/row.js
var MatrixRowView;
var init_row = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/row.js"() {
    init_util2();
    init_base();
    MatrixRowView = class extends BaseView {
      constructor(matrix, row) {
        checkRowIndex(matrix, row);
        super(matrix, 1, matrix.columns);
        this.row = row;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/rowSelection.js
var MatrixRowSelectionView;
var init_rowSelection = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/rowSelection.js"() {
    init_util2();
    init_base();
    MatrixRowSelectionView = class extends BaseView {
      constructor(matrix, rowIndices) {
        rowIndices = checkRowIndices(matrix, rowIndices);
        super(matrix, rowIndices.length, matrix.columns);
        this.rowIndices = rowIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/selection.js
var MatrixSelectionView;
var init_selection = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/selection.js"() {
    init_util2();
    init_base();
    MatrixSelectionView = class extends BaseView {
      constructor(matrix, rowIndices, columnIndices) {
        let indices = checkIndices(matrix, rowIndices, columnIndices);
        super(matrix, indices.row.length, indices.column.length);
        this.rowIndices = indices.row;
        this.columnIndices = indices.column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/sub.js
var MatrixSubView;
var init_sub = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/sub.js"() {
    init_util2();
    init_base();
    MatrixSubView = class extends BaseView {
      constructor(matrix, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix, startRow, endRow, startColumn, endColumn);
        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/transpose.js
var MatrixTransposeView;
var init_transpose = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/transpose.js"() {
    init_base();
    MatrixTransposeView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.columns, matrix.rows);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/views/index.js
var init_views = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/views/index.js"() {
    init_column();
    init_columnSelection();
    init_flipColumn();
    init_flipRow();
    init_row();
    init_rowSelection();
    init_selection();
    init_sub();
    init_transpose();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js
var WrapperMatrix1D;
var init_WrapperMatrix1D = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js"() {
    init_matrix2();
    WrapperMatrix1D = class extends AbstractMatrix {
      constructor(data, options = {}) {
        const { rows = 1 } = options;
        if (data.length % rows !== 0) {
          throw new Error("the data length is not divisible by the number of rows");
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }
      set(rowIndex, columnIndex, value) {
        let index2 = this._calculateIndex(rowIndex, columnIndex);
        this.data[index2] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        let index2 = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index2];
      }
      _calculateIndex(row, column) {
        return row * this.columns + column;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js
var WrapperMatrix2D;
var init_WrapperMatrix2D = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js"() {
    init_matrix2();
    WrapperMatrix2D = class extends AbstractMatrix {
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/wrap.js
function wrap(array, options) {
  if (Array.isArray(array)) {
    if (array[0] && Array.isArray(array[0])) {
      return new WrapperMatrix2D(array);
    } else {
      return new WrapperMatrix1D(array, options);
    }
  } else {
    throw new Error("the argument is not an array");
  }
}
var init_wrap = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/wrap/wrap.js"() {
    init_WrapperMatrix1D();
    init_WrapperMatrix2D();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/lu.js
var LuDecomposition;
var init_lu = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/lu.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    LuDecomposition = class {
      constructor(matrix) {
        matrix = WrapperMatrix2D.checkMatrix(matrix);
        let lu2 = matrix.clone();
        let rows = lu2.rows;
        let columns = lu2.columns;
        let pivotVector = new Float64Array(rows);
        let pivotSign = 1;
        let i2, j2, k2, p2, s2, t2, v2;
        let LUcolj, kmax;
        for (i2 = 0; i2 < rows; i2++) {
          pivotVector[i2] = i2;
        }
        LUcolj = new Float64Array(rows);
        for (j2 = 0; j2 < columns; j2++) {
          for (i2 = 0; i2 < rows; i2++) {
            LUcolj[i2] = lu2.get(i2, j2);
          }
          for (i2 = 0; i2 < rows; i2++) {
            kmax = Math.min(i2, j2);
            s2 = 0;
            for (k2 = 0; k2 < kmax; k2++) {
              s2 += lu2.get(i2, k2) * LUcolj[k2];
            }
            LUcolj[i2] -= s2;
            lu2.set(i2, j2, LUcolj[i2]);
          }
          p2 = j2;
          for (i2 = j2 + 1; i2 < rows; i2++) {
            if (Math.abs(LUcolj[i2]) > Math.abs(LUcolj[p2])) {
              p2 = i2;
            }
          }
          if (p2 !== j2) {
            for (k2 = 0; k2 < columns; k2++) {
              t2 = lu2.get(p2, k2);
              lu2.set(p2, k2, lu2.get(j2, k2));
              lu2.set(j2, k2, t2);
            }
            v2 = pivotVector[p2];
            pivotVector[p2] = pivotVector[j2];
            pivotVector[j2] = v2;
            pivotSign = -pivotSign;
          }
          if (j2 < rows && lu2.get(j2, j2) !== 0) {
            for (i2 = j2 + 1; i2 < rows; i2++) {
              lu2.set(i2, j2, lu2.get(i2, j2) / lu2.get(j2, j2));
            }
          }
        }
        this.LU = lu2;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }
      isSingular() {
        let data = this.LU;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          if (data.get(j2, j2) === 0) {
            return true;
          }
        }
        return false;
      }
      solve(value) {
        value = Matrix.checkMatrix(value);
        let lu2 = this.LU;
        let rows = lu2.rows;
        if (rows !== value.rows) {
          throw new Error("Invalid matrix dimensions");
        }
        if (this.isSingular()) {
          throw new Error("LU matrix is singular");
        }
        let count = value.columns;
        let X2 = value.subMatrixRow(this.pivotVector, 0, count - 1);
        let columns = lu2.columns;
        let i2, j2, k2;
        for (k2 = 0; k2 < columns; k2++) {
          for (i2 = k2 + 1; i2 < columns; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * lu2.get(i2, k2));
            }
          }
        }
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / lu2.get(k2, k2));
          }
          for (i2 = 0; i2 < k2; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * lu2.get(i2, k2));
            }
          }
        }
        return X2;
      }
      get determinant() {
        let data = this.LU;
        if (!data.isSquare()) {
          throw new Error("Matrix must be square");
        }
        let determinant2 = this.pivotSign;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          determinant2 *= data.get(j2, j2);
        }
        return determinant2;
      }
      get lowerTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i2 > j2) {
              X2.set(i2, j2, data.get(i2, j2));
            } else if (i2 === j2) {
              X2.set(i2, j2, 1);
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get upperTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i2 <= j2) {
              X2.set(i2, j2, data.get(i2, j2));
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get pivotPermutationVector() {
        return Array.from(this.pivotVector);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/util.js
function hypotenuse(a3, b2) {
  let r2 = 0;
  if (Math.abs(a3) > Math.abs(b2)) {
    r2 = b2 / a3;
    return Math.abs(a3) * Math.sqrt(1 + r2 * r2);
  }
  if (b2 !== 0) {
    r2 = a3 / b2;
    return Math.abs(b2) * Math.sqrt(1 + r2 * r2);
  }
  return 0;
}
var init_util3 = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/util.js"() {
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/qr.js
var QrDecomposition;
var init_qr = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/qr.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    init_util3();
    QrDecomposition = class {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        let qr2 = value.clone();
        let m3 = value.rows;
        let n2 = value.columns;
        let rdiag = new Float64Array(n2);
        let i2, j2, k2, s2;
        for (k2 = 0; k2 < n2; k2++) {
          let nrm = 0;
          for (i2 = k2; i2 < m3; i2++) {
            nrm = hypotenuse(nrm, qr2.get(i2, k2));
          }
          if (nrm !== 0) {
            if (qr2.get(k2, k2) < 0) {
              nrm = -nrm;
            }
            for (i2 = k2; i2 < m3; i2++) {
              qr2.set(i2, k2, qr2.get(i2, k2) / nrm);
            }
            qr2.set(k2, k2, qr2.get(k2, k2) + 1);
            for (j2 = k2 + 1; j2 < n2; j2++) {
              s2 = 0;
              for (i2 = k2; i2 < m3; i2++) {
                s2 += qr2.get(i2, k2) * qr2.get(i2, j2);
              }
              s2 = -s2 / qr2.get(k2, k2);
              for (i2 = k2; i2 < m3; i2++) {
                qr2.set(i2, j2, qr2.get(i2, j2) + s2 * qr2.get(i2, k2));
              }
            }
          }
          rdiag[k2] = -nrm;
        }
        this.QR = qr2;
        this.Rdiag = rdiag;
      }
      solve(value) {
        value = Matrix.checkMatrix(value);
        let qr2 = this.QR;
        let m3 = qr2.rows;
        if (value.rows !== m3) {
          throw new Error("Matrix row dimensions must agree");
        }
        if (!this.isFullRank()) {
          throw new Error("Matrix is rank deficient");
        }
        let count = value.columns;
        let X2 = value.clone();
        let n2 = qr2.columns;
        let i2, j2, k2, s2;
        for (k2 = 0; k2 < n2; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            s2 = 0;
            for (i2 = k2; i2 < m3; i2++) {
              s2 += qr2.get(i2, k2) * X2.get(i2, j2);
            }
            s2 = -s2 / qr2.get(k2, k2);
            for (i2 = k2; i2 < m3; i2++) {
              X2.set(i2, j2, X2.get(i2, j2) + s2 * qr2.get(i2, k2));
            }
          }
        }
        for (k2 = n2 - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / this.Rdiag[k2]);
          }
          for (i2 = 0; i2 < k2; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * qr2.get(i2, k2));
            }
          }
        }
        return X2.subMatrix(0, n2 - 1, 0, count - 1);
      }
      isFullRank() {
        let columns = this.QR.columns;
        for (let i2 = 0; i2 < columns; i2++) {
          if (this.Rdiag[i2] === 0) {
            return false;
          }
        }
        return true;
      }
      get upperTriangularMatrix() {
        let qr2 = this.QR;
        let n2 = qr2.columns;
        let X2 = new Matrix(n2, n2);
        let i2, j2;
        for (i2 = 0; i2 < n2; i2++) {
          for (j2 = 0; j2 < n2; j2++) {
            if (i2 < j2) {
              X2.set(i2, j2, qr2.get(i2, j2));
            } else if (i2 === j2) {
              X2.set(i2, j2, this.Rdiag[i2]);
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get orthogonalMatrix() {
        let qr2 = this.QR;
        let rows = qr2.rows;
        let columns = qr2.columns;
        let X2 = new Matrix(rows, columns);
        let i2, j2, k2, s2;
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (i2 = 0; i2 < rows; i2++) {
            X2.set(i2, k2, 0);
          }
          X2.set(k2, k2, 1);
          for (j2 = k2; j2 < columns; j2++) {
            if (qr2.get(k2, k2) !== 0) {
              s2 = 0;
              for (i2 = k2; i2 < rows; i2++) {
                s2 += qr2.get(i2, k2) * X2.get(i2, j2);
              }
              s2 = -s2 / qr2.get(k2, k2);
              for (i2 = k2; i2 < rows; i2++) {
                X2.set(i2, j2, X2.get(i2, j2) + s2 * qr2.get(i2, k2));
              }
            }
          }
        }
        return X2;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/svd.js
var SingularValueDecomposition;
var init_svd = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/svd.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    init_util3();
    SingularValueDecomposition = class {
      constructor(value, options = {}) {
        value = WrapperMatrix2D.checkMatrix(value);
        let m3 = value.rows;
        let n2 = value.columns;
        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;
        let wantu = Boolean(computeLeftSingularVectors);
        let wantv = Boolean(computeRightSingularVectors);
        let swapped = false;
        let a3;
        if (m3 < n2) {
          if (!autoTranspose) {
            a3 = value.clone();
            console.warn(
              "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
            );
          } else {
            a3 = value.transpose();
            m3 = a3.rows;
            n2 = a3.columns;
            swapped = true;
            let aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a3 = value.clone();
        }
        let nu2 = Math.min(m3, n2);
        let ni2 = Math.min(m3 + 1, n2);
        let s2 = new Float64Array(ni2);
        let U2 = new Matrix(m3, nu2);
        let V2 = new Matrix(n2, n2);
        let e8 = new Float64Array(n2);
        let work = new Float64Array(m3);
        let si2 = new Float64Array(ni2);
        for (let i2 = 0; i2 < ni2; i2++)
          si2[i2] = i2;
        let nct = Math.min(m3 - 1, n2);
        let nrt = Math.max(0, Math.min(n2 - 2, m3));
        let mrc = Math.max(nct, nrt);
        for (let k2 = 0; k2 < mrc; k2++) {
          if (k2 < nct) {
            s2[k2] = 0;
            for (let i2 = k2; i2 < m3; i2++) {
              s2[k2] = hypotenuse(s2[k2], a3.get(i2, k2));
            }
            if (s2[k2] !== 0) {
              if (a3.get(k2, k2) < 0) {
                s2[k2] = -s2[k2];
              }
              for (let i2 = k2; i2 < m3; i2++) {
                a3.set(i2, k2, a3.get(i2, k2) / s2[k2]);
              }
              a3.set(k2, k2, a3.get(k2, k2) + 1);
            }
            s2[k2] = -s2[k2];
          }
          for (let j2 = k2 + 1; j2 < n2; j2++) {
            if (k2 < nct && s2[k2] !== 0) {
              let t2 = 0;
              for (let i2 = k2; i2 < m3; i2++) {
                t2 += a3.get(i2, k2) * a3.get(i2, j2);
              }
              t2 = -t2 / a3.get(k2, k2);
              for (let i2 = k2; i2 < m3; i2++) {
                a3.set(i2, j2, a3.get(i2, j2) + t2 * a3.get(i2, k2));
              }
            }
            e8[j2] = a3.get(k2, j2);
          }
          if (wantu && k2 < nct) {
            for (let i2 = k2; i2 < m3; i2++) {
              U2.set(i2, k2, a3.get(i2, k2));
            }
          }
          if (k2 < nrt) {
            e8[k2] = 0;
            for (let i2 = k2 + 1; i2 < n2; i2++) {
              e8[k2] = hypotenuse(e8[k2], e8[i2]);
            }
            if (e8[k2] !== 0) {
              if (e8[k2 + 1] < 0) {
                e8[k2] = 0 - e8[k2];
              }
              for (let i2 = k2 + 1; i2 < n2; i2++) {
                e8[i2] /= e8[k2];
              }
              e8[k2 + 1] += 1;
            }
            e8[k2] = -e8[k2];
            if (k2 + 1 < m3 && e8[k2] !== 0) {
              for (let i2 = k2 + 1; i2 < m3; i2++) {
                work[i2] = 0;
              }
              for (let i2 = k2 + 1; i2 < m3; i2++) {
                for (let j2 = k2 + 1; j2 < n2; j2++) {
                  work[i2] += e8[j2] * a3.get(i2, j2);
                }
              }
              for (let j2 = k2 + 1; j2 < n2; j2++) {
                let t2 = -e8[j2] / e8[k2 + 1];
                for (let i2 = k2 + 1; i2 < m3; i2++) {
                  a3.set(i2, j2, a3.get(i2, j2) + t2 * work[i2]);
                }
              }
            }
            if (wantv) {
              for (let i2 = k2 + 1; i2 < n2; i2++) {
                V2.set(i2, k2, e8[i2]);
              }
            }
          }
        }
        let p2 = Math.min(n2, m3 + 1);
        if (nct < n2) {
          s2[nct] = a3.get(nct, nct);
        }
        if (m3 < p2) {
          s2[p2 - 1] = 0;
        }
        if (nrt + 1 < p2) {
          e8[nrt] = a3.get(nrt, p2 - 1);
        }
        e8[p2 - 1] = 0;
        if (wantu) {
          for (let j2 = nct; j2 < nu2; j2++) {
            for (let i2 = 0; i2 < m3; i2++) {
              U2.set(i2, j2, 0);
            }
            U2.set(j2, j2, 1);
          }
          for (let k2 = nct - 1; k2 >= 0; k2--) {
            if (s2[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < nu2; j2++) {
                let t2 = 0;
                for (let i2 = k2; i2 < m3; i2++) {
                  t2 += U2.get(i2, k2) * U2.get(i2, j2);
                }
                t2 = -t2 / U2.get(k2, k2);
                for (let i2 = k2; i2 < m3; i2++) {
                  U2.set(i2, j2, U2.get(i2, j2) + t2 * U2.get(i2, k2));
                }
              }
              for (let i2 = k2; i2 < m3; i2++) {
                U2.set(i2, k2, -U2.get(i2, k2));
              }
              U2.set(k2, k2, 1 + U2.get(k2, k2));
              for (let i2 = 0; i2 < k2 - 1; i2++) {
                U2.set(i2, k2, 0);
              }
            } else {
              for (let i2 = 0; i2 < m3; i2++) {
                U2.set(i2, k2, 0);
              }
              U2.set(k2, k2, 1);
            }
          }
        }
        if (wantv) {
          for (let k2 = n2 - 1; k2 >= 0; k2--) {
            if (k2 < nrt && e8[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < n2; j2++) {
                let t2 = 0;
                for (let i2 = k2 + 1; i2 < n2; i2++) {
                  t2 += V2.get(i2, k2) * V2.get(i2, j2);
                }
                t2 = -t2 / V2.get(k2 + 1, k2);
                for (let i2 = k2 + 1; i2 < n2; i2++) {
                  V2.set(i2, j2, V2.get(i2, j2) + t2 * V2.get(i2, k2));
                }
              }
            }
            for (let i2 = 0; i2 < n2; i2++) {
              V2.set(i2, k2, 0);
            }
            V2.set(k2, k2, 1);
          }
        }
        let pp = p2 - 1;
        let iter = 0;
        let eps = Number.EPSILON;
        while (p2 > 0) {
          let k2, kase;
          for (k2 = p2 - 2; k2 >= -1; k2--) {
            if (k2 === -1) {
              break;
            }
            const alpha = Number.MIN_VALUE + eps * Math.abs(s2[k2] + Math.abs(s2[k2 + 1]));
            if (Math.abs(e8[k2]) <= alpha || Number.isNaN(e8[k2])) {
              e8[k2] = 0;
              break;
            }
          }
          if (k2 === p2 - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p2 - 1; ks >= k2; ks--) {
              if (ks === k2) {
                break;
              }
              let t2 = (ks !== p2 ? Math.abs(e8[ks]) : 0) + (ks !== k2 + 1 ? Math.abs(e8[ks - 1]) : 0);
              if (Math.abs(s2[ks]) <= eps * t2) {
                s2[ks] = 0;
                break;
              }
            }
            if (ks === k2) {
              kase = 3;
            } else if (ks === p2 - 1) {
              kase = 1;
            } else {
              kase = 2;
              k2 = ks;
            }
          }
          k2++;
          switch (kase) {
            case 1: {
              let f2 = e8[p2 - 2];
              e8[p2 - 2] = 0;
              for (let j2 = p2 - 2; j2 >= k2; j2--) {
                let t2 = hypotenuse(s2[j2], f2);
                let cs = s2[j2] / t2;
                let sn2 = f2 / t2;
                s2[j2] = t2;
                if (j2 !== k2) {
                  f2 = -sn2 * e8[j2 - 1];
                  e8[j2 - 1] = cs * e8[j2 - 1];
                }
                if (wantv) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t2 = cs * V2.get(i2, j2) + sn2 * V2.get(i2, p2 - 1);
                    V2.set(i2, p2 - 1, -sn2 * V2.get(i2, j2) + cs * V2.get(i2, p2 - 1));
                    V2.set(i2, j2, t2);
                  }
                }
              }
              break;
            }
            case 2: {
              let f2 = e8[k2 - 1];
              e8[k2 - 1] = 0;
              for (let j2 = k2; j2 < p2; j2++) {
                let t2 = hypotenuse(s2[j2], f2);
                let cs = s2[j2] / t2;
                let sn2 = f2 / t2;
                s2[j2] = t2;
                f2 = -sn2 * e8[j2];
                e8[j2] = cs * e8[j2];
                if (wantu) {
                  for (let i2 = 0; i2 < m3; i2++) {
                    t2 = cs * U2.get(i2, j2) + sn2 * U2.get(i2, k2 - 1);
                    U2.set(i2, k2 - 1, -sn2 * U2.get(i2, j2) + cs * U2.get(i2, k2 - 1));
                    U2.set(i2, j2, t2);
                  }
                }
              }
              break;
            }
            case 3: {
              const scale3 = Math.max(
                Math.abs(s2[p2 - 1]),
                Math.abs(s2[p2 - 2]),
                Math.abs(e8[p2 - 2]),
                Math.abs(s2[k2]),
                Math.abs(e8[k2])
              );
              const sp = s2[p2 - 1] / scale3;
              const spm1 = s2[p2 - 2] / scale3;
              const epm1 = e8[p2 - 2] / scale3;
              const sk = s2[k2] / scale3;
              const ek = e8[k2] / scale3;
              const b2 = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c3 = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b2 !== 0 || c3 !== 0) {
                if (b2 < 0) {
                  shift = 0 - Math.sqrt(b2 * b2 + c3);
                } else {
                  shift = Math.sqrt(b2 * b2 + c3);
                }
                shift = c3 / (b2 + shift);
              }
              let f2 = (sk + sp) * (sk - sp) + shift;
              let g2 = sk * ek;
              for (let j2 = k2; j2 < p2 - 1; j2++) {
                let t2 = hypotenuse(f2, g2);
                if (t2 === 0)
                  t2 = Number.MIN_VALUE;
                let cs = f2 / t2;
                let sn2 = g2 / t2;
                if (j2 !== k2) {
                  e8[j2 - 1] = t2;
                }
                f2 = cs * s2[j2] + sn2 * e8[j2];
                e8[j2] = cs * e8[j2] - sn2 * s2[j2];
                g2 = sn2 * s2[j2 + 1];
                s2[j2 + 1] = cs * s2[j2 + 1];
                if (wantv) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t2 = cs * V2.get(i2, j2) + sn2 * V2.get(i2, j2 + 1);
                    V2.set(i2, j2 + 1, -sn2 * V2.get(i2, j2) + cs * V2.get(i2, j2 + 1));
                    V2.set(i2, j2, t2);
                  }
                }
                t2 = hypotenuse(f2, g2);
                if (t2 === 0)
                  t2 = Number.MIN_VALUE;
                cs = f2 / t2;
                sn2 = g2 / t2;
                s2[j2] = t2;
                f2 = cs * e8[j2] + sn2 * s2[j2 + 1];
                s2[j2 + 1] = -sn2 * e8[j2] + cs * s2[j2 + 1];
                g2 = sn2 * e8[j2 + 1];
                e8[j2 + 1] = cs * e8[j2 + 1];
                if (wantu && j2 < m3 - 1) {
                  for (let i2 = 0; i2 < m3; i2++) {
                    t2 = cs * U2.get(i2, j2) + sn2 * U2.get(i2, j2 + 1);
                    U2.set(i2, j2 + 1, -sn2 * U2.get(i2, j2) + cs * U2.get(i2, j2 + 1));
                    U2.set(i2, j2, t2);
                  }
                }
              }
              e8[p2 - 2] = f2;
              iter = iter + 1;
              break;
            }
            case 4: {
              if (s2[k2] <= 0) {
                s2[k2] = s2[k2] < 0 ? -s2[k2] : 0;
                if (wantv) {
                  for (let i2 = 0; i2 <= pp; i2++) {
                    V2.set(i2, k2, -V2.get(i2, k2));
                  }
                }
              }
              while (k2 < pp) {
                if (s2[k2] >= s2[k2 + 1]) {
                  break;
                }
                let t2 = s2[k2];
                s2[k2] = s2[k2 + 1];
                s2[k2 + 1] = t2;
                if (wantv && k2 < n2 - 1) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t2 = V2.get(i2, k2 + 1);
                    V2.set(i2, k2 + 1, V2.get(i2, k2));
                    V2.set(i2, k2, t2);
                  }
                }
                if (wantu && k2 < m3 - 1) {
                  for (let i2 = 0; i2 < m3; i2++) {
                    t2 = U2.get(i2, k2 + 1);
                    U2.set(i2, k2 + 1, U2.get(i2, k2));
                    U2.set(i2, k2, t2);
                  }
                }
                k2++;
              }
              iter = 0;
              p2--;
              break;
            }
          }
        }
        if (swapped) {
          let tmp = V2;
          V2 = U2;
          U2 = tmp;
        }
        this.m = m3;
        this.n = n2;
        this.s = s2;
        this.U = U2;
        this.V = V2;
      }
      solve(value) {
        let Y2 = value;
        let e8 = this.threshold;
        let scols = this.s.length;
        let Ls = Matrix.zeros(scols, scols);
        for (let i2 = 0; i2 < scols; i2++) {
          if (Math.abs(this.s[i2]) <= e8) {
            Ls.set(i2, i2, 0);
          } else {
            Ls.set(i2, i2, 1 / this.s[i2]);
          }
        }
        let U2 = this.U;
        let V2 = this.rightSingularVectors;
        let VL = V2.mmul(Ls);
        let vrows = V2.rows;
        let urows = U2.rows;
        let VLU = Matrix.zeros(vrows, urows);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum = 0;
            for (let k2 = 0; k2 < scols; k2++) {
              sum += VL.get(i2, k2) * U2.get(j2, k2);
            }
            VLU.set(i2, j2, sum);
          }
        }
        return VLU.mmul(Y2);
      }
      solveForDiagonal(value) {
        return this.solve(Matrix.diag(value));
      }
      inverse() {
        let V2 = this.V;
        let e8 = this.threshold;
        let vrows = V2.rows;
        let vcols = V2.columns;
        let X2 = new Matrix(vrows, this.s.length);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < vcols; j2++) {
            if (Math.abs(this.s[j2]) > e8) {
              X2.set(i2, j2, V2.get(i2, j2) / this.s[j2]);
            }
          }
        }
        let U2 = this.U;
        let urows = U2.rows;
        let ucols = U2.columns;
        let Y2 = new Matrix(vrows, urows);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum = 0;
            for (let k2 = 0; k2 < ucols; k2++) {
              sum += X2.get(i2, k2) * U2.get(j2, k2);
            }
            Y2.set(i2, j2, sum);
          }
        }
        return Y2;
      }
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }
      get norm2() {
        return this.s[0];
      }
      get rank() {
        let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        let r2 = 0;
        let s2 = this.s;
        for (let i2 = 0, ii2 = s2.length; i2 < ii2; i2++) {
          if (s2[i2] > tol) {
            r2++;
          }
        }
        return r2;
      }
      get diagonal() {
        return Array.from(this.s);
      }
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }
      get leftSingularVectors() {
        return this.U;
      }
      get rightSingularVectors() {
        return this.V;
      }
      get diagonalMatrix() {
        return Matrix.diag(this.s);
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/decompositions.js
function inverse(matrix, useSVD = false) {
  matrix = WrapperMatrix2D.checkMatrix(matrix);
  if (useSVD) {
    return new SingularValueDecomposition(matrix).inverse();
  } else {
    return solve(matrix, Matrix.eye(matrix.rows));
  }
}
function solve(leftHandSide, rightHandSide, useSVD = false) {
  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
  if (useSVD) {
    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
  } else {
    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);
  }
}
var init_decompositions = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/decompositions.js"() {
    init_lu();
    init_qr();
    init_svd();
    init_matrix2();
    init_WrapperMatrix2D();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/determinant.js
function determinant(matrix) {
  matrix = Matrix.checkMatrix(matrix);
  if (matrix.isSquare()) {
    let a3, b2, c3, d2;
    if (matrix.columns === 2) {
      a3 = matrix.get(0, 0);
      b2 = matrix.get(0, 1);
      c3 = matrix.get(1, 0);
      d2 = matrix.get(1, 1);
      return a3 * d2 - b2 * c3;
    } else if (matrix.columns === 3) {
      let subMatrix0, subMatrix1, subMatrix2;
      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);
      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);
      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);
      a3 = matrix.get(0, 0);
      b2 = matrix.get(0, 1);
      c3 = matrix.get(0, 2);
      return a3 * determinant(subMatrix0) - b2 * determinant(subMatrix1) + c3 * determinant(subMatrix2);
    } else {
      return new LuDecomposition(matrix).determinant;
    }
  } else {
    throw Error("determinant can only be calculated for a square matrix");
  }
}
var init_determinant = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/determinant.js"() {
    init_lu();
    init_matrix2();
    init_selection();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/linearDependencies.js
function xrange(n2, exception) {
  let range = [];
  for (let i2 = 0; i2 < n2; i2++) {
    if (i2 !== exception) {
      range.push(i2);
    }
  }
  return range;
}
function dependenciesOneRow(error, matrix, index2, thresholdValue = 1e-9, thresholdError = 1e-9) {
  if (error > thresholdError) {
    return new Array(matrix.rows + 1).fill(0);
  } else {
    let returnArray = matrix.addRow(index2, [0]);
    for (let i2 = 0; i2 < returnArray.rows; i2++) {
      if (Math.abs(returnArray.get(i2, 0)) < thresholdValue) {
        returnArray.set(i2, 0, 0);
      }
    }
    return returnArray.to1DArray();
  }
}
function linearDependencies(matrix, options = {}) {
  const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
  matrix = Matrix.checkMatrix(matrix);
  let n2 = matrix.rows;
  let results = new Matrix(n2, n2);
  for (let i2 = 0; i2 < n2; i2++) {
    let b2 = Matrix.columnVector(matrix.getRow(i2));
    let Abis = matrix.subMatrixRow(xrange(n2, i2)).transpose();
    let svd = new SingularValueDecomposition(Abis);
    let x4 = svd.solve(b2);
    let error = Matrix.sub(b2, Abis.mmul(x4)).abs().max();
    results.setRow(
      i2,
      dependenciesOneRow(error, x4, i2, thresholdValue, thresholdError)
    );
  }
  return results;
}
var init_linearDependencies = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/linearDependencies.js"() {
    init_svd();
    init_matrix2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/pseudoInverse.js
function pseudoInverse(matrix, threshold = Number.EPSILON) {
  matrix = Matrix.checkMatrix(matrix);
  let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });
  let U2 = svdSolution.leftSingularVectors;
  let V2 = svdSolution.rightSingularVectors;
  let s2 = svdSolution.diagonal;
  for (let i2 = 0; i2 < s2.length; i2++) {
    if (Math.abs(s2[i2]) > threshold) {
      s2[i2] = 1 / s2[i2];
    } else {
      s2[i2] = 0;
    }
  }
  return V2.mmul(Matrix.diag(s2).mmul(U2.transpose()));
}
var init_pseudoInverse = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/pseudoInverse.js"() {
    init_svd();
    init_matrix2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/covariance.js
function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (typeof yMatrix === "object" && !Matrix.isMatrix(yMatrix) && !Array.isArray(yMatrix)) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError("Both matrices must have the same number of rows");
  }
  const { center = true } = options;
  if (center) {
    xMatrix = xMatrix.center("column");
    if (!yIsSame) {
      yMatrix = yMatrix.center("column");
    }
  }
  const cov = xMatrix.transpose().mmul(yMatrix);
  for (let i2 = 0; i2 < cov.rows; i2++) {
    for (let j2 = 0; j2 < cov.columns; j2++) {
      cov.set(i2, j2, cov.get(i2, j2) * (1 / (xMatrix.rows - 1)));
    }
  }
  return cov;
}
var init_covariance = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/covariance.js"() {
    init_matrix2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/correlation.js
function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (typeof yMatrix === "object" && !Matrix.isMatrix(yMatrix) && !Array.isArray(yMatrix)) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError("Both matrices must have the same number of rows");
  }
  const { center = true, scale: scale3 = true } = options;
  if (center) {
    xMatrix.center("column");
    if (!yIsSame) {
      yMatrix.center("column");
    }
  }
  if (scale3) {
    xMatrix.scale("column");
    if (!yIsSame) {
      yMatrix.scale("column");
    }
  }
  const sdx = xMatrix.standardDeviation("column", { unbiased: true });
  const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
  const corr = xMatrix.transpose().mmul(yMatrix);
  for (let i2 = 0; i2 < corr.rows; i2++) {
    for (let j2 = 0; j2 < corr.columns; j2++) {
      corr.set(
        i2,
        j2,
        corr.get(i2, j2) * (1 / (sdx[i2] * sdy[j2])) * (1 / (xMatrix.rows - 1))
      );
    }
  }
  return corr;
}
var init_correlation = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/correlation.js"() {
    init_matrix2();
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/evd.js
function tred2(n2, e8, d2, V2) {
  let f2, g2, h2, i2, j2, k2, hh, scale3;
  for (j2 = 0; j2 < n2; j2++) {
    d2[j2] = V2.get(n2 - 1, j2);
  }
  for (i2 = n2 - 1; i2 > 0; i2--) {
    scale3 = 0;
    h2 = 0;
    for (k2 = 0; k2 < i2; k2++) {
      scale3 = scale3 + Math.abs(d2[k2]);
    }
    if (scale3 === 0) {
      e8[i2] = d2[i2 - 1];
      for (j2 = 0; j2 < i2; j2++) {
        d2[j2] = V2.get(i2 - 1, j2);
        V2.set(i2, j2, 0);
        V2.set(j2, i2, 0);
      }
    } else {
      for (k2 = 0; k2 < i2; k2++) {
        d2[k2] /= scale3;
        h2 += d2[k2] * d2[k2];
      }
      f2 = d2[i2 - 1];
      g2 = Math.sqrt(h2);
      if (f2 > 0) {
        g2 = -g2;
      }
      e8[i2] = scale3 * g2;
      h2 = h2 - f2 * g2;
      d2[i2 - 1] = f2 - g2;
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] = 0;
      }
      for (j2 = 0; j2 < i2; j2++) {
        f2 = d2[j2];
        V2.set(j2, i2, f2);
        g2 = e8[j2] + V2.get(j2, j2) * f2;
        for (k2 = j2 + 1; k2 <= i2 - 1; k2++) {
          g2 += V2.get(k2, j2) * d2[k2];
          e8[k2] += V2.get(k2, j2) * f2;
        }
        e8[j2] = g2;
      }
      f2 = 0;
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] /= h2;
        f2 += e8[j2] * d2[j2];
      }
      hh = f2 / (h2 + h2);
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] -= hh * d2[j2];
      }
      for (j2 = 0; j2 < i2; j2++) {
        f2 = d2[j2];
        g2 = e8[j2];
        for (k2 = j2; k2 <= i2 - 1; k2++) {
          V2.set(k2, j2, V2.get(k2, j2) - (f2 * e8[k2] + g2 * d2[k2]));
        }
        d2[j2] = V2.get(i2 - 1, j2);
        V2.set(i2, j2, 0);
      }
    }
    d2[i2] = h2;
  }
  for (i2 = 0; i2 < n2 - 1; i2++) {
    V2.set(n2 - 1, i2, V2.get(i2, i2));
    V2.set(i2, i2, 1);
    h2 = d2[i2 + 1];
    if (h2 !== 0) {
      for (k2 = 0; k2 <= i2; k2++) {
        d2[k2] = V2.get(k2, i2 + 1) / h2;
      }
      for (j2 = 0; j2 <= i2; j2++) {
        g2 = 0;
        for (k2 = 0; k2 <= i2; k2++) {
          g2 += V2.get(k2, i2 + 1) * V2.get(k2, j2);
        }
        for (k2 = 0; k2 <= i2; k2++) {
          V2.set(k2, j2, V2.get(k2, j2) - g2 * d2[k2]);
        }
      }
    }
    for (k2 = 0; k2 <= i2; k2++) {
      V2.set(k2, i2 + 1, 0);
    }
  }
  for (j2 = 0; j2 < n2; j2++) {
    d2[j2] = V2.get(n2 - 1, j2);
    V2.set(n2 - 1, j2, 0);
  }
  V2.set(n2 - 1, n2 - 1, 1);
  e8[0] = 0;
}
function tql2(n2, e8, d2, V2) {
  let g2, h2, i2, j2, k2, l2, m3, p2, r2, dl1, c3, c22, c32, el1, s2, s22, iter;
  for (i2 = 1; i2 < n2; i2++) {
    e8[i2 - 1] = e8[i2];
  }
  e8[n2 - 1] = 0;
  let f2 = 0;
  let tst1 = 0;
  let eps = Number.EPSILON;
  for (l2 = 0; l2 < n2; l2++) {
    tst1 = Math.max(tst1, Math.abs(d2[l2]) + Math.abs(e8[l2]));
    m3 = l2;
    while (m3 < n2) {
      if (Math.abs(e8[m3]) <= eps * tst1) {
        break;
      }
      m3++;
    }
    if (m3 > l2) {
      iter = 0;
      do {
        iter = iter + 1;
        g2 = d2[l2];
        p2 = (d2[l2 + 1] - g2) / (2 * e8[l2]);
        r2 = hypotenuse(p2, 1);
        if (p2 < 0) {
          r2 = -r2;
        }
        d2[l2] = e8[l2] / (p2 + r2);
        d2[l2 + 1] = e8[l2] * (p2 + r2);
        dl1 = d2[l2 + 1];
        h2 = g2 - d2[l2];
        for (i2 = l2 + 2; i2 < n2; i2++) {
          d2[i2] -= h2;
        }
        f2 = f2 + h2;
        p2 = d2[m3];
        c3 = 1;
        c22 = c3;
        c32 = c3;
        el1 = e8[l2 + 1];
        s2 = 0;
        s22 = 0;
        for (i2 = m3 - 1; i2 >= l2; i2--) {
          c32 = c22;
          c22 = c3;
          s22 = s2;
          g2 = c3 * e8[i2];
          h2 = c3 * p2;
          r2 = hypotenuse(p2, e8[i2]);
          e8[i2 + 1] = s2 * r2;
          s2 = e8[i2] / r2;
          c3 = p2 / r2;
          p2 = c3 * d2[i2] - s2 * g2;
          d2[i2 + 1] = h2 + s2 * (c3 * g2 + s2 * d2[i2]);
          for (k2 = 0; k2 < n2; k2++) {
            h2 = V2.get(k2, i2 + 1);
            V2.set(k2, i2 + 1, s2 * V2.get(k2, i2) + c3 * h2);
            V2.set(k2, i2, c3 * V2.get(k2, i2) - s2 * h2);
          }
        }
        p2 = -s2 * s22 * c32 * el1 * e8[l2] / dl1;
        e8[l2] = s2 * p2;
        d2[l2] = c3 * p2;
      } while (Math.abs(e8[l2]) > eps * tst1);
    }
    d2[l2] = d2[l2] + f2;
    e8[l2] = 0;
  }
  for (i2 = 0; i2 < n2 - 1; i2++) {
    k2 = i2;
    p2 = d2[i2];
    for (j2 = i2 + 1; j2 < n2; j2++) {
      if (d2[j2] < p2) {
        k2 = j2;
        p2 = d2[j2];
      }
    }
    if (k2 !== i2) {
      d2[k2] = d2[i2];
      d2[i2] = p2;
      for (j2 = 0; j2 < n2; j2++) {
        p2 = V2.get(j2, i2);
        V2.set(j2, i2, V2.get(j2, k2));
        V2.set(j2, k2, p2);
      }
    }
  }
}
function orthes(n2, H2, ort, V2) {
  let low = 0;
  let high = n2 - 1;
  let f2, g2, h2, i2, j2, m3;
  let scale3;
  for (m3 = low + 1; m3 <= high - 1; m3++) {
    scale3 = 0;
    for (i2 = m3; i2 <= high; i2++) {
      scale3 = scale3 + Math.abs(H2.get(i2, m3 - 1));
    }
    if (scale3 !== 0) {
      h2 = 0;
      for (i2 = high; i2 >= m3; i2--) {
        ort[i2] = H2.get(i2, m3 - 1) / scale3;
        h2 += ort[i2] * ort[i2];
      }
      g2 = Math.sqrt(h2);
      if (ort[m3] > 0) {
        g2 = -g2;
      }
      h2 = h2 - ort[m3] * g2;
      ort[m3] = ort[m3] - g2;
      for (j2 = m3; j2 < n2; j2++) {
        f2 = 0;
        for (i2 = high; i2 >= m3; i2--) {
          f2 += ort[i2] * H2.get(i2, j2);
        }
        f2 = f2 / h2;
        for (i2 = m3; i2 <= high; i2++) {
          H2.set(i2, j2, H2.get(i2, j2) - f2 * ort[i2]);
        }
      }
      for (i2 = 0; i2 <= high; i2++) {
        f2 = 0;
        for (j2 = high; j2 >= m3; j2--) {
          f2 += ort[j2] * H2.get(i2, j2);
        }
        f2 = f2 / h2;
        for (j2 = m3; j2 <= high; j2++) {
          H2.set(i2, j2, H2.get(i2, j2) - f2 * ort[j2]);
        }
      }
      ort[m3] = scale3 * ort[m3];
      H2.set(m3, m3 - 1, scale3 * g2);
    }
  }
  for (i2 = 0; i2 < n2; i2++) {
    for (j2 = 0; j2 < n2; j2++) {
      V2.set(i2, j2, i2 === j2 ? 1 : 0);
    }
  }
  for (m3 = high - 1; m3 >= low + 1; m3--) {
    if (H2.get(m3, m3 - 1) !== 0) {
      for (i2 = m3 + 1; i2 <= high; i2++) {
        ort[i2] = H2.get(i2, m3 - 1);
      }
      for (j2 = m3; j2 <= high; j2++) {
        g2 = 0;
        for (i2 = m3; i2 <= high; i2++) {
          g2 += ort[i2] * V2.get(i2, j2);
        }
        g2 = g2 / ort[m3] / H2.get(m3, m3 - 1);
        for (i2 = m3; i2 <= high; i2++) {
          V2.set(i2, j2, V2.get(i2, j2) + g2 * ort[i2]);
        }
      }
    }
  }
}
function hqr2(nn2, e8, d2, V2, H2) {
  let n2 = nn2 - 1;
  let low = 0;
  let high = nn2 - 1;
  let eps = Number.EPSILON;
  let exshift = 0;
  let norm = 0;
  let p2 = 0;
  let q2 = 0;
  let r2 = 0;
  let s2 = 0;
  let z2 = 0;
  let iter = 0;
  let i2, j2, k2, l2, m3, t2, w2, x4, y4;
  let ra2, sa2, vr2, vi2;
  let notlast, cdivres;
  for (i2 = 0; i2 < nn2; i2++) {
    if (i2 < low || i2 > high) {
      d2[i2] = H2.get(i2, i2);
      e8[i2] = 0;
    }
    for (j2 = Math.max(i2 - 1, 0); j2 < nn2; j2++) {
      norm = norm + Math.abs(H2.get(i2, j2));
    }
  }
  while (n2 >= low) {
    l2 = n2;
    while (l2 > low) {
      s2 = Math.abs(H2.get(l2 - 1, l2 - 1)) + Math.abs(H2.get(l2, l2));
      if (s2 === 0) {
        s2 = norm;
      }
      if (Math.abs(H2.get(l2, l2 - 1)) < eps * s2) {
        break;
      }
      l2--;
    }
    if (l2 === n2) {
      H2.set(n2, n2, H2.get(n2, n2) + exshift);
      d2[n2] = H2.get(n2, n2);
      e8[n2] = 0;
      n2--;
      iter = 0;
    } else if (l2 === n2 - 1) {
      w2 = H2.get(n2, n2 - 1) * H2.get(n2 - 1, n2);
      p2 = (H2.get(n2 - 1, n2 - 1) - H2.get(n2, n2)) / 2;
      q2 = p2 * p2 + w2;
      z2 = Math.sqrt(Math.abs(q2));
      H2.set(n2, n2, H2.get(n2, n2) + exshift);
      H2.set(n2 - 1, n2 - 1, H2.get(n2 - 1, n2 - 1) + exshift);
      x4 = H2.get(n2, n2);
      if (q2 >= 0) {
        z2 = p2 >= 0 ? p2 + z2 : p2 - z2;
        d2[n2 - 1] = x4 + z2;
        d2[n2] = d2[n2 - 1];
        if (z2 !== 0) {
          d2[n2] = x4 - w2 / z2;
        }
        e8[n2 - 1] = 0;
        e8[n2] = 0;
        x4 = H2.get(n2, n2 - 1);
        s2 = Math.abs(x4) + Math.abs(z2);
        p2 = x4 / s2;
        q2 = z2 / s2;
        r2 = Math.sqrt(p2 * p2 + q2 * q2);
        p2 = p2 / r2;
        q2 = q2 / r2;
        for (j2 = n2 - 1; j2 < nn2; j2++) {
          z2 = H2.get(n2 - 1, j2);
          H2.set(n2 - 1, j2, q2 * z2 + p2 * H2.get(n2, j2));
          H2.set(n2, j2, q2 * H2.get(n2, j2) - p2 * z2);
        }
        for (i2 = 0; i2 <= n2; i2++) {
          z2 = H2.get(i2, n2 - 1);
          H2.set(i2, n2 - 1, q2 * z2 + p2 * H2.get(i2, n2));
          H2.set(i2, n2, q2 * H2.get(i2, n2) - p2 * z2);
        }
        for (i2 = low; i2 <= high; i2++) {
          z2 = V2.get(i2, n2 - 1);
          V2.set(i2, n2 - 1, q2 * z2 + p2 * V2.get(i2, n2));
          V2.set(i2, n2, q2 * V2.get(i2, n2) - p2 * z2);
        }
      } else {
        d2[n2 - 1] = x4 + p2;
        d2[n2] = x4 + p2;
        e8[n2 - 1] = z2;
        e8[n2] = -z2;
      }
      n2 = n2 - 2;
      iter = 0;
    } else {
      x4 = H2.get(n2, n2);
      y4 = 0;
      w2 = 0;
      if (l2 < n2) {
        y4 = H2.get(n2 - 1, n2 - 1);
        w2 = H2.get(n2, n2 - 1) * H2.get(n2 - 1, n2);
      }
      if (iter === 10) {
        exshift += x4;
        for (i2 = low; i2 <= n2; i2++) {
          H2.set(i2, i2, H2.get(i2, i2) - x4);
        }
        s2 = Math.abs(H2.get(n2, n2 - 1)) + Math.abs(H2.get(n2 - 1, n2 - 2));
        x4 = y4 = 0.75 * s2;
        w2 = -0.4375 * s2 * s2;
      }
      if (iter === 30) {
        s2 = (y4 - x4) / 2;
        s2 = s2 * s2 + w2;
        if (s2 > 0) {
          s2 = Math.sqrt(s2);
          if (y4 < x4) {
            s2 = -s2;
          }
          s2 = x4 - w2 / ((y4 - x4) / 2 + s2);
          for (i2 = low; i2 <= n2; i2++) {
            H2.set(i2, i2, H2.get(i2, i2) - s2);
          }
          exshift += s2;
          x4 = y4 = w2 = 0.964;
        }
      }
      iter = iter + 1;
      m3 = n2 - 2;
      while (m3 >= l2) {
        z2 = H2.get(m3, m3);
        r2 = x4 - z2;
        s2 = y4 - z2;
        p2 = (r2 * s2 - w2) / H2.get(m3 + 1, m3) + H2.get(m3, m3 + 1);
        q2 = H2.get(m3 + 1, m3 + 1) - z2 - r2 - s2;
        r2 = H2.get(m3 + 2, m3 + 1);
        s2 = Math.abs(p2) + Math.abs(q2) + Math.abs(r2);
        p2 = p2 / s2;
        q2 = q2 / s2;
        r2 = r2 / s2;
        if (m3 === l2) {
          break;
        }
        if (Math.abs(H2.get(m3, m3 - 1)) * (Math.abs(q2) + Math.abs(r2)) < eps * (Math.abs(p2) * (Math.abs(H2.get(m3 - 1, m3 - 1)) + Math.abs(z2) + Math.abs(H2.get(m3 + 1, m3 + 1))))) {
          break;
        }
        m3--;
      }
      for (i2 = m3 + 2; i2 <= n2; i2++) {
        H2.set(i2, i2 - 2, 0);
        if (i2 > m3 + 2) {
          H2.set(i2, i2 - 3, 0);
        }
      }
      for (k2 = m3; k2 <= n2 - 1; k2++) {
        notlast = k2 !== n2 - 1;
        if (k2 !== m3) {
          p2 = H2.get(k2, k2 - 1);
          q2 = H2.get(k2 + 1, k2 - 1);
          r2 = notlast ? H2.get(k2 + 2, k2 - 1) : 0;
          x4 = Math.abs(p2) + Math.abs(q2) + Math.abs(r2);
          if (x4 !== 0) {
            p2 = p2 / x4;
            q2 = q2 / x4;
            r2 = r2 / x4;
          }
        }
        if (x4 === 0) {
          break;
        }
        s2 = Math.sqrt(p2 * p2 + q2 * q2 + r2 * r2);
        if (p2 < 0) {
          s2 = -s2;
        }
        if (s2 !== 0) {
          if (k2 !== m3) {
            H2.set(k2, k2 - 1, -s2 * x4);
          } else if (l2 !== m3) {
            H2.set(k2, k2 - 1, -H2.get(k2, k2 - 1));
          }
          p2 = p2 + s2;
          x4 = p2 / s2;
          y4 = q2 / s2;
          z2 = r2 / s2;
          q2 = q2 / p2;
          r2 = r2 / p2;
          for (j2 = k2; j2 < nn2; j2++) {
            p2 = H2.get(k2, j2) + q2 * H2.get(k2 + 1, j2);
            if (notlast) {
              p2 = p2 + r2 * H2.get(k2 + 2, j2);
              H2.set(k2 + 2, j2, H2.get(k2 + 2, j2) - p2 * z2);
            }
            H2.set(k2, j2, H2.get(k2, j2) - p2 * x4);
            H2.set(k2 + 1, j2, H2.get(k2 + 1, j2) - p2 * y4);
          }
          for (i2 = 0; i2 <= Math.min(n2, k2 + 3); i2++) {
            p2 = x4 * H2.get(i2, k2) + y4 * H2.get(i2, k2 + 1);
            if (notlast) {
              p2 = p2 + z2 * H2.get(i2, k2 + 2);
              H2.set(i2, k2 + 2, H2.get(i2, k2 + 2) - p2 * r2);
            }
            H2.set(i2, k2, H2.get(i2, k2) - p2);
            H2.set(i2, k2 + 1, H2.get(i2, k2 + 1) - p2 * q2);
          }
          for (i2 = low; i2 <= high; i2++) {
            p2 = x4 * V2.get(i2, k2) + y4 * V2.get(i2, k2 + 1);
            if (notlast) {
              p2 = p2 + z2 * V2.get(i2, k2 + 2);
              V2.set(i2, k2 + 2, V2.get(i2, k2 + 2) - p2 * r2);
            }
            V2.set(i2, k2, V2.get(i2, k2) - p2);
            V2.set(i2, k2 + 1, V2.get(i2, k2 + 1) - p2 * q2);
          }
        }
      }
    }
  }
  if (norm === 0) {
    return;
  }
  for (n2 = nn2 - 1; n2 >= 0; n2--) {
    p2 = d2[n2];
    q2 = e8[n2];
    if (q2 === 0) {
      l2 = n2;
      H2.set(n2, n2, 1);
      for (i2 = n2 - 1; i2 >= 0; i2--) {
        w2 = H2.get(i2, i2) - p2;
        r2 = 0;
        for (j2 = l2; j2 <= n2; j2++) {
          r2 = r2 + H2.get(i2, j2) * H2.get(j2, n2);
        }
        if (e8[i2] < 0) {
          z2 = w2;
          s2 = r2;
        } else {
          l2 = i2;
          if (e8[i2] === 0) {
            H2.set(i2, n2, w2 !== 0 ? -r2 / w2 : -r2 / (eps * norm));
          } else {
            x4 = H2.get(i2, i2 + 1);
            y4 = H2.get(i2 + 1, i2);
            q2 = (d2[i2] - p2) * (d2[i2] - p2) + e8[i2] * e8[i2];
            t2 = (x4 * s2 - z2 * r2) / q2;
            H2.set(i2, n2, t2);
            H2.set(
              i2 + 1,
              n2,
              Math.abs(x4) > Math.abs(z2) ? (-r2 - w2 * t2) / x4 : (-s2 - y4 * t2) / z2
            );
          }
          t2 = Math.abs(H2.get(i2, n2));
          if (eps * t2 * t2 > 1) {
            for (j2 = i2; j2 <= n2; j2++) {
              H2.set(j2, n2, H2.get(j2, n2) / t2);
            }
          }
        }
      }
    } else if (q2 < 0) {
      l2 = n2 - 1;
      if (Math.abs(H2.get(n2, n2 - 1)) > Math.abs(H2.get(n2 - 1, n2))) {
        H2.set(n2 - 1, n2 - 1, q2 / H2.get(n2, n2 - 1));
        H2.set(n2 - 1, n2, -(H2.get(n2, n2) - p2) / H2.get(n2, n2 - 1));
      } else {
        cdivres = cdiv(0, -H2.get(n2 - 1, n2), H2.get(n2 - 1, n2 - 1) - p2, q2);
        H2.set(n2 - 1, n2 - 1, cdivres[0]);
        H2.set(n2 - 1, n2, cdivres[1]);
      }
      H2.set(n2, n2 - 1, 0);
      H2.set(n2, n2, 1);
      for (i2 = n2 - 2; i2 >= 0; i2--) {
        ra2 = 0;
        sa2 = 0;
        for (j2 = l2; j2 <= n2; j2++) {
          ra2 = ra2 + H2.get(i2, j2) * H2.get(j2, n2 - 1);
          sa2 = sa2 + H2.get(i2, j2) * H2.get(j2, n2);
        }
        w2 = H2.get(i2, i2) - p2;
        if (e8[i2] < 0) {
          z2 = w2;
          r2 = ra2;
          s2 = sa2;
        } else {
          l2 = i2;
          if (e8[i2] === 0) {
            cdivres = cdiv(-ra2, -sa2, w2, q2);
            H2.set(i2, n2 - 1, cdivres[0]);
            H2.set(i2, n2, cdivres[1]);
          } else {
            x4 = H2.get(i2, i2 + 1);
            y4 = H2.get(i2 + 1, i2);
            vr2 = (d2[i2] - p2) * (d2[i2] - p2) + e8[i2] * e8[i2] - q2 * q2;
            vi2 = (d2[i2] - p2) * 2 * q2;
            if (vr2 === 0 && vi2 === 0) {
              vr2 = eps * norm * (Math.abs(w2) + Math.abs(q2) + Math.abs(x4) + Math.abs(y4) + Math.abs(z2));
            }
            cdivres = cdiv(
              x4 * r2 - z2 * ra2 + q2 * sa2,
              x4 * s2 - z2 * sa2 - q2 * ra2,
              vr2,
              vi2
            );
            H2.set(i2, n2 - 1, cdivres[0]);
            H2.set(i2, n2, cdivres[1]);
            if (Math.abs(x4) > Math.abs(z2) + Math.abs(q2)) {
              H2.set(
                i2 + 1,
                n2 - 1,
                (-ra2 - w2 * H2.get(i2, n2 - 1) + q2 * H2.get(i2, n2)) / x4
              );
              H2.set(
                i2 + 1,
                n2,
                (-sa2 - w2 * H2.get(i2, n2) - q2 * H2.get(i2, n2 - 1)) / x4
              );
            } else {
              cdivres = cdiv(
                -r2 - y4 * H2.get(i2, n2 - 1),
                -s2 - y4 * H2.get(i2, n2),
                z2,
                q2
              );
              H2.set(i2 + 1, n2 - 1, cdivres[0]);
              H2.set(i2 + 1, n2, cdivres[1]);
            }
          }
          t2 = Math.max(Math.abs(H2.get(i2, n2 - 1)), Math.abs(H2.get(i2, n2)));
          if (eps * t2 * t2 > 1) {
            for (j2 = i2; j2 <= n2; j2++) {
              H2.set(j2, n2 - 1, H2.get(j2, n2 - 1) / t2);
              H2.set(j2, n2, H2.get(j2, n2) / t2);
            }
          }
        }
      }
    }
  }
  for (i2 = 0; i2 < nn2; i2++) {
    if (i2 < low || i2 > high) {
      for (j2 = i2; j2 < nn2; j2++) {
        V2.set(i2, j2, H2.get(i2, j2));
      }
    }
  }
  for (j2 = nn2 - 1; j2 >= low; j2--) {
    for (i2 = low; i2 <= high; i2++) {
      z2 = 0;
      for (k2 = low; k2 <= Math.min(j2, high); k2++) {
        z2 = z2 + V2.get(i2, k2) * H2.get(k2, j2);
      }
      V2.set(i2, j2, z2);
    }
  }
}
function cdiv(xr2, xi2, yr2, yi2) {
  let r2, d2;
  if (Math.abs(yr2) > Math.abs(yi2)) {
    r2 = yi2 / yr2;
    d2 = yr2 + r2 * yi2;
    return [(xr2 + r2 * xi2) / d2, (xi2 - r2 * xr2) / d2];
  } else {
    r2 = yr2 / yi2;
    d2 = yi2 + r2 * yr2;
    return [(r2 * xr2 + xi2) / d2, (r2 * xi2 - xr2) / d2];
  }
}
var EigenvalueDecomposition;
var init_evd = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/evd.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    init_util3();
    EigenvalueDecomposition = class {
      constructor(matrix, options = {}) {
        const { assumeSymmetric = false } = options;
        matrix = WrapperMatrix2D.checkMatrix(matrix);
        if (!matrix.isSquare()) {
          throw new Error("Matrix is not a square matrix");
        }
        let n2 = matrix.columns;
        let V2 = new Matrix(n2, n2);
        let d2 = new Float64Array(n2);
        let e8 = new Float64Array(n2);
        let value = matrix;
        let i2, j2;
        let isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix.isSymmetric();
        }
        if (isSymmetric) {
          for (i2 = 0; i2 < n2; i2++) {
            for (j2 = 0; j2 < n2; j2++) {
              V2.set(i2, j2, value.get(i2, j2));
            }
          }
          tred2(n2, e8, d2, V2);
          tql2(n2, e8, d2, V2);
        } else {
          let H2 = new Matrix(n2, n2);
          let ort = new Float64Array(n2);
          for (j2 = 0; j2 < n2; j2++) {
            for (i2 = 0; i2 < n2; i2++) {
              H2.set(i2, j2, value.get(i2, j2));
            }
          }
          orthes(n2, H2, ort, V2);
          hqr2(n2, e8, d2, V2, H2);
        }
        this.n = n2;
        this.e = e8;
        this.d = d2;
        this.V = V2;
      }
      get realEigenvalues() {
        return Array.from(this.d);
      }
      get imaginaryEigenvalues() {
        return Array.from(this.e);
      }
      get eigenvectorMatrix() {
        return this.V;
      }
      get diagonalMatrix() {
        let n2 = this.n;
        let e8 = this.e;
        let d2 = this.d;
        let X2 = new Matrix(n2, n2);
        let i2, j2;
        for (i2 = 0; i2 < n2; i2++) {
          for (j2 = 0; j2 < n2; j2++) {
            X2.set(i2, j2, 0);
          }
          X2.set(i2, i2, d2[i2]);
          if (e8[i2] > 0) {
            X2.set(i2, i2 + 1, e8[i2]);
          } else if (e8[i2] < 0) {
            X2.set(i2, i2 - 1, e8[i2]);
          }
        }
        return X2;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/cholesky.js
var CholeskyDecomposition;
var init_cholesky = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/cholesky.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    CholeskyDecomposition = class {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error("Matrix is not symmetric");
        }
        let a3 = value;
        let dimension = a3.rows;
        let l2 = new Matrix(dimension, dimension);
        let positiveDefinite = true;
        let i2, j2, k2;
        for (j2 = 0; j2 < dimension; j2++) {
          let d2 = 0;
          for (k2 = 0; k2 < j2; k2++) {
            let s2 = 0;
            for (i2 = 0; i2 < k2; i2++) {
              s2 += l2.get(k2, i2) * l2.get(j2, i2);
            }
            s2 = (a3.get(j2, k2) - s2) / l2.get(k2, k2);
            l2.set(j2, k2, s2);
            d2 = d2 + s2 * s2;
          }
          d2 = a3.get(j2, j2) - d2;
          positiveDefinite &= d2 > 0;
          l2.set(j2, j2, Math.sqrt(Math.max(d2, 0)));
          for (k2 = j2 + 1; k2 < dimension; k2++) {
            l2.set(j2, k2, 0);
          }
        }
        this.L = l2;
        this.positiveDefinite = Boolean(positiveDefinite);
      }
      isPositiveDefinite() {
        return this.positiveDefinite;
      }
      solve(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        let l2 = this.L;
        let dimension = l2.rows;
        if (value.rows !== dimension) {
          throw new Error("Matrix dimensions do not match");
        }
        if (this.isPositiveDefinite() === false) {
          throw new Error("Matrix is not positive definite");
        }
        let count = value.columns;
        let B2 = value.clone();
        let i2, j2, k2;
        for (k2 = 0; k2 < dimension; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            for (i2 = 0; i2 < k2; i2++) {
              B2.set(k2, j2, B2.get(k2, j2) - B2.get(i2, j2) * l2.get(k2, i2));
            }
            B2.set(k2, j2, B2.get(k2, j2) / l2.get(k2, k2));
          }
        }
        for (k2 = dimension - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            for (i2 = k2 + 1; i2 < dimension; i2++) {
              B2.set(k2, j2, B2.get(k2, j2) - B2.get(i2, j2) * l2.get(i2, k2));
            }
            B2.set(k2, j2, B2.get(k2, j2) / l2.get(k2, k2));
          }
        }
        return B2;
      }
      get lowerTriangularMatrix() {
        return this.L;
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/dc/nipals.js
var nipals;
var init_nipals = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/dc/nipals.js"() {
    init_matrix2();
    init_WrapperMatrix2D();
    nipals = class {
      constructor(X2, options = {}) {
        X2 = WrapperMatrix2D.checkMatrix(X2);
        let { Y: Y2 } = options;
        const {
          scaleScores = false,
          maxIterations = 1e3,
          terminationCriteria = 1e-10
        } = options;
        let u2;
        if (Y2) {
          if (Array.isArray(Y2) && typeof Y2[0] === "number") {
            Y2 = Matrix.columnVector(Y2);
          } else {
            Y2 = WrapperMatrix2D.checkMatrix(Y2);
          }
          if (!Y2.isColumnVector() || Y2.rows !== X2.rows) {
            throw new Error("Y must be a column vector of length X.rows");
          }
          u2 = Y2;
        } else {
          u2 = X2.getColumnVector(0);
        }
        let diff = 1;
        let t2, q2, w2, tOld;
        for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
          w2 = X2.transpose().mmul(u2).div(u2.transpose().mmul(u2).get(0, 0));
          w2 = w2.div(w2.norm());
          t2 = X2.mmul(w2).div(w2.transpose().mmul(w2).get(0, 0));
          if (counter > 0) {
            diff = t2.clone().sub(tOld).pow(2).sum();
          }
          tOld = t2.clone();
          if (Y2) {
            q2 = Y2.transpose().mmul(t2).div(t2.transpose().mmul(t2).get(0, 0));
            q2 = q2.div(q2.norm());
            u2 = Y2.mmul(q2).div(q2.transpose().mmul(q2).get(0, 0));
          } else {
            u2 = t2;
          }
        }
        if (Y2) {
          let p2 = X2.transpose().mmul(t2).div(t2.transpose().mmul(t2).get(0, 0));
          p2 = p2.div(p2.norm());
          let xResidual = X2.clone().sub(t2.clone().mmul(p2.transpose()));
          let residual = u2.transpose().mmul(t2).div(t2.transpose().mmul(t2).get(0, 0));
          let yResidual = Y2.clone().sub(
            t2.clone().mulS(residual.get(0, 0)).mmul(q2.transpose())
          );
          this.t = t2;
          this.p = p2.transpose();
          this.w = w2.transpose();
          this.q = q2;
          this.u = u2;
          this.s = t2.transpose().mmul(t2);
          this.xResidual = xResidual;
          this.yResidual = yResidual;
          this.betas = residual;
        } else {
          this.w = w2.transpose();
          this.s = t2.transpose().mmul(t2).sqrt();
          if (scaleScores) {
            this.t = t2.clone().div(this.s.get(0, 0));
          } else {
            this.t = t2;
          }
          this.xResidual = X2.sub(t2.mmul(w2.transpose()));
        }
      }
    };
  }
});

// node_modules/@antv/layout/node_modules/ml-matrix/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  AbstractMatrix: () => AbstractMatrix,
  CHO: () => CholeskyDecomposition,
  CholeskyDecomposition: () => CholeskyDecomposition,
  EVD: () => EigenvalueDecomposition,
  EigenvalueDecomposition: () => EigenvalueDecomposition,
  LU: () => LuDecomposition,
  LuDecomposition: () => LuDecomposition,
  Matrix: () => Matrix,
  MatrixColumnSelectionView: () => MatrixColumnSelectionView,
  MatrixColumnView: () => MatrixColumnView,
  MatrixFlipColumnView: () => MatrixFlipColumnView,
  MatrixFlipRowView: () => MatrixFlipRowView,
  MatrixRowSelectionView: () => MatrixRowSelectionView,
  MatrixRowView: () => MatrixRowView,
  MatrixSelectionView: () => MatrixSelectionView,
  MatrixSubView: () => MatrixSubView,
  MatrixTransposeView: () => MatrixTransposeView,
  NIPALS: () => nipals,
  Nipals: () => nipals,
  QR: () => QrDecomposition,
  QrDecomposition: () => QrDecomposition,
  SVD: () => SingularValueDecomposition,
  SingularValueDecomposition: () => SingularValueDecomposition,
  WrapperMatrix1D: () => WrapperMatrix1D,
  WrapperMatrix2D: () => WrapperMatrix2D,
  correlation: () => correlation,
  covariance: () => covariance,
  default: () => Matrix,
  determinant: () => determinant,
  inverse: () => inverse,
  linearDependencies: () => linearDependencies,
  pseudoInverse: () => pseudoInverse,
  solve: () => solve,
  wrap: () => wrap
});
var init_src5 = __esm({
  "node_modules/@antv/layout/node_modules/ml-matrix/src/index.js"() {
    init_matrix2();
    init_views();
    init_wrap();
    init_WrapperMatrix1D();
    init_WrapperMatrix2D();
    init_decompositions();
    init_determinant();
    init_linearDependencies();
    init_pseudoInverse();
    init_covariance();
    init_correlation();
    init_svd();
    init_evd();
    init_cholesky();
    init_lu();
    init_qr();
    init_nipals();
  }
});

// node_modules/@antv/layout/lib/layout/radial/mds.js
var require_mds = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/mds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ml_matrix_1 = (init_src5(), __toCommonJS(src_exports3));
    var MDS = (
      /** @class */
      function() {
        function MDS2(params) {
          this.distances = params.distances;
          this.dimension = params.dimension || 2;
          this.linkDistance = params.linkDistance;
        }
        MDS2.prototype.layout = function() {
          var self2 = this;
          var dimension = self2.dimension, distances = self2.distances, linkDistance = self2.linkDistance;
          try {
            var M2 = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);
            var rowMeans = M2.mean("row");
            var colMeans = M2.mean("column");
            var totalMean = M2.mean();
            M2.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
            var ret = new ml_matrix_1.SingularValueDecomposition(M2);
            var eigenValues_1 = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();
            return ret.leftSingularVectors.toJSON().map(function(row) {
              return ml_matrix_1.Matrix.mul([row], [eigenValues_1]).toJSON()[0].splice(0, dimension);
            });
          } catch (_a2) {
            var res = [];
            for (var i2 = 0; i2 < distances.length; i2++) {
              var x4 = Math.random() * linkDistance;
              var y4 = Math.random() * linkDistance;
              res.push([x4, y4]);
            }
            return res;
          }
        };
        return MDS2;
      }()
    );
    exports.default = MDS;
  }
});

// node_modules/@antv/layout/lib/layout/radial/radialNonoverlapForce.js
var require_radialNonoverlapForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/radialNonoverlapForce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SPEED_DIVISOR = 800;
    var RadialNonoverlapForce = (
      /** @class */
      function() {
        function RadialNonoverlapForce2(params) {
          this.disp = [];
          this.positions = params.positions;
          this.adjMatrix = params.adjMatrix;
          this.focusID = params.focusID;
          this.radii = params.radii;
          this.iterations = params.iterations || 10;
          this.height = params.height || 10;
          this.width = params.width || 10;
          this.speed = params.speed || 100;
          this.gravity = params.gravity || 10;
          this.nodeSizeFunc = params.nodeSizeFunc;
          this.k = params.k || 5;
          this.strictRadial = params.strictRadial;
          this.nodes = params.nodes;
        }
        RadialNonoverlapForce2.prototype.layout = function() {
          var self2 = this;
          var positions = self2.positions;
          var disp = [];
          var iterations = self2.iterations;
          var maxDisplace = self2.width / 10;
          self2.maxDisplace = maxDisplace;
          self2.disp = disp;
          for (var i2 = 0; i2 < iterations; i2++) {
            positions.forEach(function(_2, k2) {
              disp[k2] = { x: 0, y: 0 };
            });
            self2.getRepulsion();
            self2.updatePositions();
          }
          return positions;
        };
        RadialNonoverlapForce2.prototype.getRepulsion = function() {
          var self2 = this;
          var positions = self2.positions;
          var nodes = self2.nodes;
          var disp = self2.disp;
          var k2 = self2.k;
          var radii = self2.radii || [];
          positions.forEach(function(v2, i2) {
            disp[i2] = { x: 0, y: 0 };
            positions.forEach(function(u2, j2) {
              if (i2 === j2) {
                return;
              }
              if (radii[i2] !== radii[j2]) {
                return;
              }
              var vecx = v2[0] - u2[0];
              var vecy = v2[1] - u2[1];
              var vecLength = Math.sqrt(vecx * vecx + vecy * vecy);
              if (vecLength === 0) {
                vecLength = 1;
                var sign = i2 > j2 ? 1 : -1;
                vecx = 0.01 * sign;
                vecy = 0.01 * sign;
              }
              if (vecLength < self2.nodeSizeFunc(nodes[i2]) / 2 + self2.nodeSizeFunc(nodes[j2]) / 2) {
                var common = k2 * k2 / vecLength;
                disp[i2].x += vecx / vecLength * common;
                disp[i2].y += vecy / vecLength * common;
              }
            });
          });
        };
        RadialNonoverlapForce2.prototype.updatePositions = function() {
          var self2 = this;
          var positions = self2.positions;
          var disp = self2.disp;
          var speed = self2.speed;
          var strictRadial = self2.strictRadial;
          var f2 = self2.focusID;
          var maxDisplace = self2.maxDisplace || self2.width / 10;
          if (strictRadial) {
            disp.forEach(function(di2, i2) {
              var vx = positions[i2][0] - positions[f2][0];
              var vy = positions[i2][1] - positions[f2][1];
              var vLength = Math.sqrt(vx * vx + vy * vy);
              var vpx = vy / vLength;
              var vpy = -vx / vLength;
              var diLength = Math.sqrt(di2.x * di2.x + di2.y * di2.y);
              var alpha = Math.acos((vpx * di2.x + vpy * di2.y) / diLength);
              if (alpha > Math.PI / 2) {
                alpha -= Math.PI / 2;
                vpx *= -1;
                vpy *= -1;
              }
              var tdispLength = Math.cos(alpha) * diLength;
              di2.x = vpx * tdispLength;
              di2.y = vpy * tdispLength;
            });
          }
          var radii = self2.radii;
          positions.forEach(function(n2, i2) {
            if (i2 === f2) {
              return;
            }
            var distLength = Math.sqrt(disp[i2].x * disp[i2].x + disp[i2].y * disp[i2].y);
            if (distLength > 0 && i2 !== f2) {
              var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
              n2[0] += disp[i2].x / distLength * limitedDist;
              n2[1] += disp[i2].y / distLength * limitedDist;
              if (strictRadial) {
                var vx = n2[0] - positions[f2][0];
                var vy = n2[1] - positions[f2][1];
                var nfDis = Math.sqrt(vx * vx + vy * vy);
                vx = vx / nfDis * radii[i2];
                vy = vy / nfDis * radii[i2];
                n2[0] = positions[f2][0] + vx;
                n2[1] = positions[f2][1] + vy;
              }
            }
          });
        };
        return RadialNonoverlapForce2;
      }()
    );
    exports.default = RadialNonoverlapForce;
  }
});

// node_modules/@antv/layout/lib/layout/radial/radial.js
var require_radial = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/radial.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RadialLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var mds_1 = __importDefault(require_mds());
    var radialNonoverlapForce_1 = __importDefault(require_radialNonoverlapForce());
    function getWeightMatrix(M2) {
      var rows = M2.length;
      var cols = M2[0].length;
      var result = [];
      for (var i2 = 0; i2 < rows; i2++) {
        var row = [];
        for (var j2 = 0; j2 < cols; j2++) {
          if (M2[i2][j2] !== 0) {
            row.push(1 / (M2[i2][j2] * M2[i2][j2]));
          } else {
            row.push(0);
          }
        }
        result.push(row);
      }
      return result;
    }
    function getIndexById(array, id) {
      var index2 = -1;
      array.forEach(function(a3, i2) {
        if (a3.id === id) {
          index2 = i2;
        }
      });
      return index2;
    }
    function getEDistance(p1, p2) {
      return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));
    }
    var RadialLayout2 = (
      /** @class */
      function(_super) {
        __extends15(RadialLayout3, _super);
        function RadialLayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.focusNode = null;
          _this.unitRadius = null;
          _this.linkDistance = 50;
          _this.preventOverlap = false;
          _this.strictRadial = true;
          _this.maxPreventOverlapIteration = 200;
          _this.sortStrength = 10;
          _this.nodes = [];
          _this.edges = [];
          _this.updateCfg(options);
          return _this;
        }
        RadialLayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 1e3,
            focusNode: null,
            unitRadius: null,
            linkDistance: 50,
            preventOverlap: false,
            nodeSize: void 0,
            nodeSpacing: void 0,
            strictRadial: true,
            maxPreventOverlapIteration: 200,
            sortBy: void 0,
            sortStrength: 10
          };
        };
        RadialLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var edges = self2.edges || [];
          if (!nodes || nodes.length === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          var linkDistance = self2.linkDistance;
          var focusNode = null;
          if ((0, util_1.isString)(self2.focusNode)) {
            var found = false;
            for (var i2 = 0; i2 < nodes.length; i2++) {
              if (nodes[i2].id === self2.focusNode) {
                focusNode = nodes[i2];
                self2.focusNode = focusNode;
                found = true;
                i2 = nodes.length;
              }
            }
            if (!found) {
              focusNode = null;
            }
          } else {
            focusNode = self2.focusNode;
          }
          if (!focusNode) {
            focusNode = nodes[0];
            self2.focusNode = focusNode;
          }
          var focusIndex = getIndexById(nodes, focusNode.id);
          if (focusIndex < 0)
            focusIndex = 0;
          self2.focusIndex = focusIndex;
          var adjMatrix3 = (0, util_1.getAdjMatrix)({ nodes, edges }, false);
          var D2 = (0, util_1.floydWarshall)(adjMatrix3);
          var maxDistance = self2.maxToFocus(D2, focusIndex);
          self2.handleInfinity(D2, focusIndex, maxDistance + 1);
          self2.distances = D2;
          var focusNodeD = D2[focusIndex];
          var width = self2.width || 500;
          var height = self2.height || 500;
          var semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];
          var semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];
          if (semiWidth === 0) {
            semiWidth = width / 2;
          }
          if (semiHeight === 0) {
            semiHeight = height / 2;
          }
          var maxRadius = semiHeight > semiWidth ? semiWidth : semiHeight;
          var maxD = Math.max.apply(Math, focusNodeD);
          var radii = [];
          focusNodeD.forEach(function(value, i3) {
            if (!self2.unitRadius) {
              self2.unitRadius = maxRadius / maxD;
            }
            radii[i3] = value * self2.unitRadius;
          });
          self2.radii = radii;
          var eIdealD = self2.eIdealDisMatrix();
          self2.eIdealDistances = eIdealD;
          var W2 = getWeightMatrix(eIdealD);
          self2.weights = W2;
          var mds = new mds_1.default({ linkDistance, distances: eIdealD });
          var positions = mds.layout();
          positions.forEach(function(p2) {
            if ((0, util_1.isNaN)(p2[0])) {
              p2[0] = Math.random() * linkDistance;
            }
            if ((0, util_1.isNaN)(p2[1])) {
              p2[1] = Math.random() * linkDistance;
            }
          });
          self2.positions = positions;
          positions.forEach(function(p2, i3) {
            nodes[i3].x = p2[0] + center[0];
            nodes[i3].y = p2[1] + center[1];
          });
          positions.forEach(function(p2) {
            p2[0] -= positions[focusIndex][0];
            p2[1] -= positions[focusIndex][1];
          });
          self2.run();
          var preventOverlap = self2.preventOverlap;
          var nodeSize = self2.nodeSize;
          var nodeSizeFunc;
          var strictRadial = self2.strictRadial;
          if (preventOverlap) {
            var nodeSpacing_1 = self2.nodeSpacing;
            var nodeSpacingFunc_1;
            if ((0, util_1.isNumber)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = function() {
                return nodeSpacing_1;
              };
            } else if ((0, util_1.isFunction)(nodeSpacing_1)) {
              nodeSpacingFunc_1 = nodeSpacing_1;
            } else {
              nodeSpacingFunc_1 = function() {
                return 0;
              };
            }
            if (!nodeSize) {
              nodeSizeFunc = function(d2) {
                if (d2.size) {
                  if ((0, util_1.isArray)(d2.size)) {
                    var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                    return res + nodeSpacingFunc_1(d2);
                  }
                  if ((0, util_1.isObject)(d2.size)) {
                    var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                    return res + nodeSpacingFunc_1(d2);
                  }
                  return d2.size + nodeSpacingFunc_1(d2);
                }
                return 10 + nodeSpacingFunc_1(d2);
              };
            } else if ((0, util_1.isArray)(nodeSize)) {
              nodeSizeFunc = function(d2) {
                var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
                return res + nodeSpacingFunc_1(d2);
              };
            } else {
              nodeSizeFunc = function(d2) {
                return nodeSize + nodeSpacingFunc_1(d2);
              };
            }
            var nonoverlapForceParams = {
              nodes,
              nodeSizeFunc,
              adjMatrix: adjMatrix3,
              positions,
              radii,
              height,
              width,
              strictRadial,
              focusID: focusIndex,
              iterations: self2.maxPreventOverlapIteration || 200,
              k: positions.length / 4.5
            };
            var nonoverlapForce = new radialNonoverlapForce_1.default(nonoverlapForceParams);
            positions = nonoverlapForce.layout();
          }
          positions.forEach(function(p2, i3) {
            nodes[i3].x = p2[0] + center[0];
            nodes[i3].y = p2[1] + center[1];
          });
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        RadialLayout3.prototype.run = function() {
          var self2 = this;
          var maxIteration = self2.maxIteration;
          var positions = self2.positions || [];
          var W2 = self2.weights || [];
          var eIdealDis = self2.eIdealDistances || [];
          var radii = self2.radii || [];
          for (var i2 = 0; i2 <= maxIteration; i2++) {
            var param = i2 / maxIteration;
            self2.oneIteration(param, positions, radii, eIdealDis, W2);
          }
        };
        RadialLayout3.prototype.oneIteration = function(param, positions, radii, D2, W2) {
          var self2 = this;
          var vparam = 1 - param;
          var focusIndex = self2.focusIndex;
          positions.forEach(function(v2, i2) {
            var originDis = getEDistance(v2, [0, 0]);
            var reciODis = originDis === 0 ? 0 : 1 / originDis;
            if (i2 === focusIndex) {
              return;
            }
            var xMolecule = 0;
            var yMolecule = 0;
            var denominator = 0;
            positions.forEach(function(u2, j2) {
              if (i2 === j2) {
                return;
              }
              var edis = getEDistance(v2, u2);
              var reciEdis = edis === 0 ? 0 : 1 / edis;
              var idealDis = D2[j2][i2];
              denominator += W2[i2][j2];
              xMolecule += W2[i2][j2] * (u2[0] + idealDis * (v2[0] - u2[0]) * reciEdis);
              yMolecule += W2[i2][j2] * (u2[1] + idealDis * (v2[1] - u2[1]) * reciEdis);
            });
            var reciR = radii[i2] === 0 ? 0 : 1 / radii[i2];
            denominator *= vparam;
            denominator += param * reciR * reciR;
            xMolecule *= vparam;
            xMolecule += param * reciR * v2[0] * reciODis;
            v2[0] = xMolecule / denominator;
            yMolecule *= vparam;
            yMolecule += param * reciR * v2[1] * reciODis;
            v2[1] = yMolecule / denominator;
          });
        };
        RadialLayout3.prototype.eIdealDisMatrix = function() {
          var self2 = this;
          var nodes = self2.nodes;
          if (!nodes)
            return [];
          var D2 = self2.distances;
          var linkDis = self2.linkDistance;
          var radii = self2.radii || [];
          var unitRadius = self2.unitRadius || 50;
          var result = [];
          if (D2) {
            D2.forEach(function(row, i2) {
              var newRow = [];
              row.forEach(function(v2, j2) {
                if (i2 === j2) {
                  newRow.push(0);
                } else if (radii[i2] === radii[j2]) {
                  if (self2.sortBy === "data") {
                    newRow.push(v2 * (Math.abs(i2 - j2) * self2.sortStrength) / (radii[i2] / unitRadius));
                  } else if (self2.sortBy) {
                    var iValue = nodes[i2][self2.sortBy] || 0;
                    var jValue = nodes[j2][self2.sortBy] || 0;
                    if ((0, util_1.isString)(iValue)) {
                      iValue = iValue.charCodeAt(0);
                    }
                    if ((0, util_1.isString)(jValue)) {
                      jValue = jValue.charCodeAt(0);
                    }
                    newRow.push(v2 * (Math.abs(iValue - jValue) * self2.sortStrength) / (radii[i2] / unitRadius));
                  } else {
                    newRow.push(v2 * linkDis / (radii[i2] / unitRadius));
                  }
                } else {
                  var link = (linkDis + unitRadius) / 2;
                  newRow.push(v2 * link);
                }
              });
              result.push(newRow);
            });
          }
          return result;
        };
        RadialLayout3.prototype.handleInfinity = function(matrix, focusIndex, step) {
          var length = matrix.length;
          for (var i2 = 0; i2 < length; i2++) {
            if (matrix[focusIndex][i2] === Infinity) {
              matrix[focusIndex][i2] = step;
              matrix[i2][focusIndex] = step;
              for (var j2 = 0; j2 < length; j2++) {
                if (matrix[i2][j2] !== Infinity && matrix[focusIndex][j2] === Infinity) {
                  matrix[focusIndex][j2] = step + matrix[i2][j2];
                  matrix[j2][focusIndex] = step + matrix[i2][j2];
                }
              }
            }
          }
          for (var i2 = 0; i2 < length; i2++) {
            if (i2 === focusIndex) {
              continue;
            }
            for (var j2 = 0; j2 < length; j2++) {
              if (matrix[i2][j2] === Infinity) {
                var minus = Math.abs(matrix[focusIndex][i2] - matrix[focusIndex][j2]);
                minus = minus === 0 ? 1 : minus;
                matrix[i2][j2] = minus;
              }
            }
          }
        };
        RadialLayout3.prototype.maxToFocus = function(matrix, focusIndex) {
          var max4 = 0;
          for (var i2 = 0; i2 < matrix[focusIndex].length; i2++) {
            if (matrix[focusIndex][i2] === Infinity) {
              continue;
            }
            max4 = matrix[focusIndex][i2] > max4 ? matrix[focusIndex][i2] : max4;
          }
          return max4;
        };
        RadialLayout3.prototype.getType = function() {
          return "radial";
        };
        return RadialLayout3;
      }(base_1.Base)
    );
    exports.RadialLayout = RadialLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/radial/index.js
var require_radial2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_radial(), exports);
  }
});

// node_modules/@antv/layout/lib/layout/concentric.js
var require_concentric = __commonJS({
  "node_modules/@antv/layout/lib/layout/concentric.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConcentricLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var ConcentricLayout2 = (
      /** @class */
      function(_super) {
        __extends15(ConcentricLayout3, _super);
        function ConcentricLayout3(options) {
          var _this = _super.call(this) || this;
          _this.nodeSize = 30;
          _this.minNodeSpacing = 10;
          _this.nodeSpacing = 10;
          _this.preventOverlap = false;
          _this.equidistant = false;
          _this.startAngle = 3 / 2 * Math.PI;
          _this.clockwise = true;
          _this.sortBy = "degree";
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        ConcentricLayout3.prototype.getDefaultCfg = function() {
          return {
            nodeSize: 30,
            minNodeSpacing: 10,
            nodeSpacing: 10,
            preventOverlap: false,
            sweep: void 0,
            equidistant: false,
            startAngle: 3 / 2 * Math.PI,
            clockwise: true,
            maxLevelDiff: void 0,
            sortBy: "degree"
          };
        };
        ConcentricLayout3.prototype.execute = function() {
          var _a2, _b;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges;
          var n2 = nodes.length;
          if (n2 === 0) {
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (n2 === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
            return;
          }
          var nodeSize = self2.nodeSize, nodeSpacing = self2.nodeSpacing;
          var layoutNodes = [];
          var maxNodeSize;
          var maxNodeSpacing = 0;
          if ((0, util_1.isArray)(nodeSize)) {
            maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
          } else {
            maxNodeSize = nodeSize;
          }
          if ((0, util_1.isArray)(nodeSpacing)) {
            maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);
          } else if ((0, util_1.isNumber)(nodeSpacing)) {
            maxNodeSpacing = nodeSpacing;
          }
          nodes.forEach(function(node) {
            layoutNodes.push(node);
            var nodeSize2 = maxNodeSize;
            if ((0, util_1.isArray)(node.size)) {
              nodeSize2 = Math.max(node.size[0], node.size[1]);
            } else if ((0, util_1.isNumber)(node.size)) {
              nodeSize2 = node.size;
            } else if ((0, util_1.isObject)(node.size)) {
              nodeSize2 = Math.max(node.size.width, node.size.height);
            }
            maxNodeSize = Math.max(maxNodeSize, nodeSize2);
            if ((0, util_1.isFunction)(nodeSpacing)) {
              maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);
            }
          });
          self2.clockwise = self2.counterclockwise !== void 0 ? !self2.counterclockwise : self2.clockwise;
          var nodeMap = {};
          var indexMap = {};
          layoutNodes.forEach(function(node, i3) {
            nodeMap[node.id] = node;
            indexMap[node.id] = i3;
          });
          if (self2.sortBy === "degree" || !(0, util_1.isString)(self2.sortBy) || layoutNodes[0][self2.sortBy] === void 0) {
            self2.sortBy = "degree";
            if (!(0, util_1.isNumber)(nodes[0].degree)) {
              var values_1 = (0, util_1.getDegree)(nodes.length, indexMap, edges);
              layoutNodes.forEach(function(node, i3) {
                node.degree = values_1[i3].all;
              });
            }
          }
          layoutNodes.sort(function(n1, n22) {
            return n22[self2.sortBy] - n1[self2.sortBy];
          });
          self2.maxValueNode = layoutNodes[0];
          self2.maxLevelDiff = self2.maxLevelDiff || self2.maxValueNode[self2.sortBy] / 4;
          var levels = [[]];
          var currentLevel = levels[0];
          layoutNodes.forEach(function(node) {
            if (currentLevel.length > 0) {
              var diff = Math.abs(currentLevel[0][self2.sortBy] - node[self2.sortBy]);
              if (self2.maxLevelDiff && diff >= self2.maxLevelDiff) {
                currentLevel = [];
                levels.push(currentLevel);
              }
            }
            currentLevel.push(node);
          });
          var minDist = maxNodeSize + (maxNodeSpacing || self2.minNodeSpacing);
          if (!self2.preventOverlap) {
            var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
            var maxR = Math.min(self2.width, self2.height) / 2 - minDist;
            var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
            minDist = Math.min(minDist, rStep);
          }
          var r2 = 0;
          levels.forEach(function(level2) {
            var sweep = self2.sweep;
            if (sweep === void 0) {
              sweep = 2 * Math.PI - 2 * Math.PI / level2.length;
            }
            var dTheta = level2.dTheta = sweep / Math.max(1, level2.length - 1);
            if (level2.length > 1 && self2.preventOverlap) {
              var dcos = Math.cos(dTheta) - Math.cos(0);
              var dsin = Math.sin(dTheta) - Math.sin(0);
              var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin));
              r2 = Math.max(rMin, r2);
            }
            level2.r = r2;
            r2 += minDist;
          });
          if (self2.equidistant) {
            var rDeltaMax_1 = 0;
            var rr_1 = 0;
            for (var i2 = 0; i2 < levels.length; i2++) {
              var level = levels[i2];
              var rDelta = level.r - rr_1;
              rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);
            }
            rr_1 = 0;
            levels.forEach(function(level2, i3) {
              if (i3 === 0) {
                rr_1 = level2.r;
              }
              level2.r = rr_1;
              rr_1 += rDeltaMax_1;
            });
          }
          levels.forEach(function(level2) {
            var dTheta = level2.dTheta;
            var rr2 = level2.r;
            level2.forEach(function(node, j2) {
              var theta = self2.startAngle + (self2.clockwise ? 1 : -1) * dTheta * j2;
              node.x = center[0] + rr2 * Math.cos(theta);
              node.y = center[1] + rr2 * Math.sin(theta);
            });
          });
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        ConcentricLayout3.prototype.getType = function() {
          return "concentric";
        };
        return ConcentricLayout3;
      }(base_1.Base)
    );
    exports.ConcentricLayout = ConcentricLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/mds.js
var require_mds2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/mds.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MDSLayout = void 0;
    var ml_matrix_1 = (init_src5(), __toCommonJS(src_exports3));
    var util_1 = require_util2();
    var base_1 = require_base();
    var MDSLayout2 = (
      /** @class */
      function(_super) {
        __extends15(MDSLayout3, _super);
        function MDSLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.linkDistance = 50;
          _this.nodes = [];
          _this.edges = [];
          _this.onLayoutEnd = function() {
          };
          _this.updateCfg(options);
          return _this;
        }
        MDSLayout3.prototype.getDefaultCfg = function() {
          return {
            center: [0, 0],
            linkDistance: 50
          };
        };
        MDSLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes, _a2 = self2.edges, edges = _a2 === void 0 ? [] : _a2;
          var center = self2.center;
          if (!nodes || nodes.length === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          var linkDistance = self2.linkDistance;
          var adjMatrix3 = (0, util_1.getAdjMatrix)({ nodes, edges }, false);
          var distances = (0, util_1.floydWarshall)(adjMatrix3);
          self2.handleInfinity(distances);
          var scaledD = (0, util_1.scaleMatrix)(distances, linkDistance);
          self2.scaledDistances = scaledD;
          var positions = self2.runMDS();
          self2.positions = positions;
          positions.forEach(function(p2, i2) {
            nodes[i2].x = p2[0] + center[0];
            nodes[i2].y = p2[1] + center[1];
          });
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        };
        MDSLayout3.prototype.runMDS = function() {
          var self2 = this;
          var dimension = 2;
          var distances = self2.scaledDistances;
          var M2 = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);
          var rowMeans = M2.mean("row");
          var colMeans = M2.mean("column");
          var totalMean = M2.mean();
          M2.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
          var ret = new ml_matrix_1.SingularValueDecomposition(M2);
          var eigenValues = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();
          return ret.leftSingularVectors.toJSON().map(function(row) {
            return ml_matrix_1.Matrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);
          });
        };
        MDSLayout3.prototype.handleInfinity = function(distances) {
          var maxDistance = -999999;
          distances.forEach(function(row) {
            row.forEach(function(value) {
              if (value === Infinity) {
                return;
              }
              if (maxDistance < value) {
                maxDistance = value;
              }
            });
          });
          distances.forEach(function(row, i2) {
            row.forEach(function(value, j2) {
              if (value === Infinity) {
                distances[i2][j2] = maxDistance;
              }
            });
          });
        };
        MDSLayout3.prototype.getType = function() {
          return "mds";
        };
        return MDSLayout3;
      }(base_1.Base)
    );
    exports.MDSLayout = MDSLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/fruchterman.js
var require_fruchterman = __commonJS({
  "node_modules/@antv/layout/lib/layout/fruchterman.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FruchtermanLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var SPEED_DIVISOR = 800;
    var FruchtermanLayout2 = (
      /** @class */
      function(_super) {
        __extends15(FruchtermanLayout3, _super);
        function FruchtermanLayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.workerEnabled = false;
          _this.gravity = 10;
          _this.speed = 5;
          _this.clustering = false;
          _this.clusterGravity = 10;
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.onLayoutEnd = function() {
          };
          _this.tick = function() {
          };
          _this.animate = true;
          _this.updateCfg(options);
          return _this;
        }
        FruchtermanLayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 1e3,
            gravity: 10,
            speed: 1,
            clustering: false,
            clusterGravity: 10,
            animate: true
          };
        };
        FruchtermanLayout3.prototype.execute = function() {
          var _this = this;
          var _a2, _b;
          var self2 = this;
          var nodes = self2.nodes;
          if (self2.timeInterval !== void 0 && typeof window !== "undefined") {
            window.clearInterval(self2.timeInterval);
          }
          if (!nodes || nodes.length === 0) {
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
            return;
          }
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          if (!self2.center) {
            self2.center = [self2.width / 2, self2.height / 2];
          }
          var center = self2.center;
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
            return;
          }
          var nodeMap = {};
          var nodeIdxMap = {};
          nodes.forEach(function(node, i2) {
            if (!(0, util_1.isNumber)(node.x))
              node.x = Math.random() * _this.width;
            if (!(0, util_1.isNumber)(node.y))
              node.y = Math.random() * _this.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i2;
          });
          self2.nodeMap = nodeMap;
          self2.nodeIdxMap = nodeIdxMap;
          return self2.run();
        };
        FruchtermanLayout3.prototype.run = function() {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes;
          if (!nodes)
            return;
          var edges = self2.edges, maxIteration = self2.maxIteration, workerEnabled = self2.workerEnabled, clustering = self2.clustering, animate = self2.animate;
          var clusterMap = {};
          if (clustering) {
            nodes.forEach(function(n2) {
              if (clusterMap[n2.cluster] === void 0) {
                clusterMap[n2.cluster] = {
                  name: n2.cluster,
                  cx: 0,
                  cy: 0,
                  count: 0
                };
              }
            });
          }
          if (workerEnabled || !animate) {
            for (var i2 = 0; i2 < maxIteration; i2++) {
              self2.runOneStep(clusterMap);
            }
            (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          } else {
            if (typeof window === "undefined")
              return;
            var iter_1 = 0;
            this.timeInterval = window.setInterval(function() {
              var _a3;
              self2.runOneStep(clusterMap);
              iter_1++;
              if (iter_1 >= maxIteration) {
                (_a3 = self2.onLayoutEnd) === null || _a3 === void 0 ? void 0 : _a3.call(self2);
                window.clearInterval(self2.timeInterval);
              }
            }, 0);
          }
          return {
            nodes,
            edges
          };
        };
        FruchtermanLayout3.prototype.runOneStep = function(clusterMap) {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes;
          if (!nodes)
            return;
          var edges = self2.edges, center = self2.center, gravity = self2.gravity, speed = self2.speed, clustering = self2.clustering;
          var area = self2.height * self2.width;
          var maxDisplace = Math.sqrt(area) / 10;
          var k2 = area / (nodes.length + 1);
          var k3 = Math.sqrt(k2);
          var displacements = [];
          nodes.forEach(function(_2, j2) {
            displacements[j2] = { x: 0, y: 0 };
          });
          self2.applyCalculate(nodes, edges, displacements, k3, k2);
          if (clustering) {
            for (var key in clusterMap) {
              clusterMap[key].cx = 0;
              clusterMap[key].cy = 0;
              clusterMap[key].count = 0;
            }
            nodes.forEach(function(n2) {
              var c3 = clusterMap[n2.cluster];
              if ((0, util_1.isNumber)(n2.x)) {
                c3.cx += n2.x;
              }
              if ((0, util_1.isNumber)(n2.y)) {
                c3.cy += n2.y;
              }
              c3.count++;
            });
            for (var key in clusterMap) {
              clusterMap[key].cx /= clusterMap[key].count;
              clusterMap[key].cy /= clusterMap[key].count;
            }
            var clusterGravity_1 = self2.clusterGravity || gravity;
            nodes.forEach(function(n2, j2) {
              if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
                return;
              var c3 = clusterMap[n2.cluster];
              var distLength = Math.sqrt((n2.x - c3.cx) * (n2.x - c3.cx) + (n2.y - c3.cy) * (n2.y - c3.cy));
              var gravityForce = k3 * clusterGravity_1;
              displacements[j2].x -= gravityForce * (n2.x - c3.cx) / distLength;
              displacements[j2].y -= gravityForce * (n2.y - c3.cy) / distLength;
            });
          }
          nodes.forEach(function(n2, j2) {
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            var gravityForce = 0.01 * k3 * gravity;
            displacements[j2].x -= gravityForce * (n2.x - center[0]);
            displacements[j2].y -= gravityForce * (n2.y - center[1]);
          });
          nodes.forEach(function(n2, j2) {
            if ((0, util_1.isNumber)(n2.fx) && (0, util_1.isNumber)(n2.fy)) {
              n2.x = n2.fx;
              n2.y = n2.fy;
              return;
            }
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            var distLength = Math.sqrt(displacements[j2].x * displacements[j2].x + displacements[j2].y * displacements[j2].y);
            if (distLength > 0) {
              var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
              n2.x += displacements[j2].x / distLength * limitedDist;
              n2.y += displacements[j2].y / distLength * limitedDist;
            }
          });
          (_a2 = self2.tick) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
        };
        FruchtermanLayout3.prototype.applyCalculate = function(nodes, edges, displacements, k2, k22) {
          var self2 = this;
          self2.calRepulsive(nodes, displacements, k22);
          if (edges)
            self2.calAttractive(edges, displacements, k2);
        };
        FruchtermanLayout3.prototype.calRepulsive = function(nodes, displacements, k2) {
          nodes.forEach(function(v2, i2) {
            displacements[i2] = { x: 0, y: 0 };
            nodes.forEach(function(u2, j2) {
              if (i2 === j2) {
                return;
              }
              if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
                return;
              }
              var vecX = v2.x - u2.x;
              var vecY = v2.y - u2.y;
              var vecLengthSqr = vecX * vecX + vecY * vecY;
              if (vecLengthSqr === 0) {
                vecLengthSqr = 1;
                var sign = i2 > j2 ? 1 : -1;
                vecX = 0.01 * sign;
                vecY = 0.01 * sign;
              }
              var common = k2 / vecLengthSqr;
              displacements[i2].x += vecX * common;
              displacements[i2].y += vecY * common;
            });
          });
        };
        FruchtermanLayout3.prototype.calAttractive = function(edges, displacements, k2) {
          var _this = this;
          edges.forEach(function(e8) {
            var source = (0, util_1.getEdgeTerminal)(e8, "source");
            var target = (0, util_1.getEdgeTerminal)(e8, "target");
            if (!source || !target)
              return;
            var uIndex = _this.nodeIdxMap[source];
            var vIndex = _this.nodeIdxMap[target];
            if (uIndex === vIndex) {
              return;
            }
            var u2 = _this.nodeMap[source];
            var v2 = _this.nodeMap[target];
            if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
              return;
            }
            var vecX = v2.x - u2.x;
            var vecY = v2.y - u2.y;
            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            var common = vecLength * vecLength / k2;
            displacements[vIndex].x -= vecX / vecLength * common;
            displacements[vIndex].y -= vecY / vecLength * common;
            displacements[uIndex].x += vecX / vecLength * common;
            displacements[uIndex].y += vecY / vecLength * common;
          });
        };
        FruchtermanLayout3.prototype.stop = function() {
          if (this.timeInterval && typeof window !== "undefined") {
            window.clearInterval(this.timeInterval);
          }
        };
        FruchtermanLayout3.prototype.destroy = function() {
          var self2 = this;
          self2.stop();
          self2.tick = null;
          self2.nodes = null;
          self2.edges = null;
          self2.destroyed = true;
        };
        FruchtermanLayout3.prototype.getType = function() {
          return "fruchterman";
        };
        return FruchtermanLayout3;
      }(base_1.Base)
    );
    exports.FruchtermanLayout = FruchtermanLayout2;
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn2) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn2.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof6(o2) {
  "@babel/helpers - typeof";
  return _typeof6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof6(o2);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t2, r2) {
  if ("object" != _typeof6(t2) || !t2)
    return t2;
  var e8 = t2[Symbol.toPrimitive];
  if (void 0 !== e8) {
    var i2 = e8.call(t2, r2 || "default");
    if ("object" != _typeof6(i2))
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t2) {
  var i2 = toPrimitive(t2, "string");
  return "symbol" == _typeof6(i2) ? i2 : String(i2);
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty2(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties5(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties5(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto2 = Object.prototype;
    var hasOwnProperty4 = objectProto2.hasOwnProperty;
    var nativeObjectToString = objectProto2.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty4.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e8) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto2 = Object.prototype;
    var nativeObjectToString = objectProto2.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike2(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike2;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike2 = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e8) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber2;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof8(o2) {
      "@babel/helpers - typeof";
      return module.exports = _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof8(o2);
    }
    module.exports = _typeof8, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof8 = require_typeof()["default"];
    function _regeneratorRuntime5() {
      "use strict";
      module.exports = _regeneratorRuntime5 = function _regeneratorRuntime6() {
        return e8;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t2, e8 = {}, r2 = Object.prototype, n2 = r2.hasOwnProperty, o2 = Object.defineProperty || function(t3, e9, r3) {
        t3[e9] = r3.value;
      }, i2 = "function" == typeof Symbol ? Symbol : {}, a3 = i2.iterator || "@@iterator", c3 = i2.asyncIterator || "@@asyncIterator", u2 = i2.toStringTag || "@@toStringTag";
      function define2(t3, e9, r3) {
        return Object.defineProperty(t3, e9, {
          value: r3,
          enumerable: true,
          configurable: true,
          writable: true
        }), t3[e9];
      }
      try {
        define2({}, "");
      } catch (t3) {
        define2 = function define3(t4, e9, r3) {
          return t4[e9] = r3;
        };
      }
      function wrap2(t3, e9, r3, n3) {
        var i3 = e9 && e9.prototype instanceof Generator ? e9 : Generator, a4 = Object.create(i3.prototype), c4 = new Context(n3 || []);
        return o2(a4, "_invoke", {
          value: makeInvokeMethod(t3, r3, c4)
        }), a4;
      }
      function tryCatch(t3, e9, r3) {
        try {
          return {
            type: "normal",
            arg: t3.call(e9, r3)
          };
        } catch (t4) {
          return {
            type: "throw",
            arg: t4
          };
        }
      }
      e8.wrap = wrap2;
      var h2 = "suspendedStart", l2 = "suspendedYield", f2 = "executing", s2 = "completed", y4 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p2 = {};
      define2(p2, a3, function() {
        return this;
      });
      var d2 = Object.getPrototypeOf, v2 = d2 && d2(d2(values2([])));
      v2 && v2 !== r2 && n2.call(v2, a3) && (p2 = v2);
      var g2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
      function defineIteratorMethods(t3) {
        ["next", "throw", "return"].forEach(function(e9) {
          define2(t3, e9, function(t4) {
            return this._invoke(e9, t4);
          });
        });
      }
      function AsyncIterator(t3, e9) {
        function invoke(r4, o3, i3, a4) {
          var c4 = tryCatch(t3[r4], t3, o3);
          if ("throw" !== c4.type) {
            var u3 = c4.arg, h3 = u3.value;
            return h3 && "object" == _typeof8(h3) && n2.call(h3, "__await") ? e9.resolve(h3.__await).then(function(t4) {
              invoke("next", t4, i3, a4);
            }, function(t4) {
              invoke("throw", t4, i3, a4);
            }) : e9.resolve(h3).then(function(t4) {
              u3.value = t4, i3(u3);
            }, function(t4) {
              return invoke("throw", t4, i3, a4);
            });
          }
          a4(c4.arg);
        }
        var r3;
        o2(this, "_invoke", {
          value: function value(t4, n3) {
            function callInvokeWithMethodAndArg() {
              return new e9(function(e10, r4) {
                invoke(t4, n3, e10, r4);
              });
            }
            return r3 = r3 ? r3.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e9, r3, n3) {
        var o3 = h2;
        return function(i3, a4) {
          if (o3 === f2)
            throw new Error("Generator is already running");
          if (o3 === s2) {
            if ("throw" === i3)
              throw a4;
            return {
              value: t2,
              done: true
            };
          }
          for (n3.method = i3, n3.arg = a4; ; ) {
            var c4 = n3.delegate;
            if (c4) {
              var u3 = maybeInvokeDelegate(c4, n3);
              if (u3) {
                if (u3 === y4)
                  continue;
                return u3;
              }
            }
            if ("next" === n3.method)
              n3.sent = n3._sent = n3.arg;
            else if ("throw" === n3.method) {
              if (o3 === h2)
                throw o3 = s2, n3.arg;
              n3.dispatchException(n3.arg);
            } else
              "return" === n3.method && n3.abrupt("return", n3.arg);
            o3 = f2;
            var p3 = tryCatch(e9, r3, n3);
            if ("normal" === p3.type) {
              if (o3 = n3.done ? s2 : l2, p3.arg === y4)
                continue;
              return {
                value: p3.arg,
                done: n3.done
              };
            }
            "throw" === p3.type && (o3 = s2, n3.method = "throw", n3.arg = p3.arg);
          }
        };
      }
      function maybeInvokeDelegate(e9, r3) {
        var n3 = r3.method, o3 = e9.iterator[n3];
        if (o3 === t2)
          return r3.delegate = null, "throw" === n3 && e9.iterator["return"] && (r3.method = "return", r3.arg = t2, maybeInvokeDelegate(e9, r3), "throw" === r3.method) || "return" !== n3 && (r3.method = "throw", r3.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y4;
        var i3 = tryCatch(o3, e9.iterator, r3.arg);
        if ("throw" === i3.type)
          return r3.method = "throw", r3.arg = i3.arg, r3.delegate = null, y4;
        var a4 = i3.arg;
        return a4 ? a4.done ? (r3[e9.resultName] = a4.value, r3.next = e9.nextLoc, "return" !== r3.method && (r3.method = "next", r3.arg = t2), r3.delegate = null, y4) : a4 : (r3.method = "throw", r3.arg = new TypeError("iterator result is not an object"), r3.delegate = null, y4);
      }
      function pushTryEntry(t3) {
        var e9 = {
          tryLoc: t3[0]
        };
        1 in t3 && (e9.catchLoc = t3[1]), 2 in t3 && (e9.finallyLoc = t3[2], e9.afterLoc = t3[3]), this.tryEntries.push(e9);
      }
      function resetTryEntry(t3) {
        var e9 = t3.completion || {};
        e9.type = "normal", delete e9.arg, t3.completion = e9;
      }
      function Context(t3) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t3.forEach(pushTryEntry, this), this.reset(true);
      }
      function values2(e9) {
        if (e9 || "" === e9) {
          var r3 = e9[a3];
          if (r3)
            return r3.call(e9);
          if ("function" == typeof e9.next)
            return e9;
          if (!isNaN(e9.length)) {
            var o3 = -1, i3 = function next() {
              for (; ++o3 < e9.length; )
                if (n2.call(e9, o3))
                  return next.value = e9[o3], next.done = false, next;
              return next.value = t2, next.done = true, next;
            };
            return i3.next = i3;
          }
        }
        throw new TypeError(_typeof8(e9) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g2, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e8.isGeneratorFunction = function(t3) {
        var e9 = "function" == typeof t3 && t3.constructor;
        return !!e9 && (e9 === GeneratorFunction || "GeneratorFunction" === (e9.displayName || e9.name));
      }, e8.mark = function(t3) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define2(t3, u2, "GeneratorFunction")), t3.prototype = Object.create(g2), t3;
      }, e8.awrap = function(t3) {
        return {
          __await: t3
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c3, function() {
        return this;
      }), e8.AsyncIterator = AsyncIterator, e8.async = function(t3, r3, n3, o3, i3) {
        void 0 === i3 && (i3 = Promise);
        var a4 = new AsyncIterator(wrap2(t3, r3, n3, o3), i3);
        return e8.isGeneratorFunction(r3) ? a4 : a4.next().then(function(t4) {
          return t4.done ? t4.value : a4.next();
        });
      }, defineIteratorMethods(g2), define2(g2, u2, "Generator"), define2(g2, a3, function() {
        return this;
      }), define2(g2, "toString", function() {
        return "[object Generator]";
      }), e8.keys = function(t3) {
        var e9 = Object(t3), r3 = [];
        for (var n3 in e9)
          r3.push(n3);
        return r3.reverse(), function next() {
          for (; r3.length; ) {
            var t4 = r3.pop();
            if (t4 in e9)
              return next.value = t4, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e8.values = values2, Context.prototype = {
        constructor: Context,
        reset: function reset(e9) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e9)
            for (var r3 in this)
              "t" === r3.charAt(0) && n2.call(this, r3) && !isNaN(+r3.slice(1)) && (this[r3] = t2);
        },
        stop: function stop() {
          this.done = true;
          var t3 = this.tryEntries[0].completion;
          if ("throw" === t3.type)
            throw t3.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e9) {
          if (this.done)
            throw e9;
          var r3 = this;
          function handle(n3, o4) {
            return a4.type = "throw", a4.arg = e9, r3.next = n3, o4 && (r3.method = "next", r3.arg = t2), !!o4;
          }
          for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
            var i3 = this.tryEntries[o3], a4 = i3.completion;
            if ("root" === i3.tryLoc)
              return handle("end");
            if (i3.tryLoc <= this.prev) {
              var c4 = n2.call(i3, "catchLoc"), u3 = n2.call(i3, "finallyLoc");
              if (c4 && u3) {
                if (this.prev < i3.catchLoc)
                  return handle(i3.catchLoc, true);
                if (this.prev < i3.finallyLoc)
                  return handle(i3.finallyLoc);
              } else if (c4) {
                if (this.prev < i3.catchLoc)
                  return handle(i3.catchLoc, true);
              } else {
                if (!u3)
                  throw new Error("try statement without catch or finally");
                if (this.prev < i3.finallyLoc)
                  return handle(i3.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t3, e9) {
          for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
            var o3 = this.tryEntries[r3];
            if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
              var i3 = o3;
              break;
            }
          }
          i3 && ("break" === t3 || "continue" === t3) && i3.tryLoc <= e9 && e9 <= i3.finallyLoc && (i3 = null);
          var a4 = i3 ? i3.completion : {};
          return a4.type = t3, a4.arg = e9, i3 ? (this.method = "next", this.next = i3.finallyLoc, y4) : this.complete(a4);
        },
        complete: function complete(t3, e9) {
          if ("throw" === t3.type)
            throw t3.arg;
          return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e9 && (this.next = e9), y4;
        },
        finish: function finish(t3) {
          for (var e9 = this.tryEntries.length - 1; e9 >= 0; --e9) {
            var r3 = this.tryEntries[e9];
            if (r3.finallyLoc === t3)
              return this.complete(r3.completion, r3.afterLoc), resetTryEntry(r3), y4;
          }
        },
        "catch": function _catch(t3) {
          for (var e9 = this.tryEntries.length - 1; e9 >= 0; --e9) {
            var r3 = this.tryEntries[e9];
            if (r3.tryLoc === t3) {
              var n3 = r3.completion;
              if ("throw" === n3.type) {
                var o3 = n3.arg;
                resetTryEntry(r3);
              }
              return o3;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e9, r3, n3) {
          return this.delegate = {
            iterator: values2(e9),
            resultName: r3,
            nextLoc: n3
          }, "next" === this.method && (this.arg = t2), y4;
        }
      }, e8;
    }
    module.exports = _regeneratorRuntime5, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@antv/g-webgpu-core/es/Entity.js
function createEntity() {
  return entitySequence++;
}
var EMPTY, entitySequence;
var init_Entity = __esm({
  "node_modules/@antv/g-webgpu-core/es/Entity.js"() {
    EMPTY = -1;
    entitySequence = 1;
  }
});

// node_modules/@antv/g-webgpu-core/es/ComponentManager.js
var import_regenerator, Component, ComponentManager;
var init_ComponentManager = __esm({
  "node_modules/@antv/g-webgpu-core/es/ComponentManager.js"() {
    init_asyncToGenerator();
    init_createClass();
    init_classCallCheck();
    import_regenerator = __toESM(require_regenerator());
    init_Entity();
    Component = _createClass5(
      function Component2(data) {
        _classCallCheck5(this, Component2);
      }
      //
    );
    ComponentManager = function() {
      function ComponentManager2(clazz) {
        _classCallCheck5(this, ComponentManager2);
        this.clazz = void 0;
        this.components = [];
        this.entities = [];
        this.lookup = {};
        this.clazz = clazz;
      }
      _createClass5(ComponentManager2, [{
        key: "clear",
        value: function clear() {
          this.components = [];
          this.entities = [];
          this.lookup = {};
        }
      }, {
        key: "contains",
        value: function contains2(entity) {
          return this.lookup[entity] > -1;
        }
      }, {
        key: "create",
        value: function create(entity, data) {
          this.lookup[entity] = this.components.length;
          var component = new this.clazz(data || {});
          this.components.push(component);
          this.entities.push(entity);
          return component;
        }
      }, {
        key: "remove",
        value: function remove2(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            if (componentIndex < this.components.length - 1) {
              this.components[componentIndex] = this.components[this.components.length - 1];
              this.entities[componentIndex] = this.entities[this.entities.length - 1];
              this.lookup[this.entities[componentIndex]] = componentIndex;
            }
          }
          this.components.pop();
          this.entities.pop();
          delete this.lookup[entity];
        }
      }, {
        key: "removeKeepSorted",
        value: function removeKeepSorted(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            var entity2 = this.entities[componentIndex];
            if (componentIndex < this.components.length - 1) {
              for (var _i2 = componentIndex + 1; _i2 < this.components.length; ++_i2) {
                this.components[_i2 - 1] = this.components[_i2];
              }
              for (var _i22 = componentIndex + 1; _i22 < this.entities.length; ++_i22) {
                this.entities[_i22 - 1] = this.entities[_i22];
                this.lookup[this.entities[_i22 - 1]] = _i22 - 1;
              }
            }
            this.components.pop();
            this.entities.pop();
            delete this.lookup[entity2];
          }
        }
      }, {
        key: "moveItem",
        value: function moveItem(srcIndex, destIndex) {
          if (srcIndex === destIndex) {
            return;
          }
          var srcComponent = this.components[srcIndex];
          var srcEntity = this.entities[srcIndex];
          var direction2 = srcIndex < destIndex ? 1 : -1;
          for (var _i3 = srcIndex; _i3 !== destIndex; _i3 += direction2) {
            var next = _i3 + direction2;
            this.components[_i3] = this.components[next];
            this.entities[_i3] = this.entities[next];
            this.lookup[this.entities[_i3]] = _i3;
          }
          this.components[destIndex] = srcComponent;
          this.entities[destIndex] = srcEntity;
          this.lookup[srcEntity] = destIndex;
        }
      }, {
        key: "getEntity",
        value: function getEntity(index2) {
          return this.entities[index2];
        }
        /**
         * 由于缺少类似 C++ 的重载操作符，没法通过 [下标] 直接访问。因此只能增加该方法用于遍历。
         */
      }, {
        key: "getComponent",
        value: function getComponent(index2) {
          return this.components[index2];
        }
      }, {
        key: "getComponentByEntity",
        value: function getComponentByEntity(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            return this.components[componentIndex];
          }
          return null;
        }
      }, {
        key: "getCount",
        value: function getCount() {
          return this.components.length;
        }
      }, {
        key: "getEntityByComponentIndex",
        value: function getEntityByComponentIndex(componentIdx) {
          for (var _i4 = 0, _Object$keys = Object.keys(this.lookup); _i4 < _Object$keys.length; _i4++) {
            var _entity = _Object$keys[_i4];
            var entityInNum = Number(_entity);
            if (this.lookup[entityInNum] === componentIdx) {
              return entityInNum;
            }
          }
          return EMPTY;
        }
      }, {
        key: "find",
        value: function find3(callback) {
          for (var _i5 = 0; _i5 < this.getCount(); _i5++) {
            var _component = this.getComponent(_i5);
            if (callback(_component, _i5)) {
              return _component;
            }
          }
          return null;
        }
      }, {
        key: "findIndex",
        value: function findIndex2(callback) {
          for (var _i6 = 0; _i6 < this.getCount(); _i6++) {
            var _component2 = this.getComponent(_i6);
            if (callback(_component2, _i6)) {
              return _i6;
            }
          }
          return -1;
        }
      }, {
        key: "forEach",
        value: function forEach(callback) {
          for (var _i7 = 0, _Object$keys2 = Object.keys(this.lookup); _i7 < _Object$keys2.length; _i7++) {
            var _entity2 = _Object$keys2[_i7];
            var entityInNum = Number(_entity2);
            var componentIndex = this.lookup[entityInNum];
            callback(entityInNum, this.getComponent(componentIndex));
          }
        }
      }, {
        key: "forEachAsync",
        value: function() {
          var _forEachAsync = _asyncToGenerator(import_regenerator.default.mark(function _callee(callback) {
            var _i8, _Object$keys3, _entity3, entityInNum, componentIndex;
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _i8 = 0, _Object$keys3 = Object.keys(this.lookup);
                  case 1:
                    if (!(_i8 < _Object$keys3.length)) {
                      _context.next = 10;
                      break;
                    }
                    _entity3 = _Object$keys3[_i8];
                    entityInNum = Number(_entity3);
                    componentIndex = this.lookup[entityInNum];
                    _context.next = 7;
                    return callback(entityInNum, this.getComponent(componentIndex));
                  case 7:
                    _i8++;
                    _context.next = 1;
                    break;
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function forEachAsync(_x) {
            return _forEachAsync.apply(this, arguments);
          }
          return forEachAsync;
        }()
      }, {
        key: "map",
        value: function map3(callback) {
          var result = [];
          for (var _i9 = 0, _Object$keys4 = Object.keys(this.lookup); _i9 < _Object$keys4.length; _i9++) {
            var _entity4 = _Object$keys4[_i9];
            var entityInNum = Number(_entity4);
            var componentIndex = this.lookup[entityInNum];
            result.push(callback(entityInNum, this.getComponent(componentIndex)));
          }
          return result;
        }
      }]);
      return ComponentManager2;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js
var gl;
var init_gl = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js"() {
    (function(gl2) {
      gl2[gl2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
      gl2[gl2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
      gl2[gl2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
      gl2[gl2["POINTS"] = 0] = "POINTS";
      gl2[gl2["LINES"] = 1] = "LINES";
      gl2[gl2["LINE_LOOP"] = 2] = "LINE_LOOP";
      gl2[gl2["LINE_STRIP"] = 3] = "LINE_STRIP";
      gl2[gl2["TRIANGLES"] = 4] = "TRIANGLES";
      gl2[gl2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      gl2[gl2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
      gl2[gl2["ZERO"] = 0] = "ZERO";
      gl2[gl2["ONE"] = 1] = "ONE";
      gl2[gl2["SRC_COLOR"] = 768] = "SRC_COLOR";
      gl2[gl2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
      gl2[gl2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
      gl2[gl2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
      gl2[gl2["DST_ALPHA"] = 772] = "DST_ALPHA";
      gl2[gl2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
      gl2[gl2["DST_COLOR"] = 774] = "DST_COLOR";
      gl2[gl2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
      gl2[gl2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
      gl2[gl2["FUNC_ADD"] = 32774] = "FUNC_ADD";
      gl2[gl2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
      gl2[gl2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
      gl2[gl2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
      gl2[gl2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
      gl2[gl2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
      gl2[gl2["MAX_EXT"] = 32776] = "MAX_EXT";
      gl2[gl2["MIN_EXT"] = 32775] = "MIN_EXT";
      gl2[gl2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
      gl2[gl2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
      gl2[gl2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
      gl2[gl2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
      gl2[gl2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
      gl2[gl2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
      gl2[gl2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
      gl2[gl2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
      gl2[gl2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
      gl2[gl2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      gl2[gl2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      gl2[gl2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
      gl2[gl2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
      gl2[gl2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
      gl2[gl2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
      gl2[gl2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
      gl2[gl2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
      gl2[gl2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
      gl2[gl2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
      gl2[gl2["FRONT"] = 1028] = "FRONT";
      gl2[gl2["BACK"] = 1029] = "BACK";
      gl2[gl2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
      gl2[gl2["CULL_FACE"] = 2884] = "CULL_FACE";
      gl2[gl2["BLEND"] = 3042] = "BLEND";
      gl2[gl2["DITHER"] = 3024] = "DITHER";
      gl2[gl2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
      gl2[gl2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
      gl2[gl2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
      gl2[gl2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
      gl2[gl2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
      gl2[gl2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
      gl2[gl2["NO_ERROR"] = 0] = "NO_ERROR";
      gl2[gl2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
      gl2[gl2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
      gl2[gl2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
      gl2[gl2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
      gl2[gl2["CW"] = 2304] = "CW";
      gl2[gl2["CCW"] = 2305] = "CCW";
      gl2[gl2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
      gl2[gl2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
      gl2[gl2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
      gl2[gl2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
      gl2[gl2["FRONT_FACE"] = 2886] = "FRONT_FACE";
      gl2[gl2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
      gl2[gl2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
      gl2[gl2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
      gl2[gl2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
      gl2[gl2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
      gl2[gl2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
      gl2[gl2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
      gl2[gl2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
      gl2[gl2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
      gl2[gl2["STENCIL_REF"] = 2967] = "STENCIL_REF";
      gl2[gl2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
      gl2[gl2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
      gl2[gl2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
      gl2[gl2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
      gl2[gl2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
      gl2[gl2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
      gl2[gl2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
      gl2[gl2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
      gl2[gl2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
      gl2[gl2["VIEWPORT"] = 2978] = "VIEWPORT";
      gl2[gl2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
      gl2[gl2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
      gl2[gl2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
      gl2[gl2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
      gl2[gl2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
      gl2[gl2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
      gl2[gl2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
      gl2[gl2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
      gl2[gl2["RED_BITS"] = 3410] = "RED_BITS";
      gl2[gl2["GREEN_BITS"] = 3411] = "GREEN_BITS";
      gl2[gl2["BLUE_BITS"] = 3412] = "BLUE_BITS";
      gl2[gl2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
      gl2[gl2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
      gl2[gl2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
      gl2[gl2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
      gl2[gl2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
      gl2[gl2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
      gl2[gl2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
      gl2[gl2["SAMPLES"] = 32937] = "SAMPLES";
      gl2[gl2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
      gl2[gl2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
      gl2[gl2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
      gl2[gl2["DONT_CARE"] = 4352] = "DONT_CARE";
      gl2[gl2["FASTEST"] = 4353] = "FASTEST";
      gl2[gl2["NICEST"] = 4354] = "NICEST";
      gl2[gl2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
      gl2[gl2["BYTE"] = 5120] = "BYTE";
      gl2[gl2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      gl2[gl2["SHORT"] = 5122] = "SHORT";
      gl2[gl2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      gl2[gl2["INT"] = 5124] = "INT";
      gl2[gl2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      gl2[gl2["FLOAT"] = 5126] = "FLOAT";
      gl2[gl2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      gl2[gl2["ALPHA"] = 6406] = "ALPHA";
      gl2[gl2["RGB"] = 6407] = "RGB";
      gl2[gl2["RGBA"] = 6408] = "RGBA";
      gl2[gl2["LUMINANCE"] = 6409] = "LUMINANCE";
      gl2[gl2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      gl2[gl2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      gl2[gl2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      gl2[gl2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      gl2[gl2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
      gl2[gl2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
      gl2[gl2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
      gl2[gl2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
      gl2[gl2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
      gl2[gl2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
      gl2[gl2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
      gl2[gl2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
      gl2[gl2["LINK_STATUS"] = 35714] = "LINK_STATUS";
      gl2[gl2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
      gl2[gl2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
      gl2[gl2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
      gl2[gl2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
      gl2[gl2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
      gl2[gl2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
      gl2[gl2["NEVER"] = 512] = "NEVER";
      gl2[gl2["LESS"] = 513] = "LESS";
      gl2[gl2["EQUAL"] = 514] = "EQUAL";
      gl2[gl2["LEQUAL"] = 515] = "LEQUAL";
      gl2[gl2["GREATER"] = 516] = "GREATER";
      gl2[gl2["NOTEQUAL"] = 517] = "NOTEQUAL";
      gl2[gl2["GEQUAL"] = 518] = "GEQUAL";
      gl2[gl2["ALWAYS"] = 519] = "ALWAYS";
      gl2[gl2["KEEP"] = 7680] = "KEEP";
      gl2[gl2["REPLACE"] = 7681] = "REPLACE";
      gl2[gl2["INCR"] = 7682] = "INCR";
      gl2[gl2["DECR"] = 7683] = "DECR";
      gl2[gl2["INVERT"] = 5386] = "INVERT";
      gl2[gl2["INCR_WRAP"] = 34055] = "INCR_WRAP";
      gl2[gl2["DECR_WRAP"] = 34056] = "DECR_WRAP";
      gl2[gl2["VENDOR"] = 7936] = "VENDOR";
      gl2[gl2["RENDERER"] = 7937] = "RENDERER";
      gl2[gl2["VERSION"] = 7938] = "VERSION";
      gl2[gl2["NEAREST"] = 9728] = "NEAREST";
      gl2[gl2["LINEAR"] = 9729] = "LINEAR";
      gl2[gl2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
      gl2[gl2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
      gl2[gl2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
      gl2[gl2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
      gl2[gl2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
      gl2[gl2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
      gl2[gl2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
      gl2[gl2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
      gl2[gl2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      gl2[gl2["TEXTURE"] = 5890] = "TEXTURE";
      gl2[gl2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      gl2[gl2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      gl2[gl2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
      gl2[gl2["TEXTURE0"] = 33984] = "TEXTURE0";
      gl2[gl2["TEXTURE1"] = 33985] = "TEXTURE1";
      gl2[gl2["TEXTURE2"] = 33986] = "TEXTURE2";
      gl2[gl2["TEXTURE3"] = 33987] = "TEXTURE3";
      gl2[gl2["TEXTURE4"] = 33988] = "TEXTURE4";
      gl2[gl2["TEXTURE5"] = 33989] = "TEXTURE5";
      gl2[gl2["TEXTURE6"] = 33990] = "TEXTURE6";
      gl2[gl2["TEXTURE7"] = 33991] = "TEXTURE7";
      gl2[gl2["TEXTURE8"] = 33992] = "TEXTURE8";
      gl2[gl2["TEXTURE9"] = 33993] = "TEXTURE9";
      gl2[gl2["TEXTURE10"] = 33994] = "TEXTURE10";
      gl2[gl2["TEXTURE11"] = 33995] = "TEXTURE11";
      gl2[gl2["TEXTURE12"] = 33996] = "TEXTURE12";
      gl2[gl2["TEXTURE13"] = 33997] = "TEXTURE13";
      gl2[gl2["TEXTURE14"] = 33998] = "TEXTURE14";
      gl2[gl2["TEXTURE15"] = 33999] = "TEXTURE15";
      gl2[gl2["TEXTURE16"] = 34e3] = "TEXTURE16";
      gl2[gl2["TEXTURE17"] = 34001] = "TEXTURE17";
      gl2[gl2["TEXTURE18"] = 34002] = "TEXTURE18";
      gl2[gl2["TEXTURE19"] = 34003] = "TEXTURE19";
      gl2[gl2["TEXTURE20"] = 34004] = "TEXTURE20";
      gl2[gl2["TEXTURE21"] = 34005] = "TEXTURE21";
      gl2[gl2["TEXTURE22"] = 34006] = "TEXTURE22";
      gl2[gl2["TEXTURE23"] = 34007] = "TEXTURE23";
      gl2[gl2["TEXTURE24"] = 34008] = "TEXTURE24";
      gl2[gl2["TEXTURE25"] = 34009] = "TEXTURE25";
      gl2[gl2["TEXTURE26"] = 34010] = "TEXTURE26";
      gl2[gl2["TEXTURE27"] = 34011] = "TEXTURE27";
      gl2[gl2["TEXTURE28"] = 34012] = "TEXTURE28";
      gl2[gl2["TEXTURE29"] = 34013] = "TEXTURE29";
      gl2[gl2["TEXTURE30"] = 34014] = "TEXTURE30";
      gl2[gl2["TEXTURE31"] = 34015] = "TEXTURE31";
      gl2[gl2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
      gl2[gl2["REPEAT"] = 10497] = "REPEAT";
      gl2[gl2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
      gl2[gl2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
      gl2[gl2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
      gl2[gl2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
      gl2[gl2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
      gl2[gl2["INT_VEC2"] = 35667] = "INT_VEC2";
      gl2[gl2["INT_VEC3"] = 35668] = "INT_VEC3";
      gl2[gl2["INT_VEC4"] = 35669] = "INT_VEC4";
      gl2[gl2["BOOL"] = 35670] = "BOOL";
      gl2[gl2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
      gl2[gl2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
      gl2[gl2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
      gl2[gl2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
      gl2[gl2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
      gl2[gl2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
      gl2[gl2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
      gl2[gl2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
      gl2[gl2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
      gl2[gl2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
      gl2[gl2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
      gl2[gl2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
      gl2[gl2["LOW_INT"] = 36339] = "LOW_INT";
      gl2[gl2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
      gl2[gl2["HIGH_INT"] = 36341] = "HIGH_INT";
      gl2[gl2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
      gl2[gl2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
      gl2[gl2["RGBA4"] = 32854] = "RGBA4";
      gl2[gl2["RGB5_A1"] = 32855] = "RGB5_A1";
      gl2[gl2["RGB565"] = 36194] = "RGB565";
      gl2[gl2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
      gl2[gl2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
      gl2[gl2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
      gl2[gl2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      gl2[gl2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
      gl2[gl2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
      gl2[gl2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
      gl2[gl2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
      gl2[gl2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
      gl2[gl2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
      gl2[gl2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
      gl2[gl2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
      gl2[gl2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
      gl2[gl2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
      gl2[gl2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
      gl2[gl2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
      gl2[gl2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
      gl2[gl2["NONE"] = 0] = "NONE";
      gl2[gl2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      gl2[gl2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
      gl2[gl2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
      gl2[gl2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
      gl2[gl2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
      gl2[gl2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
      gl2[gl2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
      gl2[gl2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
      gl2[gl2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
      gl2[gl2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
      gl2[gl2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
      gl2[gl2["COPY_SRC"] = 1] = "COPY_SRC";
      gl2[gl2["COPY_DST"] = 2] = "COPY_DST";
      gl2[gl2["SAMPLED"] = 4] = "SAMPLED";
      gl2[gl2["STORAGE"] = 8] = "STORAGE";
      gl2[gl2["RENDER_ATTACHMENT"] = 16] = "RENDER_ATTACHMENT";
    })(gl || (gl = {}));
  }
});

// node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js
var ConfigService;
var init_ConfigService = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js"() {
    init_classCallCheck();
    init_createClass();
    ConfigService = function() {
      function ConfigService2() {
        _classCallCheck5(this, ConfigService2);
        this.config = void 0;
      }
      _createClass5(ConfigService2, [{
        key: "get",
        value: function get3() {
          return this.config;
        }
      }, {
        key: "set",
        value: function set3(config) {
          this.config = config;
        }
      }]);
      return ConfigService2;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/isSafari.js
var isSafari;
var init_isSafari = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/isSafari.js"() {
    isSafari = typeof navigator !== "undefined" && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
  }
});

// node_modules/@antv/g-webgpu-core/es/index.js
var AST_TOKEN_TYPES, AST_NODE_TYPES, STORAGE_CLASS, Target, DefineValuePlaceholder;
var init_es2 = __esm({
  "node_modules/@antv/g-webgpu-core/es/index.js"() {
    init_ComponentManager();
    init_gl();
    init_Entity();
    init_ConfigService();
    init_isSafari();
    (function(AST_TOKEN_TYPES2) {
      AST_TOKEN_TYPES2["Void"] = "Void";
      AST_TOKEN_TYPES2["Boolean"] = "Boolean";
      AST_TOKEN_TYPES2["Float"] = "Float";
      AST_TOKEN_TYPES2["Uint32"] = "Uint32";
      AST_TOKEN_TYPES2["Int32"] = "Int32";
      AST_TOKEN_TYPES2["Vector"] = "Vector";
      AST_TOKEN_TYPES2["Vector2Float"] = "vec2<f32>";
      AST_TOKEN_TYPES2["Vector3Float"] = "vec3<f32>";
      AST_TOKEN_TYPES2["Vector4Float"] = "vec4<f32>";
      AST_TOKEN_TYPES2["Vector2Boolean"] = "vec2<bool>";
      AST_TOKEN_TYPES2["Vector3Boolean"] = "vec3<bool>";
      AST_TOKEN_TYPES2["Vector4Boolean"] = "vec4<bool>";
      AST_TOKEN_TYPES2["Vector2Uint"] = "vec2<u32>";
      AST_TOKEN_TYPES2["Vector3Uint"] = "vec3<u32>";
      AST_TOKEN_TYPES2["Vector4Uint"] = "vec4<u32>";
      AST_TOKEN_TYPES2["Vector2Int"] = "vec2<i32>";
      AST_TOKEN_TYPES2["Vector3Int"] = "vec3<i32>";
      AST_TOKEN_TYPES2["Vector4Int"] = "vec4<i32>";
      AST_TOKEN_TYPES2["Matrix"] = "Matrix";
      AST_TOKEN_TYPES2["Matrix3x3Float"] = "mat3x3<f32>";
      AST_TOKEN_TYPES2["Matrix4x4Float"] = "mat4x4<i32>";
      AST_TOKEN_TYPES2["Struct"] = "Struct";
      AST_TOKEN_TYPES2["FloatArray"] = "Float[]";
      AST_TOKEN_TYPES2["Vector4FloatArray"] = "vec4<f32>[]";
    })(AST_TOKEN_TYPES || (AST_TOKEN_TYPES = {}));
    (function(AST_NODE_TYPES2) {
      AST_NODE_TYPES2["Program"] = "Program";
      AST_NODE_TYPES2["Identifier"] = "Identifier";
      AST_NODE_TYPES2["VariableDeclaration"] = "VariableDeclaration";
      AST_NODE_TYPES2["BlockStatement"] = "BlockStatement";
      AST_NODE_TYPES2["ReturnStatement"] = "ReturnStatement";
      AST_NODE_TYPES2["FunctionDeclaration"] = "FunctionDeclaration";
      AST_NODE_TYPES2["VariableDeclarator"] = "VariableDeclarator";
      AST_NODE_TYPES2["AssignmentExpression"] = "AssignmentExpression";
      AST_NODE_TYPES2["LogicalExpression"] = "LogicalExpression";
      AST_NODE_TYPES2["BinaryExpression"] = "BinaryExpression";
      AST_NODE_TYPES2["ArrayExpression"] = "ArrayExpression";
      AST_NODE_TYPES2["UnaryExpression"] = "UnaryExpression";
      AST_NODE_TYPES2["UpdateExpression"] = "UpdateExpression";
      AST_NODE_TYPES2["FunctionExpression"] = "FunctionExpression";
      AST_NODE_TYPES2["MemberExpression"] = "MemberExpression";
      AST_NODE_TYPES2["ConditionalExpression"] = "ConditionalExpression";
      AST_NODE_TYPES2["ExpressionStatement"] = "ExpressionStatement";
      AST_NODE_TYPES2["CallExpression"] = "CallExpression";
      AST_NODE_TYPES2["NumThreadStatement"] = "NumThreadStatement";
      AST_NODE_TYPES2["StorageStatement"] = "StorageStatement";
      AST_NODE_TYPES2["DoWhileStatement"] = "DoWhileStatement";
      AST_NODE_TYPES2["WhileStatement"] = "WhileStatement";
      AST_NODE_TYPES2["ForStatement"] = "ForStatement";
      AST_NODE_TYPES2["BreakStatement"] = "BreakStatement";
      AST_NODE_TYPES2["ContinueStatement"] = "ContinueStatement";
      AST_NODE_TYPES2["IfStatement"] = "IfStatement";
      AST_NODE_TYPES2["ImportedFunctionStatement"] = "ImportedFunctionStatement";
    })(AST_NODE_TYPES || (AST_NODE_TYPES = {}));
    (function(STORAGE_CLASS2) {
      STORAGE_CLASS2["Input"] = "Input";
      STORAGE_CLASS2["Output"] = "Output";
      STORAGE_CLASS2["Uniform"] = "Uniform";
      STORAGE_CLASS2["Workgroup"] = "Workgroup";
      STORAGE_CLASS2["UniformConstant"] = "UniformConstant";
      STORAGE_CLASS2["Image"] = "Image";
      STORAGE_CLASS2["StorageBuffer"] = "StorageBuffer";
      STORAGE_CLASS2["Private"] = "Private";
      STORAGE_CLASS2["Function"] = "Function";
    })(STORAGE_CLASS || (STORAGE_CLASS = {}));
    (function(Target2) {
      Target2["GLSL100"] = "GLSL100";
      Target2["GLSL450"] = "GLSL450";
      Target2["WGSL"] = "WGSL";
    })(Target || (Target = {}));
    DefineValuePlaceholder = "__DefineValuePlaceholder__";
  }
});

// node_modules/@antv/g-webgpu/es/utils/canvas.js
function createCanvas() {
  if (typeof document !== "undefined") {
    return document.createElement("canvas");
  } else {
    throw new Error("Cannot create a canvas in this context");
  }
}
var init_canvas = __esm({
  "node_modules/@antv/g-webgpu/es/utils/canvas.js"() {
  }
});

// node_modules/@antv/g-webgpu/es/Kernel.js
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_isTypedArray, import_isNumber, import_isArray, import_regenerator2, Kernel;
var init_Kernel = __esm({
  "node_modules/@antv/g-webgpu/es/Kernel.js"() {
    init_asyncToGenerator();
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    import_isTypedArray = __toESM(require_isTypedArray());
    import_isNumber = __toESM(require_isNumber());
    import_isArray = __toESM(require_isArray());
    import_regenerator2 = __toESM(require_regenerator());
    init_es2();
    init_canvas();
    Kernel = function() {
      function Kernel2(engine, configService) {
        _classCallCheck5(this, Kernel2);
        this.engine = engine;
        this.configService = configService;
        this.model = void 0;
        this.dirty = true;
        this.compiledBundle = void 0;
        this.initPromise = void 0;
      }
      _createClass5(Kernel2, [{
        key: "init",
        value: function init() {
          var _this$configService$g = this.configService.get(), canvas = _this$configService$g.canvas, engineOptions = _this$configService$g.engineOptions;
          this.initPromise = this.engine.init(_objectSpread2({
            canvas: canvas || createCanvas(),
            // swapChainFormat: WebGPUConstants.TextureFormat.BGRA8Unorm,
            antialiasing: false
          }, engineOptions));
        }
      }, {
        key: "setBundle",
        value: function setBundle(bundle) {
          this.compiledBundle = JSON.parse(JSON.stringify(bundle));
        }
      }, {
        key: "setDispatch",
        value: function setDispatch(dispatch2) {
          if (this.compiledBundle.context) {
            this.compiledBundle.context.dispatch = dispatch2;
          }
          return this;
        }
      }, {
        key: "setMaxIteration",
        value: function setMaxIteration(maxIteration) {
          if (this.compiledBundle.context) {
            this.compiledBundle.context.maxIteration = maxIteration;
          }
          return this;
        }
      }, {
        key: "setBinding",
        value: function setBinding(name, data) {
          var _this = this;
          if (typeof name === "string") {
            var isNumberLikeData = (0, import_isNumber.default)(data) || (0, import_isTypedArray.default)(data) || (0, import_isArray.default)(data);
            if (this.compiledBundle && this.compiledBundle.context) {
              var existedDefine = this.compiledBundle.context.defines.find(function(b2) {
                return b2.name === name;
              });
              if (existedDefine) {
                existedDefine.value = data;
                return this;
              }
              var existedBinding = this.compiledBundle.context.uniforms.find(function(b2) {
                return b2.name === name;
              });
              if (existedBinding) {
                if (isNumberLikeData) {
                  existedBinding.data = data;
                  existedBinding.isReferer = false;
                  if (existedBinding.storageClass === STORAGE_CLASS.Uniform) {
                    if (this.model) {
                      this.model.updateUniform(name, data);
                    }
                  } else {
                    if (this.model) {
                      this.model.updateBuffer(name, data);
                    }
                  }
                } else {
                  existedBinding.isReferer = true;
                  existedBinding.data = data;
                }
              }
            }
          } else {
            Object.keys(name).forEach(function(key) {
              _this.setBinding(key, name[key]);
            });
          }
          return this;
        }
      }, {
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator2.default.mark(function _callee() {
            var _this2 = this;
            var iteration, i2, _args = arguments;
            return import_regenerator2.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    iteration = _args.length > 0 && _args[0] !== void 0 ? _args[0] : 1;
                    if (!this.dirty) {
                      _context.next = 6;
                      break;
                    }
                    if (this.compiledBundle.context) {
                      if (iteration > 1) {
                        this.compiledBundle.context.maxIteration = iteration;
                      } else {
                        this.compiledBundle.context.maxIteration++;
                      }
                    }
                    _context.next = 5;
                    return this.compile();
                  case 5:
                    this.dirty = false;
                  case 6:
                    this.engine.beginFrame();
                    this.engine.clear({});
                    if (this.compiledBundle.context) {
                      this.compiledBundle.context.uniforms.filter(function(_ref) {
                        var isReferer = _ref.isReferer;
                        return isReferer;
                      }).forEach(function(_ref2) {
                        var data = _ref2.data, name = _ref2.name;
                        _this2.model.confirmInput(data.model, name);
                      });
                    }
                    for (i2 = 0; i2 < iteration; i2++) {
                      this.model.run();
                    }
                    this.engine.endFrame();
                    return _context.abrupt("return", this);
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function execute() {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
        /**
         * read output from GPUBuffer
         */
      }, {
        key: "getOutput",
        value: function() {
          var _getOutput = _asyncToGenerator(import_regenerator2.default.mark(function _callee2() {
            return import_regenerator2.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.model.readData());
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function getOutput() {
            return _getOutput.apply(this, arguments);
          }
          return getOutput;
        }()
      }, {
        key: "compile",
        value: function() {
          var _compile = _asyncToGenerator(import_regenerator2.default.mark(function _callee3() {
            var context, target, shader;
            return import_regenerator2.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.initPromise;
                  case 2:
                    context = _objectSpread2({}, this.compiledBundle.context);
                    target = this.engine.supportWebGPU ? this.engine.useWGSL ? Target.WGSL : Target.GLSL450 : Target.GLSL100;
                    shader = this.compiledBundle.shaders[target];
                    context.defines.filter(function(define2) {
                      return define2.runtime;
                    }).forEach(function(define2) {
                      var valuePlaceHolder = "".concat(DefineValuePlaceholder).concat(define2.name);
                      shader = shader.replace(valuePlaceHolder, "".concat(define2.value));
                    });
                    context.shader = shader;
                    context.uniforms.forEach(function(uniform) {
                      if (!uniform.data) {
                        if (uniform.storageClass === STORAGE_CLASS.StorageBuffer) {
                          var sizePerElement = 1;
                          if (uniform.type === AST_TOKEN_TYPES.FloatArray) {
                            sizePerElement = 1;
                          } else if (uniform.type === AST_TOKEN_TYPES.Vector4FloatArray) {
                            sizePerElement = 4;
                          }
                          uniform.data = new Float32Array(context.output.length * sizePerElement).fill(0);
                        }
                      }
                    });
                    this.compiledBundle.context = context;
                    _context3.next = 11;
                    return this.engine.createComputeModel(this.compiledBundle.context);
                  case 11:
                    this.model = _context3.sent;
                  case 12:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function compile() {
            return _compile.apply(this, arguments);
          }
          return compile;
        }()
      }]);
      return Kernel2;
    }();
  }
});

// node_modules/regl/dist/regl.js
var require_regl = __commonJS({
  "node_modules/regl/dist/regl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.createREGL = factory();
    })(exports, function() {
      "use strict";
      var isTypedArray = function(x4) {
        return x4 instanceof Uint8Array || x4 instanceof Uint16Array || x4 instanceof Uint32Array || x4 instanceof Int8Array || x4 instanceof Int16Array || x4 instanceof Int32Array || x4 instanceof Float32Array || x4 instanceof Float64Array || x4 instanceof Uint8ClampedArray;
      };
      var extend2 = function(base, opts) {
        var keys2 = Object.keys(opts);
        for (var i2 = 0; i2 < keys2.length; ++i2) {
          base[keys2[i2]] = opts[keys2[i2]];
        }
        return base;
      };
      var endl = "\n";
      function decodeB64(str) {
        if (typeof atob !== "undefined") {
          return atob(str);
        }
        return "base64:" + str;
      }
      function raise(message) {
        var error = new Error("(regl) " + message);
        console.error(error);
        throw error;
      }
      function check(pred, message) {
        if (!pred) {
          raise(message);
        }
      }
      function encolon(message) {
        if (message) {
          return ": " + message;
        }
        return "";
      }
      function checkParameter(param, possibilities, message) {
        if (!(param in possibilities)) {
          raise("unknown parameter (" + param + ")" + encolon(message) + ". possible values: " + Object.keys(possibilities).join());
        }
      }
      function checkIsTypedArray(data, message) {
        if (!isTypedArray(data)) {
          raise(
            "invalid parameter type" + encolon(message) + ". must be a typed array"
          );
        }
      }
      function standardTypeEh(value, type) {
        switch (type) {
          case "number":
            return typeof value === "number";
          case "object":
            return typeof value === "object";
          case "string":
            return typeof value === "string";
          case "boolean":
            return typeof value === "boolean";
          case "function":
            return typeof value === "function";
          case "undefined":
            return typeof value === "undefined";
          case "symbol":
            return typeof value === "symbol";
        }
      }
      function checkTypeOf(value, type, message) {
        if (!standardTypeEh(value, type)) {
          raise(
            "invalid parameter type" + encolon(message) + ". expected " + type + ", got " + typeof value
          );
        }
      }
      function checkNonNegativeInt(value, message) {
        if (!(value >= 0 && (value | 0) === value)) {
          raise("invalid parameter type, (" + value + ")" + encolon(message) + ". must be a nonnegative integer");
        }
      }
      function checkOneOf(value, list, message) {
        if (list.indexOf(value) < 0) {
          raise("invalid value" + encolon(message) + ". must be one of: " + list);
        }
      }
      var constructorKeys = [
        "gl",
        "canvas",
        "container",
        "attributes",
        "pixelRatio",
        "extensions",
        "optionalExtensions",
        "profile",
        "onDone"
      ];
      function checkConstructor(obj) {
        Object.keys(obj).forEach(function(key) {
          if (constructorKeys.indexOf(key) < 0) {
            raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys);
          }
        });
      }
      function leftPad(str, n2) {
        str = str + "";
        while (str.length < n2) {
          str = " " + str;
        }
        return str;
      }
      function ShaderFile() {
        this.name = "unknown";
        this.lines = [];
        this.index = {};
        this.hasErrors = false;
      }
      function ShaderLine(number, line2) {
        this.number = number;
        this.line = line2;
        this.errors = [];
      }
      function ShaderError(fileNumber, lineNumber, message) {
        this.file = fileNumber;
        this.line = lineNumber;
        this.message = message;
      }
      function guessCommand() {
        var error = new Error();
        var stack = (error.stack || error).toString();
        var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack);
        if (pat) {
          return pat[1];
        }
        var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack);
        if (pat2) {
          return pat2[1];
        }
        return "unknown";
      }
      function guessCallSite() {
        var error = new Error();
        var stack = (error.stack || error).toString();
        var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack);
        if (pat) {
          return pat[1];
        }
        var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack);
        if (pat2) {
          return pat2[1];
        }
        return "unknown";
      }
      function parseSource(source, command) {
        var lines2 = source.split("\n");
        var lineNumber = 1;
        var fileNumber = 0;
        var files = {
          unknown: new ShaderFile(),
          0: new ShaderFile()
        };
        files.unknown.name = files[0].name = command || guessCommand();
        files.unknown.lines.push(new ShaderLine(0, ""));
        for (var i2 = 0; i2 < lines2.length; ++i2) {
          var line2 = lines2[i2];
          var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line2);
          if (parts) {
            switch (parts[1]) {
              case "line":
                var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2]);
                if (lineNumberInfo) {
                  lineNumber = lineNumberInfo[1] | 0;
                  if (lineNumberInfo[2]) {
                    fileNumber = lineNumberInfo[2] | 0;
                    if (!(fileNumber in files)) {
                      files[fileNumber] = new ShaderFile();
                    }
                  }
                }
                break;
              case "define":
                var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2]);
                if (nameInfo) {
                  files[fileNumber].name = nameInfo[1] ? decodeB64(nameInfo[2]) : nameInfo[2];
                }
                break;
            }
          }
          files[fileNumber].lines.push(new ShaderLine(lineNumber++, line2));
        }
        Object.keys(files).forEach(function(fileNumber2) {
          var file = files[fileNumber2];
          file.lines.forEach(function(line3) {
            file.index[line3.number] = line3;
          });
        });
        return files;
      }
      function parseErrorLog(errLog) {
        var result = [];
        errLog.split("\n").forEach(function(errMsg) {
          if (errMsg.length < 5) {
            return;
          }
          var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg);
          if (parts) {
            result.push(new ShaderError(
              parts[1] | 0,
              parts[2] | 0,
              parts[3].trim()
            ));
          } else if (errMsg.length > 0) {
            result.push(new ShaderError("unknown", 0, errMsg));
          }
        });
        return result;
      }
      function annotateFiles(files, errors) {
        errors.forEach(function(error) {
          var file = files[error.file];
          if (file) {
            var line2 = file.index[error.line];
            if (line2) {
              line2.errors.push(error);
              file.hasErrors = true;
              return;
            }
          }
          files.unknown.hasErrors = true;
          files.unknown.lines[0].errors.push(error);
        });
      }
      function checkShaderError(gl2, shader, source, type, command) {
        if (!gl2.getShaderParameter(shader, gl2.COMPILE_STATUS)) {
          var errLog = gl2.getShaderInfoLog(shader);
          var typeName = type === gl2.FRAGMENT_SHADER ? "fragment" : "vertex";
          checkCommandType(source, "string", typeName + " shader source must be a string", command);
          var files = parseSource(source, command);
          var errors = parseErrorLog(errLog);
          annotateFiles(files, errors);
          Object.keys(files).forEach(function(fileNumber) {
            var file = files[fileNumber];
            if (!file.hasErrors) {
              return;
            }
            var strings = [""];
            var styles = [""];
            function push(str, style) {
              strings.push(str);
              styles.push(style || "");
            }
            push("file number " + fileNumber + ": " + file.name + "\n", "color:red;text-decoration:underline;font-weight:bold");
            file.lines.forEach(function(line2) {
              if (line2.errors.length > 0) {
                push(leftPad(line2.number, 4) + "|  ", "background-color:yellow; font-weight:bold");
                push(line2.line + endl, "color:red; background-color:yellow; font-weight:bold");
                var offset = 0;
                line2.errors.forEach(function(error) {
                  var message = error.message;
                  var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message);
                  if (token) {
                    var tokenPat = token[1];
                    message = token[2];
                    switch (tokenPat) {
                      case "assign":
                        tokenPat = "=";
                        break;
                    }
                    offset = Math.max(line2.line.indexOf(tokenPat, offset), 0);
                  } else {
                    offset = 0;
                  }
                  push(leftPad("| ", 6));
                  push(leftPad("^^^", offset + 3) + endl, "font-weight:bold");
                  push(leftPad("| ", 6));
                  push(message + endl, "font-weight:bold");
                });
                push(leftPad("| ", 6) + endl);
              } else {
                push(leftPad(line2.number, 4) + "|  ");
                push(line2.line + endl, "color:red");
              }
            });
            if (typeof document !== "undefined" && !window.chrome) {
              styles[0] = strings.join("%c");
              console.log.apply(console, styles);
            } else {
              console.log(strings.join(""));
            }
          });
          check.raise("Error compiling " + typeName + " shader, " + files[0].name);
        }
      }
      function checkLinkError(gl2, program, fragShader, vertShader, command) {
        if (!gl2.getProgramParameter(program, gl2.LINK_STATUS)) {
          var errLog = gl2.getProgramInfoLog(program);
          var fragParse = parseSource(fragShader, command);
          var vertParse = parseSource(vertShader, command);
          var header = 'Error linking program with vertex shader, "' + vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"';
          if (typeof document !== "undefined") {
            console.log(
              "%c" + header + endl + "%c" + errLog,
              "color:red;text-decoration:underline;font-weight:bold",
              "color:red"
            );
          } else {
            console.log(header + endl + errLog);
          }
          check.raise(header);
        }
      }
      function saveCommandRef(object) {
        object._commandRef = guessCommand();
      }
      function saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {
        saveCommandRef(opts);
        function id(str) {
          if (str) {
            return stringStore.id(str);
          }
          return 0;
        }
        opts._fragId = id(opts.static.frag);
        opts._vertId = id(opts.static.vert);
        function addProps(dict, set3) {
          Object.keys(set3).forEach(function(u2) {
            dict[stringStore.id(u2)] = true;
          });
        }
        var uniformSet = opts._uniformSet = {};
        addProps(uniformSet, uniforms.static);
        addProps(uniformSet, uniforms.dynamic);
        var attributeSet = opts._attributeSet = {};
        addProps(attributeSet, attributes.static);
        addProps(attributeSet, attributes.dynamic);
        opts._hasCount = "count" in opts.static || "count" in opts.dynamic || "elements" in opts.static || "elements" in opts.dynamic;
      }
      function commandRaise(message, command) {
        var callSite = guessCallSite();
        raise(message + " in command " + (command || guessCommand()) + (callSite === "unknown" ? "" : " called from " + callSite));
      }
      function checkCommand(pred, message, command) {
        if (!pred) {
          commandRaise(message, command || guessCommand());
        }
      }
      function checkParameterCommand(param, possibilities, message, command) {
        if (!(param in possibilities)) {
          commandRaise(
            "unknown parameter (" + param + ")" + encolon(message) + ". possible values: " + Object.keys(possibilities).join(),
            command || guessCommand()
          );
        }
      }
      function checkCommandType(value, type, message, command) {
        if (!standardTypeEh(value, type)) {
          commandRaise(
            "invalid parameter type" + encolon(message) + ". expected " + type + ", got " + typeof value,
            command || guessCommand()
          );
        }
      }
      function checkOptional(block) {
        block();
      }
      function checkFramebufferFormat(attachment, texFormats, rbFormats) {
        if (attachment.texture) {
          checkOneOf(
            attachment.texture._texture.internalformat,
            texFormats,
            "unsupported texture format for attachment"
          );
        } else {
          checkOneOf(
            attachment.renderbuffer._renderbuffer.format,
            rbFormats,
            "unsupported renderbuffer format for attachment"
          );
        }
      }
      var GL_CLAMP_TO_EDGE = 33071;
      var GL_NEAREST = 9728;
      var GL_NEAREST_MIPMAP_NEAREST = 9984;
      var GL_LINEAR_MIPMAP_NEAREST = 9985;
      var GL_NEAREST_MIPMAP_LINEAR = 9986;
      var GL_LINEAR_MIPMAP_LINEAR = 9987;
      var GL_BYTE = 5120;
      var GL_UNSIGNED_BYTE = 5121;
      var GL_SHORT = 5122;
      var GL_UNSIGNED_SHORT = 5123;
      var GL_INT = 5124;
      var GL_UNSIGNED_INT = 5125;
      var GL_FLOAT = 5126;
      var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;
      var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;
      var GL_UNSIGNED_SHORT_5_6_5 = 33635;
      var GL_UNSIGNED_INT_24_8_WEBGL = 34042;
      var GL_HALF_FLOAT_OES = 36193;
      var TYPE_SIZE = {};
      TYPE_SIZE[GL_BYTE] = TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;
      TYPE_SIZE[GL_SHORT] = TYPE_SIZE[GL_UNSIGNED_SHORT] = TYPE_SIZE[GL_HALF_FLOAT_OES] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] = TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;
      TYPE_SIZE[GL_INT] = TYPE_SIZE[GL_UNSIGNED_INT] = TYPE_SIZE[GL_FLOAT] = TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;
      function pixelSize(type, channels) {
        if (type === GL_UNSIGNED_SHORT_5_5_5_1 || type === GL_UNSIGNED_SHORT_4_4_4_4 || type === GL_UNSIGNED_SHORT_5_6_5) {
          return 2;
        } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
          return 4;
        } else {
          return TYPE_SIZE[type] * channels;
        }
      }
      function isPow2(v2) {
        return !(v2 & v2 - 1) && !!v2;
      }
      function checkTexture2D(info, mipData, limits) {
        var i2;
        var w2 = mipData.width;
        var h2 = mipData.height;
        var c3 = mipData.channels;
        check(
          w2 > 0 && w2 <= limits.maxTextureSize && h2 > 0 && h2 <= limits.maxTextureSize,
          "invalid texture shape"
        );
        if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
          check(
            isPow2(w2) && isPow2(h2),
            "incompatible wrap mode for texture, both width and height must be power of 2"
          );
        }
        if (mipData.mipmask === 1) {
          if (w2 !== 1 && h2 !== 1) {
            check(
              info.minFilter !== GL_NEAREST_MIPMAP_NEAREST && info.minFilter !== GL_NEAREST_MIPMAP_LINEAR && info.minFilter !== GL_LINEAR_MIPMAP_NEAREST && info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
              "min filter requires mipmap"
            );
          }
        } else {
          check(
            isPow2(w2) && isPow2(h2),
            "texture must be a square power of 2 to support mipmapping"
          );
          check(
            mipData.mipmask === (w2 << 1) - 1,
            "missing or incomplete mipmap data"
          );
        }
        if (mipData.type === GL_FLOAT) {
          if (limits.extensions.indexOf("oes_texture_float_linear") < 0) {
            check(
              info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
              "filter not supported, must enable oes_texture_float_linear"
            );
          }
          check(
            !info.genMipmaps,
            "mipmap generation not supported with float textures"
          );
        }
        var mipimages = mipData.images;
        for (i2 = 0; i2 < 16; ++i2) {
          if (mipimages[i2]) {
            var mw = w2 >> i2;
            var mh = h2 >> i2;
            check(mipData.mipmask & 1 << i2, "missing mipmap data");
            var img = mipimages[i2];
            check(
              img.width === mw && img.height === mh,
              "invalid shape for mip images"
            );
            check(
              img.format === mipData.format && img.internalformat === mipData.internalformat && img.type === mipData.type,
              "incompatible type for mip image"
            );
            if (img.compressed) {
            } else if (img.data) {
              var rowSize = Math.ceil(pixelSize(img.type, c3) * mw / img.unpackAlignment) * img.unpackAlignment;
              check(
                img.data.byteLength === rowSize * mh,
                "invalid data for image, buffer size is inconsistent with image format"
              );
            } else if (img.element) {
            } else if (img.copy) {
            }
          } else if (!info.genMipmaps) {
            check((mipData.mipmask & 1 << i2) === 0, "extra mipmap data");
          }
        }
        if (mipData.compressed) {
          check(
            !info.genMipmaps,
            "mipmap generation for compressed images not supported"
          );
        }
      }
      function checkTextureCube(texture, info, faces, limits) {
        var w2 = texture.width;
        var h2 = texture.height;
        var c3 = texture.channels;
        check(
          w2 > 0 && w2 <= limits.maxTextureSize && h2 > 0 && h2 <= limits.maxTextureSize,
          "invalid texture shape"
        );
        check(
          w2 === h2,
          "cube map must be square"
        );
        check(
          info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
          "wrap mode not supported by cube map"
        );
        for (var i2 = 0; i2 < faces.length; ++i2) {
          var face = faces[i2];
          check(
            face.width === w2 && face.height === h2,
            "inconsistent cube map face shape"
          );
          if (info.genMipmaps) {
            check(
              !face.compressed,
              "can not generate mipmap for compressed textures"
            );
            check(
              face.mipmask === 1,
              "can not specify mipmaps and generate mipmaps"
            );
          } else {
          }
          var mipmaps = face.images;
          for (var j2 = 0; j2 < 16; ++j2) {
            var img = mipmaps[j2];
            if (img) {
              var mw = w2 >> j2;
              var mh = h2 >> j2;
              check(face.mipmask & 1 << j2, "missing mipmap data");
              check(
                img.width === mw && img.height === mh,
                "invalid shape for mip images"
              );
              check(
                img.format === texture.format && img.internalformat === texture.internalformat && img.type === texture.type,
                "incompatible type for mip image"
              );
              if (img.compressed) {
              } else if (img.data) {
                check(
                  img.data.byteLength === mw * mh * Math.max(pixelSize(img.type, c3), img.unpackAlignment),
                  "invalid data for image, buffer size is inconsistent with image format"
                );
              } else if (img.element) {
              } else if (img.copy) {
              }
            }
          }
        }
      }
      var check$1 = extend2(check, {
        optional: checkOptional,
        raise,
        commandRaise,
        command: checkCommand,
        parameter: checkParameter,
        commandParameter: checkParameterCommand,
        constructor: checkConstructor,
        type: checkTypeOf,
        commandType: checkCommandType,
        isTypedArray: checkIsTypedArray,
        nni: checkNonNegativeInt,
        oneOf: checkOneOf,
        shaderError: checkShaderError,
        linkError: checkLinkError,
        callSite: guessCallSite,
        saveCommandRef,
        saveDrawInfo: saveDrawCommandInfo,
        framebufferFormat: checkFramebufferFormat,
        guessCommand,
        texture2D: checkTexture2D,
        textureCube: checkTextureCube
      });
      var VARIABLE_COUNTER = 0;
      var DYN_FUNC = 0;
      var DYN_CONSTANT = 5;
      var DYN_ARRAY = 6;
      function DynamicVariable(type, data) {
        this.id = VARIABLE_COUNTER++;
        this.type = type;
        this.data = data;
      }
      function escapeStr(str) {
        return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      }
      function splitParts(str) {
        if (str.length === 0) {
          return [];
        }
        var firstChar = str.charAt(0);
        var lastChar = str.charAt(str.length - 1);
        if (str.length > 1 && firstChar === lastChar && (firstChar === '"' || firstChar === "'")) {
          return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"'];
        }
        var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str);
        if (parts) {
          return splitParts(str.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str.substr(parts.index + parts[0].length)));
        }
        var subparts = str.split(".");
        if (subparts.length === 1) {
          return ['"' + escapeStr(str) + '"'];
        }
        var result = [];
        for (var i2 = 0; i2 < subparts.length; ++i2) {
          result = result.concat(splitParts(subparts[i2]));
        }
        return result;
      }
      function toAccessorString(str) {
        return "[" + splitParts(str).join("][") + "]";
      }
      function defineDynamic(type, data) {
        return new DynamicVariable(type, toAccessorString(data + ""));
      }
      function isDynamic(x4) {
        return typeof x4 === "function" && !x4._reglType || x4 instanceof DynamicVariable;
      }
      function unbox(x4, path) {
        if (typeof x4 === "function") {
          return new DynamicVariable(DYN_FUNC, x4);
        } else if (typeof x4 === "number" || typeof x4 === "boolean") {
          return new DynamicVariable(DYN_CONSTANT, x4);
        } else if (Array.isArray(x4)) {
          return new DynamicVariable(DYN_ARRAY, x4.map((y4, i2) => unbox(y4, path + "[" + i2 + "]")));
        } else if (x4 instanceof DynamicVariable) {
          return x4;
        }
        check$1(false, "invalid option type in uniform " + path);
      }
      var dynamic = {
        DynamicVariable,
        define: defineDynamic,
        isDynamic,
        unbox,
        accessor: toAccessorString
      };
      var raf = {
        next: typeof requestAnimationFrame === "function" ? function(cb) {
          return requestAnimationFrame(cb);
        } : function(cb) {
          return setTimeout(cb, 16);
        },
        cancel: typeof cancelAnimationFrame === "function" ? function(raf2) {
          return cancelAnimationFrame(raf2);
        } : clearTimeout
      };
      var clock = typeof performance !== "undefined" && performance.now ? function() {
        return performance.now();
      } : function() {
        return +new Date();
      };
      function createStringStore() {
        var stringIds = { "": 0 };
        var stringValues = [""];
        return {
          id: function(str) {
            var result = stringIds[str];
            if (result) {
              return result;
            }
            result = stringIds[str] = stringValues.length;
            stringValues.push(str);
            return result;
          },
          str: function(id) {
            return stringValues[id];
          }
        };
      }
      function createCanvas2(element, onDone, pixelRatio) {
        var canvas = document.createElement("canvas");
        extend2(canvas.style, {
          border: 0,
          margin: 0,
          padding: 0,
          top: 0,
          left: 0
        });
        element.appendChild(canvas);
        if (element === document.body) {
          canvas.style.position = "absolute";
          extend2(element.style, {
            margin: 0,
            padding: 0
          });
        }
        function resize() {
          var w2 = window.innerWidth;
          var h2 = window.innerHeight;
          if (element !== document.body) {
            var bounds = element.getBoundingClientRect();
            w2 = bounds.right - bounds.left;
            h2 = bounds.bottom - bounds.top;
          }
          canvas.width = pixelRatio * w2;
          canvas.height = pixelRatio * h2;
          extend2(canvas.style, {
            width: w2 + "px",
            height: h2 + "px"
          });
        }
        var resizeObserver;
        if (element !== document.body && typeof ResizeObserver === "function") {
          resizeObserver = new ResizeObserver(function() {
            setTimeout(resize);
          });
          resizeObserver.observe(element);
        } else {
          window.addEventListener("resize", resize, false);
        }
        function onDestroy() {
          if (resizeObserver) {
            resizeObserver.disconnect();
          } else {
            window.removeEventListener("resize", resize);
          }
          element.removeChild(canvas);
        }
        resize();
        return {
          canvas,
          onDestroy
        };
      }
      function createContext(canvas, contextAttributes) {
        function get3(name) {
          try {
            return canvas.getContext(name, contextAttributes);
          } catch (e8) {
            return null;
          }
        }
        return get3("webgl") || get3("experimental-webgl") || get3("webgl-experimental");
      }
      function isHTMLElement(obj) {
        return typeof obj.nodeName === "string" && typeof obj.appendChild === "function" && typeof obj.getBoundingClientRect === "function";
      }
      function isWebGLContext(obj) {
        return typeof obj.drawArrays === "function" || typeof obj.drawElements === "function";
      }
      function parseExtensions(input) {
        if (typeof input === "string") {
          return input.split();
        }
        check$1(Array.isArray(input), "invalid extension array");
        return input;
      }
      function getElement(desc) {
        if (typeof desc === "string") {
          check$1(typeof document !== "undefined", "not supported outside of DOM");
          return document.querySelector(desc);
        }
        return desc;
      }
      function parseArgs(args_) {
        var args = args_ || {};
        var element, container, canvas, gl2;
        var contextAttributes = {};
        var extensions = [];
        var optionalExtensions = [];
        var pixelRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio;
        var profile = false;
        var onDone = function(err) {
          if (err) {
            check$1.raise(err);
          }
        };
        var onDestroy = function() {
        };
        if (typeof args === "string") {
          check$1(
            typeof document !== "undefined",
            "selector queries only supported in DOM enviroments"
          );
          element = document.querySelector(args);
          check$1(element, "invalid query string for element");
        } else if (typeof args === "object") {
          if (isHTMLElement(args)) {
            element = args;
          } else if (isWebGLContext(args)) {
            gl2 = args;
            canvas = gl2.canvas;
          } else {
            check$1.constructor(args);
            if ("gl" in args) {
              gl2 = args.gl;
            } else if ("canvas" in args) {
              canvas = getElement(args.canvas);
            } else if ("container" in args) {
              container = getElement(args.container);
            }
            if ("attributes" in args) {
              contextAttributes = args.attributes;
              check$1.type(contextAttributes, "object", "invalid context attributes");
            }
            if ("extensions" in args) {
              extensions = parseExtensions(args.extensions);
            }
            if ("optionalExtensions" in args) {
              optionalExtensions = parseExtensions(args.optionalExtensions);
            }
            if ("onDone" in args) {
              check$1.type(
                args.onDone,
                "function",
                "invalid or missing onDone callback"
              );
              onDone = args.onDone;
            }
            if ("profile" in args) {
              profile = !!args.profile;
            }
            if ("pixelRatio" in args) {
              pixelRatio = +args.pixelRatio;
              check$1(pixelRatio > 0, "invalid pixel ratio");
            }
          }
        } else {
          check$1.raise("invalid arguments to regl");
        }
        if (element) {
          if (element.nodeName.toLowerCase() === "canvas") {
            canvas = element;
          } else {
            container = element;
          }
        }
        if (!gl2) {
          if (!canvas) {
            check$1(
              typeof document !== "undefined",
              "must manually specify webgl context outside of DOM environments"
            );
            var result = createCanvas2(container || document.body, onDone, pixelRatio);
            if (!result) {
              return null;
            }
            canvas = result.canvas;
            onDestroy = result.onDestroy;
          }
          if (contextAttributes.premultipliedAlpha === void 0)
            contextAttributes.premultipliedAlpha = true;
          gl2 = createContext(canvas, contextAttributes);
        }
        if (!gl2) {
          onDestroy();
          onDone("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org");
          return null;
        }
        return {
          gl: gl2,
          canvas,
          container,
          extensions,
          optionalExtensions,
          pixelRatio,
          profile,
          onDone,
          onDestroy
        };
      }
      function createExtensionCache(gl2, config) {
        var extensions = {};
        function tryLoadExtension(name_) {
          check$1.type(name_, "string", "extension name must be string");
          var name2 = name_.toLowerCase();
          var ext;
          try {
            ext = extensions[name2] = gl2.getExtension(name2);
          } catch (e8) {
          }
          return !!ext;
        }
        for (var i2 = 0; i2 < config.extensions.length; ++i2) {
          var name = config.extensions[i2];
          if (!tryLoadExtension(name)) {
            config.onDestroy();
            config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
            return null;
          }
        }
        config.optionalExtensions.forEach(tryLoadExtension);
        return {
          extensions,
          restore: function() {
            Object.keys(extensions).forEach(function(name2) {
              if (extensions[name2] && !tryLoadExtension(name2)) {
                throw new Error("(regl): error restoring extension " + name2);
              }
            });
          }
        };
      }
      function loop(n2, f2) {
        var result = Array(n2);
        for (var i2 = 0; i2 < n2; ++i2) {
          result[i2] = f2(i2);
        }
        return result;
      }
      var GL_BYTE$1 = 5120;
      var GL_UNSIGNED_BYTE$2 = 5121;
      var GL_SHORT$1 = 5122;
      var GL_UNSIGNED_SHORT$1 = 5123;
      var GL_INT$1 = 5124;
      var GL_UNSIGNED_INT$1 = 5125;
      var GL_FLOAT$2 = 5126;
      function nextPow16(v2) {
        for (var i2 = 16; i2 <= 1 << 28; i2 *= 16) {
          if (v2 <= i2) {
            return i2;
          }
        }
        return 0;
      }
      function log2(v2) {
        var r2, shift;
        r2 = (v2 > 65535) << 4;
        v2 >>>= r2;
        shift = (v2 > 255) << 3;
        v2 >>>= shift;
        r2 |= shift;
        shift = (v2 > 15) << 2;
        v2 >>>= shift;
        r2 |= shift;
        shift = (v2 > 3) << 1;
        v2 >>>= shift;
        r2 |= shift;
        return r2 | v2 >> 1;
      }
      function createPool() {
        var bufferPool = loop(8, function() {
          return [];
        });
        function alloc(n2) {
          var sz = nextPow16(n2);
          var bin = bufferPool[log2(sz) >> 2];
          if (bin.length > 0) {
            return bin.pop();
          }
          return new ArrayBuffer(sz);
        }
        function free(buf) {
          bufferPool[log2(buf.byteLength) >> 2].push(buf);
        }
        function allocType(type, n2) {
          var result = null;
          switch (type) {
            case GL_BYTE$1:
              result = new Int8Array(alloc(n2), 0, n2);
              break;
            case GL_UNSIGNED_BYTE$2:
              result = new Uint8Array(alloc(n2), 0, n2);
              break;
            case GL_SHORT$1:
              result = new Int16Array(alloc(2 * n2), 0, n2);
              break;
            case GL_UNSIGNED_SHORT$1:
              result = new Uint16Array(alloc(2 * n2), 0, n2);
              break;
            case GL_INT$1:
              result = new Int32Array(alloc(4 * n2), 0, n2);
              break;
            case GL_UNSIGNED_INT$1:
              result = new Uint32Array(alloc(4 * n2), 0, n2);
              break;
            case GL_FLOAT$2:
              result = new Float32Array(alloc(4 * n2), 0, n2);
              break;
            default:
              return null;
          }
          if (result.length !== n2) {
            return result.subarray(0, n2);
          }
          return result;
        }
        function freeType(array) {
          free(array.buffer);
        }
        return {
          alloc,
          free,
          allocType,
          freeType
        };
      }
      var pool = createPool();
      pool.zero = createPool();
      var GL_SUBPIXEL_BITS = 3408;
      var GL_RED_BITS = 3410;
      var GL_GREEN_BITS = 3411;
      var GL_BLUE_BITS = 3412;
      var GL_ALPHA_BITS = 3413;
      var GL_DEPTH_BITS = 3414;
      var GL_STENCIL_BITS = 3415;
      var GL_ALIASED_POINT_SIZE_RANGE = 33901;
      var GL_ALIASED_LINE_WIDTH_RANGE = 33902;
      var GL_MAX_TEXTURE_SIZE = 3379;
      var GL_MAX_VIEWPORT_DIMS = 3386;
      var GL_MAX_VERTEX_ATTRIBS = 34921;
      var GL_MAX_VERTEX_UNIFORM_VECTORS = 36347;
      var GL_MAX_VARYING_VECTORS = 36348;
      var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
      var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
      var GL_MAX_TEXTURE_IMAGE_UNITS = 34930;
      var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
      var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
      var GL_MAX_RENDERBUFFER_SIZE = 34024;
      var GL_VENDOR = 7936;
      var GL_RENDERER = 7937;
      var GL_VERSION = 7938;
      var GL_SHADING_LANGUAGE_VERSION = 35724;
      var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
      var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
      var GL_MAX_DRAW_BUFFERS_WEBGL = 34852;
      var GL_TEXTURE_2D = 3553;
      var GL_TEXTURE_CUBE_MAP = 34067;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
      var GL_TEXTURE0 = 33984;
      var GL_RGBA = 6408;
      var GL_FLOAT$1 = 5126;
      var GL_UNSIGNED_BYTE$1 = 5121;
      var GL_FRAMEBUFFER = 36160;
      var GL_FRAMEBUFFER_COMPLETE = 36053;
      var GL_COLOR_ATTACHMENT0 = 36064;
      var GL_COLOR_BUFFER_BIT$1 = 16384;
      var wrapLimits = function(gl2, extensions) {
        var maxAnisotropic = 1;
        if (extensions.ext_texture_filter_anisotropic) {
          maxAnisotropic = gl2.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        }
        var maxDrawbuffers = 1;
        var maxColorAttachments = 1;
        if (extensions.webgl_draw_buffers) {
          maxDrawbuffers = gl2.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
          maxColorAttachments = gl2.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
        }
        var readFloat = !!extensions.oes_texture_float;
        if (readFloat) {
          var readFloatTexture = gl2.createTexture();
          gl2.bindTexture(GL_TEXTURE_2D, readFloatTexture);
          gl2.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null);
          var fbo = gl2.createFramebuffer();
          gl2.bindFramebuffer(GL_FRAMEBUFFER, fbo);
          gl2.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);
          gl2.bindTexture(GL_TEXTURE_2D, null);
          if (gl2.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE)
            readFloat = false;
          else {
            gl2.viewport(0, 0, 1, 1);
            gl2.clearColor(1, 0, 0, 1);
            gl2.clear(GL_COLOR_BUFFER_BIT$1);
            var pixels = pool.allocType(GL_FLOAT$1, 4);
            gl2.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels);
            if (gl2.getError())
              readFloat = false;
            else {
              gl2.deleteFramebuffer(fbo);
              gl2.deleteTexture(readFloatTexture);
              readFloat = pixels[0] === 1;
            }
            pool.freeType(pixels);
          }
        }
        var isIE = typeof navigator !== "undefined" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent));
        var npotTextureCube = true;
        if (!isIE) {
          var cubeTexture = gl2.createTexture();
          var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36);
          gl2.activeTexture(GL_TEXTURE0);
          gl2.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);
          gl2.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data);
          pool.freeType(data);
          gl2.bindTexture(GL_TEXTURE_CUBE_MAP, null);
          gl2.deleteTexture(cubeTexture);
          npotTextureCube = !gl2.getError();
        }
        return {
          // drawing buffer bit depth
          colorBits: [
            gl2.getParameter(GL_RED_BITS),
            gl2.getParameter(GL_GREEN_BITS),
            gl2.getParameter(GL_BLUE_BITS),
            gl2.getParameter(GL_ALPHA_BITS)
          ],
          depthBits: gl2.getParameter(GL_DEPTH_BITS),
          stencilBits: gl2.getParameter(GL_STENCIL_BITS),
          subpixelBits: gl2.getParameter(GL_SUBPIXEL_BITS),
          // supported extensions
          extensions: Object.keys(extensions).filter(function(ext) {
            return !!extensions[ext];
          }),
          // max aniso samples
          maxAnisotropic,
          // max draw buffers
          maxDrawbuffers,
          maxColorAttachments,
          // point and line size ranges
          pointSizeDims: gl2.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
          lineWidthDims: gl2.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
          maxViewportDims: gl2.getParameter(GL_MAX_VIEWPORT_DIMS),
          maxCombinedTextureUnits: gl2.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
          maxCubeMapSize: gl2.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
          maxRenderbufferSize: gl2.getParameter(GL_MAX_RENDERBUFFER_SIZE),
          maxTextureUnits: gl2.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
          maxTextureSize: gl2.getParameter(GL_MAX_TEXTURE_SIZE),
          maxAttributes: gl2.getParameter(GL_MAX_VERTEX_ATTRIBS),
          maxVertexUniforms: gl2.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
          maxVertexTextureUnits: gl2.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          maxVaryingVectors: gl2.getParameter(GL_MAX_VARYING_VECTORS),
          maxFragmentUniforms: gl2.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),
          // vendor info
          glsl: gl2.getParameter(GL_SHADING_LANGUAGE_VERSION),
          renderer: gl2.getParameter(GL_RENDERER),
          vendor: gl2.getParameter(GL_VENDOR),
          version: gl2.getParameter(GL_VERSION),
          // quirks
          readFloat,
          npotTextureCube
        };
      };
      function isNDArrayLike(obj) {
        return !!obj && typeof obj === "object" && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === "number" && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray(obj.data));
      }
      var values2 = function(obj) {
        return Object.keys(obj).map(function(key) {
          return obj[key];
        });
      };
      var flattenUtils = {
        shape: arrayShape$1,
        flatten: flattenArray
      };
      function flatten1D(array, nx, out) {
        for (var i2 = 0; i2 < nx; ++i2) {
          out[i2] = array[i2];
        }
      }
      function flatten2D(array, nx, ny, out) {
        var ptr = 0;
        for (var i2 = 0; i2 < nx; ++i2) {
          var row = array[i2];
          for (var j2 = 0; j2 < ny; ++j2) {
            out[ptr++] = row[j2];
          }
        }
      }
      function flatten3D(array, nx, ny, nz, out, ptr_) {
        var ptr = ptr_;
        for (var i2 = 0; i2 < nx; ++i2) {
          var row = array[i2];
          for (var j2 = 0; j2 < ny; ++j2) {
            var col = row[j2];
            for (var k2 = 0; k2 < nz; ++k2) {
              out[ptr++] = col[k2];
            }
          }
        }
      }
      function flattenRec(array, shape, level, out, ptr) {
        var stride = 1;
        for (var i2 = level + 1; i2 < shape.length; ++i2) {
          stride *= shape[i2];
        }
        var n2 = shape[level];
        if (shape.length - level === 4) {
          var nx = shape[level + 1];
          var ny = shape[level + 2];
          var nz = shape[level + 3];
          for (i2 = 0; i2 < n2; ++i2) {
            flatten3D(array[i2], nx, ny, nz, out, ptr);
            ptr += stride;
          }
        } else {
          for (i2 = 0; i2 < n2; ++i2) {
            flattenRec(array[i2], shape, level + 1, out, ptr);
            ptr += stride;
          }
        }
      }
      function flattenArray(array, shape, type, out_) {
        var sz = 1;
        if (shape.length) {
          for (var i2 = 0; i2 < shape.length; ++i2) {
            sz *= shape[i2];
          }
        } else {
          sz = 0;
        }
        var out = out_ || pool.allocType(type, sz);
        switch (shape.length) {
          case 0:
            break;
          case 1:
            flatten1D(array, shape[0], out);
            break;
          case 2:
            flatten2D(array, shape[0], shape[1], out);
            break;
          case 3:
            flatten3D(array, shape[0], shape[1], shape[2], out, 0);
            break;
          default:
            flattenRec(array, shape, 0, out, 0);
        }
        return out;
      }
      function arrayShape$1(array_) {
        var shape = [];
        for (var array = array_; array.length; array = array[0]) {
          shape.push(array.length);
        }
        return shape;
      }
      var arrayTypes = {
        "[object Int8Array]": 5120,
        "[object Int16Array]": 5122,
        "[object Int32Array]": 5124,
        "[object Uint8Array]": 5121,
        "[object Uint8ClampedArray]": 5121,
        "[object Uint16Array]": 5123,
        "[object Uint32Array]": 5125,
        "[object Float32Array]": 5126,
        "[object Float64Array]": 5121,
        "[object ArrayBuffer]": 5121
      };
      var int8 = 5120;
      var int16 = 5122;
      var int32 = 5124;
      var uint8 = 5121;
      var uint16 = 5123;
      var uint32 = 5125;
      var float = 5126;
      var float32 = 5126;
      var glTypes = {
        int8,
        int16,
        int32,
        uint8,
        uint16,
        uint32,
        float,
        float32
      };
      var dynamic$1 = 35048;
      var stream = 35040;
      var usageTypes = {
        dynamic: dynamic$1,
        stream,
        "static": 35044
      };
      var arrayFlatten = flattenUtils.flatten;
      var arrayShape = flattenUtils.shape;
      var GL_STATIC_DRAW = 35044;
      var GL_STREAM_DRAW = 35040;
      var GL_UNSIGNED_BYTE$3 = 5121;
      var GL_FLOAT$3 = 5126;
      var DTYPES_SIZES = [];
      DTYPES_SIZES[5120] = 1;
      DTYPES_SIZES[5122] = 2;
      DTYPES_SIZES[5124] = 4;
      DTYPES_SIZES[5121] = 1;
      DTYPES_SIZES[5123] = 2;
      DTYPES_SIZES[5125] = 4;
      DTYPES_SIZES[5126] = 4;
      function typedArrayCode(data) {
        return arrayTypes[Object.prototype.toString.call(data)] | 0;
      }
      function copyArray(out, inp) {
        for (var i2 = 0; i2 < inp.length; ++i2) {
          out[i2] = inp[i2];
        }
      }
      function transpose(result, data, shapeX, shapeY, strideX, strideY, offset) {
        var ptr = 0;
        for (var i2 = 0; i2 < shapeX; ++i2) {
          for (var j2 = 0; j2 < shapeY; ++j2) {
            result[ptr++] = data[strideX * i2 + strideY * j2 + offset];
          }
        }
      }
      function wrapBufferState(gl2, stats2, config, destroyBuffer) {
        var bufferCount = 0;
        var bufferSet = {};
        function REGLBuffer(type) {
          this.id = bufferCount++;
          this.buffer = gl2.createBuffer();
          this.type = type;
          this.usage = GL_STATIC_DRAW;
          this.byteLength = 0;
          this.dimension = 1;
          this.dtype = GL_UNSIGNED_BYTE$3;
          this.persistentData = null;
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        REGLBuffer.prototype.bind = function() {
          gl2.bindBuffer(this.type, this.buffer);
        };
        REGLBuffer.prototype.destroy = function() {
          destroy(this);
        };
        var streamPool = [];
        function createStream(type, data) {
          var buffer = streamPool.pop();
          if (!buffer) {
            buffer = new REGLBuffer(type);
          }
          buffer.bind();
          initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
          return buffer;
        }
        function destroyStream(stream$$1) {
          streamPool.push(stream$$1);
        }
        function initBufferFromTypedArray(buffer, data, usage) {
          buffer.byteLength = data.byteLength;
          gl2.bufferData(buffer.type, data, usage);
        }
        function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {
          var shape;
          buffer.usage = usage;
          if (Array.isArray(data)) {
            buffer.dtype = dtype || GL_FLOAT$3;
            if (data.length > 0) {
              var flatData;
              if (Array.isArray(data[0])) {
                shape = arrayShape(data);
                var dim = 1;
                for (var i2 = 1; i2 < shape.length; ++i2) {
                  dim *= shape[i2];
                }
                buffer.dimension = dim;
                flatData = arrayFlatten(data, shape, buffer.dtype);
                initBufferFromTypedArray(buffer, flatData, usage);
                if (persist) {
                  buffer.persistentData = flatData;
                } else {
                  pool.freeType(flatData);
                }
              } else if (typeof data[0] === "number") {
                buffer.dimension = dimension;
                var typedData = pool.allocType(buffer.dtype, data.length);
                copyArray(typedData, data);
                initBufferFromTypedArray(buffer, typedData, usage);
                if (persist) {
                  buffer.persistentData = typedData;
                } else {
                  pool.freeType(typedData);
                }
              } else if (isTypedArray(data[0])) {
                buffer.dimension = data[0].length;
                buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3;
                flatData = arrayFlatten(
                  data,
                  [data.length, data[0].length],
                  buffer.dtype
                );
                initBufferFromTypedArray(buffer, flatData, usage);
                if (persist) {
                  buffer.persistentData = flatData;
                } else {
                  pool.freeType(flatData);
                }
              } else {
                check$1.raise("invalid buffer data");
              }
            }
          } else if (isTypedArray(data)) {
            buffer.dtype = dtype || typedArrayCode(data);
            buffer.dimension = dimension;
            initBufferFromTypedArray(buffer, data, usage);
            if (persist) {
              buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
            }
          } else if (isNDArrayLike(data)) {
            shape = data.shape;
            var stride = data.stride;
            var offset = data.offset;
            var shapeX = 0;
            var shapeY = 0;
            var strideX = 0;
            var strideY = 0;
            if (shape.length === 1) {
              shapeX = shape[0];
              shapeY = 1;
              strideX = stride[0];
              strideY = 0;
            } else if (shape.length === 2) {
              shapeX = shape[0];
              shapeY = shape[1];
              strideX = stride[0];
              strideY = stride[1];
            } else {
              check$1.raise("invalid shape");
            }
            buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3;
            buffer.dimension = shapeY;
            var transposeData2 = pool.allocType(buffer.dtype, shapeX * shapeY);
            transpose(
              transposeData2,
              data.data,
              shapeX,
              shapeY,
              strideX,
              strideY,
              offset
            );
            initBufferFromTypedArray(buffer, transposeData2, usage);
            if (persist) {
              buffer.persistentData = transposeData2;
            } else {
              pool.freeType(transposeData2);
            }
          } else if (data instanceof ArrayBuffer) {
            buffer.dtype = GL_UNSIGNED_BYTE$3;
            buffer.dimension = dimension;
            initBufferFromTypedArray(buffer, data, usage);
            if (persist) {
              buffer.persistentData = new Uint8Array(new Uint8Array(data));
            }
          } else {
            check$1.raise("invalid buffer data");
          }
        }
        function destroy(buffer) {
          stats2.bufferCount--;
          destroyBuffer(buffer);
          var handle = buffer.buffer;
          check$1(handle, "buffer must not be deleted already");
          gl2.deleteBuffer(handle);
          buffer.buffer = null;
          delete bufferSet[buffer.id];
        }
        function createBuffer(options, type, deferInit, persistent) {
          stats2.bufferCount++;
          var buffer = new REGLBuffer(type);
          bufferSet[buffer.id] = buffer;
          function reglBuffer(options2) {
            var usage = GL_STATIC_DRAW;
            var data = null;
            var byteLength = 0;
            var dtype = 0;
            var dimension = 1;
            if (Array.isArray(options2) || isTypedArray(options2) || isNDArrayLike(options2) || options2 instanceof ArrayBuffer) {
              data = options2;
            } else if (typeof options2 === "number") {
              byteLength = options2 | 0;
            } else if (options2) {
              check$1.type(
                options2,
                "object",
                "buffer arguments must be an object, a number or an array"
              );
              if ("data" in options2) {
                check$1(
                  data === null || Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data),
                  "invalid data for buffer"
                );
                data = options2.data;
              }
              if ("usage" in options2) {
                check$1.parameter(options2.usage, usageTypes, "invalid buffer usage");
                usage = usageTypes[options2.usage];
              }
              if ("type" in options2) {
                check$1.parameter(options2.type, glTypes, "invalid buffer type");
                dtype = glTypes[options2.type];
              }
              if ("dimension" in options2) {
                check$1.type(options2.dimension, "number", "invalid dimension");
                dimension = options2.dimension | 0;
              }
              if ("length" in options2) {
                check$1.nni(byteLength, "buffer length must be a nonnegative integer");
                byteLength = options2.length | 0;
              }
            }
            buffer.bind();
            if (!data) {
              if (byteLength)
                gl2.bufferData(buffer.type, byteLength, usage);
              buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
              buffer.usage = usage;
              buffer.dimension = dimension;
              buffer.byteLength = byteLength;
            } else {
              initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
            }
            if (config.profile) {
              buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
            }
            return reglBuffer;
          }
          function setSubData(data, offset) {
            check$1(
              offset + data.byteLength <= buffer.byteLength,
              "invalid buffer subdata call, buffer is too small.  Can't write data of size " + data.byteLength + " starting from offset " + offset + " to a buffer of size " + buffer.byteLength
            );
            gl2.bufferSubData(buffer.type, offset, data);
          }
          function subdata(data, offset_) {
            var offset = (offset_ || 0) | 0;
            var shape;
            buffer.bind();
            if (isTypedArray(data) || data instanceof ArrayBuffer) {
              setSubData(data, offset);
            } else if (Array.isArray(data)) {
              if (data.length > 0) {
                if (typeof data[0] === "number") {
                  var converted = pool.allocType(buffer.dtype, data.length);
                  copyArray(converted, data);
                  setSubData(converted, offset);
                  pool.freeType(converted);
                } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
                  shape = arrayShape(data);
                  var flatData = arrayFlatten(data, shape, buffer.dtype);
                  setSubData(flatData, offset);
                  pool.freeType(flatData);
                } else {
                  check$1.raise("invalid buffer data");
                }
              }
            } else if (isNDArrayLike(data)) {
              shape = data.shape;
              var stride = data.stride;
              var shapeX = 0;
              var shapeY = 0;
              var strideX = 0;
              var strideY = 0;
              if (shape.length === 1) {
                shapeX = shape[0];
                shapeY = 1;
                strideX = stride[0];
                strideY = 0;
              } else if (shape.length === 2) {
                shapeX = shape[0];
                shapeY = shape[1];
                strideX = stride[0];
                strideY = stride[1];
              } else {
                check$1.raise("invalid shape");
              }
              var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);
              var transposeData2 = pool.allocType(dtype, shapeX * shapeY);
              transpose(
                transposeData2,
                data.data,
                shapeX,
                shapeY,
                strideX,
                strideY,
                data.offset
              );
              setSubData(transposeData2, offset);
              pool.freeType(transposeData2);
            } else {
              check$1.raise("invalid data for buffer subdata");
            }
            return reglBuffer;
          }
          if (!deferInit) {
            reglBuffer(options);
          }
          reglBuffer._reglType = "buffer";
          reglBuffer._buffer = buffer;
          reglBuffer.subdata = subdata;
          if (config.profile) {
            reglBuffer.stats = buffer.stats;
          }
          reglBuffer.destroy = function() {
            destroy(buffer);
          };
          return reglBuffer;
        }
        function restoreBuffers() {
          values2(bufferSet).forEach(function(buffer) {
            buffer.buffer = gl2.createBuffer();
            gl2.bindBuffer(buffer.type, buffer.buffer);
            gl2.bufferData(
              buffer.type,
              buffer.persistentData || buffer.byteLength,
              buffer.usage
            );
          });
        }
        if (config.profile) {
          stats2.getTotalBufferSize = function() {
            var total = 0;
            Object.keys(bufferSet).forEach(function(key) {
              total += bufferSet[key].stats.size;
            });
            return total;
          };
        }
        return {
          create: createBuffer,
          createStream,
          destroyStream,
          clear: function() {
            values2(bufferSet).forEach(destroy);
            streamPool.forEach(destroy);
          },
          getBuffer: function(wrapper) {
            if (wrapper && wrapper._buffer instanceof REGLBuffer) {
              return wrapper._buffer;
            }
            return null;
          },
          restore: restoreBuffers,
          _initBuffer: initBufferFromData
        };
      }
      var points = 0;
      var point = 0;
      var lines = 1;
      var line = 1;
      var triangles = 4;
      var triangle2 = 4;
      var primTypes = {
        points,
        point,
        lines,
        line,
        triangles,
        triangle: triangle2,
        "line loop": 2,
        "line strip": 3,
        "triangle strip": 5,
        "triangle fan": 6
      };
      var GL_POINTS = 0;
      var GL_LINES = 1;
      var GL_TRIANGLES = 4;
      var GL_BYTE$2 = 5120;
      var GL_UNSIGNED_BYTE$4 = 5121;
      var GL_SHORT$2 = 5122;
      var GL_UNSIGNED_SHORT$2 = 5123;
      var GL_INT$2 = 5124;
      var GL_UNSIGNED_INT$2 = 5125;
      var GL_ELEMENT_ARRAY_BUFFER = 34963;
      var GL_STREAM_DRAW$1 = 35040;
      var GL_STATIC_DRAW$1 = 35044;
      function wrapElementsState(gl2, extensions, bufferState, stats2) {
        var elementSet = {};
        var elementCount = 0;
        var elementTypes = {
          "uint8": GL_UNSIGNED_BYTE$4,
          "uint16": GL_UNSIGNED_SHORT$2
        };
        if (extensions.oes_element_index_uint) {
          elementTypes.uint32 = GL_UNSIGNED_INT$2;
        }
        function REGLElementBuffer(buffer) {
          this.id = elementCount++;
          elementSet[this.id] = this;
          this.buffer = buffer;
          this.primType = GL_TRIANGLES;
          this.vertCount = 0;
          this.type = 0;
        }
        REGLElementBuffer.prototype.bind = function() {
          this.buffer.bind();
        };
        var bufferPool = [];
        function createElementStream(data) {
          var result = bufferPool.pop();
          if (!result) {
            result = new REGLElementBuffer(bufferState.create(
              null,
              GL_ELEMENT_ARRAY_BUFFER,
              true,
              false
            )._buffer);
          }
          initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
          return result;
        }
        function destroyElementStream(elements) {
          bufferPool.push(elements);
        }
        function initElements(elements, data, usage, prim3, count, byteLength, type) {
          elements.buffer.bind();
          var dtype;
          if (data) {
            var predictedType = type;
            if (!type && (!isTypedArray(data) || isNDArrayLike(data) && !isTypedArray(data.data))) {
              predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$2 : GL_UNSIGNED_SHORT$2;
            }
            bufferState._initBuffer(
              elements.buffer,
              data,
              usage,
              predictedType,
              3
            );
          } else {
            gl2.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
            elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4;
            elements.buffer.usage = usage;
            elements.buffer.dimension = 3;
            elements.buffer.byteLength = byteLength;
          }
          dtype = type;
          if (!type) {
            switch (elements.buffer.dtype) {
              case GL_UNSIGNED_BYTE$4:
              case GL_BYTE$2:
                dtype = GL_UNSIGNED_BYTE$4;
                break;
              case GL_UNSIGNED_SHORT$2:
              case GL_SHORT$2:
                dtype = GL_UNSIGNED_SHORT$2;
                break;
              case GL_UNSIGNED_INT$2:
              case GL_INT$2:
                dtype = GL_UNSIGNED_INT$2;
                break;
              default:
                check$1.raise("unsupported type for element array");
            }
            elements.buffer.dtype = dtype;
          }
          elements.type = dtype;
          check$1(
            dtype !== GL_UNSIGNED_INT$2 || !!extensions.oes_element_index_uint,
            "32 bit element buffers not supported, enable oes_element_index_uint first"
          );
          var vertCount = count;
          if (vertCount < 0) {
            vertCount = elements.buffer.byteLength;
            if (dtype === GL_UNSIGNED_SHORT$2) {
              vertCount >>= 1;
            } else if (dtype === GL_UNSIGNED_INT$2) {
              vertCount >>= 2;
            }
          }
          elements.vertCount = vertCount;
          var primType = prim3;
          if (prim3 < 0) {
            primType = GL_TRIANGLES;
            var dimension = elements.buffer.dimension;
            if (dimension === 1)
              primType = GL_POINTS;
            if (dimension === 2)
              primType = GL_LINES;
            if (dimension === 3)
              primType = GL_TRIANGLES;
          }
          elements.primType = primType;
        }
        function destroyElements(elements) {
          stats2.elementsCount--;
          check$1(elements.buffer !== null, "must not double destroy elements");
          delete elementSet[elements.id];
          elements.buffer.destroy();
          elements.buffer = null;
        }
        function createElements(options, persistent) {
          var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
          var elements = new REGLElementBuffer(buffer._buffer);
          stats2.elementsCount++;
          function reglElements(options2) {
            if (!options2) {
              buffer();
              elements.primType = GL_TRIANGLES;
              elements.vertCount = 0;
              elements.type = GL_UNSIGNED_BYTE$4;
            } else if (typeof options2 === "number") {
              buffer(options2);
              elements.primType = GL_TRIANGLES;
              elements.vertCount = options2 | 0;
              elements.type = GL_UNSIGNED_BYTE$4;
            } else {
              var data = null;
              var usage = GL_STATIC_DRAW$1;
              var primType = -1;
              var vertCount = -1;
              var byteLength = 0;
              var dtype = 0;
              if (Array.isArray(options2) || isTypedArray(options2) || isNDArrayLike(options2)) {
                data = options2;
              } else {
                check$1.type(options2, "object", "invalid arguments for elements");
                if ("data" in options2) {
                  data = options2.data;
                  check$1(
                    Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data),
                    "invalid data for element buffer"
                  );
                }
                if ("usage" in options2) {
                  check$1.parameter(
                    options2.usage,
                    usageTypes,
                    "invalid element buffer usage"
                  );
                  usage = usageTypes[options2.usage];
                }
                if ("primitive" in options2) {
                  check$1.parameter(
                    options2.primitive,
                    primTypes,
                    "invalid element buffer primitive"
                  );
                  primType = primTypes[options2.primitive];
                }
                if ("count" in options2) {
                  check$1(
                    typeof options2.count === "number" && options2.count >= 0,
                    "invalid vertex count for elements"
                  );
                  vertCount = options2.count | 0;
                }
                if ("type" in options2) {
                  check$1.parameter(
                    options2.type,
                    elementTypes,
                    "invalid buffer type"
                  );
                  dtype = elementTypes[options2.type];
                }
                if ("length" in options2) {
                  byteLength = options2.length | 0;
                } else {
                  byteLength = vertCount;
                  if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
                    byteLength *= 2;
                  } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
                    byteLength *= 4;
                  }
                }
              }
              initElements(
                elements,
                data,
                usage,
                primType,
                vertCount,
                byteLength,
                dtype
              );
            }
            return reglElements;
          }
          reglElements(options);
          reglElements._reglType = "elements";
          reglElements._elements = elements;
          reglElements.subdata = function(data, offset) {
            buffer.subdata(data, offset);
            return reglElements;
          };
          reglElements.destroy = function() {
            destroyElements(elements);
          };
          return reglElements;
        }
        return {
          create: createElements,
          createStream: createElementStream,
          destroyStream: destroyElementStream,
          getElements: function(elements) {
            if (typeof elements === "function" && elements._elements instanceof REGLElementBuffer) {
              return elements._elements;
            }
            return null;
          },
          clear: function() {
            values2(elementSet).forEach(destroyElements);
          }
        };
      }
      var FLOAT = new Float32Array(1);
      var INT = new Uint32Array(FLOAT.buffer);
      var GL_UNSIGNED_SHORT$4 = 5123;
      function convertToHalfFloat(array) {
        var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length);
        for (var i2 = 0; i2 < array.length; ++i2) {
          if (isNaN(array[i2])) {
            ushorts[i2] = 65535;
          } else if (array[i2] === Infinity) {
            ushorts[i2] = 31744;
          } else if (array[i2] === -Infinity) {
            ushorts[i2] = 64512;
          } else {
            FLOAT[0] = array[i2];
            var x4 = INT[0];
            var sgn = x4 >>> 31 << 15;
            var exp = (x4 << 1 >>> 24) - 127;
            var frac = x4 >> 13 & (1 << 10) - 1;
            if (exp < -24) {
              ushorts[i2] = sgn;
            } else if (exp < -14) {
              var s2 = -14 - exp;
              ushorts[i2] = sgn + (frac + (1 << 10) >> s2);
            } else if (exp > 15) {
              ushorts[i2] = sgn + 31744;
            } else {
              ushorts[i2] = sgn + (exp + 15 << 10) + frac;
            }
          }
        }
        return ushorts;
      }
      function isArrayLike2(s2) {
        return Array.isArray(s2) || isTypedArray(s2);
      }
      var isPow2$1 = function(v2) {
        return !(v2 & v2 - 1) && !!v2;
      };
      var GL_COMPRESSED_TEXTURE_FORMATS = 34467;
      var GL_TEXTURE_2D$1 = 3553;
      var GL_TEXTURE_CUBE_MAP$1 = 34067;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 34069;
      var GL_RGBA$1 = 6408;
      var GL_ALPHA = 6406;
      var GL_RGB = 6407;
      var GL_LUMINANCE = 6409;
      var GL_LUMINANCE_ALPHA = 6410;
      var GL_RGBA4 = 32854;
      var GL_RGB5_A1 = 32855;
      var GL_RGB565 = 36194;
      var GL_UNSIGNED_SHORT_4_4_4_4$1 = 32819;
      var GL_UNSIGNED_SHORT_5_5_5_1$1 = 32820;
      var GL_UNSIGNED_SHORT_5_6_5$1 = 33635;
      var GL_UNSIGNED_INT_24_8_WEBGL$1 = 34042;
      var GL_DEPTH_COMPONENT = 6402;
      var GL_DEPTH_STENCIL = 34041;
      var GL_SRGB_EXT = 35904;
      var GL_SRGB_ALPHA_EXT = 35906;
      var GL_HALF_FLOAT_OES$1 = 36193;
      var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
      var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
      var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
      var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
      var GL_COMPRESSED_RGB_ATC_WEBGL = 35986;
      var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987;
      var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
      var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
      var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
      var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
      var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
      var GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
      var GL_UNSIGNED_BYTE$5 = 5121;
      var GL_UNSIGNED_SHORT$3 = 5123;
      var GL_UNSIGNED_INT$3 = 5125;
      var GL_FLOAT$4 = 5126;
      var GL_TEXTURE_WRAP_S = 10242;
      var GL_TEXTURE_WRAP_T = 10243;
      var GL_REPEAT = 10497;
      var GL_CLAMP_TO_EDGE$1 = 33071;
      var GL_MIRRORED_REPEAT = 33648;
      var GL_TEXTURE_MAG_FILTER = 10240;
      var GL_TEXTURE_MIN_FILTER = 10241;
      var GL_NEAREST$1 = 9728;
      var GL_LINEAR = 9729;
      var GL_NEAREST_MIPMAP_NEAREST$1 = 9984;
      var GL_LINEAR_MIPMAP_NEAREST$1 = 9985;
      var GL_NEAREST_MIPMAP_LINEAR$1 = 9986;
      var GL_LINEAR_MIPMAP_LINEAR$1 = 9987;
      var GL_GENERATE_MIPMAP_HINT = 33170;
      var GL_DONT_CARE = 4352;
      var GL_FASTEST = 4353;
      var GL_NICEST = 4354;
      var GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046;
      var GL_UNPACK_ALIGNMENT = 3317;
      var GL_UNPACK_FLIP_Y_WEBGL = 37440;
      var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
      var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
      var GL_BROWSER_DEFAULT_WEBGL = 37444;
      var GL_TEXTURE0$1 = 33984;
      var MIPMAP_FILTERS = [
        GL_NEAREST_MIPMAP_NEAREST$1,
        GL_NEAREST_MIPMAP_LINEAR$1,
        GL_LINEAR_MIPMAP_NEAREST$1,
        GL_LINEAR_MIPMAP_LINEAR$1
      ];
      var CHANNELS_FORMAT = [
        0,
        GL_LUMINANCE,
        GL_LUMINANCE_ALPHA,
        GL_RGB,
        GL_RGBA$1
      ];
      var FORMAT_CHANNELS = {};
      FORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
      FORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
      FORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
      FORMAT_CHANNELS[GL_RGBA$1] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;
      function objectName(str) {
        return "[object " + str + "]";
      }
      var CANVAS_CLASS = objectName("HTMLCanvasElement");
      var OFFSCREENCANVAS_CLASS = objectName("OffscreenCanvas");
      var CONTEXT2D_CLASS = objectName("CanvasRenderingContext2D");
      var BITMAP_CLASS = objectName("ImageBitmap");
      var IMAGE_CLASS = objectName("HTMLImageElement");
      var VIDEO_CLASS = objectName("HTMLVideoElement");
      var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
        CANVAS_CLASS,
        OFFSCREENCANVAS_CLASS,
        CONTEXT2D_CLASS,
        BITMAP_CLASS,
        IMAGE_CLASS,
        VIDEO_CLASS
      ]);
      var TYPE_SIZES = [];
      TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1;
      TYPE_SIZES[GL_FLOAT$4] = 4;
      TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;
      TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;
      TYPE_SIZES[GL_UNSIGNED_INT$3] = 4;
      var FORMAT_SIZES_SPECIAL = [];
      FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
      FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
      FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
      FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;
      function isNumericArray(arr) {
        return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === "number");
      }
      function isRectArray(arr) {
        if (!Array.isArray(arr)) {
          return false;
        }
        var width = arr.length;
        if (width === 0 || !isArrayLike2(arr[0])) {
          return false;
        }
        return true;
      }
      function classString(x4) {
        return Object.prototype.toString.call(x4);
      }
      function isCanvasElement(object) {
        return classString(object) === CANVAS_CLASS;
      }
      function isOffscreenCanvas(object) {
        return classString(object) === OFFSCREENCANVAS_CLASS;
      }
      function isContext2D(object) {
        return classString(object) === CONTEXT2D_CLASS;
      }
      function isBitmap(object) {
        return classString(object) === BITMAP_CLASS;
      }
      function isImageElement(object) {
        return classString(object) === IMAGE_CLASS;
      }
      function isVideoElement(object) {
        return classString(object) === VIDEO_CLASS;
      }
      function isPixelData(object) {
        if (!object) {
          return false;
        }
        var className = classString(object);
        if (PIXEL_CLASSES.indexOf(className) >= 0) {
          return true;
        }
        return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);
      }
      function typedArrayCode$1(data) {
        return arrayTypes[Object.prototype.toString.call(data)] | 0;
      }
      function convertData(result, data) {
        var n2 = data.length;
        switch (result.type) {
          case GL_UNSIGNED_BYTE$5:
          case GL_UNSIGNED_SHORT$3:
          case GL_UNSIGNED_INT$3:
          case GL_FLOAT$4:
            var converted = pool.allocType(result.type, n2);
            converted.set(data);
            result.data = converted;
            break;
          case GL_HALF_FLOAT_OES$1:
            result.data = convertToHalfFloat(data);
            break;
          default:
            check$1.raise("unsupported texture type, must specify a typed array");
        }
      }
      function preConvert(image, n2) {
        return pool.allocType(
          image.type === GL_HALF_FLOAT_OES$1 ? GL_FLOAT$4 : image.type,
          n2
        );
      }
      function postConvert(image, data) {
        if (image.type === GL_HALF_FLOAT_OES$1) {
          image.data = convertToHalfFloat(data);
          pool.freeType(data);
        } else {
          image.data = data;
        }
      }
      function transposeData(image, array, strideX, strideY, strideC, offset) {
        var w2 = image.width;
        var h2 = image.height;
        var c3 = image.channels;
        var n2 = w2 * h2 * c3;
        var data = preConvert(image, n2);
        var p2 = 0;
        for (var i2 = 0; i2 < h2; ++i2) {
          for (var j2 = 0; j2 < w2; ++j2) {
            for (var k2 = 0; k2 < c3; ++k2) {
              data[p2++] = array[strideX * j2 + strideY * i2 + strideC * k2 + offset];
            }
          }
        }
        postConvert(image, data);
      }
      function getTextureSize(format, type, width, height, isMipmap, isCube) {
        var s2;
        if (typeof FORMAT_SIZES_SPECIAL[format] !== "undefined") {
          s2 = FORMAT_SIZES_SPECIAL[format];
        } else {
          s2 = FORMAT_CHANNELS[format] * TYPE_SIZES[type];
        }
        if (isCube) {
          s2 *= 6;
        }
        if (isMipmap) {
          var total = 0;
          var w2 = width;
          while (w2 >= 1) {
            total += s2 * w2 * w2;
            w2 /= 2;
          }
          return total;
        } else {
          return s2 * width * height;
        }
      }
      function createTextureSet(gl2, extensions, limits, reglPoll, contextState, stats2, config) {
        var mipmapHint = {
          "don't care": GL_DONT_CARE,
          "dont care": GL_DONT_CARE,
          "nice": GL_NICEST,
          "fast": GL_FASTEST
        };
        var wrapModes = {
          "repeat": GL_REPEAT,
          "clamp": GL_CLAMP_TO_EDGE$1,
          "mirror": GL_MIRRORED_REPEAT
        };
        var magFilters = {
          "nearest": GL_NEAREST$1,
          "linear": GL_LINEAR
        };
        var minFilters = extend2({
          "mipmap": GL_LINEAR_MIPMAP_LINEAR$1,
          "nearest mipmap nearest": GL_NEAREST_MIPMAP_NEAREST$1,
          "linear mipmap nearest": GL_LINEAR_MIPMAP_NEAREST$1,
          "nearest mipmap linear": GL_NEAREST_MIPMAP_LINEAR$1,
          "linear mipmap linear": GL_LINEAR_MIPMAP_LINEAR$1
        }, magFilters);
        var colorSpace = {
          "none": 0,
          "browser": GL_BROWSER_DEFAULT_WEBGL
        };
        var textureTypes = {
          "uint8": GL_UNSIGNED_BYTE$5,
          "rgba4": GL_UNSIGNED_SHORT_4_4_4_4$1,
          "rgb565": GL_UNSIGNED_SHORT_5_6_5$1,
          "rgb5 a1": GL_UNSIGNED_SHORT_5_5_5_1$1
        };
        var textureFormats = {
          "alpha": GL_ALPHA,
          "luminance": GL_LUMINANCE,
          "luminance alpha": GL_LUMINANCE_ALPHA,
          "rgb": GL_RGB,
          "rgba": GL_RGBA$1,
          "rgba4": GL_RGBA4,
          "rgb5 a1": GL_RGB5_A1,
          "rgb565": GL_RGB565
        };
        var compressedTextureFormats = {};
        if (extensions.ext_srgb) {
          textureFormats.srgb = GL_SRGB_EXT;
          textureFormats.srgba = GL_SRGB_ALPHA_EXT;
        }
        if (extensions.oes_texture_float) {
          textureTypes.float32 = textureTypes.float = GL_FLOAT$4;
        }
        if (extensions.oes_texture_half_float) {
          textureTypes["float16"] = textureTypes["half float"] = GL_HALF_FLOAT_OES$1;
        }
        if (extensions.webgl_depth_texture) {
          extend2(textureFormats, {
            "depth": GL_DEPTH_COMPONENT,
            "depth stencil": GL_DEPTH_STENCIL
          });
          extend2(textureTypes, {
            "uint16": GL_UNSIGNED_SHORT$3,
            "uint32": GL_UNSIGNED_INT$3,
            "depth stencil": GL_UNSIGNED_INT_24_8_WEBGL$1
          });
        }
        if (extensions.webgl_compressed_texture_s3tc) {
          extend2(compressedTextureFormats, {
            "rgb s3tc dxt1": GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
            "rgba s3tc dxt1": GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "rgba s3tc dxt3": GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "rgba s3tc dxt5": GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
          });
        }
        if (extensions.webgl_compressed_texture_atc) {
          extend2(compressedTextureFormats, {
            "rgb atc": GL_COMPRESSED_RGB_ATC_WEBGL,
            "rgba atc explicit alpha": GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
            "rgba atc interpolated alpha": GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
          });
        }
        if (extensions.webgl_compressed_texture_pvrtc) {
          extend2(compressedTextureFormats, {
            "rgb pvrtc 4bppv1": GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
            "rgb pvrtc 2bppv1": GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
            "rgba pvrtc 4bppv1": GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
            "rgba pvrtc 2bppv1": GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
          });
        }
        if (extensions.webgl_compressed_texture_etc1) {
          compressedTextureFormats["rgb etc1"] = GL_COMPRESSED_RGB_ETC1_WEBGL;
        }
        var supportedCompressedFormats = Array.prototype.slice.call(
          gl2.getParameter(GL_COMPRESSED_TEXTURE_FORMATS)
        );
        Object.keys(compressedTextureFormats).forEach(function(name) {
          var format = compressedTextureFormats[name];
          if (supportedCompressedFormats.indexOf(format) >= 0) {
            textureFormats[name] = format;
          }
        });
        var supportedFormats = Object.keys(textureFormats);
        limits.textureFormats = supportedFormats;
        var textureFormatsInvert = [];
        Object.keys(textureFormats).forEach(function(key) {
          var val = textureFormats[key];
          textureFormatsInvert[val] = key;
        });
        var textureTypesInvert = [];
        Object.keys(textureTypes).forEach(function(key) {
          var val = textureTypes[key];
          textureTypesInvert[val] = key;
        });
        var magFiltersInvert = [];
        Object.keys(magFilters).forEach(function(key) {
          var val = magFilters[key];
          magFiltersInvert[val] = key;
        });
        var minFiltersInvert = [];
        Object.keys(minFilters).forEach(function(key) {
          var val = minFilters[key];
          minFiltersInvert[val] = key;
        });
        var wrapModesInvert = [];
        Object.keys(wrapModes).forEach(function(key) {
          var val = wrapModes[key];
          wrapModesInvert[val] = key;
        });
        var colorFormats = supportedFormats.reduce(function(color2, key) {
          var glenum = textureFormats[key];
          if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL || extensions.ext_srgb && (glenum === GL_SRGB_EXT || glenum === GL_SRGB_ALPHA_EXT)) {
            color2[glenum] = glenum;
          } else if (glenum === GL_RGB5_A1 || key.indexOf("rgba") >= 0) {
            color2[glenum] = GL_RGBA$1;
          } else {
            color2[glenum] = GL_RGB;
          }
          return color2;
        }, {});
        function TexFlags() {
          this.internalformat = GL_RGBA$1;
          this.format = GL_RGBA$1;
          this.type = GL_UNSIGNED_BYTE$5;
          this.compressed = false;
          this.premultiplyAlpha = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.colorSpace = GL_BROWSER_DEFAULT_WEBGL;
          this.width = 0;
          this.height = 0;
          this.channels = 0;
        }
        function copyFlags(result, other) {
          result.internalformat = other.internalformat;
          result.format = other.format;
          result.type = other.type;
          result.compressed = other.compressed;
          result.premultiplyAlpha = other.premultiplyAlpha;
          result.flipY = other.flipY;
          result.unpackAlignment = other.unpackAlignment;
          result.colorSpace = other.colorSpace;
          result.width = other.width;
          result.height = other.height;
          result.channels = other.channels;
        }
        function parseFlags(flags, options) {
          if (typeof options !== "object" || !options) {
            return;
          }
          if ("premultiplyAlpha" in options) {
            check$1.type(
              options.premultiplyAlpha,
              "boolean",
              "invalid premultiplyAlpha"
            );
            flags.premultiplyAlpha = options.premultiplyAlpha;
          }
          if ("flipY" in options) {
            check$1.type(
              options.flipY,
              "boolean",
              "invalid texture flip"
            );
            flags.flipY = options.flipY;
          }
          if ("alignment" in options) {
            check$1.oneOf(
              options.alignment,
              [1, 2, 4, 8],
              "invalid texture unpack alignment"
            );
            flags.unpackAlignment = options.alignment;
          }
          if ("colorSpace" in options) {
            check$1.parameter(
              options.colorSpace,
              colorSpace,
              "invalid colorSpace"
            );
            flags.colorSpace = colorSpace[options.colorSpace];
          }
          if ("type" in options) {
            var type = options.type;
            check$1(
              extensions.oes_texture_float || !(type === "float" || type === "float32"),
              "you must enable the OES_texture_float extension in order to use floating point textures."
            );
            check$1(
              extensions.oes_texture_half_float || !(type === "half float" || type === "float16"),
              "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."
            );
            check$1(
              extensions.webgl_depth_texture || !(type === "uint16" || type === "uint32" || type === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            );
            check$1.parameter(
              type,
              textureTypes,
              "invalid texture type"
            );
            flags.type = textureTypes[type];
          }
          var w2 = flags.width;
          var h2 = flags.height;
          var c3 = flags.channels;
          var hasChannels = false;
          if ("shape" in options) {
            check$1(
              Array.isArray(options.shape) && options.shape.length >= 2,
              "shape must be an array"
            );
            w2 = options.shape[0];
            h2 = options.shape[1];
            if (options.shape.length === 3) {
              c3 = options.shape[2];
              check$1(c3 > 0 && c3 <= 4, "invalid number of channels");
              hasChannels = true;
            }
            check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid width");
            check$1(h2 >= 0 && h2 <= limits.maxTextureSize, "invalid height");
          } else {
            if ("radius" in options) {
              w2 = h2 = options.radius;
              check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid radius");
            }
            if ("width" in options) {
              w2 = options.width;
              check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid width");
            }
            if ("height" in options) {
              h2 = options.height;
              check$1(h2 >= 0 && h2 <= limits.maxTextureSize, "invalid height");
            }
            if ("channels" in options) {
              c3 = options.channels;
              check$1(c3 > 0 && c3 <= 4, "invalid number of channels");
              hasChannels = true;
            }
          }
          flags.width = w2 | 0;
          flags.height = h2 | 0;
          flags.channels = c3 | 0;
          var hasFormat = false;
          if ("format" in options) {
            var formatStr = options.format;
            check$1(
              extensions.webgl_depth_texture || !(formatStr === "depth" || formatStr === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            );
            check$1.parameter(
              formatStr,
              textureFormats,
              "invalid texture format"
            );
            var internalformat = flags.internalformat = textureFormats[formatStr];
            flags.format = colorFormats[internalformat];
            if (formatStr in textureTypes) {
              if (!("type" in options)) {
                flags.type = textureTypes[formatStr];
              }
            }
            if (formatStr in compressedTextureFormats) {
              flags.compressed = true;
            }
            hasFormat = true;
          }
          if (!hasChannels && hasFormat) {
            flags.channels = FORMAT_CHANNELS[flags.format];
          } else if (hasChannels && !hasFormat) {
            if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
              flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
            }
          } else if (hasFormat && hasChannels) {
            check$1(
              flags.channels === FORMAT_CHANNELS[flags.format],
              "number of channels inconsistent with specified format"
            );
          }
        }
        function setFlags(flags) {
          gl2.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
          gl2.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
          gl2.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
          gl2.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
        }
        function TexImage() {
          TexFlags.call(this);
          this.xOffset = 0;
          this.yOffset = 0;
          this.data = null;
          this.needsFree = false;
          this.element = null;
          this.needsCopy = false;
        }
        function parseImage(image, options) {
          var data = null;
          if (isPixelData(options)) {
            data = options;
          } else if (options) {
            check$1.type(options, "object", "invalid pixel data type");
            parseFlags(image, options);
            if ("x" in options) {
              image.xOffset = options.x | 0;
            }
            if ("y" in options) {
              image.yOffset = options.y | 0;
            }
            if (isPixelData(options.data)) {
              data = options.data;
            }
          }
          check$1(
            !image.compressed || data instanceof Uint8Array,
            "compressed texture data must be stored in a uint8array"
          );
          if (options.copy) {
            check$1(!data, "can not specify copy and data field for the same texture");
            var viewW = contextState.viewportWidth;
            var viewH = contextState.viewportHeight;
            image.width = image.width || viewW - image.xOffset;
            image.height = image.height || viewH - image.yOffset;
            image.needsCopy = true;
            check$1(
              image.xOffset >= 0 && image.xOffset < viewW && image.yOffset >= 0 && image.yOffset < viewH && image.width > 0 && image.width <= viewW && image.height > 0 && image.height <= viewH,
              "copy texture read out of bounds"
            );
          } else if (!data) {
            image.width = image.width || 1;
            image.height = image.height || 1;
            image.channels = image.channels || 4;
          } else if (isTypedArray(data)) {
            image.channels = image.channels || 4;
            image.data = data;
            if (!("type" in options) && image.type === GL_UNSIGNED_BYTE$5) {
              image.type = typedArrayCode$1(data);
            }
          } else if (isNumericArray(data)) {
            image.channels = image.channels || 4;
            convertData(image, data);
            image.alignment = 1;
            image.needsFree = true;
          } else if (isNDArrayLike(data)) {
            var array = data.data;
            if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
              image.type = typedArrayCode$1(array);
            }
            var shape = data.shape;
            var stride = data.stride;
            var shapeX, shapeY, shapeC, strideX, strideY, strideC;
            if (shape.length === 3) {
              shapeC = shape[2];
              strideC = stride[2];
            } else {
              check$1(shape.length === 2, "invalid ndarray pixel data, must be 2 or 3D");
              shapeC = 1;
              strideC = 1;
            }
            shapeX = shape[0];
            shapeY = shape[1];
            strideX = stride[0];
            strideY = stride[1];
            image.alignment = 1;
            image.width = shapeX;
            image.height = shapeY;
            image.channels = shapeC;
            image.format = image.internalformat = CHANNELS_FORMAT[shapeC];
            image.needsFree = true;
            transposeData(image, array, strideX, strideY, strideC, data.offset);
          } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
            if (isCanvasElement(data) || isOffscreenCanvas(data)) {
              image.element = data;
            } else {
              image.element = data.canvas;
            }
            image.width = image.element.width;
            image.height = image.element.height;
            image.channels = 4;
          } else if (isBitmap(data)) {
            image.element = data;
            image.width = data.width;
            image.height = data.height;
            image.channels = 4;
          } else if (isImageElement(data)) {
            image.element = data;
            image.width = data.naturalWidth;
            image.height = data.naturalHeight;
            image.channels = 4;
          } else if (isVideoElement(data)) {
            image.element = data;
            image.width = data.videoWidth;
            image.height = data.videoHeight;
            image.channels = 4;
          } else if (isRectArray(data)) {
            var w2 = image.width || data[0].length;
            var h2 = image.height || data.length;
            var c3 = image.channels;
            if (isArrayLike2(data[0][0])) {
              c3 = c3 || data[0][0].length;
            } else {
              c3 = c3 || 1;
            }
            var arrayShape2 = flattenUtils.shape(data);
            var n2 = 1;
            for (var dd = 0; dd < arrayShape2.length; ++dd) {
              n2 *= arrayShape2[dd];
            }
            var allocData = preConvert(image, n2);
            flattenUtils.flatten(data, arrayShape2, "", allocData);
            postConvert(image, allocData);
            image.alignment = 1;
            image.width = w2;
            image.height = h2;
            image.channels = c3;
            image.format = image.internalformat = CHANNELS_FORMAT[c3];
            image.needsFree = true;
          }
          if (image.type === GL_FLOAT$4) {
            check$1(
              limits.extensions.indexOf("oes_texture_float") >= 0,
              "oes_texture_float extension not enabled"
            );
          } else if (image.type === GL_HALF_FLOAT_OES$1) {
            check$1(
              limits.extensions.indexOf("oes_texture_half_float") >= 0,
              "oes_texture_half_float extension not enabled"
            );
          }
        }
        function setImage(info, target, miplevel) {
          var element = info.element;
          var data = info.data;
          var internalformat = info.internalformat;
          var format = info.format;
          var type = info.type;
          var width = info.width;
          var height = info.height;
          setFlags(info);
          if (element) {
            gl2.texImage2D(target, miplevel, format, format, type, element);
          } else if (info.compressed) {
            gl2.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
          } else if (info.needsCopy) {
            reglPoll();
            gl2.copyTexImage2D(
              target,
              miplevel,
              format,
              info.xOffset,
              info.yOffset,
              width,
              height,
              0
            );
          } else {
            gl2.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null);
          }
        }
        function setSubImage(info, target, x4, y4, miplevel) {
          var element = info.element;
          var data = info.data;
          var internalformat = info.internalformat;
          var format = info.format;
          var type = info.type;
          var width = info.width;
          var height = info.height;
          setFlags(info);
          if (element) {
            gl2.texSubImage2D(
              target,
              miplevel,
              x4,
              y4,
              format,
              type,
              element
            );
          } else if (info.compressed) {
            gl2.compressedTexSubImage2D(
              target,
              miplevel,
              x4,
              y4,
              internalformat,
              width,
              height,
              data
            );
          } else if (info.needsCopy) {
            reglPoll();
            gl2.copyTexSubImage2D(
              target,
              miplevel,
              x4,
              y4,
              info.xOffset,
              info.yOffset,
              width,
              height
            );
          } else {
            gl2.texSubImage2D(
              target,
              miplevel,
              x4,
              y4,
              width,
              height,
              format,
              type,
              data
            );
          }
        }
        var imagePool = [];
        function allocImage() {
          return imagePool.pop() || new TexImage();
        }
        function freeImage(image) {
          if (image.needsFree) {
            pool.freeType(image.data);
          }
          TexImage.call(image);
          imagePool.push(image);
        }
        function MipMap() {
          TexFlags.call(this);
          this.genMipmaps = false;
          this.mipmapHint = GL_DONT_CARE;
          this.mipmask = 0;
          this.images = Array(16);
        }
        function parseMipMapFromShape(mipmap, width, height) {
          var img = mipmap.images[0] = allocImage();
          mipmap.mipmask = 1;
          img.width = mipmap.width = width;
          img.height = mipmap.height = height;
          img.channels = mipmap.channels = 4;
        }
        function parseMipMapFromObject(mipmap, options) {
          var imgData = null;
          if (isPixelData(options)) {
            imgData = mipmap.images[0] = allocImage();
            copyFlags(imgData, mipmap);
            parseImage(imgData, options);
            mipmap.mipmask = 1;
          } else {
            parseFlags(mipmap, options);
            if (Array.isArray(options.mipmap)) {
              var mipData = options.mipmap;
              for (var i2 = 0; i2 < mipData.length; ++i2) {
                imgData = mipmap.images[i2] = allocImage();
                copyFlags(imgData, mipmap);
                imgData.width >>= i2;
                imgData.height >>= i2;
                parseImage(imgData, mipData[i2]);
                mipmap.mipmask |= 1 << i2;
              }
            } else {
              imgData = mipmap.images[0] = allocImage();
              copyFlags(imgData, mipmap);
              parseImage(imgData, options);
              mipmap.mipmask = 1;
            }
          }
          copyFlags(mipmap, mipmap.images[0]);
          if (mipmap.compressed && (mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT)) {
            check$1(
              mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
              "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4"
            );
          }
        }
        function setMipMap(mipmap, target) {
          var images = mipmap.images;
          for (var i2 = 0; i2 < images.length; ++i2) {
            if (!images[i2]) {
              return;
            }
            setImage(images[i2], target, i2);
          }
        }
        var mipPool = [];
        function allocMipMap() {
          var result = mipPool.pop() || new MipMap();
          TexFlags.call(result);
          result.mipmask = 0;
          for (var i2 = 0; i2 < 16; ++i2) {
            result.images[i2] = null;
          }
          return result;
        }
        function freeMipMap(mipmap) {
          var images = mipmap.images;
          for (var i2 = 0; i2 < images.length; ++i2) {
            if (images[i2]) {
              freeImage(images[i2]);
            }
            images[i2] = null;
          }
          mipPool.push(mipmap);
        }
        function TexInfo() {
          this.minFilter = GL_NEAREST$1;
          this.magFilter = GL_NEAREST$1;
          this.wrapS = GL_CLAMP_TO_EDGE$1;
          this.wrapT = GL_CLAMP_TO_EDGE$1;
          this.anisotropic = 1;
          this.genMipmaps = false;
          this.mipmapHint = GL_DONT_CARE;
        }
        function parseTexInfo(info, options) {
          if ("min" in options) {
            var minFilter = options.min;
            check$1.parameter(minFilter, minFilters);
            info.minFilter = minFilters[minFilter];
            if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !("faces" in options)) {
              info.genMipmaps = true;
            }
          }
          if ("mag" in options) {
            var magFilter = options.mag;
            check$1.parameter(magFilter, magFilters);
            info.magFilter = magFilters[magFilter];
          }
          var wrapS = info.wrapS;
          var wrapT = info.wrapT;
          if ("wrap" in options) {
            var wrap2 = options.wrap;
            if (typeof wrap2 === "string") {
              check$1.parameter(wrap2, wrapModes);
              wrapS = wrapT = wrapModes[wrap2];
            } else if (Array.isArray(wrap2)) {
              check$1.parameter(wrap2[0], wrapModes);
              check$1.parameter(wrap2[1], wrapModes);
              wrapS = wrapModes[wrap2[0]];
              wrapT = wrapModes[wrap2[1]];
            }
          } else {
            if ("wrapS" in options) {
              var optWrapS = options.wrapS;
              check$1.parameter(optWrapS, wrapModes);
              wrapS = wrapModes[optWrapS];
            }
            if ("wrapT" in options) {
              var optWrapT = options.wrapT;
              check$1.parameter(optWrapT, wrapModes);
              wrapT = wrapModes[optWrapT];
            }
          }
          info.wrapS = wrapS;
          info.wrapT = wrapT;
          if ("anisotropic" in options) {
            var anisotropic = options.anisotropic;
            check$1(
              typeof anisotropic === "number" && anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
              "aniso samples must be between 1 and "
            );
            info.anisotropic = options.anisotropic;
          }
          if ("mipmap" in options) {
            var hasMipMap = false;
            switch (typeof options.mipmap) {
              case "string":
                check$1.parameter(
                  options.mipmap,
                  mipmapHint,
                  "invalid mipmap hint"
                );
                info.mipmapHint = mipmapHint[options.mipmap];
                info.genMipmaps = true;
                hasMipMap = true;
                break;
              case "boolean":
                hasMipMap = info.genMipmaps = options.mipmap;
                break;
              case "object":
                check$1(Array.isArray(options.mipmap), "invalid mipmap type");
                info.genMipmaps = false;
                hasMipMap = true;
                break;
              default:
                check$1.raise("invalid mipmap type");
            }
            if (hasMipMap && !("min" in options)) {
              info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;
            }
          }
        }
        function setTexInfo(info, target) {
          gl2.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
          gl2.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
          gl2.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
          gl2.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
          if (extensions.ext_texture_filter_anisotropic) {
            gl2.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
          }
          if (info.genMipmaps) {
            gl2.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
            gl2.generateMipmap(target);
          }
        }
        var textureCount = 0;
        var textureSet = {};
        var numTexUnits = limits.maxTextureUnits;
        var textureUnits = Array(numTexUnits).map(function() {
          return null;
        });
        function REGLTexture(target) {
          TexFlags.call(this);
          this.mipmask = 0;
          this.internalformat = GL_RGBA$1;
          this.id = textureCount++;
          this.refCount = 1;
          this.target = target;
          this.texture = gl2.createTexture();
          this.unit = -1;
          this.bindCount = 0;
          this.texInfo = new TexInfo();
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        function tempBind(texture) {
          gl2.activeTexture(GL_TEXTURE0$1);
          gl2.bindTexture(texture.target, texture.texture);
        }
        function tempRestore() {
          var prev = textureUnits[0];
          if (prev) {
            gl2.bindTexture(prev.target, prev.texture);
          } else {
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
          }
        }
        function destroy(texture) {
          var handle = texture.texture;
          check$1(handle, "must not double destroy texture");
          var unit = texture.unit;
          var target = texture.target;
          if (unit >= 0) {
            gl2.activeTexture(GL_TEXTURE0$1 + unit);
            gl2.bindTexture(target, null);
            textureUnits[unit] = null;
          }
          gl2.deleteTexture(handle);
          texture.texture = null;
          texture.params = null;
          texture.pixels = null;
          texture.refCount = 0;
          delete textureSet[texture.id];
          stats2.textureCount--;
        }
        extend2(REGLTexture.prototype, {
          bind: function() {
            var texture = this;
            texture.bindCount += 1;
            var unit = texture.unit;
            if (unit < 0) {
              for (var i2 = 0; i2 < numTexUnits; ++i2) {
                var other = textureUnits[i2];
                if (other) {
                  if (other.bindCount > 0) {
                    continue;
                  }
                  other.unit = -1;
                }
                textureUnits[i2] = texture;
                unit = i2;
                break;
              }
              if (unit >= numTexUnits) {
                check$1.raise("insufficient number of texture units");
              }
              if (config.profile && stats2.maxTextureUnits < unit + 1) {
                stats2.maxTextureUnits = unit + 1;
              }
              texture.unit = unit;
              gl2.activeTexture(GL_TEXTURE0$1 + unit);
              gl2.bindTexture(texture.target, texture.texture);
            }
            return unit;
          },
          unbind: function() {
            this.bindCount -= 1;
          },
          decRef: function() {
            if (--this.refCount <= 0) {
              destroy(this);
            }
          }
        });
        function createTexture2D(a3, b2) {
          var texture = new REGLTexture(GL_TEXTURE_2D$1);
          textureSet[texture.id] = texture;
          stats2.textureCount++;
          function reglTexture2D(a4, b3) {
            var texInfo = texture.texInfo;
            TexInfo.call(texInfo);
            var mipData = allocMipMap();
            if (typeof a4 === "number") {
              if (typeof b3 === "number") {
                parseMipMapFromShape(mipData, a4 | 0, b3 | 0);
              } else {
                parseMipMapFromShape(mipData, a4 | 0, a4 | 0);
              }
            } else if (a4) {
              check$1.type(a4, "object", "invalid arguments to regl.texture");
              parseTexInfo(texInfo, a4);
              parseMipMapFromObject(mipData, a4);
            } else {
              parseMipMapFromShape(mipData, 1, 1);
            }
            if (texInfo.genMipmaps) {
              mipData.mipmask = (mipData.width << 1) - 1;
            }
            texture.mipmask = mipData.mipmask;
            copyFlags(texture, mipData);
            check$1.texture2D(texInfo, mipData, limits);
            texture.internalformat = mipData.internalformat;
            reglTexture2D.width = mipData.width;
            reglTexture2D.height = mipData.height;
            tempBind(texture);
            setMipMap(mipData, GL_TEXTURE_2D$1);
            setTexInfo(texInfo, GL_TEXTURE_2D$1);
            tempRestore();
            freeMipMap(mipData);
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                mipData.width,
                mipData.height,
                texInfo.genMipmaps,
                false
              );
            }
            reglTexture2D.format = textureFormatsInvert[texture.internalformat];
            reglTexture2D.type = textureTypesInvert[texture.type];
            reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
            reglTexture2D.min = minFiltersInvert[texInfo.minFilter];
            reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
            reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];
            return reglTexture2D;
          }
          function subimage(image, x_, y_, level_) {
            check$1(!!image, "must specify image data");
            var x4 = x_ | 0;
            var y4 = y_ | 0;
            var level = level_ | 0;
            var imageData = allocImage();
            copyFlags(imageData, texture);
            imageData.width = 0;
            imageData.height = 0;
            parseImage(imageData, image);
            imageData.width = imageData.width || (texture.width >> level) - x4;
            imageData.height = imageData.height || (texture.height >> level) - y4;
            check$1(
              texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat,
              "incompatible format for texture.subimage"
            );
            check$1(
              x4 >= 0 && y4 >= 0 && x4 + imageData.width <= texture.width && y4 + imageData.height <= texture.height,
              "texture.subimage write out of bounds"
            );
            check$1(
              texture.mipmask & 1 << level,
              "missing mipmap data"
            );
            check$1(
              imageData.data || imageData.element || imageData.needsCopy,
              "missing image data"
            );
            tempBind(texture);
            setSubImage(imageData, GL_TEXTURE_2D$1, x4, y4, level);
            tempRestore();
            freeImage(imageData);
            return reglTexture2D;
          }
          function resize(w_, h_) {
            var w2 = w_ | 0;
            var h2 = h_ | 0 || w2;
            if (w2 === texture.width && h2 === texture.height) {
              return reglTexture2D;
            }
            reglTexture2D.width = texture.width = w2;
            reglTexture2D.height = texture.height = h2;
            tempBind(texture);
            for (var i2 = 0; texture.mipmask >> i2; ++i2) {
              var _w = w2 >> i2;
              var _h = h2 >> i2;
              if (!_w || !_h)
                break;
              gl2.texImage2D(
                GL_TEXTURE_2D$1,
                i2,
                texture.format,
                _w,
                _h,
                0,
                texture.format,
                texture.type,
                null
              );
            }
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                w2,
                h2,
                false,
                false
              );
            }
            return reglTexture2D;
          }
          reglTexture2D(a3, b2);
          reglTexture2D.subimage = subimage;
          reglTexture2D.resize = resize;
          reglTexture2D._reglType = "texture2d";
          reglTexture2D._texture = texture;
          if (config.profile) {
            reglTexture2D.stats = texture.stats;
          }
          reglTexture2D.destroy = function() {
            texture.decRef();
          };
          return reglTexture2D;
        }
        function createTextureCube(a0, a1, a22, a3, a4, a5) {
          var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);
          textureSet[texture.id] = texture;
          stats2.cubeCount++;
          var faces = new Array(6);
          function reglTextureCube(a02, a12, a23, a32, a42, a52) {
            var i2;
            var texInfo = texture.texInfo;
            TexInfo.call(texInfo);
            for (i2 = 0; i2 < 6; ++i2) {
              faces[i2] = allocMipMap();
            }
            if (typeof a02 === "number" || !a02) {
              var s2 = a02 | 0 || 1;
              for (i2 = 0; i2 < 6; ++i2) {
                parseMipMapFromShape(faces[i2], s2, s2);
              }
            } else if (typeof a02 === "object") {
              if (a12) {
                parseMipMapFromObject(faces[0], a02);
                parseMipMapFromObject(faces[1], a12);
                parseMipMapFromObject(faces[2], a23);
                parseMipMapFromObject(faces[3], a32);
                parseMipMapFromObject(faces[4], a42);
                parseMipMapFromObject(faces[5], a52);
              } else {
                parseTexInfo(texInfo, a02);
                parseFlags(texture, a02);
                if ("faces" in a02) {
                  var faceInput = a02.faces;
                  check$1(
                    Array.isArray(faceInput) && faceInput.length === 6,
                    "cube faces must be a length 6 array"
                  );
                  for (i2 = 0; i2 < 6; ++i2) {
                    check$1(
                      typeof faceInput[i2] === "object" && !!faceInput[i2],
                      "invalid input for cube map face"
                    );
                    copyFlags(faces[i2], texture);
                    parseMipMapFromObject(faces[i2], faceInput[i2]);
                  }
                } else {
                  for (i2 = 0; i2 < 6; ++i2) {
                    parseMipMapFromObject(faces[i2], a02);
                  }
                }
              }
            } else {
              check$1.raise("invalid arguments to cube map");
            }
            copyFlags(texture, faces[0]);
            if (!limits.npotTextureCube) {
              check$1(isPow2$1(texture.width) && isPow2$1(texture.height), "your browser does not support non power or two texture dimensions");
            }
            if (texInfo.genMipmaps) {
              texture.mipmask = (faces[0].width << 1) - 1;
            } else {
              texture.mipmask = faces[0].mipmask;
            }
            check$1.textureCube(texture, texInfo, faces, limits);
            texture.internalformat = faces[0].internalformat;
            reglTextureCube.width = faces[0].width;
            reglTextureCube.height = faces[0].height;
            tempBind(texture);
            for (i2 = 0; i2 < 6; ++i2) {
              setMipMap(faces[i2], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i2);
            }
            setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                reglTextureCube.width,
                reglTextureCube.height,
                texInfo.genMipmaps,
                true
              );
            }
            reglTextureCube.format = textureFormatsInvert[texture.internalformat];
            reglTextureCube.type = textureTypesInvert[texture.type];
            reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
            reglTextureCube.min = minFiltersInvert[texInfo.minFilter];
            reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
            reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];
            for (i2 = 0; i2 < 6; ++i2) {
              freeMipMap(faces[i2]);
            }
            return reglTextureCube;
          }
          function subimage(face, image, x_, y_, level_) {
            check$1(!!image, "must specify image data");
            check$1(typeof face === "number" && face === (face | 0) && face >= 0 && face < 6, "invalid face");
            var x4 = x_ | 0;
            var y4 = y_ | 0;
            var level = level_ | 0;
            var imageData = allocImage();
            copyFlags(imageData, texture);
            imageData.width = 0;
            imageData.height = 0;
            parseImage(imageData, image);
            imageData.width = imageData.width || (texture.width >> level) - x4;
            imageData.height = imageData.height || (texture.height >> level) - y4;
            check$1(
              texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat,
              "incompatible format for texture.subimage"
            );
            check$1(
              x4 >= 0 && y4 >= 0 && x4 + imageData.width <= texture.width && y4 + imageData.height <= texture.height,
              "texture.subimage write out of bounds"
            );
            check$1(
              texture.mipmask & 1 << level,
              "missing mipmap data"
            );
            check$1(
              imageData.data || imageData.element || imageData.needsCopy,
              "missing image data"
            );
            tempBind(texture);
            setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x4, y4, level);
            tempRestore();
            freeImage(imageData);
            return reglTextureCube;
          }
          function resize(radius_) {
            var radius = radius_ | 0;
            if (radius === texture.width) {
              return;
            }
            reglTextureCube.width = texture.width = radius;
            reglTextureCube.height = texture.height = radius;
            tempBind(texture);
            for (var i2 = 0; i2 < 6; ++i2) {
              for (var j2 = 0; texture.mipmask >> j2; ++j2) {
                gl2.texImage2D(
                  GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i2,
                  j2,
                  texture.format,
                  radius >> j2,
                  radius >> j2,
                  0,
                  texture.format,
                  texture.type,
                  null
                );
              }
            }
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                reglTextureCube.width,
                reglTextureCube.height,
                false,
                true
              );
            }
            return reglTextureCube;
          }
          reglTextureCube(a0, a1, a22, a3, a4, a5);
          reglTextureCube.subimage = subimage;
          reglTextureCube.resize = resize;
          reglTextureCube._reglType = "textureCube";
          reglTextureCube._texture = texture;
          if (config.profile) {
            reglTextureCube.stats = texture.stats;
          }
          reglTextureCube.destroy = function() {
            texture.decRef();
          };
          return reglTextureCube;
        }
        function destroyTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            gl2.activeTexture(GL_TEXTURE0$1 + i2);
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
            textureUnits[i2] = null;
          }
          values2(textureSet).forEach(destroy);
          stats2.cubeCount = 0;
          stats2.textureCount = 0;
        }
        if (config.profile) {
          stats2.getTotalTextureSize = function() {
            var total = 0;
            Object.keys(textureSet).forEach(function(key) {
              total += textureSet[key].stats.size;
            });
            return total;
          };
        }
        function restoreTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            var tex = textureUnits[i2];
            if (tex) {
              tex.bindCount = 0;
              tex.unit = -1;
              textureUnits[i2] = null;
            }
          }
          values2(textureSet).forEach(function(texture) {
            texture.texture = gl2.createTexture();
            gl2.bindTexture(texture.target, texture.texture);
            for (var i3 = 0; i3 < 32; ++i3) {
              if ((texture.mipmask & 1 << i3) === 0) {
                continue;
              }
              if (texture.target === GL_TEXTURE_2D$1) {
                gl2.texImage2D(
                  GL_TEXTURE_2D$1,
                  i3,
                  texture.internalformat,
                  texture.width >> i3,
                  texture.height >> i3,
                  0,
                  texture.internalformat,
                  texture.type,
                  null
                );
              } else {
                for (var j2 = 0; j2 < 6; ++j2) {
                  gl2.texImage2D(
                    GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j2,
                    i3,
                    texture.internalformat,
                    texture.width >> i3,
                    texture.height >> i3,
                    0,
                    texture.internalformat,
                    texture.type,
                    null
                  );
                }
              }
            }
            setTexInfo(texture.texInfo, texture.target);
          });
        }
        function refreshTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            var tex = textureUnits[i2];
            if (tex) {
              tex.bindCount = 0;
              tex.unit = -1;
              textureUnits[i2] = null;
            }
            gl2.activeTexture(GL_TEXTURE0$1 + i2);
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
            gl2.bindTexture(GL_TEXTURE_CUBE_MAP$1, null);
          }
        }
        return {
          create2D: createTexture2D,
          createCube: createTextureCube,
          clear: destroyTextures,
          getTexture: function(wrapper) {
            return null;
          },
          restore: restoreTextures,
          refresh: refreshTextures
        };
      }
      var GL_RENDERBUFFER = 36161;
      var GL_RGBA4$1 = 32854;
      var GL_RGB5_A1$1 = 32855;
      var GL_RGB565$1 = 36194;
      var GL_DEPTH_COMPONENT16 = 33189;
      var GL_STENCIL_INDEX8 = 36168;
      var GL_DEPTH_STENCIL$1 = 34041;
      var GL_SRGB8_ALPHA8_EXT = 35907;
      var GL_RGBA32F_EXT = 34836;
      var GL_RGBA16F_EXT = 34842;
      var GL_RGB16F_EXT = 34843;
      var FORMAT_SIZES = [];
      FORMAT_SIZES[GL_RGBA4$1] = 2;
      FORMAT_SIZES[GL_RGB5_A1$1] = 2;
      FORMAT_SIZES[GL_RGB565$1] = 2;
      FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
      FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
      FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;
      FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
      FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
      FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
      FORMAT_SIZES[GL_RGB16F_EXT] = 6;
      function getRenderbufferSize(format, width, height) {
        return FORMAT_SIZES[format] * width * height;
      }
      var wrapRenderbuffers = function(gl2, extensions, limits, stats2, config) {
        var formatTypes = {
          "rgba4": GL_RGBA4$1,
          "rgb565": GL_RGB565$1,
          "rgb5 a1": GL_RGB5_A1$1,
          "depth": GL_DEPTH_COMPONENT16,
          "stencil": GL_STENCIL_INDEX8,
          "depth stencil": GL_DEPTH_STENCIL$1
        };
        if (extensions.ext_srgb) {
          formatTypes["srgba"] = GL_SRGB8_ALPHA8_EXT;
        }
        if (extensions.ext_color_buffer_half_float) {
          formatTypes["rgba16f"] = GL_RGBA16F_EXT;
          formatTypes["rgb16f"] = GL_RGB16F_EXT;
        }
        if (extensions.webgl_color_buffer_float) {
          formatTypes["rgba32f"] = GL_RGBA32F_EXT;
        }
        var formatTypesInvert = [];
        Object.keys(formatTypes).forEach(function(key) {
          var val = formatTypes[key];
          formatTypesInvert[val] = key;
        });
        var renderbufferCount = 0;
        var renderbufferSet = {};
        function REGLRenderbuffer(renderbuffer) {
          this.id = renderbufferCount++;
          this.refCount = 1;
          this.renderbuffer = renderbuffer;
          this.format = GL_RGBA4$1;
          this.width = 0;
          this.height = 0;
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        REGLRenderbuffer.prototype.decRef = function() {
          if (--this.refCount <= 0) {
            destroy(this);
          }
        };
        function destroy(rb) {
          var handle = rb.renderbuffer;
          check$1(handle, "must not double destroy renderbuffer");
          gl2.bindRenderbuffer(GL_RENDERBUFFER, null);
          gl2.deleteRenderbuffer(handle);
          rb.renderbuffer = null;
          rb.refCount = 0;
          delete renderbufferSet[rb.id];
          stats2.renderbufferCount--;
        }
        function createRenderbuffer(a3, b2) {
          var renderbuffer = new REGLRenderbuffer(gl2.createRenderbuffer());
          renderbufferSet[renderbuffer.id] = renderbuffer;
          stats2.renderbufferCount++;
          function reglRenderbuffer(a4, b3) {
            var w2 = 0;
            var h2 = 0;
            var format = GL_RGBA4$1;
            if (typeof a4 === "object" && a4) {
              var options = a4;
              if ("shape" in options) {
                var shape = options.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid renderbuffer shape"
                );
                w2 = shape[0] | 0;
                h2 = shape[1] | 0;
              } else {
                if ("radius" in options) {
                  w2 = h2 = options.radius | 0;
                }
                if ("width" in options) {
                  w2 = options.width | 0;
                }
                if ("height" in options) {
                  h2 = options.height | 0;
                }
              }
              if ("format" in options) {
                check$1.parameter(
                  options.format,
                  formatTypes,
                  "invalid renderbuffer format"
                );
                format = formatTypes[options.format];
              }
            } else if (typeof a4 === "number") {
              w2 = a4 | 0;
              if (typeof b3 === "number") {
                h2 = b3 | 0;
              } else {
                h2 = w2;
              }
            } else if (!a4) {
              w2 = h2 = 1;
            } else {
              check$1.raise("invalid arguments to renderbuffer constructor");
            }
            check$1(
              w2 > 0 && h2 > 0 && w2 <= limits.maxRenderbufferSize && h2 <= limits.maxRenderbufferSize,
              "invalid renderbuffer size"
            );
            if (w2 === renderbuffer.width && h2 === renderbuffer.height && format === renderbuffer.format) {
              return;
            }
            reglRenderbuffer.width = renderbuffer.width = w2;
            reglRenderbuffer.height = renderbuffer.height = h2;
            renderbuffer.format = format;
            gl2.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, format, w2, h2);
            check$1(
              gl2.getError() === 0,
              "invalid render buffer format"
            );
            if (config.profile) {
              renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
            }
            reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];
            return reglRenderbuffer;
          }
          function resize(w_, h_) {
            var w2 = w_ | 0;
            var h2 = h_ | 0 || w2;
            if (w2 === renderbuffer.width && h2 === renderbuffer.height) {
              return reglRenderbuffer;
            }
            check$1(
              w2 > 0 && h2 > 0 && w2 <= limits.maxRenderbufferSize && h2 <= limits.maxRenderbufferSize,
              "invalid renderbuffer size"
            );
            reglRenderbuffer.width = renderbuffer.width = w2;
            reglRenderbuffer.height = renderbuffer.height = h2;
            gl2.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w2, h2);
            check$1(
              gl2.getError() === 0,
              "invalid render buffer format"
            );
            if (config.profile) {
              renderbuffer.stats.size = getRenderbufferSize(
                renderbuffer.format,
                renderbuffer.width,
                renderbuffer.height
              );
            }
            return reglRenderbuffer;
          }
          reglRenderbuffer(a3, b2);
          reglRenderbuffer.resize = resize;
          reglRenderbuffer._reglType = "renderbuffer";
          reglRenderbuffer._renderbuffer = renderbuffer;
          if (config.profile) {
            reglRenderbuffer.stats = renderbuffer.stats;
          }
          reglRenderbuffer.destroy = function() {
            renderbuffer.decRef();
          };
          return reglRenderbuffer;
        }
        if (config.profile) {
          stats2.getTotalRenderbufferSize = function() {
            var total = 0;
            Object.keys(renderbufferSet).forEach(function(key) {
              total += renderbufferSet[key].stats.size;
            });
            return total;
          };
        }
        function restoreRenderbuffers() {
          values2(renderbufferSet).forEach(function(rb) {
            rb.renderbuffer = gl2.createRenderbuffer();
            gl2.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
          });
          gl2.bindRenderbuffer(GL_RENDERBUFFER, null);
        }
        return {
          create: createRenderbuffer,
          clear: function() {
            values2(renderbufferSet).forEach(destroy);
          },
          restore: restoreRenderbuffers
        };
      };
      var GL_FRAMEBUFFER$1 = 36160;
      var GL_RENDERBUFFER$1 = 36161;
      var GL_TEXTURE_2D$2 = 3553;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 34069;
      var GL_COLOR_ATTACHMENT0$1 = 36064;
      var GL_DEPTH_ATTACHMENT = 36096;
      var GL_STENCIL_ATTACHMENT = 36128;
      var GL_DEPTH_STENCIL_ATTACHMENT = 33306;
      var GL_FRAMEBUFFER_COMPLETE$1 = 36053;
      var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
      var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
      var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
      var GL_FRAMEBUFFER_UNSUPPORTED = 36061;
      var GL_HALF_FLOAT_OES$2 = 36193;
      var GL_UNSIGNED_BYTE$6 = 5121;
      var GL_FLOAT$5 = 5126;
      var GL_RGB$1 = 6407;
      var GL_RGBA$2 = 6408;
      var GL_DEPTH_COMPONENT$1 = 6402;
      var colorTextureFormatEnums = [
        GL_RGB$1,
        GL_RGBA$2
      ];
      var textureFormatChannels = [];
      textureFormatChannels[GL_RGBA$2] = 4;
      textureFormatChannels[GL_RGB$1] = 3;
      var textureTypeSizes = [];
      textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1;
      textureTypeSizes[GL_FLOAT$5] = 4;
      textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;
      var GL_RGBA4$2 = 32854;
      var GL_RGB5_A1$2 = 32855;
      var GL_RGB565$2 = 36194;
      var GL_DEPTH_COMPONENT16$1 = 33189;
      var GL_STENCIL_INDEX8$1 = 36168;
      var GL_DEPTH_STENCIL$2 = 34041;
      var GL_SRGB8_ALPHA8_EXT$1 = 35907;
      var GL_RGBA32F_EXT$1 = 34836;
      var GL_RGBA16F_EXT$1 = 34842;
      var GL_RGB16F_EXT$1 = 34843;
      var colorRenderbufferFormatEnums = [
        GL_RGBA4$2,
        GL_RGB5_A1$2,
        GL_RGB565$2,
        GL_SRGB8_ALPHA8_EXT$1,
        GL_RGBA16F_EXT$1,
        GL_RGB16F_EXT$1,
        GL_RGBA32F_EXT$1
      ];
      var statusCode = {};
      statusCode[GL_FRAMEBUFFER_COMPLETE$1] = "complete";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = "incomplete attachment";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = "incomplete dimensions";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = "incomplete, missing attachment";
      statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = "unsupported";
      function wrapFBOState(gl2, extensions, limits, textureState, renderbufferState, stats2) {
        var framebufferState = {
          cur: null,
          next: null,
          dirty: false,
          setFBO: null
        };
        var colorTextureFormats = ["rgba"];
        var colorRenderbufferFormats = ["rgba4", "rgb565", "rgb5 a1"];
        if (extensions.ext_srgb) {
          colorRenderbufferFormats.push("srgba");
        }
        if (extensions.ext_color_buffer_half_float) {
          colorRenderbufferFormats.push("rgba16f", "rgb16f");
        }
        if (extensions.webgl_color_buffer_float) {
          colorRenderbufferFormats.push("rgba32f");
        }
        var colorTypes = ["uint8"];
        if (extensions.oes_texture_half_float) {
          colorTypes.push("half float", "float16");
        }
        if (extensions.oes_texture_float) {
          colorTypes.push("float", "float32");
        }
        function FramebufferAttachment(target, texture, renderbuffer) {
          this.target = target;
          this.texture = texture;
          this.renderbuffer = renderbuffer;
          var w2 = 0;
          var h2 = 0;
          if (texture) {
            w2 = texture.width;
            h2 = texture.height;
          } else if (renderbuffer) {
            w2 = renderbuffer.width;
            h2 = renderbuffer.height;
          }
          this.width = w2;
          this.height = h2;
        }
        function decRef(attachment) {
          if (attachment) {
            if (attachment.texture) {
              attachment.texture._texture.decRef();
            }
            if (attachment.renderbuffer) {
              attachment.renderbuffer._renderbuffer.decRef();
            }
          }
        }
        function incRefAndCheckShape(attachment, width, height) {
          if (!attachment) {
            return;
          }
          if (attachment.texture) {
            var texture = attachment.texture._texture;
            var tw = Math.max(1, texture.width);
            var th = Math.max(1, texture.height);
            check$1(
              tw === width && th === height,
              "inconsistent width/height for supplied texture"
            );
            texture.refCount += 1;
          } else {
            var renderbuffer = attachment.renderbuffer._renderbuffer;
            check$1(
              renderbuffer.width === width && renderbuffer.height === height,
              "inconsistent width/height for renderbuffer"
            );
            renderbuffer.refCount += 1;
          }
        }
        function attach(location, attachment) {
          if (attachment) {
            if (attachment.texture) {
              gl2.framebufferTexture2D(
                GL_FRAMEBUFFER$1,
                location,
                attachment.target,
                attachment.texture._texture.texture,
                0
              );
            } else {
              gl2.framebufferRenderbuffer(
                GL_FRAMEBUFFER$1,
                location,
                GL_RENDERBUFFER$1,
                attachment.renderbuffer._renderbuffer.renderbuffer
              );
            }
          }
        }
        function parseAttachment(attachment) {
          var target = GL_TEXTURE_2D$2;
          var texture = null;
          var renderbuffer = null;
          var data = attachment;
          if (typeof attachment === "object") {
            data = attachment.data;
            if ("target" in attachment) {
              target = attachment.target | 0;
            }
          }
          check$1.type(data, "function", "invalid attachment data");
          var type = data._reglType;
          if (type === "texture2d") {
            texture = data;
            check$1(target === GL_TEXTURE_2D$2);
          } else if (type === "textureCube") {
            texture = data;
            check$1(
              target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 && target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
              "invalid cube map target"
            );
          } else if (type === "renderbuffer") {
            renderbuffer = data;
            target = GL_RENDERBUFFER$1;
          } else {
            check$1.raise("invalid regl object for attachment");
          }
          return new FramebufferAttachment(target, texture, renderbuffer);
        }
        function allocAttachment(width, height, isTexture, format, type) {
          if (isTexture) {
            var texture = textureState.create2D({
              width,
              height,
              format,
              type
            });
            texture._texture.refCount = 0;
            return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null);
          } else {
            var rb = renderbufferState.create({
              width,
              height,
              format
            });
            rb._renderbuffer.refCount = 0;
            return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);
          }
        }
        function unwrapAttachment(attachment) {
          return attachment && (attachment.texture || attachment.renderbuffer);
        }
        function resizeAttachment(attachment, w2, h2) {
          if (attachment) {
            if (attachment.texture) {
              attachment.texture.resize(w2, h2);
            } else if (attachment.renderbuffer) {
              attachment.renderbuffer.resize(w2, h2);
            }
            attachment.width = w2;
            attachment.height = h2;
          }
        }
        var framebufferCount = 0;
        var framebufferSet = {};
        function REGLFramebuffer() {
          this.id = framebufferCount++;
          framebufferSet[this.id] = this;
          this.framebuffer = gl2.createFramebuffer();
          this.width = 0;
          this.height = 0;
          this.colorAttachments = [];
          this.depthAttachment = null;
          this.stencilAttachment = null;
          this.depthStencilAttachment = null;
        }
        function decFBORefs(framebuffer) {
          framebuffer.colorAttachments.forEach(decRef);
          decRef(framebuffer.depthAttachment);
          decRef(framebuffer.stencilAttachment);
          decRef(framebuffer.depthStencilAttachment);
        }
        function destroy(framebuffer) {
          var handle = framebuffer.framebuffer;
          check$1(handle, "must not double destroy framebuffer");
          gl2.deleteFramebuffer(handle);
          framebuffer.framebuffer = null;
          stats2.framebufferCount--;
          delete framebufferSet[framebuffer.id];
        }
        function updateFramebuffer(framebuffer) {
          var i2;
          gl2.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);
          var colorAttachments = framebuffer.colorAttachments;
          for (i2 = 0; i2 < colorAttachments.length; ++i2) {
            attach(GL_COLOR_ATTACHMENT0$1 + i2, colorAttachments[i2]);
          }
          for (i2 = colorAttachments.length; i2 < limits.maxColorAttachments; ++i2) {
            gl2.framebufferTexture2D(
              GL_FRAMEBUFFER$1,
              GL_COLOR_ATTACHMENT0$1 + i2,
              GL_TEXTURE_2D$2,
              null,
              0
            );
          }
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_DEPTH_STENCIL_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_DEPTH_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_STENCIL_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
          attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
          attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);
          var status = gl2.checkFramebufferStatus(GL_FRAMEBUFFER$1);
          if (!gl2.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
            check$1.raise("framebuffer configuration not supported, status = " + statusCode[status]);
          }
          gl2.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);
          framebufferState.cur = framebufferState.next;
          gl2.getError();
        }
        function createFBO(a0, a1) {
          var framebuffer = new REGLFramebuffer();
          stats2.framebufferCount++;
          function reglFramebuffer(a3, b2) {
            var i2;
            check$1(
              framebufferState.next !== framebuffer,
              "can not update framebuffer which is currently in use"
            );
            var width = 0;
            var height = 0;
            var needsDepth = true;
            var needsStencil = true;
            var colorBuffer = null;
            var colorTexture = true;
            var colorFormat = "rgba";
            var colorType = "uint8";
            var colorCount = 1;
            var depthBuffer = null;
            var stencilBuffer = null;
            var depthStencilBuffer = null;
            var depthStencilTexture = false;
            if (typeof a3 === "number") {
              width = a3 | 0;
              height = b2 | 0 || width;
            } else if (!a3) {
              width = height = 1;
            } else {
              check$1.type(a3, "object", "invalid arguments for framebuffer");
              var options = a3;
              if ("shape" in options) {
                var shape = options.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid shape for framebuffer"
                );
                width = shape[0];
                height = shape[1];
              } else {
                if ("radius" in options) {
                  width = height = options.radius;
                }
                if ("width" in options) {
                  width = options.width;
                }
                if ("height" in options) {
                  height = options.height;
                }
              }
              if ("color" in options || "colors" in options) {
                colorBuffer = options.color || options.colors;
                if (Array.isArray(colorBuffer)) {
                  check$1(
                    colorBuffer.length === 1 || extensions.webgl_draw_buffers,
                    "multiple render targets not supported"
                  );
                }
              }
              if (!colorBuffer) {
                if ("colorCount" in options) {
                  colorCount = options.colorCount | 0;
                  check$1(colorCount > 0, "invalid color buffer count");
                }
                if ("colorTexture" in options) {
                  colorTexture = !!options.colorTexture;
                  colorFormat = "rgba4";
                }
                if ("colorType" in options) {
                  colorType = options.colorType;
                  if (!colorTexture) {
                    if (colorType === "half float" || colorType === "float16") {
                      check$1(
                        extensions.ext_color_buffer_half_float,
                        "you must enable EXT_color_buffer_half_float to use 16-bit render buffers"
                      );
                      colorFormat = "rgba16f";
                    } else if (colorType === "float" || colorType === "float32") {
                      check$1(
                        extensions.webgl_color_buffer_float,
                        "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"
                      );
                      colorFormat = "rgba32f";
                    }
                  } else {
                    check$1(
                      extensions.oes_texture_float || !(colorType === "float" || colorType === "float32"),
                      "you must enable OES_texture_float in order to use floating point framebuffer objects"
                    );
                    check$1(
                      extensions.oes_texture_half_float || !(colorType === "half float" || colorType === "float16"),
                      "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects"
                    );
                  }
                  check$1.oneOf(colorType, colorTypes, "invalid color type");
                }
                if ("colorFormat" in options) {
                  colorFormat = options.colorFormat;
                  if (colorTextureFormats.indexOf(colorFormat) >= 0) {
                    colorTexture = true;
                  } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
                    colorTexture = false;
                  } else {
                    if (colorTexture) {
                      check$1.oneOf(
                        options.colorFormat,
                        colorTextureFormats,
                        "invalid color format for texture"
                      );
                    } else {
                      check$1.oneOf(
                        options.colorFormat,
                        colorRenderbufferFormats,
                        "invalid color format for renderbuffer"
                      );
                    }
                  }
                }
              }
              if ("depthTexture" in options || "depthStencilTexture" in options) {
                depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);
                check$1(
                  !depthStencilTexture || extensions.webgl_depth_texture,
                  "webgl_depth_texture extension not supported"
                );
              }
              if ("depth" in options) {
                if (typeof options.depth === "boolean") {
                  needsDepth = options.depth;
                } else {
                  depthBuffer = options.depth;
                  needsStencil = false;
                }
              }
              if ("stencil" in options) {
                if (typeof options.stencil === "boolean") {
                  needsStencil = options.stencil;
                } else {
                  stencilBuffer = options.stencil;
                  needsDepth = false;
                }
              }
              if ("depthStencil" in options) {
                if (typeof options.depthStencil === "boolean") {
                  needsDepth = needsStencil = options.depthStencil;
                } else {
                  depthStencilBuffer = options.depthStencil;
                  needsDepth = false;
                  needsStencil = false;
                }
              }
            }
            var colorAttachments = null;
            var depthAttachment = null;
            var stencilAttachment = null;
            var depthStencilAttachment = null;
            if (Array.isArray(colorBuffer)) {
              colorAttachments = colorBuffer.map(parseAttachment);
            } else if (colorBuffer) {
              colorAttachments = [parseAttachment(colorBuffer)];
            } else {
              colorAttachments = new Array(colorCount);
              for (i2 = 0; i2 < colorCount; ++i2) {
                colorAttachments[i2] = allocAttachment(
                  width,
                  height,
                  colorTexture,
                  colorFormat,
                  colorType
                );
              }
            }
            check$1(
              extensions.webgl_draw_buffers || colorAttachments.length <= 1,
              "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."
            );
            check$1(
              colorAttachments.length <= limits.maxColorAttachments,
              "too many color attachments, not supported"
            );
            width = width || colorAttachments[0].width;
            height = height || colorAttachments[0].height;
            if (depthBuffer) {
              depthAttachment = parseAttachment(depthBuffer);
            } else if (needsDepth && !needsStencil) {
              depthAttachment = allocAttachment(
                width,
                height,
                depthStencilTexture,
                "depth",
                "uint32"
              );
            }
            if (stencilBuffer) {
              stencilAttachment = parseAttachment(stencilBuffer);
            } else if (needsStencil && !needsDepth) {
              stencilAttachment = allocAttachment(
                width,
                height,
                false,
                "stencil",
                "uint8"
              );
            }
            if (depthStencilBuffer) {
              depthStencilAttachment = parseAttachment(depthStencilBuffer);
            } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
              depthStencilAttachment = allocAttachment(
                width,
                height,
                depthStencilTexture,
                "depth stencil",
                "depth stencil"
              );
            }
            check$1(
              !!depthBuffer + !!stencilBuffer + !!depthStencilBuffer <= 1,
              "invalid framebuffer configuration, can specify exactly one depth/stencil attachment"
            );
            var commonColorAttachmentSize = null;
            for (i2 = 0; i2 < colorAttachments.length; ++i2) {
              incRefAndCheckShape(colorAttachments[i2], width, height);
              check$1(
                !colorAttachments[i2] || colorAttachments[i2].texture && colorTextureFormatEnums.indexOf(colorAttachments[i2].texture._texture.format) >= 0 || colorAttachments[i2].renderbuffer && colorRenderbufferFormatEnums.indexOf(colorAttachments[i2].renderbuffer._renderbuffer.format) >= 0,
                "framebuffer color attachment " + i2 + " is invalid"
              );
              if (colorAttachments[i2] && colorAttachments[i2].texture) {
                var colorAttachmentSize = textureFormatChannels[colorAttachments[i2].texture._texture.format] * textureTypeSizes[colorAttachments[i2].texture._texture.type];
                if (commonColorAttachmentSize === null) {
                  commonColorAttachmentSize = colorAttachmentSize;
                } else {
                  check$1(
                    commonColorAttachmentSize === colorAttachmentSize,
                    "all color attachments much have the same number of bits per pixel."
                  );
                }
              }
            }
            incRefAndCheckShape(depthAttachment, width, height);
            check$1(
              !depthAttachment || depthAttachment.texture && depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1 || depthAttachment.renderbuffer && depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1,
              "invalid depth attachment for framebuffer object"
            );
            incRefAndCheckShape(stencilAttachment, width, height);
            check$1(
              !stencilAttachment || stencilAttachment.renderbuffer && stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1,
              "invalid stencil attachment for framebuffer object"
            );
            incRefAndCheckShape(depthStencilAttachment, width, height);
            check$1(
              !depthStencilAttachment || depthStencilAttachment.texture && depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2 || depthStencilAttachment.renderbuffer && depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2,
              "invalid depth-stencil attachment for framebuffer object"
            );
            decFBORefs(framebuffer);
            framebuffer.width = width;
            framebuffer.height = height;
            framebuffer.colorAttachments = colorAttachments;
            framebuffer.depthAttachment = depthAttachment;
            framebuffer.stencilAttachment = stencilAttachment;
            framebuffer.depthStencilAttachment = depthStencilAttachment;
            reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
            reglFramebuffer.depth = unwrapAttachment(depthAttachment);
            reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
            reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);
            reglFramebuffer.width = framebuffer.width;
            reglFramebuffer.height = framebuffer.height;
            updateFramebuffer(framebuffer);
            return reglFramebuffer;
          }
          function resize(w_, h_) {
            check$1(
              framebufferState.next !== framebuffer,
              "can not resize a framebuffer which is currently in use"
            );
            var w2 = Math.max(w_ | 0, 1);
            var h2 = Math.max(h_ | 0 || w2, 1);
            if (w2 === framebuffer.width && h2 === framebuffer.height) {
              return reglFramebuffer;
            }
            var colorAttachments = framebuffer.colorAttachments;
            for (var i2 = 0; i2 < colorAttachments.length; ++i2) {
              resizeAttachment(colorAttachments[i2], w2, h2);
            }
            resizeAttachment(framebuffer.depthAttachment, w2, h2);
            resizeAttachment(framebuffer.stencilAttachment, w2, h2);
            resizeAttachment(framebuffer.depthStencilAttachment, w2, h2);
            framebuffer.width = reglFramebuffer.width = w2;
            framebuffer.height = reglFramebuffer.height = h2;
            updateFramebuffer(framebuffer);
            return reglFramebuffer;
          }
          reglFramebuffer(a0, a1);
          return extend2(reglFramebuffer, {
            resize,
            _reglType: "framebuffer",
            _framebuffer: framebuffer,
            destroy: function() {
              destroy(framebuffer);
              decFBORefs(framebuffer);
            },
            use: function(block) {
              framebufferState.setFBO({
                framebuffer: reglFramebuffer
              }, block);
            }
          });
        }
        function createCubeFBO(options) {
          var faces = Array(6);
          function reglFramebufferCube(a3) {
            var i2;
            check$1(
              faces.indexOf(framebufferState.next) < 0,
              "can not update framebuffer which is currently in use"
            );
            var params = {
              color: null
            };
            var radius = 0;
            var colorBuffer = null;
            var colorFormat = "rgba";
            var colorType = "uint8";
            var colorCount = 1;
            if (typeof a3 === "number") {
              radius = a3 | 0;
            } else if (!a3) {
              radius = 1;
            } else {
              check$1.type(a3, "object", "invalid arguments for framebuffer");
              var options2 = a3;
              if ("shape" in options2) {
                var shape = options2.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid shape for framebuffer"
                );
                check$1(
                  shape[0] === shape[1],
                  "cube framebuffer must be square"
                );
                radius = shape[0];
              } else {
                if ("radius" in options2) {
                  radius = options2.radius | 0;
                }
                if ("width" in options2) {
                  radius = options2.width | 0;
                  if ("height" in options2) {
                    check$1(options2.height === radius, "must be square");
                  }
                } else if ("height" in options2) {
                  radius = options2.height | 0;
                }
              }
              if ("color" in options2 || "colors" in options2) {
                colorBuffer = options2.color || options2.colors;
                if (Array.isArray(colorBuffer)) {
                  check$1(
                    colorBuffer.length === 1 || extensions.webgl_draw_buffers,
                    "multiple render targets not supported"
                  );
                }
              }
              if (!colorBuffer) {
                if ("colorCount" in options2) {
                  colorCount = options2.colorCount | 0;
                  check$1(colorCount > 0, "invalid color buffer count");
                }
                if ("colorType" in options2) {
                  check$1.oneOf(
                    options2.colorType,
                    colorTypes,
                    "invalid color type"
                  );
                  colorType = options2.colorType;
                }
                if ("colorFormat" in options2) {
                  colorFormat = options2.colorFormat;
                  check$1.oneOf(
                    options2.colorFormat,
                    colorTextureFormats,
                    "invalid color format for texture"
                  );
                }
              }
              if ("depth" in options2) {
                params.depth = options2.depth;
              }
              if ("stencil" in options2) {
                params.stencil = options2.stencil;
              }
              if ("depthStencil" in options2) {
                params.depthStencil = options2.depthStencil;
              }
            }
            var colorCubes;
            if (colorBuffer) {
              if (Array.isArray(colorBuffer)) {
                colorCubes = [];
                for (i2 = 0; i2 < colorBuffer.length; ++i2) {
                  colorCubes[i2] = colorBuffer[i2];
                }
              } else {
                colorCubes = [colorBuffer];
              }
            } else {
              colorCubes = Array(colorCount);
              var cubeMapParams = {
                radius,
                format: colorFormat,
                type: colorType
              };
              for (i2 = 0; i2 < colorCount; ++i2) {
                colorCubes[i2] = textureState.createCube(cubeMapParams);
              }
            }
            params.color = Array(colorCubes.length);
            for (i2 = 0; i2 < colorCubes.length; ++i2) {
              var cube = colorCubes[i2];
              check$1(
                typeof cube === "function" && cube._reglType === "textureCube",
                "invalid cube map"
              );
              radius = radius || cube.width;
              check$1(
                cube.width === radius && cube.height === radius,
                "invalid cube map shape"
              );
              params.color[i2] = {
                target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
                data: colorCubes[i2]
              };
            }
            for (i2 = 0; i2 < 6; ++i2) {
              for (var j2 = 0; j2 < colorCubes.length; ++j2) {
                params.color[j2].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i2;
              }
              if (i2 > 0) {
                params.depth = faces[0].depth;
                params.stencil = faces[0].stencil;
                params.depthStencil = faces[0].depthStencil;
              }
              if (faces[i2]) {
                faces[i2](params);
              } else {
                faces[i2] = createFBO(params);
              }
            }
            return extend2(reglFramebufferCube, {
              width: radius,
              height: radius,
              color: colorCubes
            });
          }
          function resize(radius_) {
            var i2;
            var radius = radius_ | 0;
            check$1(
              radius > 0 && radius <= limits.maxCubeMapSize,
              "invalid radius for cube fbo"
            );
            if (radius === reglFramebufferCube.width) {
              return reglFramebufferCube;
            }
            var colors = reglFramebufferCube.color;
            for (i2 = 0; i2 < colors.length; ++i2) {
              colors[i2].resize(radius);
            }
            for (i2 = 0; i2 < 6; ++i2) {
              faces[i2].resize(radius);
            }
            reglFramebufferCube.width = reglFramebufferCube.height = radius;
            return reglFramebufferCube;
          }
          reglFramebufferCube(options);
          return extend2(reglFramebufferCube, {
            faces,
            resize,
            _reglType: "framebufferCube",
            destroy: function() {
              faces.forEach(function(f2) {
                f2.destroy();
              });
            }
          });
        }
        function restoreFramebuffers() {
          framebufferState.cur = null;
          framebufferState.next = null;
          framebufferState.dirty = true;
          values2(framebufferSet).forEach(function(fb) {
            fb.framebuffer = gl2.createFramebuffer();
            updateFramebuffer(fb);
          });
        }
        return extend2(framebufferState, {
          getFramebuffer: function(object) {
            if (typeof object === "function" && object._reglType === "framebuffer") {
              var fbo = object._framebuffer;
              if (fbo instanceof REGLFramebuffer) {
                return fbo;
              }
            }
            return null;
          },
          create: createFBO,
          createCube: createCubeFBO,
          clear: function() {
            values2(framebufferSet).forEach(destroy);
          },
          restore: restoreFramebuffers
        });
      }
      var GL_FLOAT$6 = 5126;
      var GL_ARRAY_BUFFER$1 = 34962;
      function AttributeRecord() {
        this.state = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        this.buffer = null;
        this.size = 0;
        this.normalized = false;
        this.type = GL_FLOAT$6;
        this.offset = 0;
        this.stride = 0;
        this.divisor = 0;
      }
      function wrapAttributeState(gl2, extensions, limits, stats2, bufferState) {
        var NUM_ATTRIBUTES = limits.maxAttributes;
        var attributeBindings = new Array(NUM_ATTRIBUTES);
        for (var i2 = 0; i2 < NUM_ATTRIBUTES; ++i2) {
          attributeBindings[i2] = new AttributeRecord();
        }
        var vaoCount = 0;
        var vaoSet = {};
        var state = {
          Record: AttributeRecord,
          scope: {},
          state: attributeBindings,
          currentVAO: null,
          targetVAO: null,
          restore: extVAO() ? restoreVAO : function() {
          },
          createVAO,
          getVAO,
          destroyBuffer,
          setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
          clear: extVAO() ? destroyVAOEXT : function() {
          }
        };
        function destroyBuffer(buffer) {
          for (var i3 = 0; i3 < attributeBindings.length; ++i3) {
            var record = attributeBindings[i3];
            if (record.buffer === buffer) {
              gl2.disableVertexAttribArray(i3);
              record.buffer = null;
            }
          }
        }
        function extVAO() {
          return extensions.oes_vertex_array_object;
        }
        function extInstanced() {
          return extensions.angle_instanced_arrays;
        }
        function getVAO(vao) {
          if (typeof vao === "function" && vao._vao) {
            return vao._vao;
          }
          return null;
        }
        function setVAOEXT(vao) {
          if (vao === state.currentVAO) {
            return;
          }
          var ext = extVAO();
          if (vao) {
            ext.bindVertexArrayOES(vao.vao);
          } else {
            ext.bindVertexArrayOES(null);
          }
          state.currentVAO = vao;
        }
        function setVAOEmulated(vao) {
          if (vao === state.currentVAO) {
            return;
          }
          if (vao) {
            vao.bindAttrs();
          } else {
            var exti = extInstanced();
            for (var i3 = 0; i3 < attributeBindings.length; ++i3) {
              var binding = attributeBindings[i3];
              if (binding.buffer) {
                gl2.enableVertexAttribArray(i3);
                gl2.vertexAttribPointer(i3, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset);
                if (exti && binding.divisor) {
                  exti.vertexAttribDivisorANGLE(i3, binding.divisor);
                }
              } else {
                gl2.disableVertexAttribArray(i3);
                gl2.vertexAttrib4f(i3, binding.x, binding.y, binding.z, binding.w);
              }
            }
          }
          state.currentVAO = vao;
        }
        function destroyVAOEXT() {
          values2(vaoSet).forEach(function(vao) {
            vao.destroy();
          });
        }
        function REGLVAO() {
          this.id = ++vaoCount;
          this.attributes = [];
          var extension = extVAO();
          if (extension) {
            this.vao = extension.createVertexArrayOES();
          } else {
            this.vao = null;
          }
          vaoSet[this.id] = this;
          this.buffers = [];
        }
        REGLVAO.prototype.bindAttrs = function() {
          var exti = extInstanced();
          var attributes = this.attributes;
          for (var i3 = 0; i3 < attributes.length; ++i3) {
            var attr = attributes[i3];
            if (attr.buffer) {
              gl2.enableVertexAttribArray(i3);
              gl2.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer);
              gl2.vertexAttribPointer(i3, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);
              if (exti && attr.divisor) {
                exti.vertexAttribDivisorANGLE(i3, attr.divisor);
              }
            } else {
              gl2.disableVertexAttribArray(i3);
              gl2.vertexAttrib4f(i3, attr.x, attr.y, attr.z, attr.w);
            }
          }
          for (var j2 = attributes.length; j2 < NUM_ATTRIBUTES; ++j2) {
            gl2.disableVertexAttribArray(j2);
          }
        };
        REGLVAO.prototype.refresh = function() {
          var ext = extVAO();
          if (ext) {
            ext.bindVertexArrayOES(this.vao);
            this.bindAttrs();
            state.currentVAO = this;
          }
        };
        REGLVAO.prototype.destroy = function() {
          if (this.vao) {
            var extension = extVAO();
            if (this === state.currentVAO) {
              state.currentVAO = null;
              extension.bindVertexArrayOES(null);
            }
            extension.deleteVertexArrayOES(this.vao);
            this.vao = null;
          }
          if (vaoSet[this.id]) {
            delete vaoSet[this.id];
            stats2.vaoCount -= 1;
          }
        };
        function restoreVAO() {
          var ext = extVAO();
          if (ext) {
            values2(vaoSet).forEach(function(vao) {
              vao.refresh();
            });
          }
        }
        function createVAO(_attr) {
          var vao = new REGLVAO();
          stats2.vaoCount += 1;
          function updateVAO(attributes) {
            check$1(Array.isArray(attributes), "arguments to vertex array constructor must be an array");
            check$1(attributes.length < NUM_ATTRIBUTES, "too many attributes");
            check$1(attributes.length > 0, "must specify at least one attribute");
            var bufUpdated = {};
            var nattributes = vao.attributes;
            nattributes.length = attributes.length;
            for (var i3 = 0; i3 < attributes.length; ++i3) {
              var spec = attributes[i3];
              var rec = nattributes[i3] = new AttributeRecord();
              var data = spec.data || spec;
              if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
                var buf;
                if (vao.buffers[i3]) {
                  buf = vao.buffers[i3];
                  if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
                    buf.subdata(data);
                  } else {
                    buf.destroy();
                    vao.buffers[i3] = null;
                  }
                }
                if (!vao.buffers[i3]) {
                  buf = vao.buffers[i3] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true);
                }
                rec.buffer = bufferState.getBuffer(buf);
                rec.size = rec.buffer.dimension | 0;
                rec.normalized = false;
                rec.type = rec.buffer.dtype;
                rec.offset = 0;
                rec.stride = 0;
                rec.divisor = 0;
                rec.state = 1;
                bufUpdated[i3] = 1;
              } else if (bufferState.getBuffer(spec)) {
                rec.buffer = bufferState.getBuffer(spec);
                rec.size = rec.buffer.dimension | 0;
                rec.normalized = false;
                rec.type = rec.buffer.dtype;
                rec.offset = 0;
                rec.stride = 0;
                rec.divisor = 0;
                rec.state = 1;
              } else if (bufferState.getBuffer(spec.buffer)) {
                rec.buffer = bufferState.getBuffer(spec.buffer);
                rec.size = (+spec.size || rec.buffer.dimension) | 0;
                rec.normalized = !!spec.normalized || false;
                if ("type" in spec) {
                  check$1.parameter(spec.type, glTypes, "invalid buffer type");
                  rec.type = glTypes[spec.type];
                } else {
                  rec.type = rec.buffer.dtype;
                }
                rec.offset = (spec.offset || 0) | 0;
                rec.stride = (spec.stride || 0) | 0;
                rec.divisor = (spec.divisor || 0) | 0;
                rec.state = 1;
                check$1(rec.size >= 1 && rec.size <= 4, "size must be between 1 and 4");
                check$1(rec.offset >= 0, "invalid offset");
                check$1(rec.stride >= 0 && rec.stride <= 255, "stride must be between 0 and 255");
                check$1(rec.divisor >= 0, "divisor must be positive");
                check$1(!rec.divisor || !!extensions.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor");
              } else if ("x" in spec) {
                check$1(i3 > 0, "first attribute must not be a constant");
                rec.x = +spec.x || 0;
                rec.y = +spec.y || 0;
                rec.z = +spec.z || 0;
                rec.w = +spec.w || 0;
                rec.state = 2;
              } else {
                check$1(false, "invalid attribute spec for location " + i3);
              }
            }
            for (var j2 = 0; j2 < vao.buffers.length; ++j2) {
              if (!bufUpdated[j2] && vao.buffers[j2]) {
                vao.buffers[j2].destroy();
                vao.buffers[j2] = null;
              }
            }
            vao.refresh();
            return updateVAO;
          }
          updateVAO.destroy = function() {
            for (var j2 = 0; j2 < vao.buffers.length; ++j2) {
              if (vao.buffers[j2]) {
                vao.buffers[j2].destroy();
              }
            }
            vao.buffers.length = 0;
            vao.destroy();
          };
          updateVAO._vao = vao;
          updateVAO._reglType = "vao";
          return updateVAO(_attr);
        }
        return state;
      }
      var GL_FRAGMENT_SHADER = 35632;
      var GL_VERTEX_SHADER = 35633;
      var GL_ACTIVE_UNIFORMS = 35718;
      var GL_ACTIVE_ATTRIBUTES = 35721;
      function wrapShaderState(gl2, stringStore, stats2, config) {
        var fragShaders = {};
        var vertShaders = {};
        function ActiveInfo(name, id, location, info) {
          this.name = name;
          this.id = id;
          this.location = location;
          this.info = info;
        }
        function insertActiveInfo(list, info) {
          for (var i2 = 0; i2 < list.length; ++i2) {
            if (list[i2].id === info.id) {
              list[i2].location = info.location;
              return;
            }
          }
          list.push(info);
        }
        function getShader(type, id, command) {
          var cache2 = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
          var shader = cache2[id];
          if (!shader) {
            var source = stringStore.str(id);
            shader = gl2.createShader(type);
            gl2.shaderSource(shader, source);
            gl2.compileShader(shader);
            check$1.shaderError(gl2, shader, source, type, command);
            cache2[id] = shader;
          }
          return shader;
        }
        var programCache = {};
        var programList = [];
        var PROGRAM_COUNTER = 0;
        function REGLProgram(fragId, vertId) {
          this.id = PROGRAM_COUNTER++;
          this.fragId = fragId;
          this.vertId = vertId;
          this.program = null;
          this.uniforms = [];
          this.attributes = [];
          this.refCount = 1;
          if (config.profile) {
            this.stats = {
              uniformsCount: 0,
              attributesCount: 0
            };
          }
        }
        function linkProgram(desc, command, attributeLocations) {
          var i2, info;
          var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
          var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);
          var program = desc.program = gl2.createProgram();
          gl2.attachShader(program, fragShader);
          gl2.attachShader(program, vertShader);
          if (attributeLocations) {
            for (i2 = 0; i2 < attributeLocations.length; ++i2) {
              var binding = attributeLocations[i2];
              gl2.bindAttribLocation(program, binding[0], binding[1]);
            }
          }
          gl2.linkProgram(program);
          check$1.linkError(
            gl2,
            program,
            stringStore.str(desc.fragId),
            stringStore.str(desc.vertId),
            command
          );
          var numUniforms = gl2.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
          if (config.profile) {
            desc.stats.uniformsCount = numUniforms;
          }
          var uniforms = desc.uniforms;
          for (i2 = 0; i2 < numUniforms; ++i2) {
            info = gl2.getActiveUniform(program, i2);
            if (info) {
              if (info.size > 1) {
                for (var j2 = 0; j2 < info.size; ++j2) {
                  var name = info.name.replace("[0]", "[" + j2 + "]");
                  insertActiveInfo(uniforms, new ActiveInfo(
                    name,
                    stringStore.id(name),
                    gl2.getUniformLocation(program, name),
                    info
                  ));
                }
              } else {
                insertActiveInfo(uniforms, new ActiveInfo(
                  info.name,
                  stringStore.id(info.name),
                  gl2.getUniformLocation(program, info.name),
                  info
                ));
              }
            }
          }
          var numAttributes = gl2.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
          if (config.profile) {
            desc.stats.attributesCount = numAttributes;
          }
          var attributes = desc.attributes;
          for (i2 = 0; i2 < numAttributes; ++i2) {
            info = gl2.getActiveAttrib(program, i2);
            if (info) {
              insertActiveInfo(attributes, new ActiveInfo(
                info.name,
                stringStore.id(info.name),
                gl2.getAttribLocation(program, info.name),
                info
              ));
            }
          }
        }
        if (config.profile) {
          stats2.getMaxUniformsCount = function() {
            var m3 = 0;
            programList.forEach(function(desc) {
              if (desc.stats.uniformsCount > m3) {
                m3 = desc.stats.uniformsCount;
              }
            });
            return m3;
          };
          stats2.getMaxAttributesCount = function() {
            var m3 = 0;
            programList.forEach(function(desc) {
              if (desc.stats.attributesCount > m3) {
                m3 = desc.stats.attributesCount;
              }
            });
            return m3;
          };
        }
        function restoreShaders() {
          fragShaders = {};
          vertShaders = {};
          for (var i2 = 0; i2 < programList.length; ++i2) {
            linkProgram(programList[i2], null, programList[i2].attributes.map(function(info) {
              return [info.location, info.name];
            }));
          }
        }
        return {
          clear: function() {
            var deleteShader = gl2.deleteShader.bind(gl2);
            values2(fragShaders).forEach(deleteShader);
            fragShaders = {};
            values2(vertShaders).forEach(deleteShader);
            vertShaders = {};
            programList.forEach(function(desc) {
              gl2.deleteProgram(desc.program);
            });
            programList.length = 0;
            programCache = {};
            stats2.shaderCount = 0;
          },
          program: function(vertId, fragId, command, attribLocations) {
            check$1.command(vertId >= 0, "missing vertex shader", command);
            check$1.command(fragId >= 0, "missing fragment shader", command);
            var cache2 = programCache[fragId];
            if (!cache2) {
              cache2 = programCache[fragId] = {};
            }
            var prevProgram = cache2[vertId];
            if (prevProgram) {
              prevProgram.refCount++;
              if (!attribLocations) {
                return prevProgram;
              }
            }
            var program = new REGLProgram(fragId, vertId);
            stats2.shaderCount++;
            linkProgram(program, command, attribLocations);
            if (!prevProgram) {
              cache2[vertId] = program;
            }
            programList.push(program);
            return extend2(program, {
              destroy: function() {
                program.refCount--;
                if (program.refCount <= 0) {
                  gl2.deleteProgram(program.program);
                  var idx = programList.indexOf(program);
                  programList.splice(idx, 1);
                  stats2.shaderCount--;
                }
                if (cache2[program.vertId].refCount <= 0) {
                  gl2.deleteShader(vertShaders[program.vertId]);
                  delete vertShaders[program.vertId];
                  delete programCache[program.fragId][program.vertId];
                }
                if (!Object.keys(programCache[program.fragId]).length) {
                  gl2.deleteShader(fragShaders[program.fragId]);
                  delete fragShaders[program.fragId];
                  delete programCache[program.fragId];
                }
              }
            });
          },
          restore: restoreShaders,
          shader: getShader,
          frag: -1,
          vert: -1
        };
      }
      var GL_RGBA$3 = 6408;
      var GL_UNSIGNED_BYTE$7 = 5121;
      var GL_PACK_ALIGNMENT = 3333;
      var GL_FLOAT$7 = 5126;
      function wrapReadPixels(gl2, framebufferState, reglPoll, context, glAttributes, extensions, limits) {
        function readPixelsImpl(input) {
          var type;
          if (framebufferState.next === null) {
            check$1(
              glAttributes.preserveDrawingBuffer,
              'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'
            );
            type = GL_UNSIGNED_BYTE$7;
          } else {
            check$1(
              framebufferState.next.colorAttachments[0].texture !== null,
              "You cannot read from a renderbuffer"
            );
            type = framebufferState.next.colorAttachments[0].texture._texture.type;
            if (extensions.oes_texture_float) {
              check$1(
                type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
                "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"
              );
              if (type === GL_FLOAT$7) {
                check$1(limits.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float");
              }
            } else {
              check$1(
                type === GL_UNSIGNED_BYTE$7,
                "Reading from a framebuffer is only allowed for the type 'uint8'"
              );
            }
          }
          var x4 = 0;
          var y4 = 0;
          var width = context.framebufferWidth;
          var height = context.framebufferHeight;
          var data = null;
          if (isTypedArray(input)) {
            data = input;
          } else if (input) {
            check$1.type(input, "object", "invalid arguments to regl.read()");
            x4 = input.x | 0;
            y4 = input.y | 0;
            check$1(
              x4 >= 0 && x4 < context.framebufferWidth,
              "invalid x offset for regl.read"
            );
            check$1(
              y4 >= 0 && y4 < context.framebufferHeight,
              "invalid y offset for regl.read"
            );
            width = (input.width || context.framebufferWidth - x4) | 0;
            height = (input.height || context.framebufferHeight - y4) | 0;
            data = input.data || null;
          }
          if (data) {
            if (type === GL_UNSIGNED_BYTE$7) {
              check$1(
                data instanceof Uint8Array,
                "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"
              );
            } else if (type === GL_FLOAT$7) {
              check$1(
                data instanceof Float32Array,
                "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'"
              );
            }
          }
          check$1(
            width > 0 && width + x4 <= context.framebufferWidth,
            "invalid width for read pixels"
          );
          check$1(
            height > 0 && height + y4 <= context.framebufferHeight,
            "invalid height for read pixels"
          );
          reglPoll();
          var size3 = width * height * 4;
          if (!data) {
            if (type === GL_UNSIGNED_BYTE$7) {
              data = new Uint8Array(size3);
            } else if (type === GL_FLOAT$7) {
              data = data || new Float32Array(size3);
            }
          }
          check$1.isTypedArray(data, "data buffer for regl.read() must be a typedarray");
          check$1(data.byteLength >= size3, "data buffer for regl.read() too small");
          gl2.pixelStorei(GL_PACK_ALIGNMENT, 4);
          gl2.readPixels(
            x4,
            y4,
            width,
            height,
            GL_RGBA$3,
            type,
            data
          );
          return data;
        }
        function readPixelsFBO(options) {
          var result;
          framebufferState.setFBO({
            framebuffer: options.framebuffer
          }, function() {
            result = readPixelsImpl(options);
          });
          return result;
        }
        function readPixels(options) {
          if (!options || !("framebuffer" in options)) {
            return readPixelsImpl(options);
          } else {
            return readPixelsFBO(options);
          }
        }
        return readPixels;
      }
      function slice(x4) {
        return Array.prototype.slice.call(x4);
      }
      function join(x4) {
        return slice(x4).join("");
      }
      function createEnvironment() {
        var varCounter = 0;
        var linkedNames = [];
        var linkedValues = [];
        function link(value) {
          for (var i2 = 0; i2 < linkedValues.length; ++i2) {
            if (linkedValues[i2] === value) {
              return linkedNames[i2];
            }
          }
          var name = "g" + varCounter++;
          linkedNames.push(name);
          linkedValues.push(value);
          return name;
        }
        function block() {
          var code = [];
          function push() {
            code.push.apply(code, slice(arguments));
          }
          var vars = [];
          function def() {
            var name = "v" + varCounter++;
            vars.push(name);
            if (arguments.length > 0) {
              code.push(name, "=");
              code.push.apply(code, slice(arguments));
              code.push(";");
            }
            return name;
          }
          return extend2(push, {
            def,
            toString: function() {
              return join([
                vars.length > 0 ? "var " + vars.join(",") + ";" : "",
                join(code)
              ]);
            }
          });
        }
        function scope() {
          var entry = block();
          var exit = block();
          var entryToString = entry.toString;
          var exitToString = exit.toString;
          function save(object, prop) {
            exit(object, prop, "=", entry.def(object, prop), ";");
          }
          return extend2(function() {
            entry.apply(entry, slice(arguments));
          }, {
            def: entry.def,
            entry,
            exit,
            save,
            set: function(object, prop, value) {
              save(object, prop);
              entry(object, prop, "=", value, ";");
            },
            toString: function() {
              return entryToString() + exitToString();
            }
          });
        }
        function conditional() {
          var pred = join(arguments);
          var thenBlock = scope();
          var elseBlock = scope();
          var thenToString = thenBlock.toString;
          var elseToString = elseBlock.toString;
          return extend2(thenBlock, {
            then: function() {
              thenBlock.apply(thenBlock, slice(arguments));
              return this;
            },
            else: function() {
              elseBlock.apply(elseBlock, slice(arguments));
              return this;
            },
            toString: function() {
              var elseClause = elseToString();
              if (elseClause) {
                elseClause = "else{" + elseClause + "}";
              }
              return join([
                "if(",
                pred,
                "){",
                thenToString(),
                "}",
                elseClause
              ]);
            }
          });
        }
        var globalBlock = block();
        var procedures = {};
        function proc(name, count) {
          var args = [];
          function arg() {
            var name2 = "a" + args.length;
            args.push(name2);
            return name2;
          }
          count = count || 0;
          for (var i2 = 0; i2 < count; ++i2) {
            arg();
          }
          var body = scope();
          var bodyToString = body.toString;
          var result = procedures[name] = extend2(body, {
            arg,
            toString: function() {
              return join([
                "function(",
                args.join(),
                "){",
                bodyToString(),
                "}"
              ]);
            }
          });
          return result;
        }
        function compile() {
          var code = [
            '"use strict";',
            globalBlock,
            "return {"
          ];
          Object.keys(procedures).forEach(function(name) {
            code.push('"', name, '":', procedures[name].toString(), ",");
          });
          code.push("}");
          var src = join(code).replace(/;/g, ";\n").replace(/}/g, "}\n").replace(/{/g, "{\n");
          var proc2 = Function.apply(null, linkedNames.concat(src));
          return proc2.apply(null, linkedValues);
        }
        return {
          global: globalBlock,
          link,
          block,
          proc,
          scope,
          cond: conditional,
          compile
        };
      }
      var CUTE_COMPONENTS = "xyzw".split("");
      var GL_UNSIGNED_BYTE$8 = 5121;
      var ATTRIB_STATE_POINTER = 1;
      var ATTRIB_STATE_CONSTANT = 2;
      var DYN_FUNC$1 = 0;
      var DYN_PROP$1 = 1;
      var DYN_CONTEXT$1 = 2;
      var DYN_STATE$1 = 3;
      var DYN_THUNK = 4;
      var DYN_CONSTANT$1 = 5;
      var DYN_ARRAY$1 = 6;
      var S_DITHER = "dither";
      var S_BLEND_ENABLE = "blend.enable";
      var S_BLEND_COLOR = "blend.color";
      var S_BLEND_EQUATION = "blend.equation";
      var S_BLEND_FUNC = "blend.func";
      var S_DEPTH_ENABLE = "depth.enable";
      var S_DEPTH_FUNC = "depth.func";
      var S_DEPTH_RANGE = "depth.range";
      var S_DEPTH_MASK = "depth.mask";
      var S_COLOR_MASK = "colorMask";
      var S_CULL_ENABLE = "cull.enable";
      var S_CULL_FACE = "cull.face";
      var S_FRONT_FACE = "frontFace";
      var S_LINE_WIDTH = "lineWidth";
      var S_POLYGON_OFFSET_ENABLE = "polygonOffset.enable";
      var S_POLYGON_OFFSET_OFFSET = "polygonOffset.offset";
      var S_SAMPLE_ALPHA = "sample.alpha";
      var S_SAMPLE_ENABLE = "sample.enable";
      var S_SAMPLE_COVERAGE = "sample.coverage";
      var S_STENCIL_ENABLE = "stencil.enable";
      var S_STENCIL_MASK = "stencil.mask";
      var S_STENCIL_FUNC = "stencil.func";
      var S_STENCIL_OPFRONT = "stencil.opFront";
      var S_STENCIL_OPBACK = "stencil.opBack";
      var S_SCISSOR_ENABLE = "scissor.enable";
      var S_SCISSOR_BOX = "scissor.box";
      var S_VIEWPORT = "viewport";
      var S_PROFILE = "profile";
      var S_FRAMEBUFFER = "framebuffer";
      var S_VERT = "vert";
      var S_FRAG = "frag";
      var S_ELEMENTS = "elements";
      var S_PRIMITIVE = "primitive";
      var S_COUNT = "count";
      var S_OFFSET = "offset";
      var S_INSTANCES = "instances";
      var S_VAO = "vao";
      var SUFFIX_WIDTH = "Width";
      var SUFFIX_HEIGHT = "Height";
      var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
      var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
      var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
      var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
      var S_DRAWINGBUFFER = "drawingBuffer";
      var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
      var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;
      var NESTED_OPTIONS = [
        S_BLEND_FUNC,
        S_BLEND_EQUATION,
        S_STENCIL_FUNC,
        S_STENCIL_OPFRONT,
        S_STENCIL_OPBACK,
        S_SAMPLE_COVERAGE,
        S_VIEWPORT,
        S_SCISSOR_BOX,
        S_POLYGON_OFFSET_OFFSET
      ];
      var GL_ARRAY_BUFFER$2 = 34962;
      var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;
      var GL_FRAGMENT_SHADER$1 = 35632;
      var GL_VERTEX_SHADER$1 = 35633;
      var GL_TEXTURE_2D$3 = 3553;
      var GL_TEXTURE_CUBE_MAP$2 = 34067;
      var GL_CULL_FACE = 2884;
      var GL_BLEND = 3042;
      var GL_DITHER = 3024;
      var GL_STENCIL_TEST = 2960;
      var GL_DEPTH_TEST = 2929;
      var GL_SCISSOR_TEST = 3089;
      var GL_POLYGON_OFFSET_FILL = 32823;
      var GL_SAMPLE_ALPHA_TO_COVERAGE = 32926;
      var GL_SAMPLE_COVERAGE = 32928;
      var GL_FLOAT$8 = 5126;
      var GL_FLOAT_VEC2 = 35664;
      var GL_FLOAT_VEC3 = 35665;
      var GL_FLOAT_VEC4 = 35666;
      var GL_INT$3 = 5124;
      var GL_INT_VEC2 = 35667;
      var GL_INT_VEC3 = 35668;
      var GL_INT_VEC4 = 35669;
      var GL_BOOL = 35670;
      var GL_BOOL_VEC2 = 35671;
      var GL_BOOL_VEC3 = 35672;
      var GL_BOOL_VEC4 = 35673;
      var GL_FLOAT_MAT2 = 35674;
      var GL_FLOAT_MAT3 = 35675;
      var GL_FLOAT_MAT4 = 35676;
      var GL_SAMPLER_2D = 35678;
      var GL_SAMPLER_CUBE = 35680;
      var GL_TRIANGLES$1 = 4;
      var GL_FRONT = 1028;
      var GL_BACK = 1029;
      var GL_CW = 2304;
      var GL_CCW = 2305;
      var GL_MIN_EXT = 32775;
      var GL_MAX_EXT = 32776;
      var GL_ALWAYS = 519;
      var GL_KEEP = 7680;
      var GL_ZERO = 0;
      var GL_ONE = 1;
      var GL_FUNC_ADD = 32774;
      var GL_LESS = 513;
      var GL_FRAMEBUFFER$2 = 36160;
      var GL_COLOR_ATTACHMENT0$2 = 36064;
      var blendFuncs = {
        "0": 0,
        "1": 1,
        "zero": 0,
        "one": 1,
        "src color": 768,
        "one minus src color": 769,
        "src alpha": 770,
        "one minus src alpha": 771,
        "dst color": 774,
        "one minus dst color": 775,
        "dst alpha": 772,
        "one minus dst alpha": 773,
        "constant color": 32769,
        "one minus constant color": 32770,
        "constant alpha": 32771,
        "one minus constant alpha": 32772,
        "src alpha saturate": 776
      };
      var invalidBlendCombinations = [
        "constant color, constant alpha",
        "one minus constant color, constant alpha",
        "constant color, one minus constant alpha",
        "one minus constant color, one minus constant alpha",
        "constant alpha, constant color",
        "constant alpha, one minus constant color",
        "one minus constant alpha, constant color",
        "one minus constant alpha, one minus constant color"
      ];
      var compareFuncs = {
        "never": 512,
        "less": 513,
        "<": 513,
        "equal": 514,
        "=": 514,
        "==": 514,
        "===": 514,
        "lequal": 515,
        "<=": 515,
        "greater": 516,
        ">": 516,
        "notequal": 517,
        "!=": 517,
        "!==": 517,
        "gequal": 518,
        ">=": 518,
        "always": 519
      };
      var stencilOps = {
        "0": 0,
        "zero": 0,
        "keep": 7680,
        "replace": 7681,
        "increment": 7682,
        "decrement": 7683,
        "increment wrap": 34055,
        "decrement wrap": 34056,
        "invert": 5386
      };
      var shaderType = {
        "frag": GL_FRAGMENT_SHADER$1,
        "vert": GL_VERTEX_SHADER$1
      };
      var orientationType = {
        "cw": GL_CW,
        "ccw": GL_CCW
      };
      function isBufferArgs(x4) {
        return Array.isArray(x4) || isTypedArray(x4) || isNDArrayLike(x4);
      }
      function sortState(state) {
        return state.sort(function(a3, b2) {
          if (a3 === S_VIEWPORT) {
            return -1;
          } else if (b2 === S_VIEWPORT) {
            return 1;
          }
          return a3 < b2 ? -1 : 1;
        });
      }
      function Declaration(thisDep, contextDep, propDep, append) {
        this.thisDep = thisDep;
        this.contextDep = contextDep;
        this.propDep = propDep;
        this.append = append;
      }
      function isStatic(decl) {
        return decl && !(decl.thisDep || decl.contextDep || decl.propDep);
      }
      function createStaticDecl(append) {
        return new Declaration(false, false, false, append);
      }
      function createDynamicDecl(dyn, append) {
        var type = dyn.type;
        if (type === DYN_FUNC$1) {
          var numArgs = dyn.data.length;
          return new Declaration(
            true,
            numArgs >= 1,
            numArgs >= 2,
            append
          );
        } else if (type === DYN_THUNK) {
          var data = dyn.data;
          return new Declaration(
            data.thisDep,
            data.contextDep,
            data.propDep,
            append
          );
        } else if (type === DYN_CONSTANT$1) {
          return new Declaration(
            false,
            false,
            false,
            append
          );
        } else if (type === DYN_ARRAY$1) {
          var thisDep = false;
          var contextDep = false;
          var propDep = false;
          for (var i2 = 0; i2 < dyn.data.length; ++i2) {
            var subDyn = dyn.data[i2];
            if (subDyn.type === DYN_PROP$1) {
              propDep = true;
            } else if (subDyn.type === DYN_CONTEXT$1) {
              contextDep = true;
            } else if (subDyn.type === DYN_STATE$1) {
              thisDep = true;
            } else if (subDyn.type === DYN_FUNC$1) {
              thisDep = true;
              var subArgs = subDyn.data;
              if (subArgs >= 1) {
                contextDep = true;
              }
              if (subArgs >= 2) {
                propDep = true;
              }
            } else if (subDyn.type === DYN_THUNK) {
              thisDep = thisDep || subDyn.data.thisDep;
              contextDep = contextDep || subDyn.data.contextDep;
              propDep = propDep || subDyn.data.propDep;
            }
          }
          return new Declaration(
            thisDep,
            contextDep,
            propDep,
            append
          );
        } else {
          return new Declaration(
            type === DYN_STATE$1,
            type === DYN_CONTEXT$1,
            type === DYN_PROP$1,
            append
          );
        }
      }
      var SCOPE_DECL = new Declaration(false, false, false, function() {
      });
      function reglCore(gl2, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer2, config) {
        var AttributeRecord2 = attributeState.Record;
        var blendEquations = {
          "add": 32774,
          "subtract": 32778,
          "reverse subtract": 32779
        };
        if (extensions.ext_blend_minmax) {
          blendEquations.min = GL_MIN_EXT;
          blendEquations.max = GL_MAX_EXT;
        }
        var extInstancing = extensions.angle_instanced_arrays;
        var extDrawBuffers = extensions.webgl_draw_buffers;
        var currentState = {
          dirty: true,
          profile: config.profile
        };
        var nextState = {};
        var GL_STATE_NAMES = [];
        var GL_FLAGS = {};
        var GL_VARIABLES = {};
        function propName(name) {
          return name.replace(".", "_");
        }
        function stateFlag(sname, cap, init) {
          var name = propName(sname);
          GL_STATE_NAMES.push(sname);
          nextState[name] = currentState[name] = !!init;
          GL_FLAGS[name] = cap;
        }
        function stateVariable(sname, func, init) {
          var name = propName(sname);
          GL_STATE_NAMES.push(sname);
          if (Array.isArray(init)) {
            currentState[name] = init.slice();
            nextState[name] = init.slice();
          } else {
            currentState[name] = nextState[name] = init;
          }
          GL_VARIABLES[name] = func;
        }
        stateFlag(S_DITHER, GL_DITHER);
        stateFlag(S_BLEND_ENABLE, GL_BLEND);
        stateVariable(S_BLEND_COLOR, "blendColor", [0, 0, 0, 0]);
        stateVariable(
          S_BLEND_EQUATION,
          "blendEquationSeparate",
          [GL_FUNC_ADD, GL_FUNC_ADD]
        );
        stateVariable(
          S_BLEND_FUNC,
          "blendFuncSeparate",
          [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]
        );
        stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
        stateVariable(S_DEPTH_FUNC, "depthFunc", GL_LESS);
        stateVariable(S_DEPTH_RANGE, "depthRange", [0, 1]);
        stateVariable(S_DEPTH_MASK, "depthMask", true);
        stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);
        stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
        stateVariable(S_CULL_FACE, "cullFace", GL_BACK);
        stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);
        stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);
        stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
        stateVariable(S_POLYGON_OFFSET_OFFSET, "polygonOffset", [0, 0]);
        stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
        stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
        stateVariable(S_SAMPLE_COVERAGE, "sampleCoverage", [1, false]);
        stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
        stateVariable(S_STENCIL_MASK, "stencilMask", -1);
        stateVariable(S_STENCIL_FUNC, "stencilFunc", [GL_ALWAYS, 0, -1]);
        stateVariable(
          S_STENCIL_OPFRONT,
          "stencilOpSeparate",
          [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]
        );
        stateVariable(
          S_STENCIL_OPBACK,
          "stencilOpSeparate",
          [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]
        );
        stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
        stateVariable(
          S_SCISSOR_BOX,
          "scissor",
          [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight]
        );
        stateVariable(
          S_VIEWPORT,
          S_VIEWPORT,
          [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight]
        );
        var sharedState = {
          gl: gl2,
          context: contextState,
          strings: stringStore,
          next: nextState,
          current: currentState,
          draw: drawState,
          elements: elementState,
          buffer: bufferState,
          shader: shaderState,
          attributes: attributeState.state,
          vao: attributeState,
          uniforms: uniformState,
          framebuffer: framebufferState,
          extensions,
          timer: timer2,
          isBufferArgs
        };
        var sharedConstants = {
          primTypes,
          compareFuncs,
          blendFuncs,
          blendEquations,
          stencilOps,
          glTypes,
          orientationType
        };
        check$1.optional(function() {
          sharedState.isArrayLike = isArrayLike2;
        });
        if (extDrawBuffers) {
          sharedConstants.backBuffer = [GL_BACK];
          sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function(i2) {
            if (i2 === 0) {
              return [0];
            }
            return loop(i2, function(j2) {
              return GL_COLOR_ATTACHMENT0$2 + j2;
            });
          });
        }
        var drawCallCounter = 0;
        function createREGLEnvironment() {
          var env = createEnvironment();
          var link = env.link;
          var global2 = env.global;
          env.id = drawCallCounter++;
          env.batchId = "0";
          var SHARED = link(sharedState);
          var shared = env.shared = {
            props: "a0"
          };
          Object.keys(sharedState).forEach(function(prop) {
            shared[prop] = global2.def(SHARED, ".", prop);
          });
          check$1.optional(function() {
            env.CHECK = link(check$1);
            env.commandStr = check$1.guessCommand();
            env.command = link(env.commandStr);
            env.assert = function(block, pred, message) {
              block(
                "if(!(",
                pred,
                "))",
                this.CHECK,
                ".commandRaise(",
                link(message),
                ",",
                this.command,
                ");"
              );
            };
            sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
          });
          var nextVars = env.next = {};
          var currentVars = env.current = {};
          Object.keys(GL_VARIABLES).forEach(function(variable) {
            if (Array.isArray(currentState[variable])) {
              nextVars[variable] = global2.def(shared.next, ".", variable);
              currentVars[variable] = global2.def(shared.current, ".", variable);
            }
          });
          var constants = env.constants = {};
          Object.keys(sharedConstants).forEach(function(name) {
            constants[name] = global2.def(JSON.stringify(sharedConstants[name]));
          });
          env.invoke = function(block, x4) {
            switch (x4.type) {
              case DYN_FUNC$1:
                var argList = [
                  "this",
                  shared.context,
                  shared.props,
                  env.batchId
                ];
                return block.def(
                  link(x4.data),
                  ".call(",
                  argList.slice(0, Math.max(x4.data.length + 1, 4)),
                  ")"
                );
              case DYN_PROP$1:
                return block.def(shared.props, x4.data);
              case DYN_CONTEXT$1:
                return block.def(shared.context, x4.data);
              case DYN_STATE$1:
                return block.def("this", x4.data);
              case DYN_THUNK:
                x4.data.append(env, block);
                return x4.data.ref;
              case DYN_CONSTANT$1:
                return x4.data.toString();
              case DYN_ARRAY$1:
                return x4.data.map(function(y4) {
                  return env.invoke(block, y4);
                });
            }
          };
          env.attribCache = {};
          var scopeAttribs = {};
          env.scopeAttrib = function(name) {
            var id = stringStore.id(name);
            if (id in scopeAttribs) {
              return scopeAttribs[id];
            }
            var binding = attributeState.scope[id];
            if (!binding) {
              binding = attributeState.scope[id] = new AttributeRecord2();
            }
            var result = scopeAttribs[id] = link(binding);
            return result;
          };
          return env;
        }
        function parseProfile(options) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          var profileEnable;
          if (S_PROFILE in staticOptions) {
            var value = !!staticOptions[S_PROFILE];
            profileEnable = createStaticDecl(function(env, scope) {
              return value;
            });
            profileEnable.enable = value;
          } else if (S_PROFILE in dynamicOptions) {
            var dyn = dynamicOptions[S_PROFILE];
            profileEnable = createDynamicDecl(dyn, function(env, scope) {
              return env.invoke(scope, dyn);
            });
          }
          return profileEnable;
        }
        function parseFramebuffer(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          if (S_FRAMEBUFFER in staticOptions) {
            var framebuffer = staticOptions[S_FRAMEBUFFER];
            if (framebuffer) {
              framebuffer = framebufferState.getFramebuffer(framebuffer);
              check$1.command(framebuffer, "invalid framebuffer object");
              return createStaticDecl(function(env2, block) {
                var FRAMEBUFFER = env2.link(framebuffer);
                var shared = env2.shared;
                block.set(
                  shared.framebuffer,
                  ".next",
                  FRAMEBUFFER
                );
                var CONTEXT = shared.context;
                block.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_WIDTH,
                  FRAMEBUFFER + ".width"
                );
                block.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_HEIGHT,
                  FRAMEBUFFER + ".height"
                );
                return FRAMEBUFFER;
              });
            } else {
              return createStaticDecl(function(env2, scope) {
                var shared = env2.shared;
                scope.set(
                  shared.framebuffer,
                  ".next",
                  "null"
                );
                var CONTEXT = shared.context;
                scope.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_WIDTH,
                  CONTEXT + "." + S_DRAWINGBUFFER_WIDTH
                );
                scope.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_HEIGHT,
                  CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT
                );
                return "null";
              });
            }
          } else if (S_FRAMEBUFFER in dynamicOptions) {
            var dyn = dynamicOptions[S_FRAMEBUFFER];
            return createDynamicDecl(dyn, function(env2, scope) {
              var FRAMEBUFFER_FUNC = env2.invoke(scope, dyn);
              var shared = env2.shared;
              var FRAMEBUFFER_STATE = shared.framebuffer;
              var FRAMEBUFFER = scope.def(
                FRAMEBUFFER_STATE,
                ".getFramebuffer(",
                FRAMEBUFFER_FUNC,
                ")"
              );
              check$1.optional(function() {
                env2.assert(
                  scope,
                  "!" + FRAMEBUFFER_FUNC + "||" + FRAMEBUFFER,
                  "invalid framebuffer object"
                );
              });
              scope.set(
                FRAMEBUFFER_STATE,
                ".next",
                FRAMEBUFFER
              );
              var CONTEXT = shared.context;
              scope.set(
                CONTEXT,
                "." + S_FRAMEBUFFER_WIDTH,
                FRAMEBUFFER + "?" + FRAMEBUFFER + ".width:" + CONTEXT + "." + S_DRAWINGBUFFER_WIDTH
              );
              scope.set(
                CONTEXT,
                "." + S_FRAMEBUFFER_HEIGHT,
                FRAMEBUFFER + "?" + FRAMEBUFFER + ".height:" + CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT
              );
              return FRAMEBUFFER;
            });
          } else {
            return null;
          }
        }
        function parseViewportScissor(options, framebuffer, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseBox(param) {
            if (param in staticOptions) {
              var box = staticOptions[param];
              check$1.commandType(box, "object", "invalid " + param, env.commandStr);
              var isStatic2 = true;
              var x4 = box.x | 0;
              var y4 = box.y | 0;
              var w2, h2;
              if ("width" in box) {
                w2 = box.width | 0;
                check$1.command(w2 >= 0, "invalid " + param, env.commandStr);
              } else {
                isStatic2 = false;
              }
              if ("height" in box) {
                h2 = box.height | 0;
                check$1.command(h2 >= 0, "invalid " + param, env.commandStr);
              } else {
                isStatic2 = false;
              }
              return new Declaration(
                !isStatic2 && framebuffer && framebuffer.thisDep,
                !isStatic2 && framebuffer && framebuffer.contextDep,
                !isStatic2 && framebuffer && framebuffer.propDep,
                function(env2, scope) {
                  var CONTEXT = env2.shared.context;
                  var BOX_W = w2;
                  if (!("width" in box)) {
                    BOX_W = scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH, "-", x4);
                  }
                  var BOX_H = h2;
                  if (!("height" in box)) {
                    BOX_H = scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT, "-", y4);
                  }
                  return [x4, y4, BOX_W, BOX_H];
                }
              );
            } else if (param in dynamicOptions) {
              var dynBox = dynamicOptions[param];
              var result = createDynamicDecl(dynBox, function(env2, scope) {
                var BOX = env2.invoke(scope, dynBox);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    BOX + "&&typeof " + BOX + '==="object"',
                    "invalid " + param
                  );
                });
                var CONTEXT = env2.shared.context;
                var BOX_X = scope.def(BOX, ".x|0");
                var BOX_Y = scope.def(BOX, ".y|0");
                var BOX_W = scope.def(
                  '"width" in ',
                  BOX,
                  "?",
                  BOX,
                  ".width|0:",
                  "(",
                  CONTEXT,
                  ".",
                  S_FRAMEBUFFER_WIDTH,
                  "-",
                  BOX_X,
                  ")"
                );
                var BOX_H = scope.def(
                  '"height" in ',
                  BOX,
                  "?",
                  BOX,
                  ".height|0:",
                  "(",
                  CONTEXT,
                  ".",
                  S_FRAMEBUFFER_HEIGHT,
                  "-",
                  BOX_Y,
                  ")"
                );
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    BOX_W + ">=0&&" + BOX_H + ">=0",
                    "invalid " + param
                  );
                });
                return [BOX_X, BOX_Y, BOX_W, BOX_H];
              });
              if (framebuffer) {
                result.thisDep = result.thisDep || framebuffer.thisDep;
                result.contextDep = result.contextDep || framebuffer.contextDep;
                result.propDep = result.propDep || framebuffer.propDep;
              }
              return result;
            } else if (framebuffer) {
              return new Declaration(
                framebuffer.thisDep,
                framebuffer.contextDep,
                framebuffer.propDep,
                function(env2, scope) {
                  var CONTEXT = env2.shared.context;
                  return [
                    0,
                    0,
                    scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH),
                    scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT)
                  ];
                }
              );
            } else {
              return null;
            }
          }
          var viewport = parseBox(S_VIEWPORT);
          if (viewport) {
            var prevViewport = viewport;
            viewport = new Declaration(
              viewport.thisDep,
              viewport.contextDep,
              viewport.propDep,
              function(env2, scope) {
                var VIEWPORT = prevViewport.append(env2, scope);
                var CONTEXT = env2.shared.context;
                scope.set(
                  CONTEXT,
                  "." + S_VIEWPORT_WIDTH,
                  VIEWPORT[2]
                );
                scope.set(
                  CONTEXT,
                  "." + S_VIEWPORT_HEIGHT,
                  VIEWPORT[3]
                );
                return VIEWPORT;
              }
            );
          }
          return {
            viewport,
            scissor_box: parseBox(S_SCISSOR_BOX)
          };
        }
        function parseAttribLocations(options, attributes) {
          var staticOptions = options.static;
          var staticProgram = typeof staticOptions[S_FRAG] === "string" && typeof staticOptions[S_VERT] === "string";
          if (staticProgram) {
            if (Object.keys(attributes.dynamic).length > 0) {
              return null;
            }
            var staticAttributes = attributes.static;
            var sAttributes = Object.keys(staticAttributes);
            if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === "number") {
              var bindings = [];
              for (var i2 = 0; i2 < sAttributes.length; ++i2) {
                check$1(typeof staticAttributes[sAttributes[i2]] === "number", "must specify all vertex attribute locations when using vaos");
                bindings.push([staticAttributes[sAttributes[i2]] | 0, sAttributes[i2]]);
              }
              return bindings;
            }
          }
          return null;
        }
        function parseProgram(options, env, attribLocations) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseShader(name) {
            if (name in staticOptions) {
              var id = stringStore.id(staticOptions[name]);
              check$1.optional(function() {
                shaderState.shader(shaderType[name], id, check$1.guessCommand());
              });
              var result = createStaticDecl(function() {
                return id;
              });
              result.id = id;
              return result;
            } else if (name in dynamicOptions) {
              var dyn = dynamicOptions[name];
              return createDynamicDecl(dyn, function(env2, scope) {
                var str = env2.invoke(scope, dyn);
                var id2 = scope.def(env2.shared.strings, ".id(", str, ")");
                check$1.optional(function() {
                  scope(
                    env2.shared.shader,
                    ".shader(",
                    shaderType[name],
                    ",",
                    id2,
                    ",",
                    env2.command,
                    ");"
                  );
                });
                return id2;
              });
            }
            return null;
          }
          var frag = parseShader(S_FRAG);
          var vert = parseShader(S_VERT);
          var program = null;
          var progVar;
          if (isStatic(frag) && isStatic(vert)) {
            program = shaderState.program(vert.id, frag.id, null, attribLocations);
            progVar = createStaticDecl(function(env2, scope) {
              return env2.link(program);
            });
          } else {
            progVar = new Declaration(
              frag && frag.thisDep || vert && vert.thisDep,
              frag && frag.contextDep || vert && vert.contextDep,
              frag && frag.propDep || vert && vert.propDep,
              function(env2, scope) {
                var SHADER_STATE = env2.shared.shader;
                var fragId;
                if (frag) {
                  fragId = frag.append(env2, scope);
                } else {
                  fragId = scope.def(SHADER_STATE, ".", S_FRAG);
                }
                var vertId;
                if (vert) {
                  vertId = vert.append(env2, scope);
                } else {
                  vertId = scope.def(SHADER_STATE, ".", S_VERT);
                }
                var progDef = SHADER_STATE + ".program(" + vertId + "," + fragId;
                check$1.optional(function() {
                  progDef += "," + env2.command;
                });
                return scope.def(progDef + ")");
              }
            );
          }
          return {
            frag,
            vert,
            progVar,
            program
          };
        }
        function parseDraw(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseElements() {
            if (S_ELEMENTS in staticOptions) {
              var elements2 = staticOptions[S_ELEMENTS];
              if (isBufferArgs(elements2)) {
                elements2 = elementState.getElements(elementState.create(elements2, true));
              } else if (elements2) {
                elements2 = elementState.getElements(elements2);
                check$1.command(elements2, "invalid elements", env.commandStr);
              }
              var result = createStaticDecl(function(env2, scope) {
                if (elements2) {
                  var result2 = env2.link(elements2);
                  env2.ELEMENTS = result2;
                  return result2;
                }
                env2.ELEMENTS = null;
                return null;
              });
              result.value = elements2;
              return result;
            } else if (S_ELEMENTS in dynamicOptions) {
              var dyn = dynamicOptions[S_ELEMENTS];
              return createDynamicDecl(dyn, function(env2, scope) {
                var shared = env2.shared;
                var IS_BUFFER_ARGS = shared.isBufferArgs;
                var ELEMENT_STATE = shared.elements;
                var elementDefn = env2.invoke(scope, dyn);
                var elements3 = scope.def("null");
                var elementStream = scope.def(IS_BUFFER_ARGS, "(", elementDefn, ")");
                var ifte = env2.cond(elementStream).then(elements3, "=", ELEMENT_STATE, ".createStream(", elementDefn, ");").else(elements3, "=", ELEMENT_STATE, ".getElements(", elementDefn, ");");
                check$1.optional(function() {
                  env2.assert(
                    ifte.else,
                    "!" + elementDefn + "||" + elements3,
                    "invalid elements"
                  );
                });
                scope.entry(ifte);
                scope.exit(
                  env2.cond(elementStream).then(ELEMENT_STATE, ".destroyStream(", elements3, ");")
                );
                env2.ELEMENTS = elements3;
                return elements3;
              });
            }
            return null;
          }
          var elements = parseElements();
          function parsePrimitive() {
            if (S_PRIMITIVE in staticOptions) {
              var primitive = staticOptions[S_PRIMITIVE];
              check$1.commandParameter(primitive, primTypes, "invalid primitve", env.commandStr);
              return createStaticDecl(function(env2, scope) {
                return primTypes[primitive];
              });
            } else if (S_PRIMITIVE in dynamicOptions) {
              var dynPrimitive = dynamicOptions[S_PRIMITIVE];
              return createDynamicDecl(dynPrimitive, function(env2, scope) {
                var PRIM_TYPES = env2.constants.primTypes;
                var prim3 = env2.invoke(scope, dynPrimitive);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    prim3 + " in " + PRIM_TYPES,
                    "invalid primitive, must be one of " + Object.keys(primTypes)
                  );
                });
                return scope.def(PRIM_TYPES, "[", prim3, "]");
              });
            } else if (elements) {
              if (isStatic(elements)) {
                if (elements.value) {
                  return createStaticDecl(function(env2, scope) {
                    return scope.def(env2.ELEMENTS, ".primType");
                  });
                } else {
                  return createStaticDecl(function() {
                    return GL_TRIANGLES$1;
                  });
                }
              } else {
                return new Declaration(
                  elements.thisDep,
                  elements.contextDep,
                  elements.propDep,
                  function(env2, scope) {
                    var elements2 = env2.ELEMENTS;
                    return scope.def(elements2, "?", elements2, ".primType:", GL_TRIANGLES$1);
                  }
                );
              }
            }
            return null;
          }
          function parseParam(param, isOffset) {
            if (param in staticOptions) {
              var value = staticOptions[param] | 0;
              check$1.command(!isOffset || value >= 0, "invalid " + param, env.commandStr);
              return createStaticDecl(function(env2, scope) {
                if (isOffset) {
                  env2.OFFSET = value;
                }
                return value;
              });
            } else if (param in dynamicOptions) {
              var dynValue = dynamicOptions[param];
              return createDynamicDecl(dynValue, function(env2, scope) {
                var result = env2.invoke(scope, dynValue);
                if (isOffset) {
                  env2.OFFSET = result;
                  check$1.optional(function() {
                    env2.assert(
                      scope,
                      result + ">=0",
                      "invalid " + param
                    );
                  });
                }
                return result;
              });
            } else if (isOffset && elements) {
              return createStaticDecl(function(env2, scope) {
                env2.OFFSET = "0";
                return 0;
              });
            }
            return null;
          }
          var OFFSET = parseParam(S_OFFSET, true);
          function parseVertCount() {
            if (S_COUNT in staticOptions) {
              var count = staticOptions[S_COUNT] | 0;
              check$1.command(
                typeof count === "number" && count >= 0,
                "invalid vertex count",
                env.commandStr
              );
              return createStaticDecl(function() {
                return count;
              });
            } else if (S_COUNT in dynamicOptions) {
              var dynCount = dynamicOptions[S_COUNT];
              return createDynamicDecl(dynCount, function(env2, scope) {
                var result2 = env2.invoke(scope, dynCount);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    "typeof " + result2 + '==="number"&&' + result2 + ">=0&&" + result2 + "===(" + result2 + "|0)",
                    "invalid vertex count"
                  );
                });
                return result2;
              });
            } else if (elements) {
              if (isStatic(elements)) {
                if (elements) {
                  if (OFFSET) {
                    return new Declaration(
                      OFFSET.thisDep,
                      OFFSET.contextDep,
                      OFFSET.propDep,
                      function(env2, scope) {
                        var result2 = scope.def(
                          env2.ELEMENTS,
                          ".vertCount-",
                          env2.OFFSET
                        );
                        check$1.optional(function() {
                          env2.assert(
                            scope,
                            result2 + ">=0",
                            "invalid vertex offset/element buffer too small"
                          );
                        });
                        return result2;
                      }
                    );
                  } else {
                    return createStaticDecl(function(env2, scope) {
                      return scope.def(env2.ELEMENTS, ".vertCount");
                    });
                  }
                } else {
                  var result = createStaticDecl(function() {
                    return -1;
                  });
                  check$1.optional(function() {
                    result.MISSING = true;
                  });
                  return result;
                }
              } else {
                var variable = new Declaration(
                  elements.thisDep || OFFSET.thisDep,
                  elements.contextDep || OFFSET.contextDep,
                  elements.propDep || OFFSET.propDep,
                  function(env2, scope) {
                    var elements2 = env2.ELEMENTS;
                    if (env2.OFFSET) {
                      return scope.def(
                        elements2,
                        "?",
                        elements2,
                        ".vertCount-",
                        env2.OFFSET,
                        ":-1"
                      );
                    }
                    return scope.def(elements2, "?", elements2, ".vertCount:-1");
                  }
                );
                check$1.optional(function() {
                  variable.DYNAMIC = true;
                });
                return variable;
              }
            }
            return null;
          }
          return {
            elements,
            primitive: parsePrimitive(),
            count: parseVertCount(),
            instances: parseParam(S_INSTANCES, false),
            offset: OFFSET
          };
        }
        function parseGLState(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          var STATE = {};
          GL_STATE_NAMES.forEach(function(prop) {
            var param = propName(prop);
            function parseParam(parseStatic, parseDynamic) {
              if (prop in staticOptions) {
                var value = parseStatic(staticOptions[prop]);
                STATE[param] = createStaticDecl(function() {
                  return value;
                });
              } else if (prop in dynamicOptions) {
                var dyn = dynamicOptions[prop];
                STATE[param] = createDynamicDecl(dyn, function(env2, scope) {
                  return parseDynamic(env2, scope, env2.invoke(scope, dyn));
                });
              }
            }
            switch (prop) {
              case S_CULL_ENABLE:
              case S_BLEND_ENABLE:
              case S_DITHER:
              case S_STENCIL_ENABLE:
              case S_DEPTH_ENABLE:
              case S_SCISSOR_ENABLE:
              case S_POLYGON_OFFSET_ENABLE:
              case S_SAMPLE_ALPHA:
              case S_SAMPLE_ENABLE:
              case S_DEPTH_MASK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "boolean", prop, env.commandStr);
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="boolean"',
                        "invalid flag " + prop,
                        env2.commandStr
                      );
                    });
                    return value;
                  }
                );
              case S_DEPTH_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandParameter(value, compareFuncs, "invalid " + prop, env.commandStr);
                    return compareFuncs[value];
                  },
                  function(env2, scope, value) {
                    var COMPARE_FUNCS = env2.constants.compareFuncs;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + " in " + COMPARE_FUNCS,
                        "invalid " + prop + ", must be one of " + Object.keys(compareFuncs)
                      );
                    });
                    return scope.def(COMPARE_FUNCS, "[", value, "]");
                  }
                );
              case S_DEPTH_RANGE:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike2(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number" && value[0] <= value[1],
                      "depth range is 2d array",
                      env.commandStr
                    );
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===2&&typeof " + value + '[0]==="number"&&typeof ' + value + '[1]==="number"&&' + value + "[0]<=" + value + "[1]",
                        "depth range must be a 2d array"
                      );
                    });
                    var Z_NEAR = scope.def("+", value, "[0]");
                    var Z_FAR = scope.def("+", value, "[1]");
                    return [Z_NEAR, Z_FAR];
                  }
                );
              case S_BLEND_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", "blend.func", env.commandStr);
                    var srcRGB = "srcRGB" in value ? value.srcRGB : value.src;
                    var srcAlpha = "srcAlpha" in value ? value.srcAlpha : value.src;
                    var dstRGB = "dstRGB" in value ? value.dstRGB : value.dst;
                    var dstAlpha = "dstAlpha" in value ? value.dstAlpha : value.dst;
                    check$1.commandParameter(srcRGB, blendFuncs, param + ".srcRGB", env.commandStr);
                    check$1.commandParameter(srcAlpha, blendFuncs, param + ".srcAlpha", env.commandStr);
                    check$1.commandParameter(dstRGB, blendFuncs, param + ".dstRGB", env.commandStr);
                    check$1.commandParameter(dstAlpha, blendFuncs, param + ".dstAlpha", env.commandStr);
                    check$1.command(
                      invalidBlendCombinations.indexOf(srcRGB + ", " + dstRGB) === -1,
                      "unallowed blending combination (srcRGB, dstRGB) = (" + srcRGB + ", " + dstRGB + ")",
                      env.commandStr
                    );
                    return [
                      blendFuncs[srcRGB],
                      blendFuncs[dstRGB],
                      blendFuncs[srcAlpha],
                      blendFuncs[dstAlpha]
                    ];
                  },
                  function(env2, scope, value) {
                    var BLEND_FUNCS = env2.constants.blendFuncs;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid blend func, must be an object"
                      );
                    });
                    function read3(prefix, suffix) {
                      var func = scope.def(
                        '"',
                        prefix,
                        suffix,
                        '" in ',
                        value,
                        "?",
                        value,
                        ".",
                        prefix,
                        suffix,
                        ":",
                        value,
                        ".",
                        prefix
                      );
                      check$1.optional(function() {
                        env2.assert(
                          scope,
                          func + " in " + BLEND_FUNCS,
                          "invalid " + prop + "." + prefix + suffix + ", must be one of " + Object.keys(blendFuncs)
                        );
                      });
                      return func;
                    }
                    var srcRGB = read3("src", "RGB");
                    var dstRGB = read3("dst", "RGB");
                    check$1.optional(function() {
                      var INVALID_BLEND_COMBINATIONS = env2.constants.invalidBlendCombinations;
                      env2.assert(
                        scope,
                        INVALID_BLEND_COMBINATIONS + ".indexOf(" + srcRGB + '+", "+' + dstRGB + ") === -1 ",
                        "unallowed blending combination for (srcRGB, dstRGB)"
                      );
                    });
                    var SRC_RGB = scope.def(BLEND_FUNCS, "[", srcRGB, "]");
                    var SRC_ALPHA = scope.def(BLEND_FUNCS, "[", read3("src", "Alpha"), "]");
                    var DST_RGB = scope.def(BLEND_FUNCS, "[", dstRGB, "]");
                    var DST_ALPHA = scope.def(BLEND_FUNCS, "[", read3("dst", "Alpha"), "]");
                    return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];
                  }
                );
              case S_BLEND_EQUATION:
                return parseParam(
                  function(value) {
                    if (typeof value === "string") {
                      check$1.commandParameter(value, blendEquations, "invalid " + prop, env.commandStr);
                      return [
                        blendEquations[value],
                        blendEquations[value]
                      ];
                    } else if (typeof value === "object") {
                      check$1.commandParameter(
                        value.rgb,
                        blendEquations,
                        prop + ".rgb",
                        env.commandStr
                      );
                      check$1.commandParameter(
                        value.alpha,
                        blendEquations,
                        prop + ".alpha",
                        env.commandStr
                      );
                      return [
                        blendEquations[value.rgb],
                        blendEquations[value.alpha]
                      ];
                    } else {
                      check$1.commandRaise("invalid blend.equation", env.commandStr);
                    }
                  },
                  function(env2, scope, value) {
                    var BLEND_EQUATIONS = env2.constants.blendEquations;
                    var RGB = scope.def();
                    var ALPHA = scope.def();
                    var ifte = env2.cond("typeof ", value, '==="string"');
                    check$1.optional(function() {
                      function checkProp(block, name, value2) {
                        env2.assert(
                          block,
                          value2 + " in " + BLEND_EQUATIONS,
                          "invalid " + name + ", must be one of " + Object.keys(blendEquations)
                        );
                      }
                      checkProp(ifte.then, prop, value);
                      env2.assert(
                        ifte.else,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                      checkProp(ifte.else, prop + ".rgb", value + ".rgb");
                      checkProp(ifte.else, prop + ".alpha", value + ".alpha");
                    });
                    ifte.then(
                      RGB,
                      "=",
                      ALPHA,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      "];"
                    );
                    ifte.else(
                      RGB,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      ".rgb];",
                      ALPHA,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      ".alpha];"
                    );
                    scope(ifte);
                    return [RGB, ALPHA];
                  }
                );
              case S_BLEND_COLOR:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike2(value) && value.length === 4,
                      "blend.color must be a 4d array",
                      env.commandStr
                    );
                    return loop(4, function(i2) {
                      return +value[i2];
                    });
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===4",
                        "blend.color must be a 4d array"
                      );
                    });
                    return loop(4, function(i2) {
                      return scope.def("+", value, "[", i2, "]");
                    });
                  }
                );
              case S_STENCIL_MASK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "number", param, env.commandStr);
                    return value | 0;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="number"',
                        "invalid stencil.mask"
                      );
                    });
                    return scope.def(value, "|0");
                  }
                );
              case S_STENCIL_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var cmp = value.cmp || "keep";
                    var ref = value.ref || 0;
                    var mask = "mask" in value ? value.mask : -1;
                    check$1.commandParameter(cmp, compareFuncs, prop + ".cmp", env.commandStr);
                    check$1.commandType(ref, "number", prop + ".ref", env.commandStr);
                    check$1.commandType(mask, "number", prop + ".mask", env.commandStr);
                    return [
                      compareFuncs[cmp],
                      ref,
                      mask
                    ];
                  },
                  function(env2, scope, value) {
                    var COMPARE_FUNCS = env2.constants.compareFuncs;
                    check$1.optional(function() {
                      function assert() {
                        env2.assert(
                          scope,
                          Array.prototype.join.call(arguments, ""),
                          "invalid stencil.func"
                        );
                      }
                      assert(value + "&&typeof ", value, '==="object"');
                      assert(
                        '!("cmp" in ',
                        value,
                        ")||(",
                        value,
                        ".cmp in ",
                        COMPARE_FUNCS,
                        ")"
                      );
                    });
                    var cmp = scope.def(
                      '"cmp" in ',
                      value,
                      "?",
                      COMPARE_FUNCS,
                      "[",
                      value,
                      ".cmp]",
                      ":",
                      GL_KEEP
                    );
                    var ref = scope.def(value, ".ref|0");
                    var mask = scope.def(
                      '"mask" in ',
                      value,
                      "?",
                      value,
                      ".mask|0:-1"
                    );
                    return [cmp, ref, mask];
                  }
                );
              case S_STENCIL_OPFRONT:
              case S_STENCIL_OPBACK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var fail = value.fail || "keep";
                    var zfail = value.zfail || "keep";
                    var zpass = value.zpass || "keep";
                    check$1.commandParameter(fail, stencilOps, prop + ".fail", env.commandStr);
                    check$1.commandParameter(zfail, stencilOps, prop + ".zfail", env.commandStr);
                    check$1.commandParameter(zpass, stencilOps, prop + ".zpass", env.commandStr);
                    return [
                      prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                      stencilOps[fail],
                      stencilOps[zfail],
                      stencilOps[zpass]
                    ];
                  },
                  function(env2, scope, value) {
                    var STENCIL_OPS = env2.constants.stencilOps;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                    });
                    function read3(name) {
                      check$1.optional(function() {
                        env2.assert(
                          scope,
                          '!("' + name + '" in ' + value + ")||(" + value + "." + name + " in " + STENCIL_OPS + ")",
                          "invalid " + prop + "." + name + ", must be one of " + Object.keys(stencilOps)
                        );
                      });
                      return scope.def(
                        '"',
                        name,
                        '" in ',
                        value,
                        "?",
                        STENCIL_OPS,
                        "[",
                        value,
                        ".",
                        name,
                        "]:",
                        GL_KEEP
                      );
                    }
                    return [
                      prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                      read3("fail"),
                      read3("zfail"),
                      read3("zpass")
                    ];
                  }
                );
              case S_POLYGON_OFFSET_OFFSET:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var factor = value.factor | 0;
                    var units = value.units | 0;
                    check$1.commandType(factor, "number", param + ".factor", env.commandStr);
                    check$1.commandType(units, "number", param + ".units", env.commandStr);
                    return [factor, units];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                    });
                    var FACTOR = scope.def(value, ".factor|0");
                    var UNITS = scope.def(value, ".units|0");
                    return [FACTOR, UNITS];
                  }
                );
              case S_CULL_FACE:
                return parseParam(
                  function(value) {
                    var face = 0;
                    if (value === "front") {
                      face = GL_FRONT;
                    } else if (value === "back") {
                      face = GL_BACK;
                    }
                    check$1.command(!!face, param, env.commandStr);
                    return face;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + '==="front"||' + value + '==="back"',
                        "invalid cull.face"
                      );
                    });
                    return scope.def(value, '==="front"?', GL_FRONT, ":", GL_BACK);
                  }
                );
              case S_LINE_WIDTH:
                return parseParam(
                  function(value) {
                    check$1.command(
                      typeof value === "number" && value >= limits.lineWidthDims[0] && value <= limits.lineWidthDims[1],
                      "invalid line width, must be a positive number between " + limits.lineWidthDims[0] + " and " + limits.lineWidthDims[1],
                      env.commandStr
                    );
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="number"&&' + value + ">=" + limits.lineWidthDims[0] + "&&" + value + "<=" + limits.lineWidthDims[1],
                        "invalid line width"
                      );
                    });
                    return value;
                  }
                );
              case S_FRONT_FACE:
                return parseParam(
                  function(value) {
                    check$1.commandParameter(value, orientationType, param, env.commandStr);
                    return orientationType[value];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + '==="cw"||' + value + '==="ccw"',
                        "invalid frontFace, must be one of cw,ccw"
                      );
                    });
                    return scope.def(value + '==="cw"?' + GL_CW + ":" + GL_CCW);
                  }
                );
              case S_COLOR_MASK:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike2(value) && value.length === 4,
                      "color.mask must be length 4 array",
                      env.commandStr
                    );
                    return value.map(function(v2) {
                      return !!v2;
                    });
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===4",
                        "invalid color.mask"
                      );
                    });
                    return loop(4, function(i2) {
                      return "!!" + value + "[" + i2 + "]";
                    });
                  }
                );
              case S_SAMPLE_COVERAGE:
                return parseParam(
                  function(value) {
                    check$1.command(typeof value === "object" && value, param, env.commandStr);
                    var sampleValue = "value" in value ? value.value : 1;
                    var sampleInvert = !!value.invert;
                    check$1.command(
                      typeof sampleValue === "number" && sampleValue >= 0 && sampleValue <= 1,
                      "sample.coverage.value must be a number between 0 and 1",
                      env.commandStr
                    );
                    return [sampleValue, sampleInvert];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid sample.coverage"
                      );
                    });
                    var VALUE = scope.def(
                      '"value" in ',
                      value,
                      "?+",
                      value,
                      ".value:1"
                    );
                    var INVERT = scope.def("!!", value, ".invert");
                    return [VALUE, INVERT];
                  }
                );
            }
          });
          return STATE;
        }
        function parseUniforms(uniforms, env) {
          var staticUniforms = uniforms.static;
          var dynamicUniforms = uniforms.dynamic;
          var UNIFORMS = {};
          Object.keys(staticUniforms).forEach(function(name) {
            var value = staticUniforms[name];
            var result;
            if (typeof value === "number" || typeof value === "boolean") {
              result = createStaticDecl(function() {
                return value;
              });
            } else if (typeof value === "function") {
              var reglType = value._reglType;
              if (reglType === "texture2d" || reglType === "textureCube") {
                result = createStaticDecl(function(env2) {
                  return env2.link(value);
                });
              } else if (reglType === "framebuffer" || reglType === "framebufferCube") {
                check$1.command(
                  value.color.length > 0,
                  'missing color attachment for framebuffer sent to uniform "' + name + '"',
                  env.commandStr
                );
                result = createStaticDecl(function(env2) {
                  return env2.link(value.color[0]);
                });
              } else {
                check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr);
              }
            } else if (isArrayLike2(value)) {
              result = createStaticDecl(function(env2) {
                var ITEM = env2.global.def(
                  "[",
                  loop(value.length, function(i2) {
                    check$1.command(
                      typeof value[i2] === "number" || typeof value[i2] === "boolean",
                      "invalid uniform " + name,
                      env2.commandStr
                    );
                    return value[i2];
                  }),
                  "]"
                );
                return ITEM;
              });
            } else {
              check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr);
            }
            result.value = value;
            UNIFORMS[name] = result;
          });
          Object.keys(dynamicUniforms).forEach(function(key) {
            var dyn = dynamicUniforms[key];
            UNIFORMS[key] = createDynamicDecl(dyn, function(env2, scope) {
              return env2.invoke(scope, dyn);
            });
          });
          return UNIFORMS;
        }
        function parseAttributes(attributes, env) {
          var staticAttributes = attributes.static;
          var dynamicAttributes = attributes.dynamic;
          var attributeDefs = {};
          Object.keys(staticAttributes).forEach(function(attribute) {
            var value = staticAttributes[attribute];
            var id = stringStore.id(attribute);
            var record = new AttributeRecord2();
            if (isBufferArgs(value)) {
              record.state = ATTRIB_STATE_POINTER;
              record.buffer = bufferState.getBuffer(
                bufferState.create(value, GL_ARRAY_BUFFER$2, false, true)
              );
              record.type = 0;
            } else {
              var buffer = bufferState.getBuffer(value);
              if (buffer) {
                record.state = ATTRIB_STATE_POINTER;
                record.buffer = buffer;
                record.type = 0;
              } else {
                check$1.command(
                  typeof value === "object" && value,
                  "invalid data for attribute " + attribute,
                  env.commandStr
                );
                if ("constant" in value) {
                  var constant = value.constant;
                  record.buffer = "null";
                  record.state = ATTRIB_STATE_CONSTANT;
                  if (typeof constant === "number") {
                    record.x = constant;
                  } else {
                    check$1.command(
                      isArrayLike2(constant) && constant.length > 0 && constant.length <= 4,
                      "invalid constant for attribute " + attribute,
                      env.commandStr
                    );
                    CUTE_COMPONENTS.forEach(function(c3, i2) {
                      if (i2 < constant.length) {
                        record[c3] = constant[i2];
                      }
                    });
                  }
                } else {
                  if (isBufferArgs(value.buffer)) {
                    buffer = bufferState.getBuffer(
                      bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true)
                    );
                  } else {
                    buffer = bufferState.getBuffer(value.buffer);
                  }
                  check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr);
                  var offset = value.offset | 0;
                  check$1.command(
                    offset >= 0,
                    'invalid offset for attribute "' + attribute + '"',
                    env.commandStr
                  );
                  var stride = value.stride | 0;
                  check$1.command(
                    stride >= 0 && stride < 256,
                    'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]',
                    env.commandStr
                  );
                  var size3 = value.size | 0;
                  check$1.command(
                    !("size" in value) || size3 > 0 && size3 <= 4,
                    'invalid size for attribute "' + attribute + '", must be 1,2,3,4',
                    env.commandStr
                  );
                  var normalized = !!value.normalized;
                  var type = 0;
                  if ("type" in value) {
                    check$1.commandParameter(
                      value.type,
                      glTypes,
                      "invalid type for attribute " + attribute,
                      env.commandStr
                    );
                    type = glTypes[value.type];
                  }
                  var divisor = value.divisor | 0;
                  if ("divisor" in value) {
                    check$1.command(
                      divisor === 0 || extInstancing,
                      'cannot specify divisor for attribute "' + attribute + '", instancing not supported',
                      env.commandStr
                    );
                    check$1.command(
                      divisor >= 0,
                      'invalid divisor for attribute "' + attribute + '"',
                      env.commandStr
                    );
                  }
                  check$1.optional(function() {
                    var command = env.commandStr;
                    var VALID_KEYS = [
                      "buffer",
                      "offset",
                      "divisor",
                      "normalized",
                      "type",
                      "size",
                      "stride"
                    ];
                    Object.keys(value).forEach(function(prop) {
                      check$1.command(
                        VALID_KEYS.indexOf(prop) >= 0,
                        'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ")",
                        command
                      );
                    });
                  });
                  record.buffer = buffer;
                  record.state = ATTRIB_STATE_POINTER;
                  record.size = size3;
                  record.normalized = normalized;
                  record.type = type || buffer.dtype;
                  record.offset = offset;
                  record.stride = stride;
                  record.divisor = divisor;
                }
              }
            }
            attributeDefs[attribute] = createStaticDecl(function(env2, scope) {
              var cache2 = env2.attribCache;
              if (id in cache2) {
                return cache2[id];
              }
              var result = {
                isStream: false
              };
              Object.keys(record).forEach(function(key) {
                result[key] = record[key];
              });
              if (record.buffer) {
                result.buffer = env2.link(record.buffer);
                result.type = result.type || result.buffer + ".dtype";
              }
              cache2[id] = result;
              return result;
            });
          });
          Object.keys(dynamicAttributes).forEach(function(attribute) {
            var dyn = dynamicAttributes[attribute];
            function appendAttributeCode(env2, block) {
              var VALUE = env2.invoke(block, dyn);
              var shared = env2.shared;
              var constants = env2.constants;
              var IS_BUFFER_ARGS = shared.isBufferArgs;
              var BUFFER_STATE = shared.buffer;
              check$1.optional(function() {
                env2.assert(
                  block,
                  VALUE + "&&(typeof " + VALUE + '==="object"||typeof ' + VALUE + '==="function")&&(' + IS_BUFFER_ARGS + "(" + VALUE + ")||" + BUFFER_STATE + ".getBuffer(" + VALUE + ")||" + BUFFER_STATE + ".getBuffer(" + VALUE + ".buffer)||" + IS_BUFFER_ARGS + "(" + VALUE + '.buffer)||("constant" in ' + VALUE + "&&(typeof " + VALUE + '.constant==="number"||' + shared.isArrayLike + "(" + VALUE + ".constant))))",
                  'invalid dynamic attribute "' + attribute + '"'
                );
              });
              var result = {
                isStream: block.def(false)
              };
              var defaultRecord = new AttributeRecord2();
              defaultRecord.state = ATTRIB_STATE_POINTER;
              Object.keys(defaultRecord).forEach(function(key) {
                result[key] = block.def("" + defaultRecord[key]);
              });
              var BUFFER = result.buffer;
              var TYPE = result.type;
              block(
                "if(",
                IS_BUFFER_ARGS,
                "(",
                VALUE,
                ")){",
                result.isStream,
                "=true;",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".createStream(",
                GL_ARRAY_BUFFER$2,
                ",",
                VALUE,
                ");",
                TYPE,
                "=",
                BUFFER,
                ".dtype;",
                "}else{",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".getBuffer(",
                VALUE,
                ");",
                "if(",
                BUFFER,
                "){",
                TYPE,
                "=",
                BUFFER,
                ".dtype;",
                '}else if("constant" in ',
                VALUE,
                "){",
                result.state,
                "=",
                ATTRIB_STATE_CONSTANT,
                ";",
                "if(typeof " + VALUE + '.constant === "number"){',
                result[CUTE_COMPONENTS[0]],
                "=",
                VALUE,
                ".constant;",
                CUTE_COMPONENTS.slice(1).map(function(n2) {
                  return result[n2];
                }).join("="),
                "=0;",
                "}else{",
                CUTE_COMPONENTS.map(function(name, i2) {
                  return result[name] + "=" + VALUE + ".constant.length>" + i2 + "?" + VALUE + ".constant[" + i2 + "]:0;";
                }).join(""),
                "}}else{",
                "if(",
                IS_BUFFER_ARGS,
                "(",
                VALUE,
                ".buffer)){",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".createStream(",
                GL_ARRAY_BUFFER$2,
                ",",
                VALUE,
                ".buffer);",
                "}else{",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".getBuffer(",
                VALUE,
                ".buffer);",
                "}",
                TYPE,
                '="type" in ',
                VALUE,
                "?",
                constants.glTypes,
                "[",
                VALUE,
                ".type]:",
                BUFFER,
                ".dtype;",
                result.normalized,
                "=!!",
                VALUE,
                ".normalized;"
              );
              function emitReadRecord(name) {
                block(result[name], "=", VALUE, ".", name, "|0;");
              }
              emitReadRecord("size");
              emitReadRecord("offset");
              emitReadRecord("stride");
              emitReadRecord("divisor");
              block("}}");
              block.exit(
                "if(",
                result.isStream,
                "){",
                BUFFER_STATE,
                ".destroyStream(",
                BUFFER,
                ");",
                "}"
              );
              return result;
            }
            attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
          });
          return attributeDefs;
        }
        function parseVAO(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          if (S_VAO in staticOptions) {
            var vao = staticOptions[S_VAO];
            if (vao !== null && attributeState.getVAO(vao) === null) {
              vao = attributeState.createVAO(vao);
            }
            return createStaticDecl(function(env2) {
              return env2.link(attributeState.getVAO(vao));
            });
          } else if (S_VAO in dynamicOptions) {
            var dyn = dynamicOptions[S_VAO];
            return createDynamicDecl(dyn, function(env2, scope) {
              var vaoRef = env2.invoke(scope, dyn);
              return scope.def(env2.shared.vao + ".getVAO(" + vaoRef + ")");
            });
          }
          return null;
        }
        function parseContext(context) {
          var staticContext = context.static;
          var dynamicContext = context.dynamic;
          var result = {};
          Object.keys(staticContext).forEach(function(name) {
            var value = staticContext[name];
            result[name] = createStaticDecl(function(env, scope) {
              if (typeof value === "number" || typeof value === "boolean") {
                return "" + value;
              } else {
                return env.link(value);
              }
            });
          });
          Object.keys(dynamicContext).forEach(function(name) {
            var dyn = dynamicContext[name];
            result[name] = createDynamicDecl(dyn, function(env, scope) {
              return env.invoke(scope, dyn);
            });
          });
          return result;
        }
        function parseArguments(options, attributes, uniforms, context, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          check$1.optional(function() {
            var KEY_NAMES = [
              S_FRAMEBUFFER,
              S_VERT,
              S_FRAG,
              S_ELEMENTS,
              S_PRIMITIVE,
              S_OFFSET,
              S_COUNT,
              S_INSTANCES,
              S_PROFILE,
              S_VAO
            ].concat(GL_STATE_NAMES);
            function checkKeys(dict) {
              Object.keys(dict).forEach(function(key) {
                check$1.command(
                  KEY_NAMES.indexOf(key) >= 0,
                  'unknown parameter "' + key + '"',
                  env.commandStr
                );
              });
            }
            checkKeys(staticOptions);
            checkKeys(dynamicOptions);
          });
          var attribLocations = parseAttribLocations(options, attributes);
          var framebuffer = parseFramebuffer(options, env);
          var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
          var draw4 = parseDraw(options, env);
          var state = parseGLState(options, env);
          var shader = parseProgram(options, env, attribLocations);
          function copyBox(name) {
            var defn = viewportAndScissor[name];
            if (defn) {
              state[name] = defn;
            }
          }
          copyBox(S_VIEWPORT);
          copyBox(propName(S_SCISSOR_BOX));
          var dirty = Object.keys(state).length > 0;
          var result = {
            framebuffer,
            draw: draw4,
            shader,
            state,
            dirty,
            scopeVAO: null,
            drawVAO: null,
            useVAO: false,
            attributes: {}
          };
          result.profile = parseProfile(options, env);
          result.uniforms = parseUniforms(uniforms, env);
          result.drawVAO = result.scopeVAO = parseVAO(options, env);
          if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
            var useVAO = true;
            var staticBindings = shader.program.attributes.map(function(attr) {
              var binding = attributes.static[attr];
              useVAO = useVAO && !!binding;
              return binding;
            });
            if (useVAO && staticBindings.length > 0) {
              var vao = attributeState.getVAO(attributeState.createVAO(staticBindings));
              result.drawVAO = new Declaration(null, null, null, function(env2, scope) {
                return env2.link(vao);
              });
              result.useVAO = true;
            }
          }
          if (attribLocations) {
            result.useVAO = true;
          } else {
            result.attributes = parseAttributes(attributes, env);
          }
          result.context = parseContext(context, env);
          return result;
        }
        function emitContext(env, scope, context) {
          var shared = env.shared;
          var CONTEXT = shared.context;
          var contextEnter = env.scope();
          Object.keys(context).forEach(function(name) {
            scope.save(CONTEXT, "." + name);
            var defn = context[name];
            var value = defn.append(env, scope);
            if (Array.isArray(value)) {
              contextEnter(CONTEXT, ".", name, "=[", value.join(), "];");
            } else {
              contextEnter(CONTEXT, ".", name, "=", value, ";");
            }
          });
          scope(contextEnter);
        }
        function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {
          var shared = env.shared;
          var GL = shared.gl;
          var FRAMEBUFFER_STATE = shared.framebuffer;
          var EXT_DRAW_BUFFERS;
          if (extDrawBuffers) {
            EXT_DRAW_BUFFERS = scope.def(shared.extensions, ".webgl_draw_buffers");
          }
          var constants = env.constants;
          var DRAW_BUFFERS = constants.drawBuffer;
          var BACK_BUFFER = constants.backBuffer;
          var NEXT;
          if (framebuffer) {
            NEXT = framebuffer.append(env, scope);
          } else {
            NEXT = scope.def(FRAMEBUFFER_STATE, ".next");
          }
          if (!skipCheck) {
            scope("if(", NEXT, "!==", FRAMEBUFFER_STATE, ".cur){");
          }
          scope(
            "if(",
            NEXT,
            "){",
            GL,
            ".bindFramebuffer(",
            GL_FRAMEBUFFER$2,
            ",",
            NEXT,
            ".framebuffer);"
          );
          if (extDrawBuffers) {
            scope(
              EXT_DRAW_BUFFERS,
              ".drawBuffersWEBGL(",
              DRAW_BUFFERS,
              "[",
              NEXT,
              ".colorAttachments.length]);"
            );
          }
          scope(
            "}else{",
            GL,
            ".bindFramebuffer(",
            GL_FRAMEBUFFER$2,
            ",null);"
          );
          if (extDrawBuffers) {
            scope(EXT_DRAW_BUFFERS, ".drawBuffersWEBGL(", BACK_BUFFER, ");");
          }
          scope(
            "}",
            FRAMEBUFFER_STATE,
            ".cur=",
            NEXT,
            ";"
          );
          if (!skipCheck) {
            scope("}");
          }
        }
        function emitPollState(env, scope, args) {
          var shared = env.shared;
          var GL = shared.gl;
          var CURRENT_VARS = env.current;
          var NEXT_VARS = env.next;
          var CURRENT_STATE = shared.current;
          var NEXT_STATE = shared.next;
          var block = env.cond(CURRENT_STATE, ".dirty");
          GL_STATE_NAMES.forEach(function(prop) {
            var param = propName(prop);
            if (param in args.state) {
              return;
            }
            var NEXT, CURRENT;
            if (param in NEXT_VARS) {
              NEXT = NEXT_VARS[param];
              CURRENT = CURRENT_VARS[param];
              var parts = loop(currentState[param].length, function(i2) {
                return block.def(NEXT, "[", i2, "]");
              });
              block(env.cond(parts.map(function(p2, i2) {
                return p2 + "!==" + CURRENT + "[" + i2 + "]";
              }).join("||")).then(
                GL,
                ".",
                GL_VARIABLES[param],
                "(",
                parts,
                ");",
                parts.map(function(p2, i2) {
                  return CURRENT + "[" + i2 + "]=" + p2;
                }).join(";"),
                ";"
              ));
            } else {
              NEXT = block.def(NEXT_STATE, ".", param);
              var ifte = env.cond(NEXT, "!==", CURRENT_STATE, ".", param);
              block(ifte);
              if (param in GL_FLAGS) {
                ifte(
                  env.cond(NEXT).then(GL, ".enable(", GL_FLAGS[param], ");").else(GL, ".disable(", GL_FLAGS[param], ");"),
                  CURRENT_STATE,
                  ".",
                  param,
                  "=",
                  NEXT,
                  ";"
                );
              } else {
                ifte(
                  GL,
                  ".",
                  GL_VARIABLES[param],
                  "(",
                  NEXT,
                  ");",
                  CURRENT_STATE,
                  ".",
                  param,
                  "=",
                  NEXT,
                  ";"
                );
              }
            }
          });
          if (Object.keys(args.state).length === 0) {
            block(CURRENT_STATE, ".dirty=false;");
          }
          scope(block);
        }
        function emitSetOptions(env, scope, options, filter2) {
          var shared = env.shared;
          var CURRENT_VARS = env.current;
          var CURRENT_STATE = shared.current;
          var GL = shared.gl;
          sortState(Object.keys(options)).forEach(function(param) {
            var defn = options[param];
            if (filter2 && !filter2(defn)) {
              return;
            }
            var variable = defn.append(env, scope);
            if (GL_FLAGS[param]) {
              var flag = GL_FLAGS[param];
              if (isStatic(defn)) {
                if (variable) {
                  scope(GL, ".enable(", flag, ");");
                } else {
                  scope(GL, ".disable(", flag, ");");
                }
              } else {
                scope(env.cond(variable).then(GL, ".enable(", flag, ");").else(GL, ".disable(", flag, ");"));
              }
              scope(CURRENT_STATE, ".", param, "=", variable, ";");
            } else if (isArrayLike2(variable)) {
              var CURRENT = CURRENT_VARS[param];
              scope(
                GL,
                ".",
                GL_VARIABLES[param],
                "(",
                variable,
                ");",
                variable.map(function(v2, i2) {
                  return CURRENT + "[" + i2 + "]=" + v2;
                }).join(";"),
                ";"
              );
            } else {
              scope(
                GL,
                ".",
                GL_VARIABLES[param],
                "(",
                variable,
                ");",
                CURRENT_STATE,
                ".",
                param,
                "=",
                variable,
                ";"
              );
            }
          });
        }
        function injectExtensions(env, scope) {
          if (extInstancing) {
            env.instancing = scope.def(
              env.shared.extensions,
              ".angle_instanced_arrays"
            );
          }
        }
        function emitProfile(env, scope, args, useScope, incrementCounter) {
          var shared = env.shared;
          var STATS = env.stats;
          var CURRENT_STATE = shared.current;
          var TIMER = shared.timer;
          var profileArg = args.profile;
          function perfCounter() {
            if (typeof performance === "undefined") {
              return "Date.now()";
            } else {
              return "performance.now()";
            }
          }
          var CPU_START, QUERY_COUNTER;
          function emitProfileStart(block) {
            CPU_START = scope.def();
            block(CPU_START, "=", perfCounter(), ";");
            if (typeof incrementCounter === "string") {
              block(STATS, ".count+=", incrementCounter, ";");
            } else {
              block(STATS, ".count++;");
            }
            if (timer2) {
              if (useScope) {
                QUERY_COUNTER = scope.def();
                block(QUERY_COUNTER, "=", TIMER, ".getNumPendingQueries();");
              } else {
                block(TIMER, ".beginQuery(", STATS, ");");
              }
            }
          }
          function emitProfileEnd(block) {
            block(STATS, ".cpuTime+=", perfCounter(), "-", CPU_START, ";");
            if (timer2) {
              if (useScope) {
                block(
                  TIMER,
                  ".pushScopeStats(",
                  QUERY_COUNTER,
                  ",",
                  TIMER,
                  ".getNumPendingQueries(),",
                  STATS,
                  ");"
                );
              } else {
                block(TIMER, ".endQuery();");
              }
            }
          }
          function scopeProfile(value) {
            var prev = scope.def(CURRENT_STATE, ".profile");
            scope(CURRENT_STATE, ".profile=", value, ";");
            scope.exit(CURRENT_STATE, ".profile=", prev, ";");
          }
          var USE_PROFILE;
          if (profileArg) {
            if (isStatic(profileArg)) {
              if (profileArg.enable) {
                emitProfileStart(scope);
                emitProfileEnd(scope.exit);
                scopeProfile("true");
              } else {
                scopeProfile("false");
              }
              return;
            }
            USE_PROFILE = profileArg.append(env, scope);
            scopeProfile(USE_PROFILE);
          } else {
            USE_PROFILE = scope.def(CURRENT_STATE, ".profile");
          }
          var start = env.block();
          emitProfileStart(start);
          scope("if(", USE_PROFILE, "){", start, "}");
          var end2 = env.block();
          emitProfileEnd(end2);
          scope.exit("if(", USE_PROFILE, "){", end2, "}");
        }
        function emitAttributes(env, scope, args, attributes, filter2) {
          var shared = env.shared;
          function typeLength(x4) {
            switch (x4) {
              case GL_FLOAT_VEC2:
              case GL_INT_VEC2:
              case GL_BOOL_VEC2:
                return 2;
              case GL_FLOAT_VEC3:
              case GL_INT_VEC3:
              case GL_BOOL_VEC3:
                return 3;
              case GL_FLOAT_VEC4:
              case GL_INT_VEC4:
              case GL_BOOL_VEC4:
                return 4;
              default:
                return 1;
            }
          }
          function emitBindAttribute(ATTRIBUTE, size3, record) {
            var GL = shared.gl;
            var LOCATION = scope.def(ATTRIBUTE, ".location");
            var BINDING = scope.def(shared.attributes, "[", LOCATION, "]");
            var STATE = record.state;
            var BUFFER = record.buffer;
            var CONST_COMPONENTS = [
              record.x,
              record.y,
              record.z,
              record.w
            ];
            var COMMON_KEYS = [
              "buffer",
              "normalized",
              "offset",
              "stride"
            ];
            function emitBuffer() {
              scope(
                "if(!",
                BINDING,
                ".buffer){",
                GL,
                ".enableVertexAttribArray(",
                LOCATION,
                ");}"
              );
              var TYPE = record.type;
              var SIZE;
              if (!record.size) {
                SIZE = size3;
              } else {
                SIZE = scope.def(record.size, "||", size3);
              }
              scope(
                "if(",
                BINDING,
                ".type!==",
                TYPE,
                "||",
                BINDING,
                ".size!==",
                SIZE,
                "||",
                COMMON_KEYS.map(function(key) {
                  return BINDING + "." + key + "!==" + record[key];
                }).join("||"),
                "){",
                GL,
                ".bindBuffer(",
                GL_ARRAY_BUFFER$2,
                ",",
                BUFFER,
                ".buffer);",
                GL,
                ".vertexAttribPointer(",
                [
                  LOCATION,
                  SIZE,
                  TYPE,
                  record.normalized,
                  record.stride,
                  record.offset
                ],
                ");",
                BINDING,
                ".type=",
                TYPE,
                ";",
                BINDING,
                ".size=",
                SIZE,
                ";",
                COMMON_KEYS.map(function(key) {
                  return BINDING + "." + key + "=" + record[key] + ";";
                }).join(""),
                "}"
              );
              if (extInstancing) {
                var DIVISOR = record.divisor;
                scope(
                  "if(",
                  BINDING,
                  ".divisor!==",
                  DIVISOR,
                  "){",
                  env.instancing,
                  ".vertexAttribDivisorANGLE(",
                  [LOCATION, DIVISOR],
                  ");",
                  BINDING,
                  ".divisor=",
                  DIVISOR,
                  ";}"
                );
              }
            }
            function emitConstant() {
              scope(
                "if(",
                BINDING,
                ".buffer){",
                GL,
                ".disableVertexAttribArray(",
                LOCATION,
                ");",
                BINDING,
                ".buffer=null;",
                "}if(",
                CUTE_COMPONENTS.map(function(c3, i2) {
                  return BINDING + "." + c3 + "!==" + CONST_COMPONENTS[i2];
                }).join("||"),
                "){",
                GL,
                ".vertexAttrib4f(",
                LOCATION,
                ",",
                CONST_COMPONENTS,
                ");",
                CUTE_COMPONENTS.map(function(c3, i2) {
                  return BINDING + "." + c3 + "=" + CONST_COMPONENTS[i2] + ";";
                }).join(""),
                "}"
              );
            }
            if (STATE === ATTRIB_STATE_POINTER) {
              emitBuffer();
            } else if (STATE === ATTRIB_STATE_CONSTANT) {
              emitConstant();
            } else {
              scope("if(", STATE, "===", ATTRIB_STATE_POINTER, "){");
              emitBuffer();
              scope("}else{");
              emitConstant();
              scope("}");
            }
          }
          attributes.forEach(function(attribute) {
            var name = attribute.name;
            var arg = args.attributes[name];
            var record;
            if (arg) {
              if (!filter2(arg)) {
                return;
              }
              record = arg.append(env, scope);
            } else {
              if (!filter2(SCOPE_DECL)) {
                return;
              }
              var scopeAttrib = env.scopeAttrib(name);
              check$1.optional(function() {
                env.assert(
                  scope,
                  scopeAttrib + ".state",
                  "missing attribute " + name
                );
              });
              record = {};
              Object.keys(new AttributeRecord2()).forEach(function(key) {
                record[key] = scope.def(scopeAttrib, ".", key);
              });
            }
            emitBindAttribute(
              env.link(attribute),
              typeLength(attribute.info.type),
              record
            );
          });
        }
        function emitUniforms(env, scope, args, uniforms, filter2) {
          var shared = env.shared;
          var GL = shared.gl;
          var infix;
          for (var i2 = 0; i2 < uniforms.length; ++i2) {
            var uniform = uniforms[i2];
            var name = uniform.name;
            var type = uniform.info.type;
            var arg = args.uniforms[name];
            var UNIFORM = env.link(uniform);
            var LOCATION = UNIFORM + ".location";
            var VALUE;
            if (arg) {
              if (!filter2(arg)) {
                continue;
              }
              if (isStatic(arg)) {
                var value = arg.value;
                check$1.command(
                  value !== null && typeof value !== "undefined",
                  'missing uniform "' + name + '"',
                  env.commandStr
                );
                if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
                  check$1.command(
                    typeof value === "function" && (type === GL_SAMPLER_2D && (value._reglType === "texture2d" || value._reglType === "framebuffer") || type === GL_SAMPLER_CUBE && (value._reglType === "textureCube" || value._reglType === "framebufferCube")),
                    "invalid texture for uniform " + name,
                    env.commandStr
                  );
                  var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
                  scope(GL, ".uniform1i(", LOCATION, ",", TEX_VALUE + ".bind());");
                  scope.exit(TEX_VALUE, ".unbind();");
                } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {
                  check$1.optional(function() {
                    check$1.command(
                      isArrayLike2(value),
                      "invalid matrix for uniform " + name,
                      env.commandStr
                    );
                    check$1.command(
                      type === GL_FLOAT_MAT2 && value.length === 4 || type === GL_FLOAT_MAT3 && value.length === 9 || type === GL_FLOAT_MAT4 && value.length === 16,
                      "invalid length for matrix uniform " + name,
                      env.commandStr
                    );
                  });
                  var MAT_VALUE = env.global.def("new Float32Array([" + Array.prototype.slice.call(value) + "])");
                  var dim = 2;
                  if (type === GL_FLOAT_MAT3) {
                    dim = 3;
                  } else if (type === GL_FLOAT_MAT4) {
                    dim = 4;
                  }
                  scope(
                    GL,
                    ".uniformMatrix",
                    dim,
                    "fv(",
                    LOCATION,
                    ",false,",
                    MAT_VALUE,
                    ");"
                  );
                } else {
                  switch (type) {
                    case GL_FLOAT$8:
                      check$1.commandType(value, "number", "uniform " + name, env.commandStr);
                      infix = "1f";
                      break;
                    case GL_FLOAT_VEC2:
                      check$1.command(
                        isArrayLike2(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2f";
                      break;
                    case GL_FLOAT_VEC3:
                      check$1.command(
                        isArrayLike2(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3f";
                      break;
                    case GL_FLOAT_VEC4:
                      check$1.command(
                        isArrayLike2(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4f";
                      break;
                    case GL_BOOL:
                      check$1.commandType(value, "boolean", "uniform " + name, env.commandStr);
                      infix = "1i";
                      break;
                    case GL_INT$3:
                      check$1.commandType(value, "number", "uniform " + name, env.commandStr);
                      infix = "1i";
                      break;
                    case GL_BOOL_VEC2:
                      check$1.command(
                        isArrayLike2(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2i";
                      break;
                    case GL_INT_VEC2:
                      check$1.command(
                        isArrayLike2(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2i";
                      break;
                    case GL_BOOL_VEC3:
                      check$1.command(
                        isArrayLike2(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3i";
                      break;
                    case GL_INT_VEC3:
                      check$1.command(
                        isArrayLike2(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3i";
                      break;
                    case GL_BOOL_VEC4:
                      check$1.command(
                        isArrayLike2(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4i";
                      break;
                    case GL_INT_VEC4:
                      check$1.command(
                        isArrayLike2(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4i";
                      break;
                  }
                  scope(
                    GL,
                    ".uniform",
                    infix,
                    "(",
                    LOCATION,
                    ",",
                    isArrayLike2(value) ? Array.prototype.slice.call(value) : value,
                    ");"
                  );
                }
                continue;
              } else {
                VALUE = arg.append(env, scope);
              }
            } else {
              if (!filter2(SCOPE_DECL)) {
                continue;
              }
              VALUE = scope.def(shared.uniforms, "[", stringStore.id(name), "]");
            }
            if (type === GL_SAMPLER_2D) {
              check$1(!Array.isArray(VALUE), "must specify a scalar prop for textures");
              scope(
                "if(",
                VALUE,
                "&&",
                VALUE,
                '._reglType==="framebuffer"){',
                VALUE,
                "=",
                VALUE,
                ".color[0];",
                "}"
              );
            } else if (type === GL_SAMPLER_CUBE) {
              check$1(!Array.isArray(VALUE), "must specify a scalar prop for cube maps");
              scope(
                "if(",
                VALUE,
                "&&",
                VALUE,
                '._reglType==="framebufferCube"){',
                VALUE,
                "=",
                VALUE,
                ".color[0];",
                "}"
              );
            }
            check$1.optional(function() {
              function emitCheck(pred, message) {
                env.assert(
                  scope,
                  pred,
                  'bad data or missing for uniform "' + name + '".  ' + message
                );
              }
              function checkType(type2) {
                check$1(!Array.isArray(VALUE), "must not specify an array type for uniform");
                emitCheck(
                  "typeof " + VALUE + '==="' + type2 + '"',
                  "invalid type, expected " + type2
                );
              }
              function checkVector(n2, type2) {
                if (Array.isArray(VALUE)) {
                  check$1(VALUE.length === n2, "must have length " + n2);
                } else {
                  emitCheck(
                    shared.isArrayLike + "(" + VALUE + ")&&" + VALUE + ".length===" + n2,
                    "invalid vector, should have length " + n2,
                    env.commandStr
                  );
                }
              }
              function checkTexture(target) {
                check$1(!Array.isArray(VALUE), "must not specify a value type");
                emitCheck(
                  "typeof " + VALUE + '==="function"&&' + VALUE + '._reglType==="texture' + (target === GL_TEXTURE_2D$3 ? "2d" : "Cube") + '"',
                  "invalid texture type",
                  env.commandStr
                );
              }
              switch (type) {
                case GL_INT$3:
                  checkType("number");
                  break;
                case GL_INT_VEC2:
                  checkVector(2, "number");
                  break;
                case GL_INT_VEC3:
                  checkVector(3, "number");
                  break;
                case GL_INT_VEC4:
                  checkVector(4, "number");
                  break;
                case GL_FLOAT$8:
                  checkType("number");
                  break;
                case GL_FLOAT_VEC2:
                  checkVector(2, "number");
                  break;
                case GL_FLOAT_VEC3:
                  checkVector(3, "number");
                  break;
                case GL_FLOAT_VEC4:
                  checkVector(4, "number");
                  break;
                case GL_BOOL:
                  checkType("boolean");
                  break;
                case GL_BOOL_VEC2:
                  checkVector(2, "boolean");
                  break;
                case GL_BOOL_VEC3:
                  checkVector(3, "boolean");
                  break;
                case GL_BOOL_VEC4:
                  checkVector(4, "boolean");
                  break;
                case GL_FLOAT_MAT2:
                  checkVector(4, "number");
                  break;
                case GL_FLOAT_MAT3:
                  checkVector(9, "number");
                  break;
                case GL_FLOAT_MAT4:
                  checkVector(16, "number");
                  break;
                case GL_SAMPLER_2D:
                  checkTexture(GL_TEXTURE_2D$3);
                  break;
                case GL_SAMPLER_CUBE:
                  checkTexture(GL_TEXTURE_CUBE_MAP$2);
                  break;
              }
            });
            var unroll = 1;
            switch (type) {
              case GL_SAMPLER_2D:
              case GL_SAMPLER_CUBE:
                var TEX = scope.def(VALUE, "._texture");
                scope(GL, ".uniform1i(", LOCATION, ",", TEX, ".bind());");
                scope.exit(TEX, ".unbind();");
                continue;
              case GL_INT$3:
              case GL_BOOL:
                infix = "1i";
                break;
              case GL_INT_VEC2:
              case GL_BOOL_VEC2:
                infix = "2i";
                unroll = 2;
                break;
              case GL_INT_VEC3:
              case GL_BOOL_VEC3:
                infix = "3i";
                unroll = 3;
                break;
              case GL_INT_VEC4:
              case GL_BOOL_VEC4:
                infix = "4i";
                unroll = 4;
                break;
              case GL_FLOAT$8:
                infix = "1f";
                break;
              case GL_FLOAT_VEC2:
                infix = "2f";
                unroll = 2;
                break;
              case GL_FLOAT_VEC3:
                infix = "3f";
                unroll = 3;
                break;
              case GL_FLOAT_VEC4:
                infix = "4f";
                unroll = 4;
                break;
              case GL_FLOAT_MAT2:
                infix = "Matrix2fv";
                break;
              case GL_FLOAT_MAT3:
                infix = "Matrix3fv";
                break;
              case GL_FLOAT_MAT4:
                infix = "Matrix4fv";
                break;
            }
            scope(GL, ".uniform", infix, "(", LOCATION, ",");
            if (infix.charAt(0) === "M") {
              var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
              var STORAGE = env.global.def("new Float32Array(", matSize, ")");
              if (Array.isArray(VALUE)) {
                scope(
                  "false,(",
                  loop(matSize, function(i3) {
                    return STORAGE + "[" + i3 + "]=" + VALUE[i3];
                  }),
                  ",",
                  STORAGE,
                  ")"
                );
              } else {
                scope(
                  "false,(Array.isArray(",
                  VALUE,
                  ")||",
                  VALUE,
                  " instanceof Float32Array)?",
                  VALUE,
                  ":(",
                  loop(matSize, function(i3) {
                    return STORAGE + "[" + i3 + "]=" + VALUE + "[" + i3 + "]";
                  }),
                  ",",
                  STORAGE,
                  ")"
                );
              }
            } else if (unroll > 1) {
              scope(loop(unroll, function(i3) {
                return Array.isArray(VALUE) ? VALUE[i3] : VALUE + "[" + i3 + "]";
              }));
            } else {
              check$1(!Array.isArray(VALUE), "uniform value must not be an array");
              scope(VALUE);
            }
            scope(");");
          }
        }
        function emitDraw(env, outer, inner, args) {
          var shared = env.shared;
          var GL = shared.gl;
          var DRAW_STATE = shared.draw;
          var drawOptions = args.draw;
          function emitElements() {
            var defn = drawOptions.elements;
            var ELEMENTS2;
            var scope = outer;
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                scope = inner;
              }
              ELEMENTS2 = defn.append(env, scope);
            } else {
              ELEMENTS2 = scope.def(DRAW_STATE, ".", S_ELEMENTS);
            }
            if (ELEMENTS2) {
              scope(
                "if(" + ELEMENTS2 + ")" + GL + ".bindBuffer(" + GL_ELEMENT_ARRAY_BUFFER$1 + "," + ELEMENTS2 + ".buffer.buffer);"
              );
            }
            return ELEMENTS2;
          }
          function emitCount() {
            var defn = drawOptions.count;
            var COUNT2;
            var scope = outer;
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                scope = inner;
              }
              COUNT2 = defn.append(env, scope);
              check$1.optional(function() {
                if (defn.MISSING) {
                  env.assert(outer, "false", "missing vertex count");
                }
                if (defn.DYNAMIC) {
                  env.assert(scope, COUNT2 + ">=0", "missing vertex count");
                }
              });
            } else {
              COUNT2 = scope.def(DRAW_STATE, ".", S_COUNT);
              check$1.optional(function() {
                env.assert(scope, COUNT2 + ">=0", "missing vertex count");
              });
            }
            return COUNT2;
          }
          var ELEMENTS = emitElements();
          function emitValue(name) {
            var defn = drawOptions[name];
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                return defn.append(env, inner);
              } else {
                return defn.append(env, outer);
              }
            } else {
              return outer.def(DRAW_STATE, ".", name);
            }
          }
          var PRIMITIVE = emitValue(S_PRIMITIVE);
          var OFFSET = emitValue(S_OFFSET);
          var COUNT = emitCount();
          if (typeof COUNT === "number") {
            if (COUNT === 0) {
              return;
            }
          } else {
            inner("if(", COUNT, "){");
            inner.exit("}");
          }
          var INSTANCES, EXT_INSTANCING;
          if (extInstancing) {
            INSTANCES = emitValue(S_INSTANCES);
            EXT_INSTANCING = env.instancing;
          }
          var ELEMENT_TYPE = ELEMENTS + ".type";
          var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements);
          function emitInstancing() {
            function drawElements() {
              inner(EXT_INSTANCING, ".drawElementsInstancedANGLE(", [
                PRIMITIVE,
                COUNT,
                ELEMENT_TYPE,
                OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$8 + ")>>1)",
                INSTANCES
              ], ");");
            }
            function drawArrays() {
              inner(
                EXT_INSTANCING,
                ".drawArraysInstancedANGLE(",
                [PRIMITIVE, OFFSET, COUNT, INSTANCES],
                ");"
              );
            }
            if (ELEMENTS) {
              if (!elementsStatic) {
                inner("if(", ELEMENTS, "){");
                drawElements();
                inner("}else{");
                drawArrays();
                inner("}");
              } else {
                drawElements();
              }
            } else {
              drawArrays();
            }
          }
          function emitRegular() {
            function drawElements() {
              inner(GL + ".drawElements(" + [
                PRIMITIVE,
                COUNT,
                ELEMENT_TYPE,
                OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$8 + ")>>1)"
              ] + ");");
            }
            function drawArrays() {
              inner(GL + ".drawArrays(" + [PRIMITIVE, OFFSET, COUNT] + ");");
            }
            if (ELEMENTS) {
              if (!elementsStatic) {
                inner("if(", ELEMENTS, "){");
                drawElements();
                inner("}else{");
                drawArrays();
                inner("}");
              } else {
                drawElements();
              }
            } else {
              drawArrays();
            }
          }
          if (extInstancing && (typeof INSTANCES !== "number" || INSTANCES >= 0)) {
            if (typeof INSTANCES === "string") {
              inner("if(", INSTANCES, ">0){");
              emitInstancing();
              inner("}else if(", INSTANCES, "<0){");
              emitRegular();
              inner("}");
            } else {
              emitInstancing();
            }
          } else {
            emitRegular();
          }
        }
        function createBody(emitBody, parentEnv, args, program, count) {
          var env = createREGLEnvironment();
          var scope = env.proc("body", count);
          check$1.optional(function() {
            env.commandStr = parentEnv.commandStr;
            env.command = env.link(parentEnv.commandStr);
          });
          if (extInstancing) {
            env.instancing = scope.def(
              env.shared.extensions,
              ".angle_instanced_arrays"
            );
          }
          emitBody(env, scope, args, program);
          return env.compile().body;
        }
        function emitDrawBody(env, draw4, args, program) {
          injectExtensions(env, draw4);
          if (args.useVAO) {
            if (args.drawVAO) {
              draw4(env.shared.vao, ".setVAO(", args.drawVAO.append(env, draw4), ");");
            } else {
              draw4(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
            }
          } else {
            draw4(env.shared.vao, ".setVAO(null);");
            emitAttributes(env, draw4, args, program.attributes, function() {
              return true;
            });
          }
          emitUniforms(env, draw4, args, program.uniforms, function() {
            return true;
          });
          emitDraw(env, draw4, draw4, args);
        }
        function emitDrawProc(env, args) {
          var draw4 = env.proc("draw", 1);
          injectExtensions(env, draw4);
          emitContext(env, draw4, args.context);
          emitPollFramebuffer(env, draw4, args.framebuffer);
          emitPollState(env, draw4, args);
          emitSetOptions(env, draw4, args.state);
          emitProfile(env, draw4, args, false, true);
          var program = args.shader.progVar.append(env, draw4);
          draw4(env.shared.gl, ".useProgram(", program, ".program);");
          if (args.shader.program) {
            emitDrawBody(env, draw4, args, args.shader.program);
          } else {
            draw4(env.shared.vao, ".setVAO(null);");
            var drawCache = env.global.def("{}");
            var PROG_ID = draw4.def(program, ".id");
            var CACHED_PROC = draw4.def(drawCache, "[", PROG_ID, "]");
            draw4(
              env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0);").else(
                CACHED_PROC,
                "=",
                drawCache,
                "[",
                PROG_ID,
                "]=",
                env.link(function(program2) {
                  return createBody(emitDrawBody, env, args, program2, 1);
                }),
                "(",
                program,
                ");",
                CACHED_PROC,
                ".call(this,a0);"
              )
            );
          }
          if (Object.keys(args.state).length > 0) {
            draw4(env.shared.current, ".dirty=true;");
          }
        }
        function emitBatchDynamicShaderBody(env, scope, args, program) {
          env.batchId = "a1";
          injectExtensions(env, scope);
          function all() {
            return true;
          }
          emitAttributes(env, scope, args, program.attributes, all);
          emitUniforms(env, scope, args, program.uniforms, all);
          emitDraw(env, scope, scope, args);
        }
        function emitBatchBody(env, scope, args, program) {
          injectExtensions(env, scope);
          var contextDynamic = args.contextDep;
          var BATCH_ID = scope.def();
          var PROP_LIST = "a0";
          var NUM_PROPS = "a1";
          var PROPS = scope.def();
          env.shared.props = PROPS;
          env.batchId = BATCH_ID;
          var outer = env.scope();
          var inner = env.scope();
          scope(
            outer.entry,
            "for(",
            BATCH_ID,
            "=0;",
            BATCH_ID,
            "<",
            NUM_PROPS,
            ";++",
            BATCH_ID,
            "){",
            PROPS,
            "=",
            PROP_LIST,
            "[",
            BATCH_ID,
            "];",
            inner,
            "}",
            outer.exit
          );
          function isInnerDefn(defn) {
            return defn.contextDep && contextDynamic || defn.propDep;
          }
          function isOuterDefn(defn) {
            return !isInnerDefn(defn);
          }
          if (args.needsContext) {
            emitContext(env, inner, args.context);
          }
          if (args.needsFramebuffer) {
            emitPollFramebuffer(env, inner, args.framebuffer);
          }
          emitSetOptions(env, inner, args.state, isInnerDefn);
          if (args.profile && isInnerDefn(args.profile)) {
            emitProfile(env, inner, args, false, true);
          }
          if (!program) {
            var progCache = env.global.def("{}");
            var PROGRAM = args.shader.progVar.append(env, inner);
            var PROG_ID = inner.def(PROGRAM, ".id");
            var CACHED_PROC = inner.def(progCache, "[", PROG_ID, "]");
            inner(
              env.shared.gl,
              ".useProgram(",
              PROGRAM,
              ".program);",
              "if(!",
              CACHED_PROC,
              "){",
              CACHED_PROC,
              "=",
              progCache,
              "[",
              PROG_ID,
              "]=",
              env.link(function(program2) {
                return createBody(
                  emitBatchDynamicShaderBody,
                  env,
                  args,
                  program2,
                  2
                );
              }),
              "(",
              PROGRAM,
              ");}",
              CACHED_PROC,
              ".call(this,a0[",
              BATCH_ID,
              "],",
              BATCH_ID,
              ");"
            );
          } else {
            if (args.useVAO) {
              if (args.drawVAO) {
                if (isInnerDefn(args.drawVAO)) {
                  inner(env.shared.vao, ".setVAO(", args.drawVAO.append(env, inner), ");");
                } else {
                  outer(env.shared.vao, ".setVAO(", args.drawVAO.append(env, outer), ");");
                }
              } else {
                outer(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
              }
            } else {
              outer(env.shared.vao, ".setVAO(null);");
              emitAttributes(env, outer, args, program.attributes, isOuterDefn);
              emitAttributes(env, inner, args, program.attributes, isInnerDefn);
            }
            emitUniforms(env, outer, args, program.uniforms, isOuterDefn);
            emitUniforms(env, inner, args, program.uniforms, isInnerDefn);
            emitDraw(env, outer, inner, args);
          }
        }
        function emitBatchProc(env, args) {
          var batch = env.proc("batch", 2);
          env.batchId = "0";
          injectExtensions(env, batch);
          var contextDynamic = false;
          var needsContext = true;
          Object.keys(args.context).forEach(function(name) {
            contextDynamic = contextDynamic || args.context[name].propDep;
          });
          if (!contextDynamic) {
            emitContext(env, batch, args.context);
            needsContext = false;
          }
          var framebuffer = args.framebuffer;
          var needsFramebuffer = false;
          if (framebuffer) {
            if (framebuffer.propDep) {
              contextDynamic = needsFramebuffer = true;
            } else if (framebuffer.contextDep && contextDynamic) {
              needsFramebuffer = true;
            }
            if (!needsFramebuffer) {
              emitPollFramebuffer(env, batch, framebuffer);
            }
          } else {
            emitPollFramebuffer(env, batch, null);
          }
          if (args.state.viewport && args.state.viewport.propDep) {
            contextDynamic = true;
          }
          function isInnerDefn(defn) {
            return defn.contextDep && contextDynamic || defn.propDep;
          }
          emitPollState(env, batch, args);
          emitSetOptions(env, batch, args.state, function(defn) {
            return !isInnerDefn(defn);
          });
          if (!args.profile || !isInnerDefn(args.profile)) {
            emitProfile(env, batch, args, false, "a1");
          }
          args.contextDep = contextDynamic;
          args.needsContext = needsContext;
          args.needsFramebuffer = needsFramebuffer;
          var progDefn = args.shader.progVar;
          if (progDefn.contextDep && contextDynamic || progDefn.propDep) {
            emitBatchBody(
              env,
              batch,
              args,
              null
            );
          } else {
            var PROGRAM = progDefn.append(env, batch);
            batch(env.shared.gl, ".useProgram(", PROGRAM, ".program);");
            if (args.shader.program) {
              emitBatchBody(
                env,
                batch,
                args,
                args.shader.program
              );
            } else {
              batch(env.shared.vao, ".setVAO(null);");
              var batchCache = env.global.def("{}");
              var PROG_ID = batch.def(PROGRAM, ".id");
              var CACHED_PROC = batch.def(batchCache, "[", PROG_ID, "]");
              batch(
                env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0,a1);").else(
                  CACHED_PROC,
                  "=",
                  batchCache,
                  "[",
                  PROG_ID,
                  "]=",
                  env.link(function(program) {
                    return createBody(emitBatchBody, env, args, program, 2);
                  }),
                  "(",
                  PROGRAM,
                  ");",
                  CACHED_PROC,
                  ".call(this,a0,a1);"
                )
              );
            }
          }
          if (Object.keys(args.state).length > 0) {
            batch(env.shared.current, ".dirty=true;");
          }
        }
        function emitScopeProc(env, args) {
          var scope = env.proc("scope", 3);
          env.batchId = "a2";
          var shared = env.shared;
          var CURRENT_STATE = shared.current;
          emitContext(env, scope, args.context);
          if (args.framebuffer) {
            args.framebuffer.append(env, scope);
          }
          sortState(Object.keys(args.state)).forEach(function(name) {
            var defn = args.state[name];
            var value = defn.append(env, scope);
            if (isArrayLike2(value)) {
              value.forEach(function(v2, i2) {
                scope.set(env.next[name], "[" + i2 + "]", v2);
              });
            } else {
              scope.set(shared.next, "." + name, value);
            }
          });
          emitProfile(env, scope, args, true, true);
          [S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
            function(opt) {
              var variable = args.draw[opt];
              if (!variable) {
                return;
              }
              scope.set(shared.draw, "." + opt, "" + variable.append(env, scope));
            }
          );
          Object.keys(args.uniforms).forEach(function(opt) {
            var value = args.uniforms[opt].append(env, scope);
            if (Array.isArray(value)) {
              value = "[" + value.join() + "]";
            }
            scope.set(
              shared.uniforms,
              "[" + stringStore.id(opt) + "]",
              value
            );
          });
          Object.keys(args.attributes).forEach(function(name) {
            var record = args.attributes[name].append(env, scope);
            var scopeAttrib = env.scopeAttrib(name);
            Object.keys(new AttributeRecord2()).forEach(function(prop) {
              scope.set(scopeAttrib, "." + prop, record[prop]);
            });
          });
          if (args.scopeVAO) {
            scope.set(shared.vao, ".targetVAO", args.scopeVAO.append(env, scope));
          }
          function saveShader(name) {
            var shader = args.shader[name];
            if (shader) {
              scope.set(shared.shader, "." + name, shader.append(env, scope));
            }
          }
          saveShader(S_VERT);
          saveShader(S_FRAG);
          if (Object.keys(args.state).length > 0) {
            scope(CURRENT_STATE, ".dirty=true;");
            scope.exit(CURRENT_STATE, ".dirty=true;");
          }
          scope("a1(", env.shared.context, ",a0,", env.batchId, ");");
        }
        function isDynamicObject(object) {
          if (typeof object !== "object" || isArrayLike2(object)) {
            return;
          }
          var props = Object.keys(object);
          for (var i2 = 0; i2 < props.length; ++i2) {
            if (dynamic.isDynamic(object[props[i2]])) {
              return true;
            }
          }
          return false;
        }
        function splatObject(env, options, name) {
          var object = options.static[name];
          if (!object || !isDynamicObject(object)) {
            return;
          }
          var globals = env.global;
          var keys2 = Object.keys(object);
          var thisDep = false;
          var contextDep = false;
          var propDep = false;
          var objectRef = env.global.def("{}");
          keys2.forEach(function(key) {
            var value = object[key];
            if (dynamic.isDynamic(value)) {
              if (typeof value === "function") {
                value = object[key] = dynamic.unbox(value);
              }
              var deps = createDynamicDecl(value, null);
              thisDep = thisDep || deps.thisDep;
              propDep = propDep || deps.propDep;
              contextDep = contextDep || deps.contextDep;
            } else {
              globals(objectRef, ".", key, "=");
              switch (typeof value) {
                case "number":
                  globals(value);
                  break;
                case "string":
                  globals('"', value, '"');
                  break;
                case "object":
                  if (Array.isArray(value)) {
                    globals("[", value.join(), "]");
                  }
                  break;
                default:
                  globals(env.link(value));
                  break;
              }
              globals(";");
            }
          });
          function appendBlock(env2, block) {
            keys2.forEach(function(key) {
              var value = object[key];
              if (!dynamic.isDynamic(value)) {
                return;
              }
              var ref = env2.invoke(block, value);
              block(objectRef, ".", key, "=", ref, ";");
            });
          }
          options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
            thisDep,
            contextDep,
            propDep,
            ref: objectRef,
            append: appendBlock
          });
          delete options.static[name];
        }
        function compileCommand(options, attributes, uniforms, context, stats2) {
          var env = createREGLEnvironment();
          env.stats = env.link(stats2);
          Object.keys(attributes.static).forEach(function(key) {
            splatObject(env, attributes, key);
          });
          NESTED_OPTIONS.forEach(function(name) {
            splatObject(env, options, name);
          });
          var args = parseArguments(options, attributes, uniforms, context, env);
          emitDrawProc(env, args);
          emitScopeProc(env, args);
          emitBatchProc(env, args);
          return extend2(env.compile(), {
            destroy: function() {
              args.shader.program.destroy();
            }
          });
        }
        return {
          next: nextState,
          current: currentState,
          procs: function() {
            var env = createREGLEnvironment();
            var poll = env.proc("poll");
            var refresh = env.proc("refresh");
            var common = env.block();
            poll(common);
            refresh(common);
            var shared = env.shared;
            var GL = shared.gl;
            var NEXT_STATE = shared.next;
            var CURRENT_STATE = shared.current;
            common(CURRENT_STATE, ".dirty=false;");
            emitPollFramebuffer(env, poll);
            emitPollFramebuffer(env, refresh, null, true);
            var INSTANCING;
            if (extInstancing) {
              INSTANCING = env.link(extInstancing);
            }
            if (extensions.oes_vertex_array_object) {
              refresh(env.link(extensions.oes_vertex_array_object), ".bindVertexArrayOES(null);");
            }
            for (var i2 = 0; i2 < limits.maxAttributes; ++i2) {
              var BINDING = refresh.def(shared.attributes, "[", i2, "]");
              var ifte = env.cond(BINDING, ".buffer");
              ifte.then(
                GL,
                ".enableVertexAttribArray(",
                i2,
                ");",
                GL,
                ".bindBuffer(",
                GL_ARRAY_BUFFER$2,
                ",",
                BINDING,
                ".buffer.buffer);",
                GL,
                ".vertexAttribPointer(",
                i2,
                ",",
                BINDING,
                ".size,",
                BINDING,
                ".type,",
                BINDING,
                ".normalized,",
                BINDING,
                ".stride,",
                BINDING,
                ".offset);"
              ).else(
                GL,
                ".disableVertexAttribArray(",
                i2,
                ");",
                GL,
                ".vertexAttrib4f(",
                i2,
                ",",
                BINDING,
                ".x,",
                BINDING,
                ".y,",
                BINDING,
                ".z,",
                BINDING,
                ".w);",
                BINDING,
                ".buffer=null;"
              );
              refresh(ifte);
              if (extInstancing) {
                refresh(
                  INSTANCING,
                  ".vertexAttribDivisorANGLE(",
                  i2,
                  ",",
                  BINDING,
                  ".divisor);"
                );
              }
            }
            refresh(
              env.shared.vao,
              ".currentVAO=null;",
              env.shared.vao,
              ".setVAO(",
              env.shared.vao,
              ".targetVAO);"
            );
            Object.keys(GL_FLAGS).forEach(function(flag) {
              var cap = GL_FLAGS[flag];
              var NEXT = common.def(NEXT_STATE, ".", flag);
              var block = env.block();
              block(
                "if(",
                NEXT,
                "){",
                GL,
                ".enable(",
                cap,
                ")}else{",
                GL,
                ".disable(",
                cap,
                ")}",
                CURRENT_STATE,
                ".",
                flag,
                "=",
                NEXT,
                ";"
              );
              refresh(block);
              poll(
                "if(",
                NEXT,
                "!==",
                CURRENT_STATE,
                ".",
                flag,
                "){",
                block,
                "}"
              );
            });
            Object.keys(GL_VARIABLES).forEach(function(name) {
              var func = GL_VARIABLES[name];
              var init = currentState[name];
              var NEXT, CURRENT;
              var block = env.block();
              block(GL, ".", func, "(");
              if (isArrayLike2(init)) {
                var n2 = init.length;
                NEXT = env.global.def(NEXT_STATE, ".", name);
                CURRENT = env.global.def(CURRENT_STATE, ".", name);
                block(
                  loop(n2, function(i3) {
                    return NEXT + "[" + i3 + "]";
                  }),
                  ");",
                  loop(n2, function(i3) {
                    return CURRENT + "[" + i3 + "]=" + NEXT + "[" + i3 + "];";
                  }).join("")
                );
                poll(
                  "if(",
                  loop(n2, function(i3) {
                    return NEXT + "[" + i3 + "]!==" + CURRENT + "[" + i3 + "]";
                  }).join("||"),
                  "){",
                  block,
                  "}"
                );
              } else {
                NEXT = common.def(NEXT_STATE, ".", name);
                CURRENT = common.def(CURRENT_STATE, ".", name);
                block(
                  NEXT,
                  ");",
                  CURRENT_STATE,
                  ".",
                  name,
                  "=",
                  NEXT,
                  ";"
                );
                poll(
                  "if(",
                  NEXT,
                  "!==",
                  CURRENT,
                  "){",
                  block,
                  "}"
                );
              }
              refresh(block);
            });
            return env.compile();
          }(),
          compile: compileCommand
        };
      }
      function stats() {
        return {
          vaoCount: 0,
          bufferCount: 0,
          elementsCount: 0,
          framebufferCount: 0,
          shaderCount: 0,
          textureCount: 0,
          cubeCount: 0,
          renderbufferCount: 0,
          maxTextureUnits: 0
        };
      }
      var GL_QUERY_RESULT_EXT = 34918;
      var GL_QUERY_RESULT_AVAILABLE_EXT = 34919;
      var GL_TIME_ELAPSED_EXT = 35007;
      var createTimer = function(gl2, extensions) {
        if (!extensions.ext_disjoint_timer_query) {
          return null;
        }
        var queryPool = [];
        function allocQuery() {
          return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT();
        }
        function freeQuery(query) {
          queryPool.push(query);
        }
        var pendingQueries = [];
        function beginQuery(stats2) {
          var query = allocQuery();
          extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
          pendingQueries.push(query);
          pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats2);
        }
        function endQuery() {
          extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT);
        }
        function PendingStats() {
          this.startQueryIndex = -1;
          this.endQueryIndex = -1;
          this.sum = 0;
          this.stats = null;
        }
        var pendingStatsPool = [];
        function allocPendingStats() {
          return pendingStatsPool.pop() || new PendingStats();
        }
        function freePendingStats(pendingStats2) {
          pendingStatsPool.push(pendingStats2);
        }
        var pendingStats = [];
        function pushScopeStats(start, end2, stats2) {
          var ps = allocPendingStats();
          ps.startQueryIndex = start;
          ps.endQueryIndex = end2;
          ps.sum = 0;
          ps.stats = stats2;
          pendingStats.push(ps);
        }
        var timeSum = [];
        var queryPtr = [];
        function update14() {
          var ptr, i2;
          var n2 = pendingQueries.length;
          if (n2 === 0) {
            return;
          }
          queryPtr.length = Math.max(queryPtr.length, n2 + 1);
          timeSum.length = Math.max(timeSum.length, n2 + 1);
          timeSum[0] = 0;
          queryPtr[0] = 0;
          var queryTime = 0;
          ptr = 0;
          for (i2 = 0; i2 < pendingQueries.length; ++i2) {
            var query = pendingQueries[i2];
            if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
              queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
              freeQuery(query);
            } else {
              pendingQueries[ptr++] = query;
            }
            timeSum[i2 + 1] = queryTime;
            queryPtr[i2 + 1] = ptr;
          }
          pendingQueries.length = ptr;
          ptr = 0;
          for (i2 = 0; i2 < pendingStats.length; ++i2) {
            var stats2 = pendingStats[i2];
            var start = stats2.startQueryIndex;
            var end2 = stats2.endQueryIndex;
            stats2.sum += timeSum[end2] - timeSum[start];
            var startPtr = queryPtr[start];
            var endPtr = queryPtr[end2];
            if (endPtr === startPtr) {
              stats2.stats.gpuTime += stats2.sum / 1e6;
              freePendingStats(stats2);
            } else {
              stats2.startQueryIndex = startPtr;
              stats2.endQueryIndex = endPtr;
              pendingStats[ptr++] = stats2;
            }
          }
          pendingStats.length = ptr;
        }
        return {
          beginQuery,
          endQuery,
          pushScopeStats,
          update: update14,
          getNumPendingQueries: function() {
            return pendingQueries.length;
          },
          clear: function() {
            queryPool.push.apply(queryPool, pendingQueries);
            for (var i2 = 0; i2 < queryPool.length; i2++) {
              extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i2]);
            }
            pendingQueries.length = 0;
            queryPool.length = 0;
          },
          restore: function() {
            pendingQueries.length = 0;
            queryPool.length = 0;
          }
        };
      };
      var GL_COLOR_BUFFER_BIT = 16384;
      var GL_DEPTH_BUFFER_BIT = 256;
      var GL_STENCIL_BUFFER_BIT = 1024;
      var GL_ARRAY_BUFFER = 34962;
      var CONTEXT_LOST_EVENT = "webglcontextlost";
      var CONTEXT_RESTORED_EVENT = "webglcontextrestored";
      var DYN_PROP = 1;
      var DYN_CONTEXT = 2;
      var DYN_STATE = 3;
      function find3(haystack, needle) {
        for (var i2 = 0; i2 < haystack.length; ++i2) {
          if (haystack[i2] === needle) {
            return i2;
          }
        }
        return -1;
      }
      function wrapREGL(args) {
        var config = parseArgs(args);
        if (!config) {
          return null;
        }
        var gl2 = config.gl;
        var glAttributes = gl2.getContextAttributes();
        var contextLost = gl2.isContextLost();
        var extensionState = createExtensionCache(gl2, config);
        if (!extensionState) {
          return null;
        }
        var stringStore = createStringStore();
        var stats$$1 = stats();
        var extensions = extensionState.extensions;
        var timer2 = createTimer(gl2, extensions);
        var START_TIME = clock();
        var WIDTH = gl2.drawingBufferWidth;
        var HEIGHT = gl2.drawingBufferHeight;
        var contextState = {
          tick: 0,
          time: 0,
          viewportWidth: WIDTH,
          viewportHeight: HEIGHT,
          framebufferWidth: WIDTH,
          framebufferHeight: HEIGHT,
          drawingBufferWidth: WIDTH,
          drawingBufferHeight: HEIGHT,
          pixelRatio: config.pixelRatio
        };
        var uniformState = {};
        var drawState = {
          elements: null,
          primitive: 4,
          // GL_TRIANGLES
          count: -1,
          offset: 0,
          instances: -1
        };
        var limits = wrapLimits(gl2, extensions);
        var bufferState = wrapBufferState(
          gl2,
          stats$$1,
          config,
          destroyBuffer
        );
        var attributeState = wrapAttributeState(
          gl2,
          extensions,
          limits,
          stats$$1,
          bufferState
        );
        function destroyBuffer(buffer) {
          return attributeState.destroyBuffer(buffer);
        }
        var elementState = wrapElementsState(gl2, extensions, bufferState, stats$$1);
        var shaderState = wrapShaderState(gl2, stringStore, stats$$1, config);
        var textureState = createTextureSet(
          gl2,
          extensions,
          limits,
          function() {
            core.procs.poll();
          },
          contextState,
          stats$$1,
          config
        );
        var renderbufferState = wrapRenderbuffers(gl2, extensions, limits, stats$$1, config);
        var framebufferState = wrapFBOState(
          gl2,
          extensions,
          limits,
          textureState,
          renderbufferState,
          stats$$1
        );
        var core = reglCore(
          gl2,
          stringStore,
          extensions,
          limits,
          bufferState,
          elementState,
          textureState,
          framebufferState,
          uniformState,
          attributeState,
          shaderState,
          drawState,
          contextState,
          timer2,
          config
        );
        var readPixels = wrapReadPixels(
          gl2,
          framebufferState,
          core.procs.poll,
          contextState,
          glAttributes,
          extensions,
          limits
        );
        var nextState = core.next;
        var canvas = gl2.canvas;
        var rafCallbacks = [];
        var lossCallbacks = [];
        var restoreCallbacks = [];
        var destroyCallbacks = [config.onDestroy];
        var activeRAF = null;
        function handleRAF() {
          if (rafCallbacks.length === 0) {
            if (timer2) {
              timer2.update();
            }
            activeRAF = null;
            return;
          }
          activeRAF = raf.next(handleRAF);
          poll();
          for (var i2 = rafCallbacks.length - 1; i2 >= 0; --i2) {
            var cb = rafCallbacks[i2];
            if (cb) {
              cb(contextState, null, 0);
            }
          }
          gl2.flush();
          if (timer2) {
            timer2.update();
          }
        }
        function startRAF() {
          if (!activeRAF && rafCallbacks.length > 0) {
            activeRAF = raf.next(handleRAF);
          }
        }
        function stopRAF() {
          if (activeRAF) {
            raf.cancel(handleRAF);
            activeRAF = null;
          }
        }
        function handleContextLoss(event) {
          event.preventDefault();
          contextLost = true;
          stopRAF();
          lossCallbacks.forEach(function(cb) {
            cb();
          });
        }
        function handleContextRestored(event) {
          gl2.getError();
          contextLost = false;
          extensionState.restore();
          shaderState.restore();
          bufferState.restore();
          textureState.restore();
          renderbufferState.restore();
          framebufferState.restore();
          attributeState.restore();
          if (timer2) {
            timer2.restore();
          }
          core.procs.refresh();
          startRAF();
          restoreCallbacks.forEach(function(cb) {
            cb();
          });
        }
        if (canvas) {
          canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
          canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
        }
        function destroy() {
          rafCallbacks.length = 0;
          stopRAF();
          if (canvas) {
            canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
            canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
          }
          shaderState.clear();
          framebufferState.clear();
          renderbufferState.clear();
          textureState.clear();
          elementState.clear();
          bufferState.clear();
          attributeState.clear();
          if (timer2) {
            timer2.clear();
          }
          destroyCallbacks.forEach(function(cb) {
            cb();
          });
        }
        function compileProcedure(options) {
          check$1(!!options, "invalid args to regl({...})");
          check$1.type(options, "object", "invalid args to regl({...})");
          function flattenNestedOptions(options2) {
            var result = extend2({}, options2);
            delete result.uniforms;
            delete result.attributes;
            delete result.context;
            delete result.vao;
            if ("stencil" in result && result.stencil.op) {
              result.stencil.opBack = result.stencil.opFront = result.stencil.op;
              delete result.stencil.op;
            }
            function merge(name) {
              if (name in result) {
                var child = result[name];
                delete result[name];
                Object.keys(child).forEach(function(prop) {
                  result[name + "." + prop] = child[prop];
                });
              }
            }
            merge("blend");
            merge("depth");
            merge("cull");
            merge("stencil");
            merge("polygonOffset");
            merge("scissor");
            merge("sample");
            if ("vao" in options2) {
              result.vao = options2.vao;
            }
            return result;
          }
          function separateDynamic(object, useArrays) {
            var staticItems = {};
            var dynamicItems = {};
            Object.keys(object).forEach(function(option) {
              var value = object[option];
              if (dynamic.isDynamic(value)) {
                dynamicItems[option] = dynamic.unbox(value, option);
                return;
              } else if (useArrays && Array.isArray(value)) {
                for (var i2 = 0; i2 < value.length; ++i2) {
                  if (dynamic.isDynamic(value[i2])) {
                    dynamicItems[option] = dynamic.unbox(value, option);
                    return;
                  }
                }
              }
              staticItems[option] = value;
            });
            return {
              dynamic: dynamicItems,
              static: staticItems
            };
          }
          var context = separateDynamic(options.context || {}, true);
          var uniforms = separateDynamic(options.uniforms || {}, true);
          var attributes = separateDynamic(options.attributes || {}, false);
          var opts = separateDynamic(flattenNestedOptions(options), false);
          var stats$$12 = {
            gpuTime: 0,
            cpuTime: 0,
            count: 0
          };
          var compiled = core.compile(opts, attributes, uniforms, context, stats$$12);
          var draw4 = compiled.draw;
          var batch = compiled.batch;
          var scope = compiled.scope;
          var EMPTY_ARRAY = [];
          function reserve(count) {
            while (EMPTY_ARRAY.length < count) {
              EMPTY_ARRAY.push(null);
            }
            return EMPTY_ARRAY;
          }
          function REGLCommand(args2, body) {
            var i2;
            if (contextLost) {
              check$1.raise("context lost");
            }
            if (typeof args2 === "function") {
              return scope.call(this, null, args2, 0);
            } else if (typeof body === "function") {
              if (typeof args2 === "number") {
                for (i2 = 0; i2 < args2; ++i2) {
                  scope.call(this, null, body, i2);
                }
              } else if (Array.isArray(args2)) {
                for (i2 = 0; i2 < args2.length; ++i2) {
                  scope.call(this, args2[i2], body, i2);
                }
              } else {
                return scope.call(this, args2, body, 0);
              }
            } else if (typeof args2 === "number") {
              if (args2 > 0) {
                return batch.call(this, reserve(args2 | 0), args2 | 0);
              }
            } else if (Array.isArray(args2)) {
              if (args2.length) {
                return batch.call(this, args2, args2.length);
              }
            } else {
              return draw4.call(this, args2);
            }
          }
          return extend2(REGLCommand, {
            stats: stats$$12,
            destroy: function() {
              compiled.destroy();
            }
          });
        }
        var setFBO = framebufferState.setFBO = compileProcedure({
          framebuffer: dynamic.define.call(null, DYN_PROP, "framebuffer")
        });
        function clearImpl(_2, options) {
          var clearFlags = 0;
          core.procs.poll();
          var c3 = options.color;
          if (c3) {
            gl2.clearColor(+c3[0] || 0, +c3[1] || 0, +c3[2] || 0, +c3[3] || 0);
            clearFlags |= GL_COLOR_BUFFER_BIT;
          }
          if ("depth" in options) {
            gl2.clearDepth(+options.depth);
            clearFlags |= GL_DEPTH_BUFFER_BIT;
          }
          if ("stencil" in options) {
            gl2.clearStencil(options.stencil | 0);
            clearFlags |= GL_STENCIL_BUFFER_BIT;
          }
          check$1(!!clearFlags, "called regl.clear with no buffer specified");
          gl2.clear(clearFlags);
        }
        function clear(options) {
          check$1(
            typeof options === "object" && options,
            "regl.clear() takes an object as input"
          );
          if ("framebuffer" in options) {
            if (options.framebuffer && options.framebuffer_reglType === "framebufferCube") {
              for (var i2 = 0; i2 < 6; ++i2) {
                setFBO(extend2({
                  framebuffer: options.framebuffer.faces[i2]
                }, options), clearImpl);
              }
            } else {
              setFBO(options, clearImpl);
            }
          } else {
            clearImpl(null, options);
          }
        }
        function frame(cb) {
          check$1.type(cb, "function", "regl.frame() callback must be a function");
          rafCallbacks.push(cb);
          function cancel() {
            var i2 = find3(rafCallbacks, cb);
            check$1(i2 >= 0, "cannot cancel a frame twice");
            function pendingCancel() {
              var index2 = find3(rafCallbacks, pendingCancel);
              rafCallbacks[index2] = rafCallbacks[rafCallbacks.length - 1];
              rafCallbacks.length -= 1;
              if (rafCallbacks.length <= 0) {
                stopRAF();
              }
            }
            rafCallbacks[i2] = pendingCancel;
          }
          startRAF();
          return {
            cancel
          };
        }
        function pollViewport() {
          var viewport = nextState.viewport;
          var scissorBox = nextState.scissor_box;
          viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
          contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl2.drawingBufferWidth;
          contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl2.drawingBufferHeight;
        }
        function poll() {
          contextState.tick += 1;
          contextState.time = now();
          pollViewport();
          core.procs.poll();
        }
        function refresh() {
          textureState.refresh();
          pollViewport();
          core.procs.refresh();
          if (timer2) {
            timer2.update();
          }
        }
        function now() {
          return (clock() - START_TIME) / 1e3;
        }
        refresh();
        function addListener(event, callback) {
          check$1.type(callback, "function", "listener callback must be a function");
          var callbacks;
          switch (event) {
            case "frame":
              return frame(callback);
            case "lost":
              callbacks = lossCallbacks;
              break;
            case "restore":
              callbacks = restoreCallbacks;
              break;
            case "destroy":
              callbacks = destroyCallbacks;
              break;
            default:
              check$1.raise("invalid event, must be one of frame,lost,restore,destroy");
          }
          callbacks.push(callback);
          return {
            cancel: function() {
              for (var i2 = 0; i2 < callbacks.length; ++i2) {
                if (callbacks[i2] === callback) {
                  callbacks[i2] = callbacks[callbacks.length - 1];
                  callbacks.pop();
                  return;
                }
              }
            }
          };
        }
        var regl2 = extend2(compileProcedure, {
          // Clear current FBO
          clear,
          // Short cuts for dynamic variables
          prop: dynamic.define.bind(null, DYN_PROP),
          context: dynamic.define.bind(null, DYN_CONTEXT),
          this: dynamic.define.bind(null, DYN_STATE),
          // executes an empty draw command
          draw: compileProcedure({}),
          // Resources
          buffer: function(options) {
            return bufferState.create(options, GL_ARRAY_BUFFER, false, false);
          },
          elements: function(options) {
            return elementState.create(options, false);
          },
          texture: textureState.create2D,
          cube: textureState.createCube,
          renderbuffer: renderbufferState.create,
          framebuffer: framebufferState.create,
          framebufferCube: framebufferState.createCube,
          vao: attributeState.createVAO,
          // Expose context attributes
          attributes: glAttributes,
          // Frame rendering
          frame,
          on: addListener,
          // System limits
          limits,
          hasExtension: function(name) {
            return limits.extensions.indexOf(name.toLowerCase()) >= 0;
          },
          // Read pixels
          read: readPixels,
          // Destroy regl and all associated resources
          destroy,
          // Direct GL state manipulation
          _gl: gl2,
          _refresh: refresh,
          poll: function() {
            poll();
            if (timer2) {
              timer2.update();
            }
          },
          // Current time
          now,
          // regl Statistics Information
          stats: stats$$1
        });
        config.onDone(null, regl2);
        return regl2;
      }
      return wrapREGL;
    });
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js
var ReglAttribute;
var init_ReglAttribute = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js"() {
    init_classCallCheck();
    init_createClass();
    ReglAttribute = function() {
      function ReglAttribute2(gl2, options) {
        _classCallCheck5(this, ReglAttribute2);
        this.attribute = void 0;
        this.buffer = void 0;
        var buffer = options.buffer, offset = options.offset, stride = options.stride, normalized = options.normalized, size3 = options.size, divisor = options.divisor;
        this.buffer = buffer;
        this.attribute = {
          buffer: buffer.get(),
          offset: offset || 0,
          stride: stride || 0,
          normalized: normalized || false,
          divisor: divisor || 0
        };
        if (size3) {
          this.attribute.size = size3;
        }
      }
      _createClass5(ReglAttribute2, [{
        key: "get",
        value: function get3() {
          return this.attribute;
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(options) {
          this.buffer.subData(options);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.buffer.destroy();
        }
      }]);
      return ReglAttribute2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/constants.js
var _primitiveMap, _usageMap, _dataTypeMap, _formatMap, _mipmapMap, _filterMap, _wrapModeMap, _colorSpaceMap, _depthFuncMap, _blendEquationMap, _blendFuncMap, _stencilFuncMap, _stencilOpMap, _cullFaceMap, primitiveMap, usageMap, dataTypeMap, formatMap, mipmapMap, filterMap, wrapModeMap, colorSpaceMap, depthFuncMap, blendEquationMap, blendFuncMap, stencilFuncMap, stencilOpMap, cullFaceMap;
var init_constants = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/constants.js"() {
    init_defineProperty();
    init_es2();
    primitiveMap = (_primitiveMap = {}, _defineProperty2(_primitiveMap, gl.POINTS, "points"), _defineProperty2(_primitiveMap, gl.LINES, "lines"), _defineProperty2(_primitiveMap, gl.LINE_LOOP, "line loop"), _defineProperty2(_primitiveMap, gl.LINE_STRIP, "line strip"), _defineProperty2(_primitiveMap, gl.TRIANGLES, "triangles"), _defineProperty2(_primitiveMap, gl.TRIANGLE_FAN, "triangle fan"), _defineProperty2(_primitiveMap, gl.TRIANGLE_STRIP, "triangle strip"), _primitiveMap);
    usageMap = (_usageMap = {}, _defineProperty2(_usageMap, gl.STATIC_DRAW, "static"), _defineProperty2(_usageMap, gl.DYNAMIC_DRAW, "dynamic"), _defineProperty2(_usageMap, gl.STREAM_DRAW, "stream"), _usageMap);
    dataTypeMap = (_dataTypeMap = {}, _defineProperty2(_dataTypeMap, gl.BYTE, "int8"), _defineProperty2(_dataTypeMap, gl.UNSIGNED_INT, "int16"), _defineProperty2(_dataTypeMap, gl.INT, "int32"), _defineProperty2(_dataTypeMap, gl.UNSIGNED_BYTE, "uint8"), _defineProperty2(_dataTypeMap, gl.UNSIGNED_SHORT, "uint16"), _defineProperty2(_dataTypeMap, gl.UNSIGNED_INT, "uint32"), _defineProperty2(_dataTypeMap, gl.FLOAT, "float"), _dataTypeMap);
    formatMap = (_formatMap = {}, _defineProperty2(_formatMap, gl.ALPHA, "alpha"), _defineProperty2(_formatMap, gl.LUMINANCE, "luminance"), _defineProperty2(_formatMap, gl.LUMINANCE_ALPHA, "luminance alpha"), _defineProperty2(_formatMap, gl.RGB, "rgb"), _defineProperty2(_formatMap, gl.RGBA, "rgba"), _defineProperty2(_formatMap, gl.RGBA4, "rgba4"), _defineProperty2(_formatMap, gl.RGB5_A1, "rgb5 a1"), _defineProperty2(_formatMap, gl.RGB565, "rgb565"), _defineProperty2(_formatMap, gl.DEPTH_COMPONENT, "depth"), _defineProperty2(_formatMap, gl.DEPTH_STENCIL, "depth stencil"), _formatMap);
    mipmapMap = (_mipmapMap = {}, _defineProperty2(_mipmapMap, gl.DONT_CARE, "dont care"), _defineProperty2(_mipmapMap, gl.NICEST, "nice"), _defineProperty2(_mipmapMap, gl.FASTEST, "fast"), _mipmapMap);
    filterMap = (_filterMap = {}, _defineProperty2(_filterMap, gl.NEAREST, "nearest"), _defineProperty2(_filterMap, gl.LINEAR, "linear"), _defineProperty2(_filterMap, gl.LINEAR_MIPMAP_LINEAR, "mipmap"), _defineProperty2(_filterMap, gl.NEAREST_MIPMAP_LINEAR, "nearest mipmap linear"), _defineProperty2(_filterMap, gl.LINEAR_MIPMAP_NEAREST, "linear mipmap nearest"), _defineProperty2(_filterMap, gl.NEAREST_MIPMAP_NEAREST, "nearest mipmap nearest"), _filterMap);
    wrapModeMap = (_wrapModeMap = {}, _defineProperty2(_wrapModeMap, gl.REPEAT, "repeat"), _defineProperty2(_wrapModeMap, gl.CLAMP_TO_EDGE, "clamp"), _defineProperty2(_wrapModeMap, gl.MIRRORED_REPEAT, "mirror"), _wrapModeMap);
    colorSpaceMap = (_colorSpaceMap = {}, _defineProperty2(_colorSpaceMap, gl.NONE, "none"), _defineProperty2(_colorSpaceMap, gl.BROWSER_DEFAULT_WEBGL, "browser"), _colorSpaceMap);
    depthFuncMap = (_depthFuncMap = {}, _defineProperty2(_depthFuncMap, gl.NEVER, "never"), _defineProperty2(_depthFuncMap, gl.ALWAYS, "always"), _defineProperty2(_depthFuncMap, gl.LESS, "less"), _defineProperty2(_depthFuncMap, gl.LEQUAL, "lequal"), _defineProperty2(_depthFuncMap, gl.GREATER, "greater"), _defineProperty2(_depthFuncMap, gl.GEQUAL, "gequal"), _defineProperty2(_depthFuncMap, gl.EQUAL, "equal"), _defineProperty2(_depthFuncMap, gl.NOTEQUAL, "notequal"), _depthFuncMap);
    blendEquationMap = (_blendEquationMap = {}, _defineProperty2(_blendEquationMap, gl.FUNC_ADD, "add"), _defineProperty2(_blendEquationMap, gl.MIN_EXT, "min"), _defineProperty2(_blendEquationMap, gl.MAX_EXT, "max"), _defineProperty2(_blendEquationMap, gl.FUNC_SUBTRACT, "subtract"), _defineProperty2(_blendEquationMap, gl.FUNC_REVERSE_SUBTRACT, "reverse subtract"), _blendEquationMap);
    blendFuncMap = (_blendFuncMap = {}, _defineProperty2(_blendFuncMap, gl.ZERO, "zero"), _defineProperty2(_blendFuncMap, gl.ONE, "one"), _defineProperty2(_blendFuncMap, gl.SRC_COLOR, "src color"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_SRC_COLOR, "one minus src color"), _defineProperty2(_blendFuncMap, gl.SRC_ALPHA, "src alpha"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_SRC_ALPHA, "one minus src alpha"), _defineProperty2(_blendFuncMap, gl.DST_COLOR, "dst color"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_DST_COLOR, "one minus dst color"), _defineProperty2(_blendFuncMap, gl.DST_ALPHA, "dst alpha"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_DST_ALPHA, "one minus dst alpha"), _defineProperty2(_blendFuncMap, gl.CONSTANT_COLOR, "constant color"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_CONSTANT_COLOR, "one minus constant color"), _defineProperty2(_blendFuncMap, gl.CONSTANT_ALPHA, "constant alpha"), _defineProperty2(_blendFuncMap, gl.ONE_MINUS_CONSTANT_ALPHA, "one minus constant alpha"), _defineProperty2(_blendFuncMap, gl.SRC_ALPHA_SATURATE, "src alpha saturate"), _blendFuncMap);
    stencilFuncMap = (_stencilFuncMap = {}, _defineProperty2(_stencilFuncMap, gl.NEVER, "never"), _defineProperty2(_stencilFuncMap, gl.ALWAYS, "always"), _defineProperty2(_stencilFuncMap, gl.LESS, "less"), _defineProperty2(_stencilFuncMap, gl.LEQUAL, "lequal"), _defineProperty2(_stencilFuncMap, gl.GREATER, "greater"), _defineProperty2(_stencilFuncMap, gl.GEQUAL, "gequal"), _defineProperty2(_stencilFuncMap, gl.EQUAL, "equal"), _defineProperty2(_stencilFuncMap, gl.NOTEQUAL, "notequal"), _stencilFuncMap);
    stencilOpMap = (_stencilOpMap = {}, _defineProperty2(_stencilOpMap, gl.ZERO, "zero"), _defineProperty2(_stencilOpMap, gl.KEEP, "keep"), _defineProperty2(_stencilOpMap, gl.REPLACE, "replace"), _defineProperty2(_stencilOpMap, gl.INVERT, "invert"), _defineProperty2(_stencilOpMap, gl.INCR, "increment"), _defineProperty2(_stencilOpMap, gl.DECR, "decrement"), _defineProperty2(_stencilOpMap, gl.INCR_WRAP, "increment wrap"), _defineProperty2(_stencilOpMap, gl.DECR_WRAP, "decrement wrap"), _stencilOpMap);
    cullFaceMap = (_cullFaceMap = {}, _defineProperty2(_cullFaceMap, gl.FRONT, "front"), _defineProperty2(_cullFaceMap, gl.BACK, "back"), _cullFaceMap);
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js
var ReglBuffer;
var init_ReglBuffer = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js"() {
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_constants();
    ReglBuffer = function() {
      function ReglBuffer2(reGl, options) {
        _classCallCheck5(this, ReglBuffer2);
        this.buffer = void 0;
        var data = options.data, usage = options.usage, type = options.type;
        this.buffer = reGl.buffer({
          data,
          usage: usageMap[usage || gl.STATIC_DRAW],
          type: dataTypeMap[type || gl.UNSIGNED_BYTE]
          // length: 0,
        });
      }
      _createClass5(ReglBuffer2, [{
        key: "get",
        value: function get3() {
          return this.buffer;
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }, {
        key: "subData",
        value: function subData(_ref) {
          var data = _ref.data, offset = _ref.offset;
          this.buffer.subdata(data, offset);
        }
      }]);
      return ReglBuffer2;
    }();
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray3(arr);
}
var init_arrayWithoutHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
var init_iterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray3(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray3(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray3(o2, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableSpread = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray3(arr) || _nonIterableSpread();
}
var init_toConsumableArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"() {
    init_arrayWithoutHoles();
    init_iterableToArray();
    init_unsupportedIterableToArray();
    init_nonIterableSpread();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js
function ownKeys3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_isTypedArray2, import_regenerator3, quadVert, textureId, debug, ReglComputeModel;
var init_ReglComputeModel = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js"() {
    init_toConsumableArray();
    init_defineProperty();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_isTypedArray2 = __toESM(require_isTypedArray());
    import_regenerator3 = __toESM(require_regenerator());
    init_es2();
    quadVert = "attribute vec3 a_Position;\nattribute vec2 a_TexCoord;\n\nvarying vec2 v_TexCoord;\n\nvoid main() {\n  gl_Position = vec4(a_Position, 1.0);\n  v_TexCoord = a_TexCoord;\n}";
    textureId = 0;
    debug = false;
    ReglComputeModel = function() {
      function ReglComputeModel2(reGl, context) {
        var _this = this;
        _classCallCheck5(this, ReglComputeModel2);
        this.reGl = reGl;
        this.context = context;
        this.entity = createEntity();
        this.texFBO = void 0;
        this.computeCommand = void 0;
        this.textureCache = {};
        this.outputTextureName = void 0;
        this.swapOutputTextureName = void 0;
        this.compiledPingpong = void 0;
        this.dynamicPingpong = void 0;
        var uniforms = {};
        this.context.uniforms.forEach(function(uniform) {
          var name = uniform.name, type = uniform.type, data = uniform.data, isReferer = uniform.isReferer, storageClass = uniform.storageClass;
          if (storageClass === STORAGE_CLASS.StorageBuffer) {
            if (!isReferer) {
              _this.textureCache[name] = _this.calcDataTexture(name, type, data);
              var _this$textureCache$na = _this.textureCache[name], width = _this$textureCache$na.textureWidth, isOutput = _this$textureCache$na.isOutput;
              uniforms["".concat(name, "Size")] = [width, width];
              if (isOutput) {
                _this.outputTextureName = name;
                if (_this.context.needPingpong) {
                  _this.outputTextureName = "".concat(name, "Output");
                  _this.textureCache[_this.outputTextureName] = _this.calcDataTexture(name, type, data);
                }
              }
            } else {
              _this.textureCache[name] = {
                data: void 0
              };
              uniforms["".concat(name, "Size")] = function() {
                return (
                  // @ts-ignore
                  data.compiledBundle.context.output.textureSize
                );
              };
            }
            uniforms[name] = function() {
              if (debug) {
                console.log("[".concat(_this.entity, "]: ").concat(name, " ").concat(_this.textureCache[name].id));
              }
              return _this.textureCache[name].texture;
            };
          } else if (storageClass === STORAGE_CLASS.Uniform) {
            if (data && (Array.isArray(data) || (0, import_isTypedArray2.default)(data)) && data.length > 16) {
              throw new Error("invalid data type ".concat(type));
            }
            uniforms[name] = function() {
              return uniform.data;
            };
          }
        });
        var _this$getOuputDataTex = this.getOuputDataTexture(), textureWidth = _this$getOuputDataTex.textureWidth, texelCount = _this$getOuputDataTex.texelCount;
        uniforms.u_OutputTextureSize = [textureWidth, textureWidth];
        uniforms.u_OutputTexelCount = texelCount;
        this.context.output.textureSize = [textureWidth, textureWidth];
        var drawParams = {
          attributes: {
            a_Position: [[-1, 1, 0], [-1, -1, 0], [1, 1, 0], [1, -1, 0]],
            a_TexCoord: [[0, 1], [0, 0], [1, 1], [1, 0]]
          },
          frag: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n".concat(this.context.shader),
          uniforms,
          vert: quadVert,
          // TODO: use a fullscreen triangle instead.
          primitive: "triangle strip",
          count: 4
        };
        this.computeCommand = this.reGl(drawParams);
      }
      _createClass5(ReglComputeModel2, [{
        key: "run",
        value: function run() {
          var _this2 = this;
          if (this.context.maxIteration > 1 && this.context.needPingpong) {
            this.compiledPingpong = true;
          }
          if (this.compiledPingpong || this.dynamicPingpong) {
            this.swap();
          }
          this.texFBO = this.reGl.framebuffer({
            color: this.getOuputDataTexture().texture
          });
          this.texFBO.use(function() {
            _this2.computeCommand();
          });
          if (debug) {
            console.log("[".concat(this.entity, "]: output ").concat(this.getOuputDataTexture().id));
          }
        }
      }, {
        key: "readData",
        value: function() {
          var _readData = _asyncToGenerator(import_regenerator3.default.mark(function _callee() {
            var _this3 = this;
            var pixels, _this$getOuputDataTex2, originalDataLength, elementsPerTexel, _this$getOuputDataTex3, typedArrayConstructor, formattedPixels, i2;
            return import_regenerator3.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.reGl({
                      framebuffer: this.texFBO
                    })(function() {
                      pixels = _this3.reGl.read();
                    });
                    if (!pixels) {
                      _context.next = 6;
                      break;
                    }
                    _this$getOuputDataTex2 = this.getOuputDataTexture(), originalDataLength = _this$getOuputDataTex2.originalDataLength, elementsPerTexel = _this$getOuputDataTex2.elementsPerTexel, _this$getOuputDataTex3 = _this$getOuputDataTex2.typedArrayConstructor, typedArrayConstructor = _this$getOuputDataTex3 === void 0 ? Float32Array : _this$getOuputDataTex3;
                    formattedPixels = [];
                    if (elementsPerTexel !== 4) {
                      for (i2 = 0; i2 < pixels.length; i2 += 4) {
                        if (elementsPerTexel === 1) {
                          formattedPixels.push(pixels[i2]);
                        } else if (elementsPerTexel === 2) {
                          formattedPixels.push(pixels[i2], pixels[i2 + 1]);
                        } else {
                          formattedPixels.push(pixels[i2], pixels[i2 + 1], pixels[i2 + 2]);
                        }
                      }
                    } else {
                      formattedPixels = pixels;
                    }
                    return _context.abrupt("return", new typedArrayConstructor(formattedPixels.slice(0, originalDataLength)));
                  case 6:
                    return _context.abrupt("return", new Float32Array());
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function readData() {
            return _readData.apply(this, arguments);
          }
          return readData;
        }()
      }, {
        key: "confirmInput",
        value: function confirmInput(model, inputName) {
          var inputModel;
          if (this.entity === model.entity) {
            this.dynamicPingpong = true;
            inputModel = this;
          } else {
            inputModel = model;
          }
          this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;
          this.textureCache[inputName].texture = inputModel.getOuputDataTexture().texture;
          if (debug) {
            console.log("[".concat(this.entity, "]: confirm input ").concat(inputName, " from model ").concat(inputModel.entity, ", ").concat(inputModel.getOuputDataTexture().id));
          }
        }
      }, {
        key: "updateUniform",
        value: function updateUniform() {
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(bufferName, data) {
          var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var buffer = this.context.uniforms.find(function(_ref) {
            var name = _ref.name;
            return name === bufferName;
          });
          if (buffer) {
            var _this$calcDataTexture = this.calcDataTexture(bufferName, buffer.type, data), texture = _this$calcDataTexture.texture, paddingData = _this$calcDataTexture.data;
            this.textureCache[bufferName].data = paddingData;
            this.textureCache[bufferName].texture = texture;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }, {
        key: "swap",
        value: function swap() {
          if (!this.swapOutputTextureName) {
            this.createSwapOutputDataTexture();
          }
          if (this.compiledPingpong) {
            var outputTextureUniformName = this.context.output.name;
            this.textureCache[outputTextureUniformName].id = this.getOuputDataTexture().id;
            this.textureCache[outputTextureUniformName].texture = this.getOuputDataTexture().texture;
          }
          var tmp = this.outputTextureName;
          this.outputTextureName = this.swapOutputTextureName;
          this.swapOutputTextureName = tmp;
          if (debug) {
            console.log("[".concat(this.entity, "]: after swap, output ").concat(this.getOuputDataTexture().id));
          }
        }
      }, {
        key: "getOuputDataTexture",
        value: function getOuputDataTexture() {
          return this.textureCache[this.outputTextureName];
        }
      }, {
        key: "createSwapOutputDataTexture",
        value: function createSwapOutputDataTexture() {
          var texture = this.cloneDataTexture(this.getOuputDataTexture());
          this.swapOutputTextureName = "".concat(this.entity, "-swap");
          this.textureCache[this.swapOutputTextureName] = texture;
        }
      }, {
        key: "cloneDataTexture",
        value: function cloneDataTexture(texture) {
          var data = texture.data, textureWidth = texture.textureWidth;
          return _objectSpread3(_objectSpread3({}, texture), {}, {
            id: textureId++,
            // @ts-ignore
            texture: this.reGl.texture({
              width: textureWidth,
              height: textureWidth,
              data,
              type: "float"
            })
          });
        }
      }, {
        key: "calcDataTexture",
        value: function calcDataTexture(name, type, data) {
          var elementsPerTexel = 1;
          if (type === AST_TOKEN_TYPES.Vector4FloatArray) {
            elementsPerTexel = 4;
          }
          var paddingData = [];
          for (var i2 = 0; i2 < data.length; i2 += elementsPerTexel) {
            if (elementsPerTexel === 1) {
              paddingData.push(data[i2], 0, 0, 0);
            } else if (elementsPerTexel === 2) {
              paddingData.push(data[i2], data[i2 + 1], 0, 0);
            } else if (elementsPerTexel === 3) {
              paddingData.push(data[i2], data[i2 + 1], data[i2 + 2], 0);
            } else if (elementsPerTexel === 4) {
              paddingData.push(data[i2], data[i2 + 1], data[i2 + 2], data[i2 + 3]);
            }
          }
          var originalDataLength = data.length;
          var texelCount = Math.ceil(originalDataLength / elementsPerTexel);
          var width = Math.ceil(Math.sqrt(texelCount));
          var paddingTexelCount = width * width;
          if (texelCount < paddingTexelCount) {
            paddingData.push.apply(paddingData, _toConsumableArray(new Array((paddingTexelCount - texelCount) * 4).fill(0)));
          }
          var texture = this.reGl.texture({
            width,
            height: width,
            data: paddingData,
            type: "float"
          });
          return {
            id: textureId++,
            data: paddingData,
            originalDataLength,
            typedArrayConstructor: (0, import_isTypedArray2.default)(data) ? data.constructor : void 0,
            textureWidth: width,
            texture,
            texelCount,
            elementsPerTexel,
            isOutput: name === this.context.output.name
          };
        }
      }]);
      return ReglComputeModel2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js
var ReglElements;
var init_ReglElements = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js"() {
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_constants();
    ReglElements = function() {
      function ReglElements2(reGl, options) {
        _classCallCheck5(this, ReglElements2);
        this.elements = void 0;
        var data = options.data, usage = options.usage, type = options.type, count = options.count;
        this.elements = reGl.elements({
          data,
          usage: usageMap[usage || gl.STATIC_DRAW],
          type: dataTypeMap[type || gl.UNSIGNED_BYTE],
          count
        });
      }
      _createClass5(ReglElements2, [{
        key: "get",
        value: function get3() {
          return this.elements;
        }
      }, {
        key: "subData",
        value: function subData(_ref) {
          var data = _ref.data;
          this.elements.subdata(data);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.elements.destroy();
        }
      }]);
      return ReglElements2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js
var ReglFramebuffer;
var init_ReglFramebuffer = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js"() {
    init_classCallCheck();
    init_createClass();
    ReglFramebuffer = function() {
      function ReglFramebuffer2(reGl, options) {
        _classCallCheck5(this, ReglFramebuffer2);
        this.framebuffer = void 0;
        var width = options.width, height = options.height, color2 = options.color, colors = options.colors, depth = options.depth, stencil = options.stencil;
        var framebufferOptions = {
          width,
          height
        };
        if (Array.isArray(colors)) {
          framebufferOptions.colors = colors.map(function(c3) {
            return c3.get();
          });
        }
        if (color2 && typeof color2 !== "boolean") {
          framebufferOptions.color = color2.get();
        }
        this.framebuffer = reGl.framebuffer(framebufferOptions);
      }
      _createClass5(ReglFramebuffer2, [{
        key: "get",
        value: function get3() {
          return this.framebuffer;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.framebuffer.destroy();
        }
      }, {
        key: "resize",
        value: function resize(_ref) {
          var width = _ref.width, height = _ref.height;
          this.framebuffer.resize(width, height);
        }
      }]);
      return ReglFramebuffer2;
    }();
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform13) {
      return function(arg) {
        return func(transform13(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike2 = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto2 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty4 = objectProto2.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject2(value) {
      if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty4.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject2;
  }
});

// node_modules/@antv/g-webgpu-engine/es/utils/uniform.js
function extractUniforms(uniforms) {
  var extractedUniforms = {};
  Object.keys(uniforms).forEach(function(uniformName) {
    extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, "");
  });
  return extractedUniforms;
}
function extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
  if (uniformValue === null || typeof uniformValue === "number" || // u_A: 1
  typeof uniformValue === "boolean" || // u_A: false
  Array.isArray(uniformValue) && typeof uniformValue[0] === "number" || // u_A: [1, 2, 3]
  (0, import_isTypedArray3.default)(uniformValue) || // u_A: Float32Array
  // @ts-ignore
  uniformValue === "" || // @ts-ignore
  uniformValue.resize !== void 0) {
    uniforms["".concat(prefix && prefix + ".").concat(uniformName)] = uniformValue;
    return;
  }
  if ((0, import_isPlainObject.default)(uniformValue)) {
    Object.keys(uniformValue).forEach(function(childName) {
      extractUniformsRecursively(
        childName,
        // @ts-ignore
        uniformValue[childName],
        uniforms,
        "".concat(prefix && prefix + ".").concat(uniformName)
      );
    });
  }
  if (Array.isArray(uniformValue)) {
    uniformValue.forEach(function(child, idx) {
      Object.keys(child).forEach(function(childName) {
        extractUniformsRecursively(
          childName,
          // @ts-ignore
          child[childName],
          uniforms,
          "".concat(prefix && prefix + ".").concat(uniformName, "[").concat(idx, "]")
        );
      });
    });
  }
}
var import_isTypedArray3, import_isPlainObject;
var init_uniform = __esm({
  "node_modules/@antv/g-webgpu-engine/es/utils/uniform.js"() {
    import_isTypedArray3 = __toESM(require_isTypedArray());
    import_isPlainObject = __toESM(require_isPlainObject());
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js
function ownKeys4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ReglModel;
var init_ReglModel = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js"() {
    init_typeof();
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_uniform();
    init_constants();
    ReglModel = function() {
      function ReglModel2(reGl, options) {
        _classCallCheck5(this, ReglModel2);
        this.reGl = void 0;
        this.drawCommand = void 0;
        this.uniforms = {};
        this.reGl = reGl;
        var vs = options.vs, fs = options.fs, defines = options.defines, attributes = options.attributes, uniforms = options.uniforms, primitive = options.primitive, count = options.count, elements = options.elements, depth = options.depth, blend = options.blend, stencil = options.stencil, cull = options.cull, instances = options.instances, scissor = options.scissor, viewport = options.viewport;
        var reglUniforms = {};
        if (uniforms) {
          this.uniforms = extractUniforms(uniforms);
          Object.keys(uniforms).forEach(function(uniformName) {
            reglUniforms[uniformName] = reGl.prop(uniformName);
          });
        }
        var reglAttributes = {};
        Object.keys(attributes).forEach(function(name) {
          reglAttributes[name] = attributes[name].get();
        });
        var defineStmts = defines && this.generateDefines(defines) || "";
        var drawParams = {
          attributes: reglAttributes,
          frag: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n".concat(defineStmts, "\n").concat(fs),
          uniforms: reglUniforms,
          vert: "\n".concat(defineStmts, "\n").concat(vs),
          primitive: primitiveMap[primitive === void 0 ? gl.TRIANGLES : primitive]
        };
        if (instances) {
          drawParams.instances = instances;
        }
        if (count) {
          drawParams.count = count;
        }
        if (elements) {
          drawParams.elements = elements.get();
        }
        if (scissor) {
          drawParams.scissor = scissor;
        }
        if (viewport) {
          drawParams.viewport = viewport;
        }
        this.initDepthDrawParams({
          depth
        }, drawParams);
        this.initBlendDrawParams({
          blend
        }, drawParams);
        this.initStencilDrawParams({
          stencil
        }, drawParams);
        this.initCullDrawParams({
          cull
        }, drawParams);
        this.drawCommand = reGl(drawParams);
      }
      _createClass5(ReglModel2, [{
        key: "addUniforms",
        value: function addUniforms(uniforms) {
          this.uniforms = _objectSpread4(_objectSpread4({}, this.uniforms), extractUniforms(uniforms));
        }
      }, {
        key: "draw",
        value: function draw4(options) {
          var uniforms = _objectSpread4(_objectSpread4({}, this.uniforms), extractUniforms(options.uniforms || {}));
          var reglDrawProps = {};
          Object.keys(uniforms).forEach(function(uniformName) {
            var type = _typeof6(uniforms[uniformName]);
            if (type === "boolean" || type === "number" || Array.isArray(uniforms[uniformName]) || // @ts-ignore
            uniforms[uniformName].BYTES_PER_ELEMENT) {
              reglDrawProps[uniformName] = uniforms[uniformName];
            } else if (type === "string") {
            } else {
              reglDrawProps[uniformName] = uniforms[uniformName].get();
            }
          });
          this.drawCommand(reglDrawProps);
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
        /**
         * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#depth-buffer
         */
      }, {
        key: "initDepthDrawParams",
        value: function initDepthDrawParams(_ref, drawParams) {
          var depth = _ref.depth;
          if (depth) {
            drawParams.depth = {
              enable: depth.enable === void 0 ? true : !!depth.enable,
              mask: depth.mask === void 0 ? true : !!depth.mask,
              func: depthFuncMap[depth.func || gl.LESS],
              range: depth.range || [0, 1]
            };
          }
        }
        /**
         * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#blending
         */
      }, {
        key: "initBlendDrawParams",
        value: function initBlendDrawParams(_ref2, drawParams) {
          var blend = _ref2.blend;
          if (blend) {
            var enable = blend.enable, func = blend.func, equation = blend.equation, _blend$color = blend.color, color2 = _blend$color === void 0 ? [0, 0, 0, 0] : _blend$color;
            drawParams.blend = {
              enable: !!enable,
              func: {
                srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],
                srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],
                dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
                dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
              },
              equation: {
                rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],
                alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]
              },
              color: color2
            };
          }
        }
        /**
         * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
         */
      }, {
        key: "initStencilDrawParams",
        value: function initStencilDrawParams(_ref3, drawParams) {
          var stencil = _ref3.stencil;
          if (stencil) {
            var enable = stencil.enable, _stencil$mask = stencil.mask, mask = _stencil$mask === void 0 ? -1 : _stencil$mask, _stencil$func = stencil.func, func = _stencil$func === void 0 ? {
              cmp: gl.ALWAYS,
              ref: 0,
              mask: -1
            } : _stencil$func, _stencil$opFront = stencil.opFront, opFront = _stencil$opFront === void 0 ? {
              fail: gl.KEEP,
              zfail: gl.KEEP,
              zpass: gl.KEEP
            } : _stencil$opFront, _stencil$opBack = stencil.opBack, opBack = _stencil$opBack === void 0 ? {
              fail: gl.KEEP,
              zfail: gl.KEEP,
              zpass: gl.KEEP
            } : _stencil$opBack;
            drawParams.stencil = {
              enable: !!enable,
              mask,
              func: _objectSpread4(_objectSpread4({}, func), {}, {
                cmp: stencilFuncMap[func.cmp]
              }),
              opFront: {
                fail: stencilOpMap[opFront.fail],
                zfail: stencilOpMap[opFront.zfail],
                zpass: stencilOpMap[opFront.zpass]
              },
              opBack: {
                fail: stencilOpMap[opBack.fail],
                zfail: stencilOpMap[opBack.zfail],
                zpass: stencilOpMap[opBack.zpass]
              }
            };
          }
        }
        /**
         * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
         */
      }, {
        key: "initCullDrawParams",
        value: function initCullDrawParams(_ref4, drawParams) {
          var cull = _ref4.cull;
          if (cull) {
            var enable = cull.enable, _cull$face = cull.face, face = _cull$face === void 0 ? gl.BACK : _cull$face;
            drawParams.cull = {
              enable: !!enable,
              face: cullFaceMap[face]
            };
          }
        }
      }, {
        key: "generateDefines",
        value: function generateDefines(defines) {
          return Object.keys(defines).map(function(name) {
            return "#define ".concat(name, " ").concat(Number(defines[name]));
          }).join("\n");
        }
      }]);
      return ReglModel2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js
var ReglTexture2D;
var init_ReglTexture2D = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js"() {
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_constants();
    ReglTexture2D = function() {
      function ReglTexture2D2(reGl, options) {
        _classCallCheck5(this, ReglTexture2D2);
        this.texture = void 0;
        this.width = void 0;
        this.height = void 0;
        var data = options.data, _options$type = options.type, type = _options$type === void 0 ? gl.UNSIGNED_BYTE : _options$type, width = options.width, height = options.height, _options$flipY = options.flipY, flipY = _options$flipY === void 0 ? false : _options$flipY, _options$format = options.format, format = _options$format === void 0 ? gl.RGBA : _options$format, _options$mipmap = options.mipmap, mipmap = _options$mipmap === void 0 ? false : _options$mipmap, _options$wrapS = options.wrapS, wrapS = _options$wrapS === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapS, _options$wrapT = options.wrapT, wrapT = _options$wrapT === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapT, _options$aniso = options.aniso, aniso = _options$aniso === void 0 ? 0 : _options$aniso, _options$alignment = options.alignment, alignment = _options$alignment === void 0 ? 1 : _options$alignment, _options$premultiplyA = options.premultiplyAlpha, premultiplyAlpha = _options$premultiplyA === void 0 ? false : _options$premultiplyA, _options$mag = options.mag, mag = _options$mag === void 0 ? gl.NEAREST : _options$mag, _options$min = options.min, min3 = _options$min === void 0 ? gl.NEAREST : _options$min, _options$colorSpace = options.colorSpace, colorSpace = _options$colorSpace === void 0 ? gl.BROWSER_DEFAULT_WEBGL : _options$colorSpace;
        this.width = width;
        this.height = height;
        var textureOptions = {
          width,
          height,
          // @ts-ignore
          type: dataTypeMap[type],
          format: formatMap[format],
          wrapS: wrapModeMap[wrapS],
          wrapT: wrapModeMap[wrapT],
          // @ts-ignore
          mag: filterMap[mag],
          min: filterMap[min3],
          alignment,
          flipY,
          colorSpace: colorSpaceMap[colorSpace],
          premultiplyAlpha,
          aniso
        };
        if (data) {
          textureOptions.data = data;
        }
        if (typeof mipmap === "number") {
          textureOptions.mipmap = mipmapMap[mipmap];
        } else if (typeof mipmap === "boolean") {
          textureOptions.mipmap = mipmap;
        }
        this.texture = reGl.texture(textureOptions);
      }
      _createClass5(ReglTexture2D2, [{
        key: "get",
        value: function get3() {
          return this.texture;
        }
      }, {
        key: "update",
        value: function update14() {
          this.texture._texture.bind();
        }
      }, {
        key: "resize",
        value: function resize(_ref) {
          var width = _ref.width, height = _ref.height;
          this.texture.resize(width, height);
          this.width = width;
          this.height = height;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.texture.destroy();
        }
      }]);
      return ReglTexture2D2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/index.js
var import_regenerator4, import_regl, WebGLEngine;
var init_webgl = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/index.js"() {
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_regenerator4 = __toESM(require_regenerator());
    init_es2();
    import_regl = __toESM(require_regl());
    init_ReglAttribute();
    init_ReglBuffer();
    init_ReglComputeModel();
    init_ReglElements();
    init_ReglFramebuffer();
    init_ReglModel();
    init_ReglTexture2D();
    WebGLEngine = function() {
      function WebGLEngine2() {
        var _this = this;
        _classCallCheck5(this, WebGLEngine2);
        this.supportWebGPU = false;
        this.useWGSL = false;
        this.$canvas = void 0;
        this.gl = void 0;
        this.inited = void 0;
        this.createModel = function() {
          var _ref = _asyncToGenerator(import_regenerator4.default.mark(function _callee2(options) {
            return import_regenerator4.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!options.uniforms) {
                      _context2.next = 3;
                      break;
                    }
                    _context2.next = 3;
                    return Promise.all(Object.keys(options.uniforms).map(function() {
                      var _ref2 = _asyncToGenerator(import_regenerator4.default.mark(function _callee(name) {
                        var texture;
                        return import_regenerator4.default.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                if (!(options.uniforms[name] && // @ts-ignore
                                options.uniforms[name].load !== void 0)) {
                                  _context.next = 5;
                                  break;
                                }
                                _context.next = 3;
                                return options.uniforms[name].load();
                              case 3:
                                texture = _context.sent;
                                options.uniforms[name] = texture;
                              case 5:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));
                      return function(_x2) {
                        return _ref2.apply(this, arguments);
                      };
                    }()));
                  case 3:
                    return _context2.abrupt("return", new ReglModel(_this.gl, options));
                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function(_x) {
            return _ref.apply(this, arguments);
          };
        }();
        this.createAttribute = function(options) {
          return new ReglAttribute(_this.gl, options);
        };
        this.createBuffer = function(options) {
          return new ReglBuffer(_this.gl, options);
        };
        this.createElements = function(options) {
          return new ReglElements(_this.gl, options);
        };
        this.createTexture2D = function(options) {
          return new ReglTexture2D(_this.gl, options);
        };
        this.createFramebuffer = function(options) {
          return new ReglFramebuffer(_this.gl, options);
        };
        this.useFramebuffer = function(framebuffer, drawCommands) {
          _this.gl({
            framebuffer: framebuffer ? framebuffer.get() : null
          })(drawCommands);
        };
        this.createComputeModel = function() {
          var _ref3 = _asyncToGenerator(import_regenerator4.default.mark(function _callee3(context) {
            return import_regenerator4.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", new ReglComputeModel(_this.gl, context));
                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));
          return function(_x3) {
            return _ref3.apply(this, arguments);
          };
        }();
        this.clear = function(options) {
          var color2 = options.color, depth = options.depth, stencil = options.stencil, _options$framebuffer = options.framebuffer, framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;
          var reglClearOptions = {
            color: color2,
            depth,
            stencil
          };
          reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
          _this.gl.clear(reglClearOptions);
        };
        this.setScissor = function(scissor) {
          if (_this.gl && _this.gl._gl) {
            if (scissor.enable && scissor.box) {
              _this.gl._gl.enable(gl.SCISSOR_TEST);
              _this.gl._gl.scissor(scissor.box.x, scissor.box.y, scissor.box.width, scissor.box.height);
            } else {
              _this.gl._gl.disable(gl.SCISSOR_TEST);
            }
            _this.gl._refresh();
          }
        };
        this.viewport = function(_ref4) {
          var x4 = _ref4.x, y4 = _ref4.y, width = _ref4.width, height = _ref4.height;
          if (_this.gl && _this.gl._gl) {
            _this.gl._gl.viewport(x4, y4, width, height);
            _this.gl._refresh();
          }
        };
        this.readPixels = function(options) {
          var framebuffer = options.framebuffer, x4 = options.x, y4 = options.y, width = options.width, height = options.height;
          var readPixelsOptions = {
            x: x4,
            y: y4,
            width,
            height
          };
          if (framebuffer) {
            readPixelsOptions.framebuffer = framebuffer.get();
          }
          return _this.gl.read(readPixelsOptions);
        };
        this.getCanvas = function() {
          return _this.$canvas;
        };
        this.getGLContext = function() {
          return _this.gl._gl;
        };
        this.destroy = function() {
          if (_this.gl) {
            _this.gl.destroy();
            _this.inited = false;
          }
        };
      }
      _createClass5(WebGLEngine2, [{
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator4.default.mark(function _callee4(cfg) {
            return import_regenerator4.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!this.inited) {
                      _context4.next = 2;
                      break;
                    }
                    return _context4.abrupt("return");
                  case 2:
                    this.$canvas = cfg.canvas;
                    _context4.next = 5;
                    return new Promise(function(resolve, reject) {
                      (0, import_regl.default)({
                        canvas: cfg.canvas,
                        attributes: {
                          alpha: true,
                          // use TAA instead of MSAA
                          // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1
                          antialias: cfg.antialias,
                          premultipliedAlpha: true
                          // preserveDrawingBuffer: false,
                        },
                        pixelRatio: 1,
                        // TODO: use extensions
                        extensions: [
                          "OES_element_index_uint",
                          "OES_texture_float",
                          "OES_standard_derivatives",
                          // wireframe
                          "angle_instanced_arrays"
                          // VSM shadow map
                        ],
                        optionalExtensions: ["EXT_texture_filter_anisotropic", "EXT_blend_minmax", "WEBGL_depth_texture"],
                        profile: true,
                        onDone: function onDone(err, r2) {
                          if (err || !r2) {
                            reject(err);
                          }
                          resolve(r2);
                        }
                      });
                    });
                  case 5:
                    this.gl = _context4.sent;
                    this.inited = true;
                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function init(_x4) {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "isFloatSupported",
        value: function isFloatSupported() {
          return this.gl.limits.readFloat;
        }
      }, {
        key: "beginFrame",
        value: function beginFrame() {
        }
      }, {
        key: "endFrame",
        value: function endFrame() {
        }
      }]);
      return WebGLEngine2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/index.js
var init_es3 = __esm({
  "node_modules/@antv/g-webgpu-engine/es/index.js"() {
    init_webgl();
  }
});

// node_modules/@antv/g-webgpu/es/World.js
var World;
var init_World = __esm({
  "node_modules/@antv/g-webgpu/es/World.js"() {
    init_classCallCheck();
    init_createClass();
    init_es2();
    init_es3();
    init_Kernel();
    World = function() {
      function World2() {
        _classCallCheck5(this, World2);
        this.engine = void 0;
        this.configService = new ConfigService();
      }
      _createClass5(World2, [{
        key: "setConfig",
        value: function setConfig(config) {
          this.configService.set(config);
        }
      }, {
        key: "setEngine",
        value: function setEngine(engine) {
          this.engine = engine;
        }
      }, {
        key: "createEntity",
        value: function createEntity2() {
          return createEntity();
        }
      }, {
        key: "createKernel",
        value: function createKernel(precompiledBundle) {
          var kernel = new Kernel(this.engine, this.configService);
          if (typeof precompiledBundle === "string") {
            kernel.setBundle(JSON.parse(precompiledBundle));
          } else {
            kernel.setBundle(precompiledBundle);
          }
          kernel.init();
          return kernel;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.engine.destroy();
        }
      }], [{
        key: "create",
        value: function create() {
          var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var world = new World2();
          world.setConfig(config);
          world.setEngine(new WebGLEngine());
          return world;
        }
      }]);
      return World2;
    }();
  }
});

// node_modules/@antv/g-webgpu/es/index.js
var es_exports3 = {};
__export(es_exports3, {
  Kernel: () => Kernel,
  World: () => World
});
var init_es4 = __esm({
  "node_modules/@antv/g-webgpu/es/index.js"() {
    init_Kernel();
    init_World();
  }
});

// node_modules/@antv/layout/lib/util/gpu.js
var require_gpu = __commonJS({
  "node_modules/@antv/layout/lib/util/gpu.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayToTextureData = exports.attributesToTextureData = exports.buildTextureDataWithTwoEdgeAttr = exports.buildTextureData = exports.proccessToFunc = void 0;
    var _1 = require_util2();
    var math_1 = require_math();
    var proccessToFunc3 = function(value, defaultV) {
      var func;
      if (!value) {
        func = function() {
          return defaultV || 1;
        };
      } else if ((0, _1.isNumber)(value)) {
        func = function() {
          return value;
        };
      } else {
        func = value;
      }
      return func;
    };
    exports.proccessToFunc = proccessToFunc3;
    var buildTextureData3 = function(nodes, edges) {
      var dataArray = [];
      var nodeDict = [];
      var mapIdPos = {};
      var i2 = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var n2 = nodes[i2];
        mapIdPos[n2.id] = i2;
        dataArray.push(n2.x);
        dataArray.push(n2.y);
        dataArray.push(0);
        dataArray.push(0);
        nodeDict.push([]);
      }
      for (i2 = 0; i2 < edges.length; i2++) {
        var e8 = edges[i2];
        var source = (0, math_1.getEdgeTerminal)(e8, "source");
        var target = (0, math_1.getEdgeTerminal)(e8, "target");
        if (!isNaN(mapIdPos[source]) && !isNaN(mapIdPos[target])) {
          nodeDict[mapIdPos[source]].push(mapIdPos[target]);
          nodeDict[mapIdPos[target]].push(mapIdPos[source]);
        }
      }
      var maxEdgePerVetex = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var offset = dataArray.length;
        var dests = nodeDict[i2];
        var len = dests.length;
        dataArray[i2 * 4 + 2] = offset;
        dataArray[i2 * 4 + 3] = len;
        maxEdgePerVetex = Math.max(maxEdgePerVetex, len);
        for (var j2 = 0; j2 < len; ++j2) {
          var dest = dests[j2];
          dataArray.push(+dest);
        }
      }
      while (dataArray.length % 4 !== 0) {
        dataArray.push(0);
      }
      return {
        maxEdgePerVetex,
        array: new Float32Array(dataArray)
      };
    };
    exports.buildTextureData = buildTextureData3;
    var buildTextureDataWithTwoEdgeAttr3 = function(nodes, edges, attrs1, attrs2) {
      var dataArray = [];
      var nodeDict = [];
      var mapIdPos = {};
      var i2 = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var n2 = nodes[i2];
        mapIdPos[n2.id] = i2;
        dataArray.push(n2.x);
        dataArray.push(n2.y);
        dataArray.push(0);
        dataArray.push(0);
        nodeDict.push([]);
      }
      for (i2 = 0; i2 < edges.length; i2++) {
        var e8 = edges[i2];
        var source = (0, math_1.getEdgeTerminal)(e8, "source");
        var target = (0, math_1.getEdgeTerminal)(e8, "target");
        nodeDict[mapIdPos[source]].push(mapIdPos[target]);
        nodeDict[mapIdPos[source]].push(attrs1(e8));
        nodeDict[mapIdPos[source]].push(attrs2(e8));
        nodeDict[mapIdPos[source]].push(0);
        nodeDict[mapIdPos[target]].push(mapIdPos[source]);
        nodeDict[mapIdPos[target]].push(attrs1(e8));
        nodeDict[mapIdPos[target]].push(attrs2(e8));
        nodeDict[mapIdPos[target]].push(0);
      }
      var maxEdgePerVetex = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var offset = dataArray.length;
        var dests = nodeDict[i2];
        var len = dests.length;
        dataArray[i2 * 4 + 2] = offset + 1048576 * len / 4;
        dataArray[i2 * 4 + 3] = 0;
        maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);
        for (var j2 = 0; j2 < len; ++j2) {
          var dest = dests[j2];
          dataArray.push(+dest);
        }
      }
      while (dataArray.length % 4 !== 0) {
        dataArray.push(0);
      }
      return {
        maxEdgePerVetex,
        array: new Float32Array(dataArray)
      };
    };
    exports.buildTextureDataWithTwoEdgeAttr = buildTextureDataWithTwoEdgeAttr3;
    var attributesToTextureData3 = function(attributeNames, items) {
      var dataArray = [];
      var attributeNum = attributeNames.length;
      var attributteStringMap = {};
      items.forEach(function(item) {
        attributeNames.forEach(function(name, i2) {
          if (attributteStringMap[item[name]] === void 0) {
            attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;
          }
          dataArray.push(attributteStringMap[item[name]]);
          if (i2 === attributeNum - 1) {
            while (dataArray.length % 4 !== 0) {
              dataArray.push(0);
            }
          }
        });
      });
      return {
        array: new Float32Array(dataArray),
        count: Object.keys(attributteStringMap).length
      };
    };
    exports.attributesToTextureData = attributesToTextureData3;
    var arrayToTextureData3 = function(valueArrays) {
      var dataArray = [];
      var attributeNum = valueArrays.length;
      var itemNum = valueArrays[0].length;
      var _loop_1 = function(j3) {
        valueArrays.forEach(function(valueArray, i2) {
          dataArray.push(valueArray[j3]);
          if (i2 === attributeNum - 1) {
            while (dataArray.length % 4 !== 0) {
              dataArray.push(0);
            }
          }
        });
      };
      for (var j2 = 0; j2 < itemNum; j2++) {
        _loop_1(j2);
      }
      return new Float32Array(dataArray);
    };
    exports.arrayToTextureData = arrayToTextureData3;
  }
});

// node_modules/@antv/layout/lib/layout/gpu/fruchtermanShader.js
var require_fruchtermanShader = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/fruchtermanShader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clusterBundle = exports.clusterCode = exports.fruchtermanBundle = exports.fruchtermanCode = void 0;
    exports.fruchtermanCode = "\nimport { globalInvocationID } from 'g-webgpu';\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\n@numthreads(1, 1, 1)\nclass Fruchterman {\n  @in @out\n  u_Data: vec4[];\n  @in\n  u_K: float;\n  @in\n  u_K2: float;\n  \n  @in\n  u_Center: vec2;\n  @in\n  u_Gravity: float;\n  @in\n  u_ClusterGravity: float;\n  @in\n  u_Speed: float;\n  @in\n  u_MaxDisplace: float;\n  @in\n  u_Clustering: float;\n  @in\n  u_AttributeArray: vec4[];\n  @in\n  u_ClusterCenters: vec4[];\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const xDist = currentNode[0] - nextNode[0];\n        const yDist = currentNode[1] - nextNode[1];\n        const dist = (xDist * xDist + yDist * yDist) + 0.01;\n        let param = this.u_K2 / dist;\n        \n        if (dist > 0.0) {\n          dx += param * xDist;\n          dy += param * yDist;\n          if (xDist == 0 && yDist == 0) {\n            const sign = i < j ? 1 : -1;\n            dx += param * sign;\n            dy += param * sign;\n          }\n        }\n      }\n    }\n    return [dx, dy];\n  }\n  calcGravity(currentNode: vec4, nodeAttributes: vec4): vec2 { // \n    let dx = 0, dy = 0;\n    const vx = currentNode[0] - this.u_Center[0];\n    const vy = currentNode[1] - this.u_Center[1];\n    const gf = 0.01 * this.u_K * this.u_Gravity;\n    dx = gf * vx;\n    dy = gf * vy;\n    if (this.u_Clustering == 1) {\n      const clusterIdx = int(nodeAttributes[0]);\n      const center = this.u_ClusterCenters[clusterIdx];\n      const cvx = currentNode[0] - center[0];\n      const cvy = currentNode[1] - center[1];\n      const dist = sqrt(cvx * cvx + cvy * cvy) + 0.01;\n      const parma = this.u_K * this.u_ClusterGravity / dist;\n      dx += parma * cvx;\n      dy += parma * cvy;\n    }\n    return [dx, dy];\n  }\n  calcAttractive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const arr_offset = int(floor(currentNode[2] + 0.5));\n    const length = int(floor(currentNode[3] + 0.5));\n    const node_buffer: vec4;\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + p;\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)];\n      }\n      const float_j = buf_offset == 0 ? node_buffer[0] :\n                      buf_offset == 1 ? node_buffer[1] :\n                      buf_offset == 2 ? node_buffer[2] :\n                                        node_buffer[3];\n      const nextNode = this.u_Data[int(float_j)];\n      const xDist = currentNode[0] - nextNode[0];\n      const yDist = currentNode[1] - nextNode[1];\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n      let attractiveF = dist / this.u_K;\n    \n      if (dist > 0.0) {\n        dx -= xDist * attractiveF;\n        dy -= yDist * attractiveF;\n        if (xDist == 0 && yDist == 0) {\n          const sign = i < int(float_j) ? 1 : -1;\n          dx -= sign * attractiveF;\n          dy -= sign * attractiveF;\n        }\n      }\n    }\n    return [dx, dy];\n  }\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n    let dx = 0, dy = 0;\n    if (i >= VERTEX_COUNT) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // [gravity, fx, fy, 0]\n    const nodeAttributes = this.u_AttributeArray[i];\n\n    if (nodeAttributes[1] != 0 && nodeAttributes[2] != 0) {\n      // the node is fixed\n      this.u_Data[i] = [\n        nodeAttributes[1],\n        nodeAttributes[2],\n        currentNode[2],\n        currentNode[3]\n      ];\n      return;\n    }\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    dx += repulsive[0];\n    dy += repulsive[1];\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode);\n    dx += attractive[0];\n    dy += attractive[1];\n    // gravity\n    const gravity = this.calcGravity(currentNode, nodeAttributes);\n    dx -= gravity[0];\n    dy -= gravity[1];\n    // speed\n    dx *= this.u_Speed;\n    dy *= this.u_Speed;\n\n    // move\n    const distLength = sqrt(dx * dx + dy * dy);\n    if (distLength > 0.0) {\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\n      this.u_Data[i] = [\n        currentNode[0] + dx / distLength * limitedDist,\n        currentNode[1] + dy / distLength * limitedDist,\n        currentNode[2],\n        currentNode[3]\n      ];\n    }\n  }\n}\n";
    exports.fruchtermanBundle = '{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_K;\\nuniform float u_K2;\\nuniform vec2 u_Center;\\nuniform float u_Gravity;\\nuniform float u_ClusterGravity;\\nuniform float u_Speed;\\nuniform float u_MaxDisplace;\\nuniform float u_Clustering;\\nuniform sampler2D u_AttributeArray;\\nuniform vec2 u_AttributeArraySize;\\nvec4 getDatau_AttributeArray(vec2 address2D) {\\n  return vec4(texture2D(u_AttributeArray, address2D).rgba);\\n}\\nvec4 getDatau_AttributeArray(float address1D) {\\n  return getDatau_AttributeArray(addrTranslation_1Dto2D(address1D, u_AttributeArraySize));\\n}\\nvec4 getDatau_AttributeArray(int address1D) {\\n  return getDatau_AttributeArray(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat param = u_K2 / dist;\\nif (dist > 0.0) {dx += param * xDist;\\ndy += param * yDist;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < j) ? (1.0) : (-1.0);\\ndx += param * sign;\\ndy += param * sign;}}}}\\nreturn vec2(dx, dy);}\\nvec2 calcGravity(vec4 currentNode, vec4 nodeAttributes) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfloat vx = currentNode.x - u_Center.x;\\nfloat vy = currentNode.y - u_Center.y;\\nfloat gf = (0.01 * u_K) * u_Gravity;\\ndx = gf * vx;\\ndy = gf * vy;\\nif (u_Clustering == 1.0) {int clusterIdx = int(nodeAttributes.x);\\nvec4 center = getDatau_ClusterCenters(clusterIdx);\\nfloat cvx = currentNode.x - center.x;\\nfloat cvy = currentNode.y - center.y;\\nfloat dist = sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\nfloat parma = (u_K * u_ClusterGravity) / dist;\\ndx += parma * cvx;\\ndy += parma * cvy;}\\nreturn vec2(dx, dy);}\\nvec2 calcAttractive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nint arr_offset = int(floor(currentNode.z + 0.5));\\nint length = int(floor(currentNode.w + 0.5));\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + int(p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat attractiveF = dist / u_K;\\nif (dist > 0.0) {dx -= xDist * attractiveF;\\ndy -= yDist * attractiveF;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < int(float_j)) ? (1.0) : (-1.0);\\ndx -= sign * attractiveF;\\ndy -= sign * attractiveF;}}}\\nreturn vec2(dx, dy);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nif (i >= VERTEX_COUNT) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes = getDatau_AttributeArray(i);\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w));\\nreturn ;}\\nvec2 repulsive = calcRepulsive(i, currentNode);\\ndx += repulsive.x;\\ndy += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode);\\ndx += attractive.x;\\ndy += attractive.y;\\nvec2 gravity = calcGravity(currentNode, nodeAttributes);\\ndx -= gravity.x;\\ndy -= gravity.y;\\ndx *= u_Speed;\\ndy *= u_Speed;\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\nif (distLength > 0.0) {float limitedDist = min(u_MaxDisplace * u_Speed, distLength);\\ngl_FragColor = vec4(vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_K","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_K2","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Center","type":"vec2<f32>","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Gravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterGravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Speed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_MaxDisplace","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Clustering","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AttributeArray","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}';
    exports.clusterCode = "\nimport { globalInvocationID } from 'g-webgpu';\nconst VERTEX_COUNT;\nconst CLUSTER_COUNT;\n@numthreads(1, 1, 1)\nclass CalcCenter {\n  @in\n  u_Data: vec4[];\n  @in\n  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]\n  @in @out\n  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const center = this.u_ClusterCenters[i];\n    let sumx = 0;\n    let sumy = 0;\n    let count = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      const attributes = this.u_NodeAttributes[j];\n      const clusterIdx = int(attributes[0]);\n      const vertex = this.u_Data[j];\n      if (clusterIdx == i) {\n        sumx += vertex.x;\n        sumy += vertex.y;\n        count += 1;\n      }\n    }\n    this.u_ClusterCenters[i] = [\n      sumx / count,\n      sumy / count,\n      count,\n      i\n    ];\n  }\n}\n";
    exports.clusterBundle = '{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define CLUSTER_COUNT __DefineValuePlaceholder__CLUSTER_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributes;\\nuniform vec2 u_NodeAttributesSize;\\nvec4 getDatau_NodeAttributes(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributes, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributes(float address1D) {\\n  return getDatau_NodeAttributes(addrTranslation_1Dto2D(address1D, u_NodeAttributesSize));\\n}\\nvec4 getDatau_NodeAttributes(int address1D) {\\n  return getDatau_NodeAttributes(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 center = getDatau_ClusterCenters(i);\\nfloat sumx = 0.0;\\nfloat sumy = 0.0;\\nfloat count = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 attributes = getDatau_NodeAttributes(j);\\nint clusterIdx = int(attributes.x);\\nvec4 vertex = getDatau_Data(j);\\nif (clusterIdx == i) {sumx += vertex.x;\\nsumy += vertex.y;\\ncount += 1.0;}}\\ngl_FragColor = vec4(vec4(sumx / count, sumy / count, count, i));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"CLUSTER_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributes","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_ClusterCenters","size":[1,1],"length":1},"needPingpong":true}}';
  }
});

// node_modules/@antv/layout/lib/layout/gpu/fruchterman.js
var require_fruchterman2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/fruchterman.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e8) {
            reject(e8);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e8) {
            reject(e8);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y4, t2, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f2 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done)
              return t2;
            if (y4 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e8) {
            op = [6, e8];
            y4 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FruchtermanGPULayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var g_webgpu_1 = (init_es4(), __toCommonJS(es_exports3));
    var gpu_1 = require_gpu();
    var fruchtermanShader_1 = require_fruchtermanShader();
    var constants_1 = require_constants();
    var FruchtermanGPULayout2 = (
      /** @class */
      function(_super) {
        __extends15(FruchtermanGPULayout3, _super);
        function FruchtermanGPULayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.gravity = 10;
          _this.speed = 1;
          _this.clustering = false;
          _this.clusterField = "cluster";
          _this.clusterGravity = 10;
          _this.workerEnabled = false;
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.updateCfg(options);
          return _this;
        }
        FruchtermanGPULayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 1e3,
            gravity: 10,
            speed: 1,
            clustering: false,
            clusterGravity: 10
          };
        };
        FruchtermanGPULayout3.prototype.execute = function() {
          return __awaiter2(this, void 0, void 0, function() {
            var self2, nodes, center, nodeMap, nodeIdxMap;
            var _this = this;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  if (!nodes || nodes.length === 0) {
                    if (self2.onLayoutEnd)
                      self2.onLayoutEnd();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!self2.width && typeof window !== "undefined") {
                    self2.width = window.innerWidth;
                  }
                  if (!self2.height && typeof window !== "undefined") {
                    self2.height = window.innerHeight;
                  }
                  if (!self2.center) {
                    self2.center = [self2.width / 2, self2.height / 2];
                  }
                  center = self2.center;
                  if (nodes.length === 1) {
                    nodes[0].x = center[0];
                    nodes[0].y = center[1];
                    if (self2.onLayoutEnd)
                      self2.onLayoutEnd();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  nodeMap = {};
                  nodeIdxMap = {};
                  nodes.forEach(function(node, i2) {
                    if (!(0, util_1.isNumber)(node.x))
                      node.x = Math.random() * _this.width;
                    if (!(0, util_1.isNumber)(node.y))
                      node.y = Math.random() * _this.height;
                    nodeMap[node.id] = node;
                    nodeIdxMap[node.id] = i2;
                  });
                  self2.nodeMap = nodeMap;
                  self2.nodeIdxMap = nodeIdxMap;
                  return [4, self2.run()];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FruchtermanGPULayout3.prototype.executeWithWorker = function(canvas, ctx) {
          return __awaiter2(this, void 0, void 0, function() {
            var self2, nodes, center, nodeMap, nodeIdxMap;
            var _this = this;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  center = self2.center;
                  if (!nodes || nodes.length === 0) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (nodes.length === 1) {
                    nodes[0].x = center[0];
                    nodes[0].y = center[1];
                    return [
                      2
                      /*return*/
                    ];
                  }
                  nodeMap = {};
                  nodeIdxMap = {};
                  nodes.forEach(function(node, i2) {
                    if (!(0, util_1.isNumber)(node.x))
                      node.x = Math.random() * _this.width;
                    if (!(0, util_1.isNumber)(node.y))
                      node.y = Math.random() * _this.height;
                    nodeMap[node.id] = node;
                    nodeIdxMap[node.id] = i2;
                  });
                  self2.nodeMap = nodeMap;
                  self2.nodeIdxMap = nodeIdxMap;
                  return [4, self2.run(canvas, ctx)];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FruchtermanGPULayout3.prototype.run = function(canvas, ctx) {
          return __awaiter2(this, void 0, void 0, function() {
            var self2, nodes, edges, maxIteration, center, area, maxDisplace, k2, k3, speed, clustering, _a2, attributeArray, clusterCount, numParticles, _b, maxEdgePerVetex, nodesEdgesArray, workerEnabled, world, onLayoutEnd, clusterCenters, i2, kernelFruchterman, kernelCluster, execute;
            var _this = this;
            return __generator2(this, function(_c) {
              switch (_c.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  edges = self2.edges;
                  maxIteration = self2.maxIteration;
                  center = self2.center;
                  area = self2.height * self2.width;
                  maxDisplace = Math.sqrt(area) / 10;
                  k2 = area / (nodes.length + 1);
                  k3 = Math.sqrt(k2);
                  speed = self2.speed;
                  clustering = self2.clustering;
                  _a2 = (0, gpu_1.attributesToTextureData)([self2.clusterField], nodes), attributeArray = _a2.array, clusterCount = _a2.count;
                  nodes.forEach(function(node, i3) {
                    var fx = 0;
                    var fy = 0;
                    if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
                      fx = node.fx || 1e-3;
                      fy = node.fy || 1e-3;
                    }
                    attributeArray[4 * i3 + 1] = fx;
                    attributeArray[4 * i3 + 2] = fy;
                  });
                  numParticles = nodes.length;
                  _b = (0, gpu_1.buildTextureData)(nodes, edges), maxEdgePerVetex = _b.maxEdgePerVetex, nodesEdgesArray = _b.array;
                  workerEnabled = self2.workerEnabled;
                  if (workerEnabled) {
                    world = g_webgpu_1.World.create({
                      canvas,
                      engineOptions: {
                        supportCompute: true
                      }
                    });
                  } else {
                    world = g_webgpu_1.World.create({
                      engineOptions: {
                        supportCompute: true
                      }
                    });
                  }
                  onLayoutEnd = self2.onLayoutEnd;
                  clusterCenters = [];
                  for (i2 = 0; i2 < clusterCount; i2++) {
                    clusterCenters.push(0, 0, 0, 0);
                  }
                  kernelFruchterman = world.createKernel(fruchtermanShader_1.fruchtermanBundle).setDispatch([numParticles, 1, 1]).setBinding({
                    u_Data: nodesEdgesArray,
                    u_K: k3,
                    u_K2: k2,
                    u_Gravity: self2.gravity,
                    u_ClusterGravity: self2.clusterGravity || self2.gravity || 1,
                    u_Speed: speed,
                    u_MaxDisplace: maxDisplace,
                    u_Clustering: clustering ? 1 : 0,
                    u_Center: center,
                    u_AttributeArray: attributeArray,
                    u_ClusterCenters: clusterCenters,
                    MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
                    VERTEX_COUNT: numParticles
                  });
                  if (clustering) {
                    kernelCluster = world.createKernel(fruchtermanShader_1.clusterBundle).setDispatch([clusterCount, 1, 1]).setBinding({
                      u_Data: nodesEdgesArray,
                      u_NodeAttributes: attributeArray,
                      u_ClusterCenters: clusterCenters,
                      VERTEX_COUNT: numParticles,
                      CLUSTER_COUNT: clusterCount
                    });
                  }
                  execute = function() {
                    return __awaiter2(_this, void 0, void 0, function() {
                      var i3, finalParticleData;
                      return __generator2(this, function(_a3) {
                        switch (_a3.label) {
                          case 0:
                            i3 = 0;
                            _a3.label = 1;
                          case 1:
                            if (!(i3 < maxIteration))
                              return [3, 6];
                            return [4, kernelFruchterman.execute()];
                          case 2:
                            _a3.sent();
                            if (!clustering)
                              return [3, 4];
                            kernelCluster.setBinding({
                              u_Data: kernelFruchterman
                            });
                            return [4, kernelCluster.execute()];
                          case 3:
                            _a3.sent();
                            kernelFruchterman.setBinding({
                              u_ClusterCenters: kernelCluster
                            });
                            _a3.label = 4;
                          case 4:
                            kernelFruchterman.setBinding({
                              u_MaxDisplace: maxDisplace *= 0.99
                            });
                            _a3.label = 5;
                          case 5:
                            i3++;
                            return [3, 1];
                          case 6:
                            return [4, kernelFruchterman.getOutput()];
                          case 7:
                            finalParticleData = _a3.sent();
                            if (canvas) {
                              ctx.postMessage({
                                type: constants_1.LAYOUT_MESSAGE.GPUEND,
                                vertexEdgeData: finalParticleData
                                // edgeIndexBufferData,
                              });
                            } else {
                              nodes.forEach(function(node, i4) {
                                var x4 = finalParticleData[4 * i4];
                                var y4 = finalParticleData[4 * i4 + 1];
                                node.x = x4;
                                node.y = y4;
                              });
                            }
                            if (onLayoutEnd)
                              onLayoutEnd();
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  };
                  return [4, execute()];
                case 1:
                  _c.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FruchtermanGPULayout3.prototype.getType = function() {
          return "fruchterman-gpu";
        };
        return FruchtermanGPULayout3;
      }(base_1.Base)
    );
    exports.FruchtermanGPULayout = FruchtermanGPULayout2;
  }
});

// node_modules/@antv/layout/lib/layout/gpu/gForceShader.js
var require_gForceShader = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/gForceShader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aveMovementBundle = exports.aveMovementCode = exports.gForceBundle = exports.gForceCode = void 0;
    exports.gForceCode = "\nimport { globalInvocationID } from 'g-webgpu';\n\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\nconst SHIFT_20 = 1048576;\n\n@numthreads(1, 1, 1)\nclass GGForce {\n  @in @out\n  u_Data: vec4[];\n\n  @in\n  u_damping: float;\n  \n  @in\n  u_maxSpeed: float;\n\n  @in\n  u_minMovement: float;\n\n  @in\n  u_AveMovement: vec4[];\n\n  @in\n  u_coulombDisScale: float;\n\n  @in\n  u_factor: float;\n\n  @in\n  u_NodeAttributeArray1: vec4[];\n\n  @in\n  u_NodeAttributeArray2: vec4[];\n\n  @in\n  u_interval: float;\n\n  unpack_float(packedValue: float): ivec2 {\n    const packedIntValue = int(packedValue);\n    const v0 = packedIntValue / SHIFT_20;\n    return [v0, packedIntValue - v0 * SHIFT_20];\n  }\n\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let ax = 0, ay = 0;\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const vx = currentNode[0] - nextNode[0];\n        const vy = currentNode[1] - nextNode[1];\n        const dist = sqrt(vx * vx + vy * vy) + 0.01;\n        const n_dist = (dist + 0.1) * this.u_coulombDisScale;\n        const direx = vx / dist;\n        const direy = vy / dist;\n        const attributesi = this.u_NodeAttributeArray1[i];\n        const attributesj = this.u_NodeAttributeArray1[j];\n        const massi = attributesi[0];\n        const nodeStrengthi = attributesi[2];\n        const nodeStrengthj = attributesj[2];\n        const nodeStrength = (nodeStrengthi + nodeStrengthj) / 2;\n        // const param = nodeStrength * this.u_factor / (n_dist * n_dist * massi);\n        const param = nodeStrength * this.u_factor / (n_dist * n_dist);\n        ax += direx * param;\n        ay += direy * param;\n      }\n    }\n    return [ax, ay];\n  }\n\n  calcGravity(i: int, currentNode: vec4, attributes2: vec4): vec2 {\n    // note: attributes2 = [centerX, centerY, gravity, 0]\n\n    const vx = currentNode[0] - attributes2[0];\n    const vy = currentNode[1] - attributes2[1];\n    \n    const ax = vx * attributes2[2];\n    const ay = vy * attributes2[2];\n    \n    return [ax, ay];\n  }\n\n  calcAttractive(i: int, currentNode: vec4, attributes1: vec4): vec2 {\n    // note: attributes1 = [mass, degree, nodeSterngth, 0]\n\n    const mass = attributes1[0];\n    let ax = 0, ay = 0;\n    // const arr_offset = int(floor(currentNode[2] + 0.5));\n    // const length = int(floor(currentNode[3] + 0.5));\n\n    const compressed = this.unpack_float(currentNode[2]);\n    const length = compressed[0];\n    const arr_offset = compressed[1];\n\n    const node_buffer: vec4;\n    for (let p: int = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + 4 * p; // i 节点的第 p 条边开始的小格子位置\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)]; // 大格子，大格子位置=小个子位置 / 4，\n      }\n\n      let float_j: float = node_buffer[0];\n\n      const nextNode = this.u_Data[int(float_j)];\n      const vx = nextNode[0] - currentNode[0];\n      const vy = nextNode[1] - currentNode[1];\n      const dist = sqrt(vx * vx + vy * vy) + 0.01;\n      const direx = vx / dist;\n      const direy = vy / dist;\n      const edgeLength = node_buffer[1];\n      const edgeStrength = node_buffer[2];\n      const diff: float = edgeLength - dist;//edgeLength\n      // const param = diff * this.u_stiffness / mass; //\n      const param = diff * edgeStrength / mass; // \n      ax -= direx * param;\n      ay -= direy * param;\n    }\n    return [ax, ay];\n  }\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n    const movement = u_AveMovement[0];\n    let ax = 0, ay = 0;\n\n    if (i >= VERTEX_COUNT || movement.x < u_minMovement) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // 每个节点属性占两个数组中各一格\n    // [mass, degree, nodeStrength, fx]\n    const nodeAttributes1 = this.u_NodeAttributeArray1[i];\n    // [centerX, centerY, centerGravity, fy]\n    const nodeAttributes2 = this.u_NodeAttributeArray2[i];\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    ax += repulsive[0];\n    ay += repulsive[1];\n\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode, nodeAttributes1);\n    ax += attractive[0];\n    ay += attractive[1];\n\n    // gravity\n    const gravity = this.calcGravity(i, currentNode, nodeAttributes2);\n    ax -= gravity[0];\n    ay -= gravity[1];\n\n    // speed\n    const param = this.u_interval * this.u_damping;\n    let vx = ax * param;\n    let vy = ay * param;\n    const vlength = sqrt(vx * vx + vy * vy) + 0.0001;\n    if (vlength > this.u_maxSpeed) {\n      const param2 = this.u_maxSpeed / vlength;\n      vx = param2 * vx;\n      vy = param2 * vy;\n    }\n\n    // move\n    if (nodeAttributes1[3] != 0 && nodeAttributes2[3] != 0) {\n      this.u_Data[i] = [\n        nodeAttributes1[3],\n        nodeAttributes2[3],\n        currentNode[2],\n        0\n      ];\n    } else {\n      const distx = vx * this.u_interval;\n      const disty = vy * this.u_interval;\n      const distLength = sqrt(distx * distx + disty * disty);\n      this.u_Data[i] = [\n        currentNode[0] + distx,\n        currentNode[1] + disty,\n        currentNode[2],\n        distLength\n      ];\n    }\n    \n    // the avarage move distance\n    // need to share memory\n    \n  }\n}\n";
    exports.gForceBundle = '{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define SHIFT_20 1048576.0\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_damping;\\nuniform float u_maxSpeed;\\nuniform float u_minMovement;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nuniform float u_coulombDisScale;\\nuniform float u_factor;\\nuniform sampler2D u_NodeAttributeArray1;\\nuniform vec2 u_NodeAttributeArray1Size;\\nvec4 getDatau_NodeAttributeArray1(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray1, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray1(float address1D) {\\n  return getDatau_NodeAttributeArray1(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray1Size));\\n}\\nvec4 getDatau_NodeAttributeArray1(int address1D) {\\n  return getDatau_NodeAttributeArray1(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributeArray2;\\nuniform vec2 u_NodeAttributeArray2Size;\\nvec4 getDatau_NodeAttributeArray2(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray2, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray2(float address1D) {\\n  return getDatau_NodeAttributeArray2(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray2Size));\\n}\\nvec4 getDatau_NodeAttributeArray2(int address1D) {\\n  return getDatau_NodeAttributeArray2(float(address1D));\\n}\\nuniform float u_interval;\\nivec2 unpack_float(float packedValue) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint packedIntValue = int(packedValue);\\nint v0 = packedIntValue / int(SHIFT_20);\\nreturn ivec2(v0, packedIntValue - (v0 * int(SHIFT_20)));}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat vx = currentNode.x - nextNode.x;\\nfloat vy = currentNode.y - nextNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat n_dist = (dist + 0.1) * u_coulombDisScale;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nvec4 attributesi = getDatau_NodeAttributeArray1(i);\\nvec4 attributesj = getDatau_NodeAttributeArray1(j);\\nfloat massi = attributesi.x;\\nfloat nodeStrengthi = attributesi.z;\\nfloat nodeStrengthj = attributesj.z;\\nfloat nodeStrength = (nodeStrengthi + nodeStrengthj) / 2.0;\\nfloat param = (nodeStrength * u_factor) / (n_dist * n_dist);\\nax += direx * param;\\nay += direy * param;}}\\nreturn vec2(ax, ay);}\\nvec2 calcGravity(int i, vec4 currentNode, vec4 attributes2) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat vx = currentNode.x - attributes2.x;\\nfloat vy = currentNode.y - attributes2.y;\\nfloat ax = vx * attributes2.z;\\nfloat ay = vy * attributes2.z;\\nreturn vec2(ax, ay);}\\nvec2 calcAttractive(int i, vec4 currentNode, vec4 attributes1) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat mass = attributes1.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nivec2 compressed = unpack_float(currentNode.z);\\nint length = compressed.x;\\nint arr_offset = compressed.y;\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + (4 * p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = node_buffer.x;\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat vx = nextNode.x - currentNode.x;\\nfloat vy = nextNode.y - currentNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nfloat edgeLength = node_buffer.y;\\nfloat edgeStrength = node_buffer.z;\\nfloat diff = edgeLength - dist;\\nfloat param = (diff * edgeStrength) / mass;\\nax -= direx * param;\\nay -= direy * param;}\\nreturn vec2(ax, ay);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nvec4 movement = getDatau_AveMovement(0.0);\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nif ((i >= VERTEX_COUNT) || (movement.x < u_minMovement)) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes1 = getDatau_NodeAttributeArray1(i);\\nvec4 nodeAttributes2 = getDatau_NodeAttributeArray2(i);\\nvec2 repulsive = calcRepulsive(i, currentNode);\\nax += repulsive.x;\\nay += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode, nodeAttributes1);\\nax += attractive.x;\\nay += attractive.y;\\nvec2 gravity = calcGravity(i, currentNode, nodeAttributes2);\\nax -= gravity.x;\\nay -= gravity.y;\\nfloat param = u_interval * u_damping;\\nfloat vx = ax * param;\\nfloat vy = ay * param;\\nfloat vlength = sqrt((vx * vx) + (vy * vy)) + 0.0001;\\nif (vlength > u_maxSpeed) {float param2 = u_maxSpeed / vlength;\\nvx = param2 * vx;\\nvy = param2 * vy;}\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0));}else {float distx = vx * u_interval;\\nfloat disty = vy * u_interval;\\nfloat distLength = sqrt((distx * distx) + (disty * disty));\\ngl_FragColor = vec4(vec4(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"SHIFT_20","type":"Float","value":1048576,"runtime":false}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_damping","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_maxSpeed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_minMovement","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_coulombDisScale","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_factor","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray1","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray2","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_interval","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}';
    exports.aveMovementCode = "\nconst VERTEX_COUNT;\n@numthreads(1, 1, 1)\nclass CalcAveMovement {\n  @in\n  u_Data: vec4[];\n  @in\n  u_iter: float;\n  @in @out\n  u_AveMovement: vec4[];\n  @main\n  compute() {\n    let movement = 0;\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\n      const vertex = this.u_Data[j];\n      movement += vertex[3];\n    }\n    movement = movement / float(VERTEX_COUNT);\n    this.u_AveMovement[0] = [movement, 0, 0, 0];\n  }\n}\n";
    exports.aveMovementBundle = '{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_iter;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat movement = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 vertex = getDatau_Data(j);\\nmovement += vertex.w;}\\nmovement = movement / float(VERTEX_COUNT);\\ngl_FragColor = vec4(vec4(movement, 0.0, 0.0, 0.0));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_iter","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_AveMovement","size":[1,1],"length":1},"needPingpong":true}}';
  }
});

// node_modules/@antv/layout/lib/layout/gpu/gForce.js
var require_gForce2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/gForce.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e8) {
            reject(e8);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e8) {
            reject(e8);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y4, t2, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f2 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done)
              return t2;
            if (y4 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y4 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e8) {
            op = [6, e8];
            y4 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GForceGPULayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var g_webgpu_1 = (init_es4(), __toCommonJS(es_exports3));
    var gpu_1 = require_gpu();
    var math_1 = require_math();
    var gForceShader_1 = require_gForceShader();
    var constants_1 = require_constants();
    var GForceGPULayout2 = (
      /** @class */
      function(_super) {
        __extends15(GForceGPULayout3, _super);
        function GForceGPULayout3(options) {
          var _this = _super.call(this) || this;
          _this.maxIteration = 1e3;
          _this.edgeStrength = 200;
          _this.nodeStrength = 1e3;
          _this.coulombDisScale = 5e-3;
          _this.damping = 0.9;
          _this.maxSpeed = 1e3;
          _this.minMovement = 0.5;
          _this.interval = 0.02;
          _this.factor = 1;
          _this.linkDistance = 1;
          _this.gravity = 10;
          _this.workerEnabled = false;
          _this.nodes = [];
          _this.edges = [];
          _this.width = 300;
          _this.height = 300;
          _this.nodeMap = {};
          _this.nodeIdxMap = {};
          _this.updateCfg(options);
          return _this;
        }
        GForceGPULayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 2e3,
            gravity: 10,
            clustering: false,
            clusterGravity: 10
          };
        };
        GForceGPULayout3.prototype.execute = function() {
          return __awaiter2(this, void 0, void 0, function() {
            var self2, nodes, center, nodeMap, nodeIdxMap;
            return __generator2(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  if (!nodes || nodes.length === 0) {
                    if (self2.onLayoutEnd)
                      self2.onLayoutEnd();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!self2.width && typeof window !== "undefined") {
                    self2.width = window.innerWidth;
                  }
                  if (!self2.height && typeof window !== "undefined") {
                    self2.height = window.innerHeight;
                  }
                  if (!self2.center) {
                    self2.center = [self2.width / 2, self2.height / 2];
                  }
                  center = self2.center;
                  if (nodes.length === 1) {
                    nodes[0].x = center[0];
                    nodes[0].y = center[1];
                    if (self2.onLayoutEnd)
                      self2.onLayoutEnd();
                    return [
                      2
                      /*return*/
                    ];
                  }
                  nodeMap = {};
                  nodeIdxMap = {};
                  nodes.forEach(function(node, i2) {
                    if (!(0, util_1.isNumber)(node.x))
                      node.x = Math.random() * self2.width;
                    if (!(0, util_1.isNumber)(node.y))
                      node.y = Math.random() * self2.height;
                    nodeMap[node.id] = node;
                    nodeIdxMap[node.id] = i2;
                  });
                  self2.nodeMap = nodeMap;
                  self2.nodeIdxMap = nodeIdxMap;
                  self2.nodeStrength = (0, gpu_1.proccessToFunc)(self2.nodeStrength, 1);
                  self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength, 1);
                  return [4, self2.run()];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        GForceGPULayout3.prototype.executeWithWorker = function(canvas, ctx) {
          var self2 = this;
          var nodes = self2.nodes;
          var center = self2.center;
          if (!nodes || nodes.length === 0) {
            return;
          }
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            return;
          }
          var nodeMap = {};
          var nodeIdxMap = {};
          nodes.forEach(function(node, i2) {
            if (!(0, util_1.isNumber)(node.x))
              node.x = Math.random() * self2.width;
            if (!(0, util_1.isNumber)(node.y))
              node.y = Math.random() * self2.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i2;
          });
          self2.nodeMap = nodeMap;
          self2.nodeIdxMap = nodeIdxMap;
          self2.nodeStrength = (0, gpu_1.proccessToFunc)(self2.nodeStrength, 1);
          self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength, 1);
          self2.run(canvas, ctx);
        };
        GForceGPULayout3.prototype.run = function(canvas, ctx) {
          return __awaiter2(this, void 0, void 0, function() {
            var self2, nodes, edges, maxIteration, numParticles, _a2, maxEdgePerVetex, nodesEdgesArray, masses, nodeStrengths, centerXs, centerYs, centerGravities, fxs, fys, gravity, center, nodeAttributeArray1, nodeAttributeArray2, workerEnabled, world, onLayoutEnd, initPreviousData, i2, kernelGForce, kernelAveMovement, execute;
            var _this = this;
            return __generator2(this, function(_b) {
              switch (_b.label) {
                case 0:
                  self2 = this;
                  nodes = self2.nodes;
                  edges = self2.edges;
                  maxIteration = self2.maxIteration;
                  if (!self2.width && typeof window !== "undefined") {
                    self2.width = window.innerWidth;
                  }
                  if (!self2.height && typeof window !== "undefined") {
                    self2.height = window.innerHeight;
                  }
                  numParticles = nodes.length;
                  self2.linkDistance = (0, gpu_1.proccessToFunc)(self2.linkDistance);
                  self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength);
                  _a2 = (0, gpu_1.buildTextureDataWithTwoEdgeAttr)(nodes, edges, self2.linkDistance, self2.edgeStrength), maxEdgePerVetex = _a2.maxEdgePerVetex, nodesEdgesArray = _a2.array;
                  self2.degrees = (0, math_1.getDegree)(nodes.length, self2.nodeIdxMap, edges).map(function(degree3) {
                    return degree3.all;
                  });
                  masses = [];
                  nodeStrengths = [];
                  centerXs = [];
                  centerYs = [];
                  centerGravities = [];
                  fxs = [];
                  fys = [];
                  if (!self2.getMass) {
                    self2.getMass = function(d2) {
                      return self2.degrees[self2.nodeIdxMap[d2.id]] || 1;
                    };
                  }
                  gravity = self2.gravity;
                  center = self2.center;
                  nodes.forEach(function(node, i3) {
                    masses.push(self2.getMass(node));
                    nodeStrengths.push(self2.nodeStrength(node));
                    if (!self2.degrees[i3])
                      self2.degrees[i3] = 0;
                    var nodeGravity = [center[0], center[1], gravity];
                    if (self2.getCenter) {
                      var customCenter = self2.getCenter(node, self2.degrees[i3]);
                      if (customCenter && (0, util_1.isNumber)(customCenter[0]) && (0, util_1.isNumber)(customCenter[1]) && (0, util_1.isNumber)(customCenter[2])) {
                        nodeGravity = customCenter;
                      }
                    }
                    centerXs.push(nodeGravity[0]);
                    centerYs.push(nodeGravity[1]);
                    centerGravities.push(nodeGravity[2]);
                    if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
                      fxs.push(node.fx || 1e-3);
                      fys.push(node.fy || 1e-3);
                    } else {
                      fxs.push(0);
                      fys.push(0);
                    }
                  });
                  nodeAttributeArray1 = (0, gpu_1.arrayToTextureData)([
                    masses,
                    self2.degrees,
                    nodeStrengths,
                    fxs
                  ]);
                  nodeAttributeArray2 = (0, gpu_1.arrayToTextureData)([
                    centerXs,
                    centerYs,
                    centerGravities,
                    fys
                  ]);
                  workerEnabled = self2.workerEnabled;
                  if (workerEnabled) {
                    world = g_webgpu_1.World.create({
                      canvas,
                      engineOptions: {
                        supportCompute: true
                      }
                    });
                  } else {
                    world = g_webgpu_1.World.create({
                      engineOptions: {
                        supportCompute: true
                      }
                    });
                  }
                  onLayoutEnd = self2.onLayoutEnd;
                  initPreviousData = [];
                  nodesEdgesArray.forEach(function(value) {
                    initPreviousData.push(value);
                  });
                  for (i2 = 0; i2 < 4; i2++) {
                    initPreviousData.push(0);
                  }
                  kernelGForce = world.createKernel(gForceShader_1.gForceBundle).setDispatch([numParticles, 1, 1]).setBinding({
                    u_Data: nodesEdgesArray,
                    u_damping: self2.damping,
                    u_maxSpeed: self2.maxSpeed,
                    u_minMovement: self2.minMovement,
                    u_coulombDisScale: self2.coulombDisScale,
                    u_factor: self2.factor,
                    u_NodeAttributeArray1: nodeAttributeArray1,
                    u_NodeAttributeArray2: nodeAttributeArray2,
                    MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
                    VERTEX_COUNT: numParticles,
                    u_AveMovement: initPreviousData,
                    u_interval: self2.interval
                    // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新
                  });
                  kernelAveMovement = world.createKernel(gForceShader_1.aveMovementBundle).setDispatch([1, 1, 1]).setBinding({
                    u_Data: nodesEdgesArray,
                    VERTEX_COUNT: numParticles,
                    u_AveMovement: [0, 0, 0, 0]
                  });
                  execute = function() {
                    return __awaiter2(_this, void 0, void 0, function() {
                      var i3, stepInterval, finalParticleData;
                      return __generator2(this, function(_a3) {
                        switch (_a3.label) {
                          case 0:
                            i3 = 0;
                            _a3.label = 1;
                          case 1:
                            if (!(i3 < maxIteration))
                              return [3, 5];
                            return [4, kernelGForce.execute()];
                          case 2:
                            _a3.sent();
                            kernelAveMovement.setBinding({
                              u_Data: kernelGForce
                            });
                            return [4, kernelAveMovement.execute()];
                          case 3:
                            _a3.sent();
                            stepInterval = Math.max(0.02, self2.interval - i3 * 2e-3);
                            kernelGForce.setBinding({
                              u_interval: stepInterval,
                              u_AveMovement: kernelAveMovement
                            });
                            _a3.label = 4;
                          case 4:
                            i3++;
                            return [3, 1];
                          case 5:
                            return [4, kernelGForce.getOutput()];
                          case 6:
                            finalParticleData = _a3.sent();
                            if (canvas) {
                              ctx.postMessage({
                                type: constants_1.LAYOUT_MESSAGE.GPUEND,
                                vertexEdgeData: finalParticleData
                                // edgeIndexBufferData,
                              });
                            } else {
                              nodes.forEach(function(node, i4) {
                                var x4 = finalParticleData[4 * i4];
                                var y4 = finalParticleData[4 * i4 + 1];
                                node.x = x4;
                                node.y = y4;
                              });
                            }
                            if (onLayoutEnd)
                              onLayoutEnd();
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  };
                  return [4, execute()];
                case 1:
                  _b.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        GForceGPULayout3.prototype.getType = function() {
          return "gForce-gpu";
        };
        return GForceGPULayout3;
      }(base_1.Base)
    );
    exports.GForceGPULayout = GForceGPULayout2;
  }
});

// node_modules/@antv/layout/lib/layout/comboForce.js
var require_comboForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/comboForce.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboForceLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var ComboForceLayout2 = (
      /** @class */
      function(_super) {
        __extends15(ComboForceLayout3, _super);
        function ComboForceLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.maxIteration = 100;
          _this.gravity = 10;
          _this.comboGravity = 10;
          _this.linkDistance = 10;
          _this.alpha = 1;
          _this.alphaMin = 1e-3;
          _this.alphaDecay = 1 - Math.pow(_this.alphaMin, 1 / 300);
          _this.alphaTarget = 0;
          _this.velocityDecay = 0.6;
          _this.edgeStrength = 0.6;
          _this.nodeStrength = 30;
          _this.preventOverlap = false;
          _this.preventNodeOverlap = false;
          _this.preventComboOverlap = false;
          _this.collideStrength = void 0;
          _this.nodeCollideStrength = 0.5;
          _this.comboCollideStrength = 0.5;
          _this.comboSpacing = 20;
          _this.comboPadding = 10;
          _this.optimizeRangeFactor = 1;
          _this.onTick = function() {
          };
          _this.onLayoutEnd = function() {
          };
          _this.depthAttractiveForceScale = 1;
          _this.depthRepulsiveForceScale = 2;
          _this.nodes = [];
          _this.edges = [];
          _this.combos = [];
          _this.comboTrees = [];
          _this.width = 300;
          _this.height = 300;
          _this.bias = [];
          _this.nodeMap = {};
          _this.oriComboMap = {};
          _this.indexMap = {};
          _this.comboMap = {};
          _this.previousLayouted = false;
          _this.updateCfg(options);
          return _this;
        }
        ComboForceLayout3.prototype.getDefaultCfg = function() {
          return {
            maxIteration: 100,
            center: [0, 0],
            gravity: 10,
            speed: 1,
            comboGravity: 30,
            preventOverlap: false,
            preventComboOverlap: true,
            preventNodeOverlap: true,
            nodeSpacing: void 0,
            collideStrength: void 0,
            nodeCollideStrength: 0.5,
            comboCollideStrength: 0.5,
            comboSpacing: 20,
            comboPadding: 10,
            edgeStrength: 0.6,
            nodeStrength: 30,
            linkDistance: 10
          };
        };
        ComboForceLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var center = self2.center;
          self2.comboTree = {
            id: "comboTreeRoot",
            depth: -1,
            children: self2.comboTrees
          };
          if (!nodes || nodes.length === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          self2.initVals();
          self2.run();
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
        };
        ComboForceLayout3.prototype.run = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var maxIteration = self2.previousLayouted ? self2.maxIteration / 5 : self2.maxIteration;
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          var center = self2.center;
          var velocityDecay = self2.velocityDecay;
          var comboMap = self2.comboMap;
          if (!self2.previousLayouted)
            self2.initPos(comboMap);
          var _loop_1 = function(i3) {
            var displacements = [];
            nodes.forEach(function(_2, j2) {
              displacements[j2] = { x: 0, y: 0 };
            });
            self2.applyCalculate(displacements);
            self2.applyComboCenterForce(displacements);
            nodes.forEach(function(n2, j2) {
              if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
                return;
              n2.x += displacements[j2].x * velocityDecay;
              n2.y += displacements[j2].y * velocityDecay;
            });
            self2.alpha += (self2.alphaTarget - self2.alpha) * self2.alphaDecay;
            self2.onTick();
          };
          for (var i2 = 0; i2 < maxIteration; i2++) {
            _loop_1(i2);
          }
          var meanCenter = [0, 0];
          nodes.forEach(function(n2) {
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            meanCenter[0] += n2.x;
            meanCenter[1] += n2.y;
          });
          meanCenter[0] /= nodes.length;
          meanCenter[1] /= nodes.length;
          var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];
          nodes.forEach(function(n2, j2) {
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            n2.x += centerOffset[0];
            n2.y += centerOffset[1];
          });
          self2.combos.forEach(function(combo) {
            var mapped = comboMap[combo.id];
            if (mapped && mapped.empty) {
              combo.x = mapped.cx || combo.x;
              combo.y = mapped.cy || combo.y;
            }
          });
          self2.previousLayouted = true;
        };
        ComboForceLayout3.prototype.initVals = function() {
          var self2 = this;
          var edges = self2.edges;
          var nodes = self2.nodes;
          var combos = self2.combos;
          var count = {};
          var nodeMap = {};
          var indexMap = {};
          nodes.forEach(function(node, i3) {
            nodeMap[node.id] = node;
            indexMap[node.id] = i3;
          });
          self2.nodeMap = nodeMap;
          self2.indexMap = indexMap;
          var oriComboMap = {};
          combos.forEach(function(combo) {
            oriComboMap[combo.id] = combo;
          });
          self2.oriComboMap = oriComboMap;
          self2.comboMap = self2.getComboMap();
          var preventOverlap = self2.preventOverlap;
          self2.preventComboOverlap = self2.preventComboOverlap || preventOverlap;
          self2.preventNodeOverlap = self2.preventNodeOverlap || preventOverlap;
          var collideStrength = self2.collideStrength;
          if (collideStrength) {
            self2.comboCollideStrength = collideStrength;
            self2.nodeCollideStrength = collideStrength;
          }
          self2.comboCollideStrength = self2.comboCollideStrength ? self2.comboCollideStrength : 0;
          self2.nodeCollideStrength = self2.nodeCollideStrength ? self2.nodeCollideStrength : 0;
          for (var i2 = 0; i2 < edges.length; ++i2) {
            var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
            var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
            if (count[source])
              count[source]++;
            else
              count[source] = 1;
            if (count[target])
              count[target]++;
            else
              count[target] = 1;
          }
          var bias = [];
          for (var i2 = 0; i2 < edges.length; ++i2) {
            var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
            var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
            bias[i2] = count[source] / (count[source] + count[target]);
          }
          this.bias = bias;
          var nodeSize = self2.nodeSize;
          var nodeSpacing = self2.nodeSpacing;
          var nodeSizeFunc;
          var nodeSpacingFunc;
          if ((0, util_1.isNumber)(nodeSpacing)) {
            nodeSpacingFunc = function() {
              return nodeSpacing;
            };
          } else if ((0, util_1.isFunction)(nodeSpacing)) {
            nodeSpacingFunc = nodeSpacing;
          } else {
            nodeSpacingFunc = function() {
              return 0;
            };
          }
          this.nodeSpacing = nodeSpacingFunc;
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                  return res / 2;
                }
                if ((0, util_1.isObject)(d2.size)) {
                  var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                  return res / 2;
                }
                return d2.size / 2;
              }
              return 10;
            };
          } else if ((0, util_1.isFunction)(nodeSize)) {
            nodeSizeFunc = function(d2) {
              return nodeSize(d2);
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            var radius_1 = larger / 2;
            nodeSizeFunc = function(d2) {
              return radius_1;
            };
          } else {
            var radius_2 = nodeSize / 2;
            nodeSizeFunc = function(d2) {
              return radius_2;
            };
          }
          this.nodeSize = nodeSizeFunc;
          var comboSpacing = self2.comboSpacing;
          var comboSpacingFunc;
          if ((0, util_1.isNumber)(comboSpacing)) {
            comboSpacingFunc = function() {
              return comboSpacing;
            };
          } else if ((0, util_1.isFunction)(comboSpacing)) {
            comboSpacingFunc = comboSpacing;
          } else {
            comboSpacingFunc = function() {
              return 0;
            };
          }
          this.comboSpacing = comboSpacingFunc;
          var comboPadding = self2.comboPadding;
          var comboPaddingFunc;
          if ((0, util_1.isNumber)(comboPadding)) {
            comboPaddingFunc = function() {
              return comboPadding;
            };
          } else if ((0, util_1.isArray)(comboPadding)) {
            comboPaddingFunc = function() {
              return Math.max.apply(null, comboPadding);
            };
          } else if ((0, util_1.isFunction)(comboPadding)) {
            comboPaddingFunc = comboPadding;
          } else {
            comboPaddingFunc = function() {
              return 0;
            };
          }
          this.comboPadding = comboPaddingFunc;
          var linkDistance = this.linkDistance;
          var linkDistanceFunc;
          if (!linkDistance) {
            linkDistance = 10;
          }
          if ((0, util_1.isNumber)(linkDistance)) {
            linkDistanceFunc = function(d2) {
              return linkDistance;
            };
          } else {
            linkDistanceFunc = linkDistance;
          }
          this.linkDistance = linkDistanceFunc;
          var edgeStrength = this.edgeStrength;
          var edgeStrengthFunc;
          if (!edgeStrength) {
            edgeStrength = 1;
          }
          if ((0, util_1.isNumber)(edgeStrength)) {
            edgeStrengthFunc = function(d2) {
              return edgeStrength;
            };
          } else {
            edgeStrengthFunc = edgeStrength;
          }
          this.edgeStrength = edgeStrengthFunc;
          var nodeStrength = this.nodeStrength;
          var nodeStrengthFunc;
          if (!nodeStrength) {
            nodeStrength = 30;
          }
          if ((0, util_1.isNumber)(nodeStrength)) {
            nodeStrengthFunc = function(d2) {
              return nodeStrength;
            };
          } else {
            nodeStrengthFunc = nodeStrength;
          }
          this.nodeStrength = nodeStrengthFunc;
        };
        ComboForceLayout3.prototype.initPos = function(comboMap) {
          var self2 = this;
          var nodes = self2.nodes;
          nodes.forEach(function(node, i2) {
            var comboId = node.comboId;
            var combo = comboMap[comboId];
            if (comboId && combo) {
              node.x = combo.cx + 100 / (i2 + 1);
              node.y = combo.cy + 100 / (i2 + 1);
            } else {
              node.x = 100 / (i2 + 1);
              node.y = 100 / (i2 + 1);
            }
          });
        };
        ComboForceLayout3.prototype.getComboMap = function() {
          var self2 = this;
          var nodeMap = self2.nodeMap;
          var comboTrees = self2.comboTrees;
          var oriComboMap = self2.oriComboMap;
          var comboMap = {};
          (comboTrees || []).forEach(function(ctree) {
            var treeChildren = [];
            (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
              if (treeNode.itemType === "node")
                return true;
              if (!oriComboMap[treeNode.id])
                return true;
              if (comboMap[treeNode.id] === void 0) {
                var combo = {
                  id: treeNode.id,
                  name: treeNode.id,
                  cx: 0,
                  cy: 0,
                  count: 0,
                  depth: self2.oriComboMap[treeNode.id].depth || 0,
                  children: []
                };
                comboMap[treeNode.id] = combo;
              }
              var children = treeNode.children;
              if (children) {
                children.forEach(function(child) {
                  if (!comboMap[child.id] && !nodeMap[child.id])
                    return true;
                  treeChildren.push(child);
                });
              }
              var c3 = comboMap[treeNode.id];
              c3.cx = 0;
              c3.cy = 0;
              if (treeChildren.length === 0) {
                c3.empty = true;
                var oriCombo = oriComboMap[treeNode.id];
                c3.cx = oriCombo.x;
                c3.cy = oriCombo.y;
              }
              treeChildren.forEach(function(child) {
                c3.count++;
                if (child.itemType !== "node") {
                  var childCombo = comboMap[child.id];
                  if ((0, util_1.isNumber)(childCombo.cx))
                    c3.cx += childCombo.cx;
                  if ((0, util_1.isNumber)(childCombo.cy))
                    c3.cy += childCombo.cy;
                  return;
                }
                var node = nodeMap[child.id];
                if (!node)
                  return;
                if ((0, util_1.isNumber)(node.x)) {
                  c3.cx += node.x;
                }
                if ((0, util_1.isNumber)(node.y)) {
                  c3.cy += node.y;
                }
              });
              c3.cx /= c3.count || 1;
              c3.cy /= c3.count || 1;
              c3.children = treeChildren;
              return true;
            });
          });
          return comboMap;
        };
        ComboForceLayout3.prototype.applyComboCenterForce = function(displacements) {
          var self2 = this;
          var gravity = self2.gravity;
          var comboGravity = self2.comboGravity || gravity;
          var alpha = this.alpha;
          var comboTrees = self2.comboTrees;
          var indexMap = self2.indexMap;
          var nodeMap = self2.nodeMap;
          var comboMap = self2.comboMap;
          (comboTrees || []).forEach(function(ctree) {
            (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
              if (treeNode.itemType === "node")
                return true;
              var combo = comboMap[treeNode.id];
              if (!combo)
                return true;
              var c3 = comboMap[treeNode.id];
              var gravityScale = (c3.depth + 1) / 10 * 0.5;
              var comboX = c3.cx;
              var comboY = c3.cy;
              c3.cx = 0;
              c3.cy = 0;
              c3.children.forEach(function(child) {
                if (child.itemType !== "node") {
                  var childCombo = comboMap[child.id];
                  if (childCombo && (0, util_1.isNumber)(childCombo.cx))
                    c3.cx += childCombo.cx;
                  if (childCombo && (0, util_1.isNumber)(childCombo.cy))
                    c3.cy += childCombo.cy;
                  return;
                }
                var node = nodeMap[child.id];
                var vecX = node.x - comboX || 5e-3;
                var vecY = node.y - comboY || 5e-3;
                var l2 = Math.sqrt(vecX * vecX + vecY * vecY);
                var childIdx = indexMap[node.id];
                var params = comboGravity * alpha / l2 * gravityScale;
                displacements[childIdx].x -= vecX * params;
                displacements[childIdx].y -= vecY * params;
                if ((0, util_1.isNumber)(node.x))
                  c3.cx += node.x;
                if ((0, util_1.isNumber)(node.y))
                  c3.cy += node.y;
              });
              c3.cx /= c3.count || 1;
              c3.cy /= c3.count || 1;
              return true;
            });
          });
        };
        ComboForceLayout3.prototype.applyCalculate = function(displacements) {
          var self2 = this;
          var comboMap = self2.comboMap;
          var nodes = self2.nodes;
          var vecMap = {};
          nodes.forEach(function(v2, i2) {
            nodes.forEach(function(u2, j2) {
              if (i2 < j2)
                return;
              var vx = v2.x - u2.x || 5e-3;
              var vy = v2.y - u2.y || 5e-3;
              var vl2 = vx * vx + vy * vy;
              var vl = Math.sqrt(vl2);
              if (vl2 < 1)
                vl2 = vl;
              vecMap["".concat(v2.id, "-").concat(u2.id)] = { vx, vy, vl2, vl };
              vecMap["".concat(u2.id, "-").concat(v2.id)] = { vl2, vl, vx: -vx, vy: -vy };
            });
          });
          self2.updateComboSizes(comboMap);
          self2.calRepulsive(displacements, vecMap);
          self2.calAttractive(displacements, vecMap);
          var preventComboOverlap = self2.preventComboOverlap;
          if (preventComboOverlap)
            self2.comboNonOverlapping(displacements, comboMap);
        };
        ComboForceLayout3.prototype.updateComboSizes = function(comboMap) {
          var self2 = this;
          var comboTrees = self2.comboTrees;
          var nodeMap = self2.nodeMap;
          var nodeSize = self2.nodeSize;
          var comboSpacing = self2.comboSpacing;
          var comboPadding = self2.comboPadding;
          (comboTrees || []).forEach(function(ctree) {
            var treeChildren = [];
            (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
              if (treeNode.itemType === "node")
                return true;
              var c3 = comboMap[treeNode.id];
              if (!c3)
                return false;
              var children = treeNode.children;
              if (children) {
                children.forEach(function(child) {
                  if (!comboMap[child.id] && !nodeMap[child.id])
                    return;
                  treeChildren.push(child);
                });
              }
              c3.minX = Infinity;
              c3.minY = Infinity;
              c3.maxX = -Infinity;
              c3.maxY = -Infinity;
              treeChildren.forEach(function(child) {
                if (child.itemType !== "node")
                  return true;
                var node = nodeMap[child.id];
                if (!node)
                  return true;
                var r2 = nodeSize(node);
                var nodeMinX = node.x - r2;
                var nodeMinY = node.y - r2;
                var nodeMaxX = node.x + r2;
                var nodeMaxY = node.y + r2;
                if (c3.minX > nodeMinX)
                  c3.minX = nodeMinX;
                if (c3.minY > nodeMinY)
                  c3.minY = nodeMinY;
                if (c3.maxX < nodeMaxX)
                  c3.maxX = nodeMaxX;
                if (c3.maxY < nodeMaxY)
                  c3.maxY = nodeMaxY;
              });
              var minSize = self2.oriComboMap[treeNode.id].size || 10;
              if ((0, util_1.isArray)(minSize))
                minSize = minSize[0];
              var maxLength = Math.max(c3.maxX - c3.minX, c3.maxY - c3.minY, minSize);
              c3.r = maxLength / 2 + comboSpacing(c3) / 2 + comboPadding(c3);
              return true;
            });
          });
        };
        ComboForceLayout3.prototype.comboNonOverlapping = function(displacements, comboMap) {
          var self2 = this;
          var comboTree = self2.comboTree;
          var comboCollideStrength = self2.comboCollideStrength;
          var indexMap = self2.indexMap;
          var nodeMap = self2.nodeMap;
          (0, util_1.traverseTreeUp)(comboTree, function(treeNode) {
            if (!comboMap[treeNode.id] && !nodeMap[treeNode.id] && treeNode.id !== "comboTreeRoot") {
              return false;
            }
            var children = treeNode.children;
            if (children && children.length > 1) {
              children.forEach(function(v2, i2) {
                if (v2.itemType === "node")
                  return false;
                var cv = comboMap[v2.id];
                if (!cv)
                  return;
                children.forEach(function(u2, j2) {
                  if (i2 <= j2)
                    return false;
                  if (u2.itemType === "node")
                    return false;
                  var cu2 = comboMap[u2.id];
                  if (!cu2)
                    return false;
                  var vx = cv.cx - cu2.cx || 5e-3;
                  var vy = cv.cy - cu2.cy || 5e-3;
                  var l2 = vx * vx + vy * vy;
                  var rv = cv.r || 1;
                  var ru2 = cu2.r || 1;
                  var r2 = rv + ru2;
                  var ru22 = ru2 * ru2;
                  var rv2 = rv * rv;
                  if (l2 < r2 * r2) {
                    var vnodes = v2.children;
                    if (!vnodes || vnodes.length === 0)
                      return false;
                    var unodes_1 = u2.children;
                    if (!unodes_1 || unodes_1.length === 0)
                      return false;
                    var sqrtl = Math.sqrt(l2);
                    var ll = (r2 - sqrtl) / sqrtl * comboCollideStrength;
                    var xl_1 = vx * ll;
                    var yl_1 = vy * ll;
                    var rratio_1 = ru22 / (rv2 + ru22);
                    var irratio_1 = 1 - rratio_1;
                    vnodes.forEach(function(vn2) {
                      if (vn2.itemType !== "node")
                        return false;
                      if (!nodeMap[vn2.id])
                        return;
                      var vindex = indexMap[vn2.id];
                      unodes_1.forEach(function(un2) {
                        if (un2.itemType !== "node")
                          return false;
                        if (!nodeMap[un2.id])
                          return false;
                        var uindex = indexMap[un2.id];
                        displacements[vindex].x += xl_1 * rratio_1;
                        displacements[vindex].y += yl_1 * rratio_1;
                        displacements[uindex].x -= xl_1 * irratio_1;
                        displacements[uindex].y -= yl_1 * irratio_1;
                      });
                    });
                  }
                });
              });
            }
            return true;
          });
        };
        ComboForceLayout3.prototype.calRepulsive = function(displacements, vecMap) {
          var self2 = this;
          var nodes = self2.nodes;
          var max4 = self2.width * self2.optimizeRangeFactor;
          var nodeStrength = self2.nodeStrength;
          var alpha = self2.alpha;
          var nodeCollideStrength = self2.nodeCollideStrength;
          var preventNodeOverlap = self2.preventNodeOverlap;
          var nodeSizeFunc = self2.nodeSize;
          var nodeSpacingFunc = self2.nodeSpacing;
          var scale3 = self2.depthRepulsiveForceScale;
          var center = self2.center;
          nodes.forEach(function(v2, i2) {
            if (!v2.x || !v2.y)
              return;
            if (center) {
              var gravity = self2.gravity;
              var vecX = v2.x - center[0] || 5e-3;
              var vecY = v2.y - center[1] || 5e-3;
              var l2 = Math.sqrt(vecX * vecX + vecY * vecY);
              displacements[i2].x -= vecX * gravity * alpha / l2;
              displacements[i2].y -= vecY * gravity * alpha / l2;
            }
            nodes.forEach(function(u2, j2) {
              if (i2 === j2) {
                return;
              }
              if (!u2.x || !u2.y)
                return;
              var _a2 = vecMap["".concat(v2.id, "-").concat(u2.id)], vl2 = _a2.vl2, vl = _a2.vl;
              if (vl > max4)
                return;
              var _b = vecMap["".concat(v2.id, "-").concat(u2.id)], vx = _b.vx, vy = _b.vy;
              var depthDiff = Math.log(Math.abs(u2.depth - v2.depth) / 10) + 1 || 1;
              depthDiff = depthDiff < 1 ? 1 : depthDiff;
              if (u2.comboId !== v2.comboId)
                depthDiff += 1;
              var depthParam = depthDiff ? Math.pow(scale3, depthDiff) : 1;
              var params = nodeStrength(u2) * alpha / vl2 * depthParam;
              displacements[i2].x += vx * params;
              displacements[i2].y += vy * params;
              if (i2 < j2 && preventNodeOverlap) {
                var ri2 = nodeSizeFunc(v2) + nodeSpacingFunc(v2) || 1;
                var rj = nodeSizeFunc(u2) + nodeSpacingFunc(u2) || 1;
                var r2 = ri2 + rj;
                if (vl2 < r2 * r2) {
                  var ll = (r2 - vl) / vl * nodeCollideStrength;
                  var rj2 = rj * rj;
                  var rratio = rj2 / (ri2 * ri2 + rj2);
                  var xl = vx * ll;
                  var yl = vy * ll;
                  displacements[i2].x += xl * rratio;
                  displacements[i2].y += yl * rratio;
                  rratio = 1 - rratio;
                  displacements[j2].x -= xl * rratio;
                  displacements[j2].y -= yl * rratio;
                }
              }
            });
          });
        };
        ComboForceLayout3.prototype.calAttractive = function(displacements, vecMap) {
          var self2 = this;
          var edges = self2.edges;
          var linkDistance = self2.linkDistance;
          var alpha = self2.alpha;
          var edgeStrength = self2.edgeStrength;
          var bias = self2.bias;
          var scale3 = self2.depthAttractiveForceScale;
          edges.forEach(function(e8, i2) {
            var source = (0, util_1.getEdgeTerminal)(e8, "source");
            var target = (0, util_1.getEdgeTerminal)(e8, "target");
            if (!source || !target || source === target)
              return;
            var uIndex = self2.indexMap[source];
            var vIndex = self2.indexMap[target];
            var u2 = self2.nodeMap[source];
            var v2 = self2.nodeMap[target];
            if (!u2 || !v2)
              return;
            var depthDiff = u2.depth === v2.depth ? 0 : Math.log(Math.abs(u2.depth - v2.depth) / 10);
            if (u2.comboId === v2.comboId) {
              depthDiff = depthDiff / 2;
            }
            var depthParam = depthDiff ? Math.pow(scale3, depthDiff) : 1;
            if (u2.comboId !== v2.comboId && depthParam === 1) {
              depthParam = scale3 / 2;
            } else if (u2.comboId === v2.comboId) {
              depthParam = 2;
            }
            if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
              return;
            }
            var _a2 = vecMap["".concat(target, "-").concat(source)], vl = _a2.vl, vx = _a2.vx, vy = _a2.vy;
            var l2 = (vl - linkDistance(e8)) / vl * alpha * edgeStrength(e8) * depthParam;
            var vecX = vx * l2;
            var vecY = vy * l2;
            var b2 = bias[i2];
            displacements[vIndex].x -= vecX * b2;
            displacements[vIndex].y -= vecY * b2;
            displacements[uIndex].x += vecX * (1 - b2);
            displacements[uIndex].y += vecY * (1 - b2);
          });
        };
        ComboForceLayout3.prototype.getType = function() {
          return "comboForce";
        };
        return ComboForceLayout3;
      }(base_1.Base)
    );
    exports.ComboForceLayout = ComboForceLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/comboCombined.js
var require_comboCombined = __commonJS({
  "node_modules/@antv/layout/lib/layout/comboCombined.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __assign14 = exports && exports.__assign || function() {
      __assign14 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign14.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboCombinedLayout = void 0;
    var constants_1 = require_constants();
    var base_1 = require_base();
    var util_1 = require_util2();
    var _1 = require_layout3();
    var ComboCombinedLayout2 = (
      /** @class */
      function(_super) {
        __extends15(ComboCombinedLayout3, _super);
        function ComboCombinedLayout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.nodes = [];
          _this.edges = [];
          _this.combos = [];
          _this.comboEdges = [];
          _this.comboPadding = 10;
          _this.comboTrees = [];
          _this.updateCfg(options);
          return _this;
        }
        ComboCombinedLayout3.prototype.getDefaultCfg = function() {
          return {};
        };
        ComboCombinedLayout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var center = self2.center;
          if (!nodes || nodes.length === 0) {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
            return;
          }
          self2.initVals();
          self2.run();
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
        };
        ComboCombinedLayout3.prototype.run = function() {
          var _a2;
          var self2 = this;
          var nodes = self2.nodes, edges = self2.edges, combos = self2.combos, comboEdges = self2.comboEdges, center = self2.center;
          var nodeMap = {};
          nodes.forEach(function(node) {
            nodeMap[node.id] = node;
          });
          var comboMap = {};
          combos.forEach(function(combo) {
            comboMap[combo.id] = combo;
          });
          var innerGraphs = self2.getInnerGraphs(nodeMap);
          var outerNodeIds = [];
          var outerNodes = [];
          var nodeAncestorIdMap = {};
          var allHaveNoPosition = true;
          this.comboTrees.forEach(function(cTree) {
            var innerNode = innerGraphs[cTree.id];
            if (!innerNode) {
              return;
            }
            var oNode = __assign14(__assign14({}, cTree), { x: innerNode.x || comboMap[cTree.id].x, y: innerNode.y || comboMap[cTree.id].y, fx: innerNode.fx || comboMap[cTree.id].fx, fy: innerNode.fy || comboMap[cTree.id].fy, mass: innerNode.mass || comboMap[cTree.id].mass, size: innerNode.size });
            outerNodes.push(oNode);
            if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {
              allHaveNoPosition = false;
            } else {
              oNode.x = Math.random() * 100;
              oNode.y = Math.random() * 100;
            }
            outerNodeIds.push(cTree.id);
            (0, util_1.traverseTreeUp)(cTree, function(child) {
              if (child.id !== cTree.id)
                nodeAncestorIdMap[child.id] = cTree.id;
              return true;
            });
          });
          nodes.forEach(function(node) {
            if (node.comboId && comboMap[node.comboId])
              return;
            var oNode = __assign14({}, node);
            outerNodes.push(oNode);
            if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {
              allHaveNoPosition = false;
            } else {
              oNode.x = Math.random() * 100;
              oNode.y = Math.random() * 100;
            }
            outerNodeIds.push(node.id);
          });
          var outerEdges = [];
          edges.concat(comboEdges).forEach(function(edge) {
            var sourceAncestorId = nodeAncestorIdMap[edge.source] || edge.source;
            var targetAncestorId = nodeAncestorIdMap[edge.target] || edge.target;
            if (sourceAncestorId !== targetAncestorId && outerNodeIds.includes(sourceAncestorId) && outerNodeIds.includes(targetAncestorId)) {
              outerEdges.push({
                source: sourceAncestorId,
                target: targetAncestorId
              });
            }
          });
          if (outerNodes === null || outerNodes === void 0 ? void 0 : outerNodes.length) {
            if (outerNodes.length === 1) {
              outerNodes[0].x = center[0];
              outerNodes[0].y = center[1];
            } else {
              var outerData = {
                nodes: outerNodes,
                edges: outerEdges
              };
              var outerLayout = this.outerLayout || new _1.GForceLayout({
                gravity: 1,
                factor: 4,
                linkDistance: function(edge, source, target) {
                  var _a3, _b;
                  var nodeSize = ((((_a3 = source.size) === null || _a3 === void 0 ? void 0 : _a3[0]) || 30) + (((_b = target.size) === null || _b === void 0 ? void 0 : _b[0]) || 30)) / 2;
                  return Math.min(nodeSize * 1.5, 700);
                }
              });
              var outerLayoutType = (_a2 = outerLayout.getType) === null || _a2 === void 0 ? void 0 : _a2.call(outerLayout);
              outerLayout.updateCfg({
                center,
                kg: 5,
                preventOverlap: true,
                animate: false
              });
              if (allHaveNoPosition && constants_1.FORCE_LAYOUT_TYPE_MAP[outerLayoutType]) {
                var outerLayoutPreset = outerNodes.length < 100 ? new _1.MDSLayout() : new _1.GridLayout();
                outerLayoutPreset.layout(outerData);
              }
              outerLayout.layout(outerData);
            }
            outerNodes.forEach(function(outerNode) {
              var innerGraph = innerGraphs[outerNode.id];
              if (!innerGraph) {
                var node = nodeMap[outerNode.id];
                if (node) {
                  node.x = outerNode.x;
                  node.y = outerNode.y;
                }
                return;
              }
              innerGraph.visited = true;
              innerGraph.x = outerNode.x;
              innerGraph.y = outerNode.y;
              innerGraph.nodes.forEach(function(node2) {
                node2.x += outerNode.x;
                node2.y += outerNode.y;
              });
            });
          }
          var innerGraphIds = Object.keys(innerGraphs);
          var _loop_1 = function(i3) {
            var id = innerGraphIds[i3];
            var innerGraph = innerGraphs[id];
            if (!innerGraph)
              return "continue";
            innerGraph.nodes.forEach(function(node) {
              if (!innerGraph.visited) {
                node.x += innerGraph.x || 0;
                node.y += innerGraph.y || 0;
              }
              if (nodeMap[node.id]) {
                nodeMap[node.id].x = node.x;
                nodeMap[node.id].y = node.y;
              }
            });
            if (comboMap[id]) {
              comboMap[id].x = innerGraph.x;
              comboMap[id].y = innerGraph.y;
            }
          };
          for (var i2 = innerGraphIds.length - 1; i2 >= 0; i2--) {
            _loop_1(i2);
          }
          return { nodes, edges, combos, comboEdges };
        };
        ComboCombinedLayout3.prototype.getInnerGraphs = function(nodeMap) {
          var self2 = this;
          var comboTrees = self2.comboTrees, nodeSize = self2.nodeSize, edges = self2.edges, comboPadding = self2.comboPadding, spacing = self2.spacing;
          var innerGraphs = {};
          var innerGraphLayout = this.innerLayout || new _1.ConcentricLayout({ type: "concentric", sortBy: "id" });
          innerGraphLayout.center = [0, 0];
          innerGraphLayout.preventOverlap = true;
          innerGraphLayout.nodeSpacing = spacing;
          (comboTrees || []).forEach(function(ctree) {
            (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
              var _a2;
              var padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(treeNode)) || 10;
              if ((0, util_1.isArray)(padding))
                padding = Math.max.apply(Math, padding);
              if (!((_a2 = treeNode.children) === null || _a2 === void 0 ? void 0 : _a2.length)) {
                if (treeNode.itemType === "combo") {
                  var treeNodeSize = padding ? [padding * 2, padding * 2] : [30, 30];
                  innerGraphs[treeNode.id] = {
                    id: treeNode.id,
                    nodes: [],
                    size: treeNodeSize
                  };
                }
              } else {
                var innerGraphNodes = treeNode.children.map(function(child) {
                  if (child.itemType === "combo")
                    return innerGraphs[child.id];
                  var oriNode = nodeMap[child.id] || {};
                  return __assign14(__assign14({}, oriNode), child);
                });
                var innerGraphNodeIds_1 = innerGraphNodes.map(function(node) {
                  return node.id;
                });
                var innerGraphData = {
                  nodes: innerGraphNodes,
                  edges: edges.filter(function(edge) {
                    return innerGraphNodeIds_1.includes(edge.source) && innerGraphNodeIds_1.includes(edge.target);
                  })
                };
                var minNodeSize_1 = Infinity;
                innerGraphNodes.forEach(function(node) {
                  var _a3;
                  if (!node.size)
                    node.size = ((_a3 = innerGraphs[node.id]) === null || _a3 === void 0 ? void 0 : _a3.size) || (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
                  if ((0, util_1.isNumber)(node.size))
                    node.size = [node.size, node.size];
                  if (minNodeSize_1 > node.size[0])
                    minNodeSize_1 = node.size[0];
                  if (minNodeSize_1 > node.size[1])
                    minNodeSize_1 = node.size[1];
                });
                innerGraphLayout.layout(innerGraphData);
                var _b = (0, util_1.getLayoutBBox)(innerGraphNodes), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
                var center_1 = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };
                innerGraphData.nodes.forEach(function(node) {
                  node.x -= center_1.x;
                  node.y -= center_1.y;
                });
                var innerGraphWidth = Math.max(maxX - minX, minNodeSize_1) + padding * 2;
                var innerGraphHeight = Math.max(maxY - minY, minNodeSize_1) + padding * 2;
                innerGraphs[treeNode.id] = {
                  id: treeNode.id,
                  nodes: innerGraphNodes,
                  size: [innerGraphWidth, innerGraphHeight]
                };
              }
              return true;
            });
          });
          return innerGraphs;
        };
        ComboCombinedLayout3.prototype.initVals = function() {
          var self2 = this;
          var nodeSize = self2.nodeSize;
          var spacing = self2.spacing;
          var nodeSizeFunc;
          var spacingFunc;
          if ((0, util_1.isNumber)(spacing)) {
            spacingFunc = function() {
              return spacing;
            };
          } else if ((0, util_1.isFunction)(spacing)) {
            spacingFunc = spacing;
          } else {
            spacingFunc = function() {
              return 0;
            };
          }
          this.spacing = spacingFunc;
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              var spacing2 = spacingFunc(d2);
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                  return (res + spacing2) / 2;
                }
                if ((0, util_1.isObject)(d2.size)) {
                  var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                  return (res + spacing2) / 2;
                }
                return (d2.size + spacing2) / 2;
              }
              return 10 + spacing2 / 2;
            };
          } else if ((0, util_1.isFunction)(nodeSize)) {
            nodeSizeFunc = function(d2) {
              var size3 = nodeSize(d2);
              var spacing2 = spacingFunc(d2);
              if ((0, util_1.isArray)(d2.size)) {
                var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                return (res + spacing2) / 2;
              }
              return ((size3 || 10) + spacing2) / 2;
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            var radius_1 = larger / 2;
            nodeSizeFunc = function(d2) {
              return radius_1 + spacingFunc(d2) / 2;
            };
          } else {
            var radius_2 = nodeSize / 2;
            nodeSizeFunc = function(d2) {
              return radius_2 + spacingFunc(d2) / 2;
            };
          }
          this.nodeSize = nodeSizeFunc;
          var comboPadding = self2.comboPadding;
          var comboPaddingFunc;
          if ((0, util_1.isNumber)(comboPadding)) {
            comboPaddingFunc = function() {
              return comboPadding;
            };
          } else if ((0, util_1.isArray)(comboPadding)) {
            comboPaddingFunc = function() {
              return Math.max.apply(null, comboPadding);
            };
          } else if ((0, util_1.isFunction)(comboPadding)) {
            comboPaddingFunc = comboPadding;
          } else {
            comboPaddingFunc = function() {
              return 0;
            };
          }
          this.comboPadding = comboPaddingFunc;
        };
        ComboCombinedLayout3.prototype.getType = function() {
          return "comboCombined";
        };
        return ComboCombinedLayout3;
      }(base_1.Base)
    );
    exports.ComboCombinedLayout = ComboCombinedLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/body.js
var require_body = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/body.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Body = (
      /** @class */
      function() {
        function Body2(params) {
          this.id = params.id || 0;
          this.rx = params.rx;
          this.ry = params.ry;
          this.fx = 0;
          this.fy = 0;
          this.mass = params.mass;
          this.degree = params.degree;
          this.g = params.g || 0;
        }
        Body2.prototype.distanceTo = function(bo2) {
          var dx = this.rx - bo2.rx;
          var dy = this.ry - bo2.ry;
          return Math.hypot(dx, dy);
        };
        Body2.prototype.setPos = function(x4, y4) {
          this.rx = x4;
          this.ry = y4;
        };
        Body2.prototype.resetForce = function() {
          this.fx = 0;
          this.fy = 0;
        };
        Body2.prototype.addForce = function(b2) {
          var dx = b2.rx - this.rx;
          var dy = b2.ry - this.ry;
          var dist = Math.hypot(dx, dy);
          dist = dist < 1e-4 ? 1e-4 : dist;
          var F2 = this.g * (this.degree + 1) * (b2.degree + 1) / dist;
          this.fx += F2 * dx / dist;
          this.fy += F2 * dy / dist;
        };
        Body2.prototype.in = function(quad) {
          return quad.contains(this.rx, this.ry);
        };
        Body2.prototype.add = function(bo2) {
          var nenwMass = this.mass + bo2.mass;
          var x4 = (this.rx * this.mass + bo2.rx * bo2.mass) / nenwMass;
          var y4 = (this.ry * this.mass + bo2.ry * bo2.mass) / nenwMass;
          var dg = this.degree + bo2.degree;
          var params = {
            rx: x4,
            ry: y4,
            mass: nenwMass,
            degree: dg
          };
          return new Body2(params);
        };
        return Body2;
      }()
    );
    exports.default = Body;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/quad.js
var require_quad = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/quad.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Quad = (
      /** @class */
      function() {
        function Quad2(params) {
          this.xmid = params.xmid;
          this.ymid = params.ymid;
          this.length = params.length;
          this.massCenter = params.massCenter || [0, 0];
          this.mass = params.mass || 1;
        }
        Quad2.prototype.getLength = function() {
          return this.length;
        };
        Quad2.prototype.contains = function(x4, y4) {
          var halfLen = this.length / 2;
          return x4 <= this.xmid + halfLen && x4 >= this.xmid - halfLen && y4 <= this.ymid + halfLen && y4 >= this.ymid - halfLen;
        };
        Quad2.prototype.NW = function() {
          var x4 = this.xmid - this.length / 4;
          var y4 = this.ymid + this.length / 4;
          var len = this.length / 2;
          var params = {
            xmid: x4,
            ymid: y4,
            length: len
          };
          var NW = new Quad2(params);
          return NW;
        };
        Quad2.prototype.NE = function() {
          var x4 = this.xmid + this.length / 4;
          var y4 = this.ymid + this.length / 4;
          var len = this.length / 2;
          var params = {
            xmid: x4,
            ymid: y4,
            length: len
          };
          var NE = new Quad2(params);
          return NE;
        };
        Quad2.prototype.SW = function() {
          var x4 = this.xmid - this.length / 4;
          var y4 = this.ymid - this.length / 4;
          var len = this.length / 2;
          var params = {
            xmid: x4,
            ymid: y4,
            length: len
          };
          var SW = new Quad2(params);
          return SW;
        };
        Quad2.prototype.SE = function() {
          var x4 = this.xmid + this.length / 4;
          var y4 = this.ymid - this.length / 4;
          var len = this.length / 2;
          var params = {
            xmid: x4,
            ymid: y4,
            length: len
          };
          var SE = new Quad2(params);
          return SE;
        };
        return Quad2;
      }()
    );
    exports.default = Quad;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/quadTree.js
var require_quadTree = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/quadTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var QuadTree = (
      /** @class */
      function() {
        function QuadTree2(param) {
          this.body = null;
          this.quad = null;
          this.NW = null;
          this.NE = null;
          this.SW = null;
          this.SE = null;
          this.theta = 0.5;
          if (param != null)
            this.quad = param;
        }
        QuadTree2.prototype.insert = function(bo2) {
          if (this.body == null) {
            this.body = bo2;
            return;
          }
          if (!this._isExternal()) {
            this.body = this.body.add(bo2);
            this._putBody(bo2);
          } else {
            if (this.quad) {
              this.NW = new QuadTree2(this.quad.NW());
              this.NE = new QuadTree2(this.quad.NE());
              this.SW = new QuadTree2(this.quad.SW());
              this.SE = new QuadTree2(this.quad.SE());
            }
            this._putBody(this.body);
            this._putBody(bo2);
            this.body = this.body.add(bo2);
          }
        };
        QuadTree2.prototype._putBody = function(bo2) {
          if (!this.quad)
            return;
          if (bo2.in(this.quad.NW()) && this.NW)
            this.NW.insert(bo2);
          else if (bo2.in(this.quad.NE()) && this.NE)
            this.NE.insert(bo2);
          else if (bo2.in(this.quad.SW()) && this.SW)
            this.SW.insert(bo2);
          else if (bo2.in(this.quad.SE()) && this.SE)
            this.SE.insert(bo2);
        };
        QuadTree2.prototype._isExternal = function() {
          return this.NW == null && this.NE == null && this.SW == null && this.SE == null;
        };
        QuadTree2.prototype.updateForce = function(bo2) {
          if (this.body == null || bo2 === this.body) {
            return;
          }
          if (this._isExternal())
            bo2.addForce(this.body);
          else {
            var s2 = this.quad ? this.quad.getLength() : 0;
            var d2 = this.body.distanceTo(bo2);
            if (s2 / d2 < this.theta)
              bo2.addForce(this.body);
            else {
              this.NW && this.NW.updateForce(bo2);
              this.NE && this.NE.updateForce(bo2);
              this.SW && this.SW.updateForce(bo2);
              this.SE && this.SE.updateForce(bo2);
            }
          }
        };
        return QuadTree2;
      }()
    );
    exports.default = QuadTree;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/index.js
var require_forceAtlas2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/index.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForceAtlas2Layout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var body_1 = __importDefault(require_body());
    var quad_1 = __importDefault(require_quad());
    var quadTree_1 = __importDefault(require_quadTree());
    var ForceAtlas2Layout2 = (
      /** @class */
      function(_super) {
        __extends15(ForceAtlas2Layout3, _super);
        function ForceAtlas2Layout3(options) {
          var _this = _super.call(this) || this;
          _this.center = [0, 0];
          _this.width = 300;
          _this.height = 300;
          _this.nodes = [];
          _this.edges = [];
          _this.kr = 5;
          _this.kg = 1;
          _this.mode = "normal";
          _this.preventOverlap = false;
          _this.dissuadeHubs = false;
          _this.barnesHut = void 0;
          _this.maxIteration = 0;
          _this.ks = 0.1;
          _this.ksmax = 10;
          _this.tao = 0.1;
          _this.onLayoutEnd = function() {
          };
          _this.prune = void 0;
          _this.updateCfg(options);
          return _this;
        }
        ForceAtlas2Layout3.prototype.getDefaultCfg = function() {
          return {};
        };
        ForceAtlas2Layout3.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes, onLayoutEnd = self2.onLayoutEnd, prune = self2.prune;
          var maxIteration = self2.maxIteration;
          if (!self2.width && typeof window !== "undefined") {
            self2.width = window.innerWidth;
          }
          if (!self2.height && typeof window !== "undefined") {
            self2.height = window.innerHeight;
          }
          var sizes = [];
          var nodeNum = nodes.length;
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            var node = nodes[i2];
            var nodeWidth = 10;
            var nodeHeight = 10;
            if ((0, util_1.isNumber)(node.size)) {
              nodeWidth = node.size;
              nodeHeight = node.size;
            }
            if ((0, util_1.isArray)(node.size)) {
              if (!isNaN(node.size[0]))
                nodeWidth = node.size[0];
              if (!isNaN(node.size[1]))
                nodeHeight = node.size[1];
            } else if ((0, util_1.isObject)(node.size)) {
              nodeWidth = node.size.width;
              nodeHeight = node.size.height;
            }
            if (self2.getWidth && !isNaN(self2.getWidth(node)))
              nodeHeight = self2.getWidth(node);
            if (self2.getHeight && !isNaN(self2.getHeight(node)))
              nodeWidth = self2.getHeight(node);
            var maxSize = Math.max(nodeWidth, nodeHeight);
            sizes.push(maxSize);
          }
          if (self2.barnesHut === void 0 && nodeNum > 250)
            self2.barnesHut = true;
          if (self2.prune === void 0 && nodeNum > 100)
            self2.prune = true;
          if (this.maxIteration === 0 && !self2.prune) {
            maxIteration = 250;
            if (nodeNum <= 200 && nodeNum > 100)
              maxIteration = 1e3;
            else if (nodeNum > 200)
              maxIteration = 1200;
            this.maxIteration = maxIteration;
          } else if (this.maxIteration === 0 && prune) {
            maxIteration = 100;
            if (nodeNum <= 200 && nodeNum > 100)
              maxIteration = 500;
            else if (nodeNum > 200)
              maxIteration = 950;
            this.maxIteration = maxIteration;
          }
          if (!self2.kr) {
            self2.kr = 50;
            if (nodeNum > 100 && nodeNum <= 500)
              self2.kr = 20;
            else if (nodeNum > 500)
              self2.kr = 1;
          }
          if (!self2.kg) {
            self2.kg = 20;
            if (nodeNum > 100 && nodeNum <= 500)
              self2.kg = 10;
            else if (nodeNum > 500)
              self2.kg = 1;
          }
          this.nodes = self2.updateNodesByForces(sizes);
          onLayoutEnd();
        };
        ForceAtlas2Layout3.prototype.updateNodesByForces = function(sizes) {
          var self2 = this;
          var edges = self2.edges, maxIteration = self2.maxIteration;
          var nodes = self2.nodes;
          var nonLoopEdges = edges.filter(function(edge) {
            var source2 = (0, util_1.getEdgeTerminal)(edge, "source");
            var target2 = (0, util_1.getEdgeTerminal)(edge, "target");
            return source2 !== target2;
          });
          var size3 = nodes.length;
          var esize = nonLoopEdges.length;
          var degrees = [];
          var idMap = {};
          var edgeEndsIdMap = {};
          var Es = [];
          for (var i2 = 0; i2 < size3; i2 += 1) {
            idMap[nodes[i2].id] = i2;
            degrees[i2] = 0;
            if (nodes[i2].x === void 0 || isNaN(nodes[i2].x)) {
              nodes[i2].x = Math.random() * 1e3;
            }
            if (nodes[i2].y === void 0 || isNaN(nodes[i2].y)) {
              nodes[i2].y = Math.random() * 1e3;
            }
            Es.push({ x: nodes[i2].x, y: nodes[i2].y });
          }
          for (var i2 = 0; i2 < esize; i2 += 1) {
            var node1 = void 0;
            var node2 = void 0;
            var sIdx = 0;
            var tIdx = 0;
            for (var j2 = 0; j2 < size3; j2 += 1) {
              var source = (0, util_1.getEdgeTerminal)(nonLoopEdges[i2], "source");
              var target = (0, util_1.getEdgeTerminal)(nonLoopEdges[i2], "target");
              if (nodes[j2].id === source) {
                node1 = nodes[j2];
                sIdx = j2;
              } else if (nodes[j2].id === target) {
                node2 = nodes[j2];
                tIdx = j2;
              }
              edgeEndsIdMap[i2] = { sourceIdx: sIdx, targetIdx: tIdx };
            }
            if (node1)
              degrees[idMap[node1.id]] += 1;
            if (node2)
              degrees[idMap[node2.id]] += 1;
          }
          var iteration = maxIteration;
          nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);
          if (self2.prune) {
            for (var j2 = 0; j2 < esize; j2 += 1) {
              if (degrees[edgeEndsIdMap[j2].sourceIdx] <= 1) {
                nodes[edgeEndsIdMap[j2].sourceIdx].x = nodes[edgeEndsIdMap[j2].targetIdx].x;
                nodes[edgeEndsIdMap[j2].sourceIdx].y = nodes[edgeEndsIdMap[j2].targetIdx].y;
              } else if (degrees[edgeEndsIdMap[j2].targetIdx] <= 1) {
                nodes[edgeEndsIdMap[j2].targetIdx].x = nodes[edgeEndsIdMap[j2].sourceIdx].x;
                nodes[edgeEndsIdMap[j2].targetIdx].y = nodes[edgeEndsIdMap[j2].sourceIdx].y;
              }
            }
            self2.prune = false;
            self2.barnesHut = false;
            iteration = 100;
            nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);
          }
          return nodes;
        };
        ForceAtlas2Layout3.prototype.iterate = function(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {
          var self2 = this;
          var nodes = self2.nodes;
          var kr2 = self2.kr, preventOverlap = self2.preventOverlap;
          var barnesHut = self2.barnesHut;
          var nodeNum = nodes.length;
          var sg = 0;
          var krPrime = 100;
          var iter = iteration;
          var prevoIter = 50;
          var forces = [];
          var preForces = [];
          var bodies = [];
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            forces[2 * i2] = 0;
            forces[2 * i2 + 1] = 0;
            if (barnesHut) {
              var params = {
                id: i2,
                rx: nodes[i2].x,
                ry: nodes[i2].y,
                mass: 1,
                g: kr2,
                degree: degrees[i2]
              };
              bodies[i2] = new body_1.default(params);
            }
          }
          while (iter > 0) {
            for (var i2 = 0; i2 < nodeNum; i2 += 1) {
              preForces[2 * i2] = forces[2 * i2];
              preForces[2 * i2 + 1] = forces[2 * i2 + 1];
              forces[2 * i2] = 0;
              forces[2 * i2 + 1] = 0;
            }
            forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces);
            if (barnesHut && (preventOverlap && iter > prevoIter || !preventOverlap)) {
              forces = this.getOptRepGraForces(forces, bodies, degrees);
            } else {
              forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);
            }
            var res = this.updatePos(forces, preForces, sg, degrees);
            nodes = res.nodes;
            sg = res.sg;
            iter--;
            if (self2.tick)
              self2.tick();
          }
          return nodes;
        };
        ForceAtlas2Layout3.prototype.getAttrForces = function(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {
          var self2 = this;
          var nodes = self2.nodes, preventOverlap = self2.preventOverlap, dissuadeHubs = self2.dissuadeHubs, mode = self2.mode, prune = self2.prune;
          for (var i2 = 0; i2 < esize; i2 += 1) {
            var sourceNode = nodes[edgeEndsIdMap[i2].sourceIdx];
            var sourceIdx = edgeEndsIdMap[i2].sourceIdx;
            var targetNode = nodes[edgeEndsIdMap[i2].targetIdx];
            var targetIdx = edgeEndsIdMap[i2].targetIdx;
            if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1))
              continue;
            var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];
            var eucliDis = Math.hypot(dir[0], dir[1]);
            eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            if (preventOverlap && iter < prevoIter)
              eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];
            var Fa1 = eucliDis;
            var Fa2 = Fa1;
            if (mode === "linlog") {
              Fa1 = Math.log(1 + eucliDis);
              Fa2 = Fa1;
            }
            if (dissuadeHubs) {
              Fa1 = eucliDis / degrees[sourceIdx];
              Fa2 = eucliDis / degrees[targetIdx];
            }
            if (preventOverlap && iter < prevoIter && eucliDis <= 0) {
              Fa1 = 0;
              Fa2 = 0;
            } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {
              Fa1 = eucliDis;
              Fa2 = eucliDis;
            }
            forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];
            forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];
            forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];
            forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];
          }
          return forces;
        };
        ForceAtlas2Layout3.prototype.getRepGraForces = function(iter, prevoIter, forces, krPrime, sizes, degrees) {
          var self2 = this;
          var nodes = self2.nodes, preventOverlap = self2.preventOverlap, kr2 = self2.kr, kg = self2.kg, center = self2.center, prune = self2.prune;
          var nodeNum = nodes.length;
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            for (var j2 = i2 + 1; j2 < nodeNum; j2 += 1) {
              if (prune && (degrees[i2] <= 1 || degrees[j2] <= 1))
                continue;
              var dir_1 = [nodes[j2].x - nodes[i2].x, nodes[j2].y - nodes[i2].y];
              var eucliDis_1 = Math.hypot(dir_1[0], dir_1[1]);
              eucliDis_1 = eucliDis_1 < 1e-4 ? 1e-4 : eucliDis_1;
              dir_1[0] = dir_1[0] / eucliDis_1;
              dir_1[1] = dir_1[1] / eucliDis_1;
              if (preventOverlap && iter < prevoIter)
                eucliDis_1 = eucliDis_1 - sizes[i2] - sizes[j2];
              var Fr2 = kr2 * (degrees[i2] + 1) * (degrees[j2] + 1) / eucliDis_1;
              if (preventOverlap && iter < prevoIter && eucliDis_1 < 0) {
                Fr2 = krPrime * (degrees[i2] + 1) * (degrees[j2] + 1);
              } else if (preventOverlap && iter < prevoIter && eucliDis_1 === 0) {
                Fr2 = 0;
              } else if (preventOverlap && iter < prevoIter && eucliDis_1 > 0) {
                Fr2 = kr2 * (degrees[i2] + 1) * (degrees[j2] + 1) / eucliDis_1;
              }
              forces[2 * i2] -= Fr2 * dir_1[0];
              forces[2 * j2] += Fr2 * dir_1[0];
              forces[2 * i2 + 1] -= Fr2 * dir_1[1];
              forces[2 * j2 + 1] += Fr2 * dir_1[1];
            }
            var dir = [nodes[i2].x - center[0], nodes[i2].y - center[1]];
            var eucliDis = Math.hypot(dir[0], dir[1]);
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            var Fg = kg * (degrees[i2] + 1);
            forces[2 * i2] -= Fg * dir[0];
            forces[2 * i2 + 1] -= Fg * dir[1];
          }
          return forces;
        };
        ForceAtlas2Layout3.prototype.getOptRepGraForces = function(forces, bodies, degrees) {
          var self2 = this;
          var nodes = self2.nodes, kg = self2.kg, center = self2.center, prune = self2.prune;
          var nodeNum = nodes.length;
          var minx = 9e10;
          var maxx = -9e10;
          var miny = 9e10;
          var maxy = -9e10;
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees[i2] <= 1)
              continue;
            bodies[i2].setPos(nodes[i2].x, nodes[i2].y);
            if (nodes[i2].x >= maxx)
              maxx = nodes[i2].x;
            if (nodes[i2].x <= minx)
              minx = nodes[i2].x;
            if (nodes[i2].y >= maxy)
              maxy = nodes[i2].y;
            if (nodes[i2].y <= miny)
              miny = nodes[i2].y;
          }
          var width = Math.max(maxx - minx, maxy - miny);
          var quadParams = {
            xmid: (maxx + minx) / 2,
            ymid: (maxy + miny) / 2,
            length: width,
            massCenter: center,
            mass: nodeNum
          };
          var quad = new quad_1.default(quadParams);
          var quadTree = new quadTree_1.default(quad);
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees[i2] <= 1)
              continue;
            if (bodies[i2].in(quad))
              quadTree.insert(bodies[i2]);
          }
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees[i2] <= 1)
              continue;
            bodies[i2].resetForce();
            quadTree.updateForce(bodies[i2]);
            forces[2 * i2] -= bodies[i2].fx;
            forces[2 * i2 + 1] -= bodies[i2].fy;
            var dir = [nodes[i2].x - center[0], nodes[i2].y - center[1]];
            var eucliDis = Math.hypot(dir[0], dir[1]);
            eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            var Fg = kg * (degrees[i2] + 1);
            forces[2 * i2] -= Fg * dir[0];
            forces[2 * i2 + 1] -= Fg * dir[1];
          }
          return forces;
        };
        ForceAtlas2Layout3.prototype.updatePos = function(forces, preForces, sg, degrees) {
          var self2 = this;
          var nodes = self2.nodes, ks = self2.ks, tao = self2.tao, prune = self2.prune, ksmax = self2.ksmax;
          var nodeNum = nodes.length;
          var swgns = [];
          var trans = [];
          var swgG = 0;
          var traG = 0;
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees[i2] <= 1)
              continue;
            var minus = [
              forces[2 * i2] - preForces[2 * i2],
              forces[2 * i2 + 1] - preForces[2 * i2 + 1]
            ];
            var minusNorm = Math.hypot(minus[0], minus[1]);
            var add2 = [
              forces[2 * i2] + preForces[2 * i2],
              forces[2 * i2 + 1] + preForces[2 * i2 + 1]
            ];
            var addNorm = Math.hypot(add2[0], add2[1]);
            swgns[i2] = minusNorm;
            trans[i2] = addNorm / 2;
            swgG += (degrees[i2] + 1) * swgns[i2];
            traG += (degrees[i2] + 1) * trans[i2];
          }
          var preSG = sg;
          sg = tao * traG / swgG;
          if (preSG !== 0) {
            sg = sg > 1.5 * preSG ? 1.5 * preSG : sg;
          }
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            if (prune && degrees[i2] <= 1)
              continue;
            if ((0, util_1.isNumber)(nodes[i2].fx) && (0, util_1.isNumber)(nodes[i2].fy))
              continue;
            var sn2 = ks * sg / (1 + sg * Math.sqrt(swgns[i2]));
            var absForce = Math.hypot(forces[2 * i2], forces[2 * i2 + 1]);
            absForce = absForce < 1e-4 ? 1e-4 : absForce;
            var max4 = ksmax / absForce;
            sn2 = sn2 > max4 ? max4 : sn2;
            var dnx = sn2 * forces[2 * i2];
            var dny = sn2 * forces[2 * i2 + 1];
            nodes[i2].x += dnx;
            nodes[i2].y += dny;
          }
          return { nodes, sg };
        };
        return ForceAtlas2Layout3;
      }(base_1.Base)
    );
    exports.ForceAtlas2Layout = ForceAtlas2Layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/grid.js
var require_grid2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/grid.js"(exports) {
    "use strict";
    var __assign14 = exports && exports.__assign || function() {
      __assign14 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign14.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var Grid3 = (
      /** @class */
      function() {
        function Grid4() {
          this.cells = [];
          this.columnNum = 0;
          this.rowNum = 0;
          this.additionColumn = [];
          this.additionRow = [];
        }
        Grid4.prototype.init = function(width, height, gridSize) {
          this.cells = [];
          this.CELL_W = gridSize.CELL_W || Grid4.DEFAULT_CELL_W;
          this.CELL_H = gridSize.CELL_H || Grid4.DEFAULT_CELL_H;
          this.columnNum = Math.ceil(width / this.CELL_W);
          this.rowNum = Math.ceil(height / this.CELL_H);
          Grid4.MIN_DIST = Math.pow(width, 2) + Math.pow(height, 2);
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            var tmp = [];
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              var cell = {
                dx: i2,
                dy: j2,
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: false
              };
              tmp.push(cell);
            }
            this.cells.push(tmp);
          }
        };
        Grid4.prototype.findGridByNodeId = function(nodeId) {
          var _a2, _b;
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              if (this.cells[i2][j2].node) {
                if (((_b = (_a2 = this.cells[i2][j2]) === null || _a2 === void 0 ? void 0 : _a2.node) === null || _b === void 0 ? void 0 : _b.id) === nodeId) {
                  return { column: i2, row: j2 };
                }
              }
            }
          }
          return null;
        };
        Grid4.prototype.sqdist = function(a3, b2) {
          return Math.pow(a3.x - b2.x, 2) + Math.pow(a3.y - b2.y, 2);
        };
        Grid4.prototype.occupyNearest = function(p2) {
          var minDist = Grid4.MIN_DIST;
          var d2;
          var candidate = null;
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              if (!this.cells[i2][j2].occupied && (d2 = this.sqdist(p2, this.cells[i2][j2])) < minDist) {
                minDist = d2;
                candidate = this.cells[i2][j2];
              }
            }
          }
          if (candidate) {
            candidate.occupied = true;
          }
          return candidate;
        };
        Grid4.prototype.insertColumn = function(columnIndex, length) {
          if (length <= 0)
            return;
          for (var i2 = 0; i2 < length; i2++) {
            this.cells[i2 + this.columnNum] = [];
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              this.cells[i2 + this.columnNum][j2] = {
                dx: i2,
                dy: j2,
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: false,
                node: null
              };
            }
          }
          for (var i2 = this.columnNum - 1; i2 > columnIndex; i2--) {
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              this.cells[i2 + length][j2] = __assign14(__assign14({}, this.cells[i2][j2]), { x: (i2 + length) * this.CELL_W, y: j2 * this.CELL_H });
              this.cells[i2][j2] = {
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: true,
                node: null
              };
            }
          }
          for (var j2 = 0; j2 < this.additionColumn.length; j2++) {
            if (this.additionColumn[j2] >= columnIndex) {
              this.additionColumn[j2] += length;
            }
          }
          for (var i2 = 0; i2 < length; i2++) {
            this.additionColumn.push(columnIndex + i2 + 1);
          }
          this.columnNum += length;
        };
        Grid4.prototype.insertRow = function(rowIndex, length) {
          if (length <= 0)
            return;
          for (var j2 = 0; j2 < length; j2++) {
            for (var i2 = 0; i2 < this.columnNum; i2++) {
              this.cells[i2][j2 + this.rowNum] = {
                dx: i2,
                dy: j2,
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: false,
                node: null
              };
            }
          }
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            for (var j2 = this.rowNum - 1; j2 > rowIndex; j2--) {
              this.cells[i2][j2 + length] = __assign14(__assign14({}, this.cells[i2][j2]), { dx: i2, dy: j2 + length, x: i2 * this.CELL_W, y: (j2 + length) * this.CELL_H });
              this.cells[i2][j2] = {
                dx: i2,
                dy: j2,
                x: i2 * this.CELL_W,
                y: j2 * this.CELL_H,
                occupied: false,
                node: null
              };
            }
          }
          for (var j2 = 0; j2 < this.additionRow.length; j2++) {
            if (this.additionRow[j2] >= rowIndex) {
              this.additionRow[j2] += length;
            }
          }
          for (var i2 = 0; i2 < length; i2++) {
            this.additionRow.push(rowIndex + i2 + 1);
          }
          this.rowNum += length;
        };
        Grid4.prototype.getNodes = function() {
          var nodes = [];
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            for (var j2 = 0; j2 < this.rowNum; j2++) {
              if (this.cells[i2][j2].node) {
                nodes.push(this.cells[i2][j2]);
              }
            }
          }
          return nodes;
        };
        Grid4.MIN_DIST = 50;
        Grid4.DEFAULT_CELL_W = 80;
        Grid4.DEFAULT_CELL_H = 80;
        return Grid4;
      }()
    );
    exports.default = Grid3;
  }
});

// node_modules/@antv/layout/lib/layout/er/forceGrid.js
var require_forceGrid = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/forceGrid.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var grid_1 = __importDefault(require_grid2());
    function layout2(data, options) {
      if (!data.nodes || data.nodes.length === 0)
        return data;
      var width = options.width;
      var height = options.height;
      var nodeMinGap = options.nodeMinGap;
      var CELL_W = 1e4;
      var CELL_H = 1e4;
      data.nodes.forEach(function(node2) {
        var nodeWidth = node2.size[0] || 50;
        var nodeHeight = node2.size[1] || 50;
        CELL_W = Math.min(nodeWidth, CELL_W);
        CELL_H = Math.min(nodeHeight, CELL_H);
      });
      var grid = new grid_1.default();
      grid.init(width, height, {
        CELL_H,
        CELL_W
      });
      data.nodes.forEach(function(d2) {
        var gridpoint = grid.occupyNearest(d2);
        if (gridpoint) {
          gridpoint.node = {
            id: d2.id,
            size: d2.size
          };
          d2.x = gridpoint.x;
          d2.y = gridpoint.y;
          d2.dx = gridpoint.dx;
          d2.dy = gridpoint.dy;
        }
      });
      for (var i2 = 0; i2 < data.nodes.length; i2++) {
        var node = data.nodes[i2];
        var result = grid.findGridByNodeId(node.id);
        if (!result)
          throw new Error("can not find node cell");
        var column = result.column, row = result.row;
        if (node.size[0] + nodeMinGap > CELL_W) {
          var addGridSize = Math.ceil((node.size[0] + nodeMinGap) / CELL_W) - 1;
          var realAdd = addGridSize;
          for (var j2 = 0; j2 < addGridSize; j2++) {
            var hasColumn = grid.additionColumn.indexOf(column + j2 + 1) > -1;
            if (hasColumn && !grid.cells[column + j2 + 1][row].node) {
              realAdd--;
            } else {
              break;
            }
          }
          grid.insertColumn(column, realAdd);
        }
        if (node.size[1] + nodeMinGap > CELL_H) {
          var addGridSize = Math.ceil((node.size[1] + nodeMinGap) / CELL_H) - 1;
          var realAdd = addGridSize;
          for (var j2 = 0; j2 < addGridSize; j2++) {
            var hasColumn = grid.additionRow.indexOf(row + j2 + 1) > -1;
            if (hasColumn && !grid.cells[column][row + j2 + 1].node) {
              realAdd--;
            } else {
              break;
            }
          }
          grid.insertRow(row, realAdd);
        }
      }
      for (var i2 = 0; i2 < grid.columnNum; i2++) {
        var _loop_1 = function(j3) {
          var cell = grid.cells[i2][j3];
          if (cell.node) {
            var node2 = data.nodes.find(function(node3) {
              var _a2;
              return node3.id === ((_a2 = cell === null || cell === void 0 ? void 0 : cell.node) === null || _a2 === void 0 ? void 0 : _a2.id);
            });
            if (node2) {
              node2.x = cell.x + node2.size[0] / 2;
              node2.y = cell.y + node2.size[1] / 2;
            }
          }
        };
        for (var j2 = 0; j2 < grid.rowNum; j2++) {
          _loop_1(j2);
        }
      }
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/mysqlWorkbench.js
var require_mysqlWorkbench = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/mysqlWorkbench.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var graphWidth = 1200;
    var graphHeight = 800;
    var OVERLAP_QUOT = 1e7;
    var MIN_DIST = 10;
    var M_PI = 3.141592653589793;
    var M_PI_2 = 1.5707963267948966;
    var PI_38 = M_PI * 0.375;
    var PI_58 = M_PI * 0.625;
    var nodeEdgeMap = /* @__PURE__ */ new Map();
    var CELL_W = 10;
    var CELL_H = 10;
    var T2 = 0.8;
    var T_MIN = 0.1;
    var R2 = 0.5;
    function distanceToNode(node1, node2, isHoriz) {
      var x11 = node1.x - node1.size[0] / 2;
      var y11 = node1.y - node1.size[1] / 2;
      var x12 = node1.x + node1.size[0] / 2;
      var y12 = node1.y + node1.size[1] / 2;
      var x21 = node2.x - node2.size[0] / 2;
      var y21 = node2.y - node2.size[1] / 2;
      var x22 = node2.x + node2.size[0] / 2;
      var y22 = node2.y + node2.size[1] / 2;
      var cx1 = node1.x;
      var cy1 = node1.y;
      var cx2 = node2.x;
      var cy2 = node2.y;
      var dcx = cx2 - cx1;
      var qr2 = Math.atan2(dcx, cy2 - cy1);
      var dx = 0;
      var dy = 0;
      var l1 = 0;
      var l2 = 0;
      if (qr2 > M_PI_2) {
        dy = y11 - y22;
        dx = x21 - x12;
        l1 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
      } else if (0 < qr2 && qr2 <= M_PI_2) {
        dy = y21 - y12;
        dx = x21 - x12;
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      } else if (qr2 < -M_PI_2) {
        dy = y11 - y22;
        dx = -(x22 - x11);
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      } else {
        dy = y21 - y12;
        if (Math.abs(dcx) > (x12 - x11) / 2) {
          dx = x11 - x22;
        } else {
          dx = dcx;
        }
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx && qr2 !== 0 ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      }
      var aqr = parseFloat(qr2.toFixed(2));
      var newHoriz = isHoriz;
      if (isHoriz) {
        newHoriz = PI_38 < aqr && aqr < PI_58;
      }
      return {
        distance: Math.abs(l1 < l2 ? l1 : l2),
        isHoriz: newHoriz
      };
    }
    function calcNodePair(nodeA, nodeB) {
      var edges = nodeEdgeMap.get(nodeA.id) || [];
      var isLinked = edges.find(function(edge) {
        return edge.source === nodeB.id || edge.target === nodeB.id;
      });
      var areaA = nodeA.size[0] * nodeA.size[1];
      var areaB = nodeB.size[0] * nodeB.size[1];
      var node1 = areaA > areaB ? nodeB : nodeA;
      var node2 = areaA > areaB ? nodeA : nodeB;
      var x11 = node1.x - node1.size[0] / 2;
      var y11 = node1.y - node1.size[1] / 2;
      var x12 = node1.x + node1.size[0] / 2;
      var y12 = node1.y + node1.size[1] / 2;
      var x21 = node2.x - node2.size[0] / 2;
      var y21 = node2.y - node2.size[1] / 2;
      var x22 = node2.x + node2.size[0] / 2;
      var y22 = node2.y + node2.size[1] / 2;
      var cx1 = node1.x;
      var cy1 = node1.y;
      var cx2 = node2.x;
      var cy2 = node2.y;
      var isoverlap = x12 >= x21 && x22 >= x11 && y12 >= y21 && y22 >= y11;
      var e8 = 0;
      var distance6 = 0;
      if (isoverlap) {
        distance6 = Math.sqrt(Math.pow(cx2 - cx1, 2) + Math.pow(cy2 - cy1, 2));
        var sx1 = x11 > x21 ? x11 : x21;
        var sy1 = y11 > y21 ? y11 : y21;
        var sx2 = x12 < x22 ? x12 : x22;
        var sy2 = y12 < y22 ? y12 : y22;
        var dsx = sx2 - sx1;
        var dsy = sy2 - sy1;
        var sov = dsx * dsy;
        if (distance6 === 0) {
          distance6 = 1e-7;
        }
        e8 = MIN_DIST * 1 / distance6 * 100 + sov;
        e8 *= OVERLAP_QUOT;
      } else {
        var isHoriz = false;
        var res = distanceToNode(node1, node2, isHoriz);
        distance6 = res.distance;
        isHoriz = res.isHoriz;
        if (distance6 <= MIN_DIST) {
          if (distance6 !== 0) {
            if (isLinked) {
              e8 += MIN_DIST + OVERLAP_QUOT * 1 / distance6;
            } else {
              e8 += MIN_DIST + OVERLAP_QUOT * MIN_DIST / distance6;
            }
          } else {
            e8 += OVERLAP_QUOT;
          }
        } else {
          e8 += distance6;
          if (isLinked) {
            e8 += distance6 * distance6;
          }
        }
      }
      return e8;
    }
    function calcEnergy(nodes) {
      var energy = 0;
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (node.x < 0 || node.y < 0 || node.x > graphWidth || node.y > graphHeight) {
          energy += 1e12;
        }
        for (var j2 = i2 + 1; j2 < nodes.length; j2++) {
          energy += calcNodePair(node, nodes[j2]);
        }
      }
      return energy;
    }
    function isCorrectPosition(node, newPosition, nodes, edges) {
      var nodeIdxMap = /* @__PURE__ */ new Map();
      nodes.forEach(function(o2, i3) {
        nodeIdxMap.set(o2.id, o2);
      });
      var relateEdges = edges.filter(function(edge) {
        return edge.source === node.id || edge.target === node.id;
      }) || [];
      var relateNodes = [];
      relateEdges.forEach(function(edge) {
        var otherNodeId = edge.source === node.id ? edge.target : edge.source;
        var otherNode = nodeIdxMap.get(otherNodeId);
        if (otherNode) {
          relateNodes.push(otherNode);
        }
      });
      var flag = true;
      for (var i2 = 0; i2 < relateNodes.length; i2++) {
        var item = relateNodes[i2];
        var delta = Math.atan((node.y - item.y) / (item.x - node.y)) * 180;
        var newDelta = Math.atan((newPosition.y - item.y) / (item.x - newPosition.y)) * 180;
        var isHor = delta < 30 || delta > 150;
        var newIsHor = newDelta < 30 || newDelta > 150;
        var isVer = delta > 70 && delta < 110;
        var newIsVer = newDelta > 70 && newDelta < 110;
        if (isHor && !newIsHor || delta * newDelta < 0) {
          flag = false;
          break;
        } else if (isVer && !newIsVer || delta * newDelta < 0) {
          flag = false;
          break;
        } else if ((item.x - node.x) * (item.x - newPosition.x) < 0) {
          flag = false;
          break;
        } else if ((item.y - node.y) * (item.y - newPosition.y) < 0) {
          flag = false;
          break;
        }
      }
      return flag;
    }
    function shuffle(nodes, edges) {
      var foundSmallerEnergy = false;
      var step = 1;
      var wstep = CELL_W * step;
      var hstep = CELL_H * step;
      var wsteps = [wstep, -wstep, 0, 0];
      var hsteps = [0, 0, hstep, -hstep];
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        var node = nodes[i2];
        var nodeEnergy = calcNodeEnergy(node, nodes);
        for (var ns = 0; ns < wsteps.length; ns++) {
          var flag = isCorrectPosition(node, { x: node.x + wsteps[ns], y: node.y + hsteps[ns] }, nodes, edges);
          if (flag) {
            node.x += wsteps[ns];
            node.y += hsteps[ns];
            var energy = calcNodeEnergy(node, nodes);
            var rdm = Math.random();
            if (energy < nodeEnergy) {
              nodeEnergy = energy;
              foundSmallerEnergy = true;
            } else if (rdm < T2 && rdm > T_MIN) {
              nodeEnergy = energy;
              foundSmallerEnergy = true;
            } else {
              node.x -= wsteps[ns];
              node.y -= hsteps[ns];
            }
          }
        }
      }
      if (T2 > T_MIN) {
        T2 *= R2;
      }
      if (foundSmallerEnergy) {
        return calcEnergy(nodes);
      }
      return 0;
    }
    function calcNodeEnergy(node, nodes) {
      var e8 = 0;
      if (node.x < 0 || node.y < 0 || node.x + node.size[0] + 20 > graphWidth || node.y + node.size[1] + 20 > graphHeight) {
        e8 += 1e12;
      }
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        if (node.id !== nodes[i2].id) {
          e8 += calcNodePair(node, nodes[i2]);
        }
      }
      return e8;
    }
    function layout2(nodes, edges) {
      if (nodes.length === 0) {
        return { nodes, edges };
      }
      nodes.forEach(function(node) {
        var relateEdge = edges.filter(function(edge) {
          return edge.source === node.id || edge.target === node.id;
        });
        nodeEdgeMap.set(node, relateEdge);
      });
      nodes.sort(function(node1, node2) {
        var _a2, _b;
        return ((_a2 = nodeEdgeMap.get(node1.id)) === null || _a2 === void 0 ? void 0 : _a2.length) - ((_b = nodeEdgeMap.get(node2.id)) === null || _b === void 0 ? void 0 : _b.length);
      });
      var minEnergy = calcEnergy(nodes);
      var deSameCount = 20;
      var de2 = 1;
      var prevEnergy = 0;
      var MAX_COUNT = 50;
      var count = 0;
      while (deSameCount > 0) {
        count++;
        if (count >= MAX_COUNT) {
          break;
        }
        var ea2 = shuffle(nodes, edges);
        if (ea2 !== 0) {
          prevEnergy = ea2;
        }
        de2 = prevEnergy - minEnergy;
        minEnergy = prevEnergy;
        if (de2 === 0) {
          --deSameCount;
        } else {
          deSameCount = 20;
        }
      }
      nodes.forEach(function(node) {
        node.x = node.x - node.size[0] / 2;
        node.y = node.y - node.size[1] / 2;
      });
      return {
        nodes,
        edges
      };
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/core.js
var require_core = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/core.js"(exports) {
    "use strict";
    var __assign14 = exports && exports.__assign || function() {
      __assign14 = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign14.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
            __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3Force = __importStar((init_src4(), __toCommonJS(src_exports2)));
    var forceGrid_1 = __importDefault(require_forceGrid());
    var mysqlWorkbench_1 = __importDefault(require_mysqlWorkbench());
    var dagre_1 = require_dagre2();
    function layout2(data, options) {
      var nodes = data.nodes, edges = data.edges;
      var width = options.width;
      var height = options.height;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
        return Promise.resolve();
      var noLeafNodes = [];
      nodes.forEach(function(node) {
        var relateEdges = edges.filter(function(edge) {
          return edge.source === node.id || edge.target === node.id;
        });
        if (relateEdges.length > 1) {
          var temp = __assign14({}, node);
          delete temp.size;
          noLeafNodes.push(temp);
        }
      });
      var noLeafEdge = [];
      edges.forEach(function(edge) {
        var sourceNode = noLeafNodes.find(function(node) {
          return node.id === edge.source;
        });
        var targetNode = noLeafNodes.find(function(node) {
          return node.id === edge.target;
        });
        if (sourceNode && targetNode) {
          noLeafEdge.push(edge);
        }
      });
      var graphLayout = new dagre_1.DagreLayout({
        type: "dagre",
        ranksep: options.nodeMinGap,
        nodesep: options.nodeMinGap
      });
      var nodesTmp = graphLayout.layout({
        nodes: noLeafNodes,
        edges: noLeafEdge
      }).nodes;
      nodes.forEach(function(n2) {
        var found = (nodesTmp || []).find(function(temp) {
          return temp.id === n2.id;
        });
        n2.x = (found === null || found === void 0 ? void 0 : found.x) || width / 2;
        n2.y = (found === null || found === void 0 ? void 0 : found.y) || height / 2;
      });
      var copyNodes = JSON.parse(JSON.stringify(nodes));
      var copyEdges = JSON.parse(JSON.stringify(edges));
      var simulation = d3Force.forceSimulation().nodes(copyNodes).force("link", d3Force.forceLink(copyEdges).id(function(d2) {
        return d2.id;
      }).distance(function(d2) {
        var edgeInfo = noLeafEdge.find(function(edge) {
          return edge.source === d2.source && edge.target === d2.target;
        });
        if (edgeInfo) {
          return 30;
        }
        return 20;
      })).force("charge", d3Force.forceManyBody()).force("center", d3Force.forceCenter(width / 2, height / 2)).force("x", d3Force.forceX(width / 2)).force("y", d3Force.forceY(height / 2)).alpha(0.3).alphaDecay(0.08).alphaMin(1e-3);
      var layoutPromise = new Promise(function(resolve) {
        simulation.on("end", function() {
          nodes.forEach(function(node) {
            var nodeInfo = copyNodes.find(function(item) {
              return item.id === node.id;
            });
            if (nodeInfo) {
              node.x = nodeInfo.x;
              node.y = nodeInfo.y;
            }
          });
          var minX = Math.min.apply(Math, nodes.map(function(node) {
            return node.x;
          }));
          var maxX = Math.max.apply(Math, nodes.map(function(node) {
            return node.x;
          }));
          var minY = Math.min.apply(Math, nodes.map(function(node) {
            return node.y;
          }));
          var maxY = Math.max.apply(Math, nodes.map(function(node) {
            return node.y;
          }));
          var scalex = width / (maxX - minX);
          var scaley = height / (maxY - minY);
          nodes.forEach(function(node) {
            if (node.x !== void 0 && scalex < 1) {
              node.x = (node.x - minX) * scalex;
            }
            if (node.y !== void 0 && scaley < 1) {
              node.y = (node.y - minY) * scaley;
            }
          });
          nodes.forEach(function(node) {
            node.sizeTemp = node.size;
            node.size = [10, 10];
          });
          (0, mysqlWorkbench_1.default)(nodes, edges);
          nodes.forEach(function(node) {
            node.size = node.sizeTemp || [];
            delete node.sizeTemp;
          });
          (0, forceGrid_1.default)({
            nodes,
            edges
          }, options);
          resolve();
        });
      });
      return layoutPromise;
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/index.js
var require_er = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/index.js"(exports) {
    "use strict";
    var __extends15 = exports && exports.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERLayout = void 0;
    var base_1 = require_base();
    var core_1 = __importDefault(require_core());
    var ERLayout = (
      /** @class */
      function(_super) {
        __extends15(ERLayout2, _super);
        function ERLayout2(options) {
          var _this = _super.call(this) || this;
          _this.width = 300;
          _this.height = 300;
          _this.nodeMinGap = 50;
          _this.onLayoutEnd = function() {
          };
          if (options) {
            _this.updateCfg(options);
          }
          return _this;
        }
        ERLayout2.prototype.getDefaultCfg = function() {
          return {
            width: 300,
            height: 300,
            nodeMinGap: 50
          };
        };
        ERLayout2.prototype.execute = function() {
          var self2 = this;
          var nodes = self2.nodes;
          var edges = self2.edges;
          nodes === null || nodes === void 0 ? void 0 : nodes.forEach(function(node) {
            if (!node.size) {
              node.size = [50, 50];
            }
          });
          return (0, core_1.default)({
            nodes,
            edges
          }, {
            width: this.width,
            height: this.height,
            nodeMinGap: this.nodeMinGap
          }).then(function() {
            if (self2.onLayoutEnd)
              self2.onLayoutEnd();
          });
        };
        ERLayout2.prototype.getType = function() {
          return "er";
        };
        return ERLayout2;
      }(base_1.Base)
    );
    exports.ERLayout = ERLayout;
  }
});

// node_modules/@antv/layout/lib/layout/layout.js
var require_layout2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Layouts = exports.Layout = void 0;
    var registy_1 = require_registy();
    var grid_1 = require_grid();
    var random_1 = require_random();
    var force2_1 = require_force2();
    var gForce_1 = require_gForce();
    var force_1 = require_force3();
    var circular_1 = require_circular();
    var dagre_1 = require_dagre2();
    var radial_1 = require_radial2();
    var concentric_1 = require_concentric();
    var mds_1 = require_mds2();
    var fruchterman_1 = require_fruchterman();
    var fruchterman_2 = require_fruchterman2();
    var gForce_2 = require_gForce2();
    var comboForce_1 = require_comboForce();
    var comboCombined_1 = require_comboCombined();
    var forceAtlas2_1 = require_forceAtlas2();
    var er_1 = require_er();
    var dagreCompound_1 = require_dagreCompound();
    var util_1 = require_util2();
    var Layout2 = (
      /** @class */
      function() {
        function Layout3(options) {
          var layoutClass = (0, registy_1.getLayoutByName)(options.type);
          this.layoutInstance = new layoutClass(options);
        }
        Layout3.prototype.layout = function(data) {
          return this.layoutInstance.layout(data);
        };
        Layout3.prototype.updateCfg = function(cfg) {
          this.layoutInstance.updateCfg(cfg);
        };
        Layout3.prototype.init = function(data) {
          this.correctLayers(data.nodes);
          this.layoutInstance.init(data);
        };
        Layout3.prototype.correctLayers = function(nodes) {
          if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
          var minLayer = Infinity;
          var hasLayerNodes = [];
          nodes.forEach(function(node) {
            if ((0, util_1.isString)(node.layer)) {
              node.layer = parseInt(node.layer, 10);
            }
            if (node.layer === void 0 || isNaN(node.layer))
              return;
            hasLayerNodes.push(node);
            if (node.layer < minLayer)
              minLayer = node.layer;
          });
          if (minLayer <= 0) {
            var layerOffset_1 = Math.abs(minLayer) + 1;
            hasLayerNodes.forEach(function(node) {
              return node.layer += layerOffset_1;
            });
          }
        };
        Layout3.prototype.execute = function() {
          this.layoutInstance.execute();
        };
        Layout3.prototype.getDefaultCfg = function() {
          return this.layoutInstance.getDefaultCfg();
        };
        Layout3.prototype.destroy = function() {
          return this.layoutInstance.destroy();
        };
        return Layout3;
      }()
    );
    exports.Layout = Layout2;
    exports.Layouts = {
      force: force_1.ForceLayout,
      fruchterman: fruchterman_1.FruchtermanLayout,
      forceAtlas2: forceAtlas2_1.ForceAtlas2Layout,
      gForce: gForce_1.GForceLayout,
      force2: force2_1.Force2Layout,
      dagre: dagre_1.DagreLayout,
      dagreCompound: dagreCompound_1.DagreCompoundLayout,
      circular: circular_1.CircularLayout,
      radial: radial_1.RadialLayout,
      concentric: concentric_1.ConcentricLayout,
      grid: grid_1.GridLayout,
      mds: mds_1.MDSLayout,
      comboForce: comboForce_1.ComboForceLayout,
      comboCombined: comboCombined_1.ComboCombinedLayout,
      random: random_1.RandomLayout,
      "gForce-gpu": gForce_2.GForceGPULayout,
      "fruchterman-gpu": fruchterman_2.FruchtermanGPULayout,
      er: er_1.ERLayout
    };
  }
});

// node_modules/@antv/layout/lib/layout/types.js
var require_types2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@antv/layout/lib/layout/index.js
var require_layout3 = __commonJS({
  "node_modules/@antv/layout/lib/layout/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERLayout = exports.ForceAtlas2Layout = exports.ComboCombinedLayout = exports.ComboForceLayout = exports.GForceGPULayout = exports.FruchtermanGPULayout = exports.FruchtermanLayout = exports.MDSLayout = exports.ConcentricLayout = exports.RadialLayout = exports.DagreCompoundLayout = exports.DagreLayout = exports.CircularLayout = exports.ForceLayout = exports.Force2Layout = exports.GForceLayout = exports.RandomLayout = exports.GridLayout = exports.Layouts = exports.Layout = void 0;
    var grid_1 = require_grid();
    Object.defineProperty(exports, "GridLayout", { enumerable: true, get: function() {
      return grid_1.GridLayout;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports, "RandomLayout", { enumerable: true, get: function() {
      return random_1.RandomLayout;
    } });
    var gForce_1 = require_gForce();
    Object.defineProperty(exports, "GForceLayout", { enumerable: true, get: function() {
      return gForce_1.GForceLayout;
    } });
    var force2_1 = require_force2();
    Object.defineProperty(exports, "Force2Layout", { enumerable: true, get: function() {
      return force2_1.Force2Layout;
    } });
    var force_1 = require_force3();
    Object.defineProperty(exports, "ForceLayout", { enumerable: true, get: function() {
      return force_1.ForceLayout;
    } });
    var circular_1 = require_circular();
    Object.defineProperty(exports, "CircularLayout", { enumerable: true, get: function() {
      return circular_1.CircularLayout;
    } });
    var dagre_1 = require_dagre2();
    Object.defineProperty(exports, "DagreLayout", { enumerable: true, get: function() {
      return dagre_1.DagreLayout;
    } });
    var dagreCompound_1 = require_dagreCompound();
    Object.defineProperty(exports, "DagreCompoundLayout", { enumerable: true, get: function() {
      return dagreCompound_1.DagreCompoundLayout;
    } });
    var radial_1 = require_radial2();
    Object.defineProperty(exports, "RadialLayout", { enumerable: true, get: function() {
      return radial_1.RadialLayout;
    } });
    var concentric_1 = require_concentric();
    Object.defineProperty(exports, "ConcentricLayout", { enumerable: true, get: function() {
      return concentric_1.ConcentricLayout;
    } });
    var mds_1 = require_mds2();
    Object.defineProperty(exports, "MDSLayout", { enumerable: true, get: function() {
      return mds_1.MDSLayout;
    } });
    var fruchterman_1 = require_fruchterman();
    Object.defineProperty(exports, "FruchtermanLayout", { enumerable: true, get: function() {
      return fruchterman_1.FruchtermanLayout;
    } });
    var fruchterman_2 = require_fruchterman2();
    Object.defineProperty(exports, "FruchtermanGPULayout", { enumerable: true, get: function() {
      return fruchterman_2.FruchtermanGPULayout;
    } });
    var gForce_2 = require_gForce2();
    Object.defineProperty(exports, "GForceGPULayout", { enumerable: true, get: function() {
      return gForce_2.GForceGPULayout;
    } });
    var comboForce_1 = require_comboForce();
    Object.defineProperty(exports, "ComboForceLayout", { enumerable: true, get: function() {
      return comboForce_1.ComboForceLayout;
    } });
    var comboCombined_1 = require_comboCombined();
    Object.defineProperty(exports, "ComboCombinedLayout", { enumerable: true, get: function() {
      return comboCombined_1.ComboCombinedLayout;
    } });
    var forceAtlas2_1 = require_forceAtlas2();
    Object.defineProperty(exports, "ForceAtlas2Layout", { enumerable: true, get: function() {
      return forceAtlas2_1.ForceAtlas2Layout;
    } });
    var er_1 = require_er();
    Object.defineProperty(exports, "ERLayout", { enumerable: true, get: function() {
      return er_1.ERLayout;
    } });
    var layout_1 = require_layout2();
    Object.defineProperty(exports, "Layout", { enumerable: true, get: function() {
      return layout_1.Layout;
    } });
    Object.defineProperty(exports, "Layouts", { enumerable: true, get: function() {
      return layout_1.Layouts;
    } });
    __exportStar(require_types2(), exports);
  }
});

// node_modules/@antv/layout/lib/index.js
var require_lib = __commonJS({
  "node_modules/@antv/layout/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLayoutByName = exports.unRegisterLayout = exports.registerLayout = void 0;
    var registy_1 = require_registy();
    Object.defineProperty(exports, "registerLayout", { enumerable: true, get: function() {
      return registy_1.registerLayout;
    } });
    Object.defineProperty(exports, "unRegisterLayout", { enumerable: true, get: function() {
      return registy_1.unRegisterLayout;
    } });
    Object.defineProperty(exports, "getLayoutByName", { enumerable: true, get: function() {
      return registy_1.getLayoutByName;
    } });
    __exportStar(require_layout3(), exports);
  }
});

// node_modules/@antv/hierarchy/build/hierarchy.js
var require_hierarchy = __commonJS({
  "node_modules/@antv/hierarchy/build/hierarchy.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Hierarchy"] = factory();
      else
        root["Hierarchy"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 36);
        }([
          /* 0 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            __webpack_exports__["a"] = function(value) {
              return Array.isArray ? Array.isArray(value) : Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(value, "Array");
            };
          },
          /* 1 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var isArrayLike2 = function(value) {
              return value !== null && typeof value !== "function" && isFinite(value.length);
            };
            __webpack_exports__["a"] = isArrayLike2;
          },
          /* 2 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            __webpack_exports__["a"] = function(value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(value, "Function");
            };
          },
          /* 3 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var toString5 = {}.toString;
            var isType2 = function(value, type) {
              return toString5.call(value) === "[object " + type + "]";
            };
            __webpack_exports__["a"] = isType2;
          },
          /* 4 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            __webpack_exports__["a"] = function(str) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(str, "String");
            };
          },
          /* 5 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            var isNumber2 = function(value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(value, "Number");
            };
            __webpack_exports__["a"] = isNumber2;
          },
          /* 6 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var _require = __webpack_require__(38), mix3 = _require.mix;
            function getHeight(preNode, node, align, heightField) {
              if (heightField === void 0) {
                heightField = "height";
              }
              return align === "center" ? (preNode[heightField] + node[heightField]) / 2 : preNode.height;
            }
            module2.exports = {
              assign: mix3,
              getHeight
            };
          },
          /* 7 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var isNil2 = function(value) {
              return value === null || value === void 0;
            };
            __webpack_exports__["a"] = isNil2;
          },
          /* 8 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_object__ = __webpack_require__(12);
            function each2(elements, func) {
              if (!elements) {
                return;
              }
              var rst;
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(elements)) {
                for (var i2 = 0, len = elements.length; i2 < len; i2++) {
                  rst = func(elements[i2], i2);
                  if (rst === false) {
                    break;
                  }
                }
              } else if (Object(__WEBPACK_IMPORTED_MODULE_1__is_object__[
                "a"
                /* default */
              ])(elements)) {
                for (var k2 in elements) {
                  if (elements.hasOwnProperty(k2)) {
                    rst = func(elements[k2], k2);
                    if (rst === false) {
                      break;
                    }
                  }
                }
              }
            }
            __webpack_exports__["a"] = each2;
          },
          /* 9 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__(7);
            __webpack_exports__["a"] = function(value) {
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__[
                "a"
                /* default */
              ])(value))
                return "";
              return value.toString();
            };
          },
          /* 10 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_object_like__ = __webpack_require__(14);
            var __WEBPACK_IMPORTED_MODULE_1__is_type__ = __webpack_require__(3);
            var isPlainObject2 = function(value) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_object_like__[
                "a"
                /* default */
              ])(value) || !Object(__WEBPACK_IMPORTED_MODULE_1__is_type__[
                "a"
                /* default */
              ])(value, "Object")) {
                return false;
              }
              if (Object.getPrototypeOf(value) === null) {
                return true;
              }
              var proto = value;
              while (Object.getPrototypeOf(proto) !== null) {
                proto = Object.getPrototypeOf(proto);
              }
              return Object.getPrototypeOf(value) === proto;
            };
            __webpack_exports__["a"] = isPlainObject2;
          },
          /* 11 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var hierarchy = __webpack_require__(18);
            var Layout2 = function() {
              function Layout3(root, options) {
                if (options === void 0) {
                  options = {};
                }
                var me2 = this;
                me2.options = options;
                me2.rootNode = hierarchy(root, options);
              }
              var _proto = Layout3.prototype;
              _proto.execute = function execute() {
                throw new Error("please override this method");
              };
              return Layout3;
            }();
            module2.exports = Layout2;
          },
          /* 12 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = function(value) {
              var type = typeof value;
              return value !== null && type === "object" || type === "function";
            };
          },
          /* 13 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            var contains2 = function(arr, value) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(arr)) {
                return false;
              }
              return arr.indexOf(value) > -1;
            };
            __webpack_exports__["a"] = contains2;
          },
          /* 14 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var isObjectLike2 = function(value) {
              return typeof value === "object" && value !== null;
            };
            __webpack_exports__["a"] = isObjectLike2;
          },
          /* 15 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__(8);
            var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__(2);
            var values2 = Object.values ? function(obj) {
              return Object.values(obj);
            } : function(obj) {
              var result = [];
              Object(__WEBPACK_IMPORTED_MODULE_0__each__[
                "a"
                /* default */
              ])(obj, function(value, key) {
                if (!(Object(__WEBPACK_IMPORTED_MODULE_1__is_function__[
                  "a"
                  /* default */
                ])(obj) && key === "prototype")) {
                  result.push(value);
                }
              });
              return result;
            };
            __webpack_exports__["a"] = values2;
          },
          /* 16 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = mix3;
            function _mix2(dist, obj) {
              for (var key in obj) {
                if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
                  dist[key] = obj[key];
                }
              }
            }
            function mix3(dist, src1, src2, src3) {
              if (src1)
                _mix2(dist, src1);
              if (src2)
                _mix2(dist, src2);
              if (src3)
                _mix2(dist, src3);
              return dist;
            }
          },
          /* 17 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var separateTree = __webpack_require__(35);
            var VALID_DIRECTIONS = [
              "LR",
              // left to right
              "RL",
              // right to left
              "TB",
              // top to bottom
              "BT",
              // bottom to top
              "H",
              // horizontal
              "V"
              // vertical
            ];
            var HORIZONTAL_DIRECTIONS = ["LR", "RL", "H"];
            var isHorizontal = function isHorizontal2(direction2) {
              return HORIZONTAL_DIRECTIONS.indexOf(direction2) > -1;
            };
            var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
            module2.exports = function(root, options, layoutAlgrithm) {
              var direction2 = options.direction || DEFAULT_DIRECTION;
              options.isHorizontal = isHorizontal(direction2);
              if (direction2 && VALID_DIRECTIONS.indexOf(direction2) === -1) {
                throw new TypeError("Invalid direction: " + direction2);
              }
              if (direction2 === VALID_DIRECTIONS[0]) {
                layoutAlgrithm(root, options);
              } else if (direction2 === VALID_DIRECTIONS[1]) {
                layoutAlgrithm(root, options);
                root.right2left();
              } else if (direction2 === VALID_DIRECTIONS[2]) {
                layoutAlgrithm(root, options);
              } else if (direction2 === VALID_DIRECTIONS[3]) {
                layoutAlgrithm(root, options);
                root.bottom2top();
              } else if (direction2 === VALID_DIRECTIONS[4] || direction2 === VALID_DIRECTIONS[5]) {
                var _separateTree = separateTree(root, options), left = _separateTree.left, right = _separateTree.right;
                layoutAlgrithm(left, options);
                layoutAlgrithm(right, options);
                options.isHorizontal ? left.right2left() : left.bottom2top();
                right.translate(left.x - right.x, left.y - right.y);
                root.x = left.x;
                root.y = right.y;
                var bb = root.getBoundingBox();
                if (options.isHorizontal) {
                  if (bb.top < 0) {
                    root.translate(0, -bb.top);
                  }
                } else {
                  if (bb.left < 0) {
                    root.translate(-bb.left, 0);
                  }
                }
              }
              var fixedRoot = options.fixedRoot;
              if (fixedRoot === void 0)
                fixedRoot = true;
              if (fixedRoot) {
                root.translate(-(root.x + root.width / 2 + root.hgap), -(root.y + root.height / 2 + root.vgap));
              }
              return root;
            };
          },
          /* 18 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var util = __webpack_require__(6);
            var PEM = 18;
            var DEFAULT_HEIGHT = PEM * 2;
            var DEFAULT_GAP = PEM;
            var DEFAULT_OPTIONS = {
              getId: function getId(d2) {
                return d2.id || d2.name;
              },
              getPreH: function getPreH(d2) {
                return d2.preH || 0;
              },
              getPreV: function getPreV(d2) {
                return d2.preV || 0;
              },
              getHGap: function getHGap(d2) {
                return d2.hgap || DEFAULT_GAP;
              },
              getVGap: function getVGap(d2) {
                return d2.vgap || DEFAULT_GAP;
              },
              getChildren: function getChildren(d2) {
                return d2.children;
              },
              getHeight: function getHeight(d2) {
                return d2.height || DEFAULT_HEIGHT;
              },
              getWidth: function getWidth(d2) {
                var label = d2.label || " ";
                return d2.width || label.split("").length * PEM;
              }
            };
            function Node3(data, options) {
              var me2 = this;
              me2.vgap = me2.hgap = 0;
              if (data instanceof Node3)
                return data;
              me2.data = data;
              var hgap = options.getHGap(data);
              var vgap = options.getVGap(data);
              me2.preH = options.getPreH(data);
              me2.preV = options.getPreV(data);
              me2.width = options.getWidth(data);
              me2.height = options.getHeight(data);
              me2.width += me2.preH;
              me2.height += me2.preV;
              me2.id = options.getId(data);
              me2.x = me2.y = 0;
              me2.depth = 0;
              if (!me2.children) {
                me2.children = [];
              }
              me2.addGap(hgap, vgap);
              return me2;
            }
            util.assign(Node3.prototype, {
              isRoot: function isRoot() {
                return this.depth === 0;
              },
              isLeaf: function isLeaf() {
                return this.children.length === 0;
              },
              addGap: function addGap(hgap, vgap) {
                var me2 = this;
                me2.hgap += hgap;
                me2.vgap += vgap;
                me2.width += 2 * hgap;
                me2.height += 2 * vgap;
              },
              eachNode: function eachNode(callback) {
                var me2 = this;
                var nodes = [me2];
                var current;
                while (current = nodes.shift()) {
                  callback(current);
                  nodes = current.children.concat(nodes);
                }
              },
              DFTraverse: function DFTraverse(callback) {
                this.eachNode(callback);
              },
              BFTraverse: function BFTraverse(callback) {
                var me2 = this;
                var nodes = [me2];
                var current;
                while (current = nodes.shift()) {
                  callback(current);
                  nodes = nodes.concat(current.children);
                }
              },
              getBoundingBox: function getBoundingBox() {
                var bb = {
                  left: Number.MAX_VALUE,
                  top: Number.MAX_VALUE,
                  width: 0,
                  height: 0
                };
                this.eachNode(function(node) {
                  bb.left = Math.min(bb.left, node.x);
                  bb.top = Math.min(bb.top, node.y);
                  bb.width = Math.max(bb.width, node.x + node.width);
                  bb.height = Math.max(bb.height, node.y + node.height);
                });
                return bb;
              },
              // translate
              translate: function translate3(tx, ty) {
                if (tx === void 0) {
                  tx = 0;
                }
                if (ty === void 0) {
                  ty = 0;
                }
                this.eachNode(function(node) {
                  node.x += tx;
                  node.y += ty;
                  node.x += node.preH;
                  node.y += node.preV;
                });
              },
              right2left: function right2left() {
                var me2 = this;
                var bb = me2.getBoundingBox();
                me2.eachNode(function(node) {
                  node.x = node.x - (node.x - bb.left) * 2 - node.width;
                });
                me2.translate(bb.width, 0);
              },
              bottom2top: function bottom2top() {
                var me2 = this;
                var bb = me2.getBoundingBox();
                me2.eachNode(function(node) {
                  node.y = node.y - (node.y - bb.top) * 2 - node.height;
                });
                me2.translate(0, bb.height);
              }
            });
            function hierarchy(data, options, isolated) {
              if (options === void 0) {
                options = {};
              }
              options = util.assign({}, DEFAULT_OPTIONS, options);
              var root = new Node3(data, options);
              var nodes = [root];
              var node;
              if (!isolated && !data.collapsed) {
                while (node = nodes.shift()) {
                  if (!node.data.collapsed) {
                    var children = options.getChildren(node.data);
                    var length = children ? children.length : 0;
                    node.children = new Array(length);
                    if (children && length) {
                      for (var i2 = 0; i2 < length; i2++) {
                        var child = new Node3(children[i2], options);
                        node.children[i2] = child;
                        nodes.push(child);
                        child.parent = node;
                        child.depth = node.depth + 1;
                      }
                    }
                  }
                }
              }
              return root;
            }
            module2.exports = hierarchy;
          },
          /* 19 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            var filter2 = function(arr, func) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(arr)) {
                return arr;
              }
              var result = [];
              for (var index2 = 0; index2 < arr.length; index2++) {
                var value = arr[index2];
                if (func(value, index2)) {
                  result.push(value);
                }
              }
              return result;
            };
            __webpack_exports__["a"] = filter2;
          },
          /* 20 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__(7);
            var __WEBPACK_IMPORTED_MODULE_1__keys__ = __webpack_require__(21);
            function isMatch2(obj, attrs) {
              var _keys = Object(__WEBPACK_IMPORTED_MODULE_1__keys__[
                "a"
                /* default */
              ])(attrs);
              var length = _keys.length;
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__[
                "a"
                /* default */
              ])(obj))
                return !length;
              for (var i2 = 0; i2 < length; i2 += 1) {
                var key = _keys[i2];
                if (attrs[key] !== obj[key] || !(key in obj)) {
                  return false;
                }
              }
              return true;
            }
            __webpack_exports__["a"] = isMatch2;
          },
          /* 21 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__(8);
            var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__(2);
            var keys2 = Object.keys ? function(obj) {
              return Object.keys(obj);
            } : function(obj) {
              var result = [];
              Object(__WEBPACK_IMPORTED_MODULE_0__each__[
                "a"
                /* default */
              ])(obj, function(value, key) {
                if (!(Object(__WEBPACK_IMPORTED_MODULE_1__is_function__[
                  "a"
                  /* default */
                ])(obj) && key === "prototype")) {
                  result.push(key);
                }
              });
              return result;
            };
            __webpack_exports__["a"] = keys2;
          },
          /* 22 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            __webpack_exports__["a"] = function(arr) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(arr)) {
                return void 0;
              }
              return arr.reduce(function(prev, curr) {
                return Math.max(prev, curr);
              }, arr[0]);
            };
          },
          /* 23 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            __webpack_exports__["a"] = function(arr) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(arr)) {
                return void 0;
              }
              return arr.reduce(function(prev, curr) {
                return Math.min(prev, curr);
              }, arr[0]);
            };
          },
          /* 24 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            var splice3 = Array.prototype.splice;
            var pullAt3 = function pullAt4(arr, indexes) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(arr)) {
                return [];
              }
              var length = arr ? indexes.length : 0;
              var last2 = length - 1;
              while (length--) {
                var previous = void 0;
                var index2 = indexes[length];
                if (length === last2 || index2 !== previous) {
                  previous = index2;
                  splice3.call(arr, index2, 1);
                }
              }
              return arr;
            };
            __webpack_exports__["a"] = pullAt3;
          },
          /* 25 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__(8);
            var __WEBPACK_IMPORTED_MODULE_1__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_2__is_plain_object__ = __webpack_require__(10);
            var reduce2 = function(arr, fn2, init) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_array__[
                "a"
                /* default */
              ])(arr) && !Object(__WEBPACK_IMPORTED_MODULE_2__is_plain_object__[
                "a"
                /* default */
              ])(arr)) {
                return arr;
              }
              var result = init;
              Object(__WEBPACK_IMPORTED_MODULE_0__each__[
                "a"
                /* default */
              ])(arr, function(data, i2) {
                result = fn2(result, data, i2);
              });
              return result;
            };
            __webpack_exports__["a"] = reduce2;
          },
          /* 26 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = uniq3;
            function uniq3(arr, cache2) {
              if (cache2 === void 0) {
                cache2 = /* @__PURE__ */ new Map();
              }
              var r2 = [];
              if (Array.isArray(arr)) {
                for (var i2 = 0, len = arr.length; i2 < len; i2++) {
                  var item = arr[i2];
                  if (!cache2.has(item)) {
                    r2.push(item);
                    cache2.set(item, true);
                  }
                }
              }
              return r2;
            }
          },
          /* 27 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = groupToMap2;
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__(2);
            var __WEBPACK_IMPORTED_MODULE_2__group_by__ = __webpack_require__(28);
            function groupToMap2(data, condition) {
              if (!condition) {
                return {
                  0: data
                };
              }
              if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_function__[
                "a"
                /* default */
              ])(condition)) {
                var paramscondition_1 = Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                  "a"
                  /* default */
                ])(condition) ? condition : condition.replace(/\s+/g, "").split("*");
                condition = function(row) {
                  var unique = "_";
                  for (var i2 = 0, l2 = paramscondition_1.length; i2 < l2; i2++) {
                    unique += row[paramscondition_1[i2]] && row[paramscondition_1[i2]].toString();
                  }
                  return unique;
                };
              }
              return Object(__WEBPACK_IMPORTED_MODULE_2__group_by__[
                "a"
                /* default */
              ])(data, condition);
            }
          },
          /* 28 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__(2);
            var hasOwnProperty4 = Object.prototype.hasOwnProperty;
            function groupBy2(data, condition) {
              if (!condition || !Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(data)) {
                return {};
              }
              var result = {};
              var predicate = Object(__WEBPACK_IMPORTED_MODULE_1__is_function__[
                "a"
                /* default */
              ])(condition) ? condition : function(item2) {
                return item2[condition];
              };
              var key;
              for (var i2 = 0; i2 < data.length; i2++) {
                var item = data[i2];
                key = predicate(item);
                if (hasOwnProperty4.call(result, key)) {
                  result[key].push(item);
                } else {
                  result[key] = [item];
                }
              }
              return result;
            }
            __webpack_exports__["a"] = groupBy2;
          },
          /* 29 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = function(obj, key) {
              return obj.hasOwnProperty(key);
            };
          },
          /* 30 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var toString5 = {}.toString;
            var getType2 = function(value) {
              return toString5.call(value).replace(/^\[object /, "").replace(/]$/, "");
            };
            __webpack_exports__["a"] = getType2;
          },
          /* 31 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var objectProto2 = Object.prototype;
            var isPrototype2 = function(value) {
              var Ctor = value && value.constructor;
              var proto = typeof Ctor === "function" && Ctor.prototype || objectProto2;
              return value === proto;
            };
            __webpack_exports__["a"] = isPrototype2;
          },
          /* 32 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_function__ = __webpack_require__(2);
            __webpack_exports__["a"] = function(f2, resolver) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_function__[
                "a"
                /* default */
              ])(f2)) {
                throw new TypeError("Expected a function");
              }
              var memoized = function() {
                var args = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  args[_i2] = arguments[_i2];
                }
                var key = resolver ? resolver.apply(this, args) : args[0];
                var cache2 = memoized.cache;
                if (cache2.has(key)) {
                  return cache2.get(key);
                }
                var result = f2.apply(this, args);
                cache2.set(key, result);
                return result;
              };
              memoized.cache = /* @__PURE__ */ new Map();
              return memoized;
            };
          },
          /* 33 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_object_like__ = __webpack_require__(14);
            var __WEBPACK_IMPORTED_MODULE_1__is_array_like__ = __webpack_require__(1);
            var __WEBPACK_IMPORTED_MODULE_2__is_string__ = __webpack_require__(4);
            var isEqual2 = function(value, other) {
              if (value === other) {
                return true;
              }
              if (!value || !other) {
                return false;
              }
              if (Object(__WEBPACK_IMPORTED_MODULE_2__is_string__[
                "a"
                /* default */
              ])(value) || Object(__WEBPACK_IMPORTED_MODULE_2__is_string__[
                "a"
                /* default */
              ])(other)) {
                return false;
              }
              if (Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__[
                "a"
                /* default */
              ])(value) || Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__[
                "a"
                /* default */
              ])(other)) {
                if (value.length !== other.length) {
                  return false;
                }
                var rst = true;
                for (var i2 = 0; i2 < value.length; i2++) {
                  rst = isEqual2(value[i2], other[i2]);
                  if (!rst) {
                    break;
                  }
                }
                return rst;
              }
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_object_like__[
                "a"
                /* default */
              ])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__is_object_like__[
                "a"
                /* default */
              ])(other)) {
                var valueKeys = Object.keys(value);
                var otherKeys = Object.keys(other);
                if (valueKeys.length !== otherKeys.length) {
                  return false;
                }
                var rst = true;
                for (var i2 = 0; i2 < valueKeys.length; i2++) {
                  rst = isEqual2(value[valueKeys[i2]], other[valueKeys[i2]]);
                  if (!rst) {
                    break;
                  }
                }
                return rst;
              }
              return false;
            };
            __webpack_exports__["a"] = isEqual2;
          },
          /* 34 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(116);
            var __WEBPACK_IMPORTED_MODULE_1__values__ = __webpack_require__(15);
            var __WEBPACK_IMPORTED_MODULE_2__memoize__ = __webpack_require__(32);
            var __WEBPACK_IMPORTED_MODULE_3__is_string__ = __webpack_require__(4);
            var ctx;
            __webpack_exports__["a"] = Object(__WEBPACK_IMPORTED_MODULE_2__memoize__[
              "a"
              /* default */
            ])(function(text, font) {
              if (font === void 0) {
                font = {};
              }
              var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
              if (!ctx) {
                ctx = document.createElement("canvas").getContext("2d");
              }
              ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
              return ctx.measureText(Object(__WEBPACK_IMPORTED_MODULE_3__is_string__[
                "a"
                /* default */
              ])(text) ? text : "").width;
            }, function(text, font) {
              if (font === void 0) {
                font = {};
              }
              return Object(__WEBPACK_IMPORTED_MODULE_0_tslib__[
                "a"
                /* __spreadArrays */
              ])([text], Object(__WEBPACK_IMPORTED_MODULE_1__values__[
                "a"
                /* default */
              ])(font)).join("");
            });
          },
          /* 35 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var hierarchy = __webpack_require__(18);
            module2.exports = function(root, options) {
              var left = hierarchy(root.data, options, true);
              var right = hierarchy(root.data, options, true);
              var treeSize = root.children.length;
              var rightTreeSize = Math.round(treeSize / 2);
              var getSide = options.getSide || function(child2, index2) {
                if (index2 < rightTreeSize) {
                  return "right";
                }
                return "left";
              };
              for (var i2 = 0; i2 < treeSize; i2++) {
                var child = root.children[i2];
                var side = getSide(child, i2);
                if (side === "right") {
                  right.children.push(child);
                } else {
                  left.children.push(child);
                }
              }
              left.eachNode(function(node) {
                if (!node.isRoot()) {
                  node.side = "left";
                }
              });
              right.eachNode(function(node) {
                if (!node.isRoot()) {
                  node.side = "right";
                }
              });
              return {
                left,
                right
              };
            };
          },
          /* 36 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var hierarchy = {
              compactBox: __webpack_require__(37),
              dendrogram: __webpack_require__(120),
              indented: __webpack_require__(122),
              mindmap: __webpack_require__(124)
            };
            module2.exports = hierarchy;
          },
          /* 37 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf3(subClass, superClass);
            }
            function _setPrototypeOf3(o2, p2) {
              _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o3, p3) {
                o3.__proto__ = p3;
                return o3;
              };
              return _setPrototypeOf3(o2, p2);
            }
            var TreeLayout2 = __webpack_require__(11);
            var nonLayeredTidyTree = __webpack_require__(119);
            var doTreeLayout = __webpack_require__(17);
            var util = __webpack_require__(6);
            var CompactBoxTreeLayout = function(_TreeLayout) {
              _inheritsLoose(CompactBoxTreeLayout2, _TreeLayout);
              function CompactBoxTreeLayout2() {
                return _TreeLayout.apply(this, arguments) || this;
              }
              var _proto = CompactBoxTreeLayout2.prototype;
              _proto.execute = function execute() {
                var me2 = this;
                return doTreeLayout(me2.rootNode, me2.options, nonLayeredTidyTree);
              };
              return CompactBoxTreeLayout2;
            }(TreeLayout2);
            var DEFAULT_OPTIONS = {};
            function compactBoxLayout(root, options) {
              options = util.assign({}, DEFAULT_OPTIONS, options);
              return new CompactBoxTreeLayout(root, options).execute();
            }
            module2.exports = compactBoxLayout;
          },
          /* 38 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
            var __WEBPACK_IMPORTED_MODULE_0__contains__ = __webpack_require__(13);
            __webpack_require__.d(__webpack_exports__, "contains", function() {
              return __WEBPACK_IMPORTED_MODULE_0__contains__["a"];
            });
            __webpack_require__.d(__webpack_exports__, "includes", function() {
              return __WEBPACK_IMPORTED_MODULE_0__contains__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_1__difference__ = __webpack_require__(39);
            __webpack_require__.d(__webpack_exports__, "difference", function() {
              return __WEBPACK_IMPORTED_MODULE_1__difference__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_2__find__ = __webpack_require__(40);
            __webpack_require__.d(__webpack_exports__, "find", function() {
              return __WEBPACK_IMPORTED_MODULE_2__find__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_3__find_index__ = __webpack_require__(41);
            __webpack_require__.d(__webpack_exports__, "findIndex", function() {
              return __WEBPACK_IMPORTED_MODULE_3__find_index__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_4__first_value__ = __webpack_require__(42);
            __webpack_require__.d(__webpack_exports__, "firstValue", function() {
              return __WEBPACK_IMPORTED_MODULE_4__first_value__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_5__flatten__ = __webpack_require__(43);
            __webpack_require__.d(__webpack_exports__, "flatten", function() {
              return __WEBPACK_IMPORTED_MODULE_5__flatten__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_6__flatten_deep__ = __webpack_require__(44);
            __webpack_require__.d(__webpack_exports__, "flattenDeep", function() {
              return __WEBPACK_IMPORTED_MODULE_6__flatten_deep__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_7__get_range__ = __webpack_require__(45);
            __webpack_require__.d(__webpack_exports__, "getRange", function() {
              return __WEBPACK_IMPORTED_MODULE_7__get_range__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_8__pull__ = __webpack_require__(46);
            __webpack_require__.d(__webpack_exports__, "pull", function() {
              return __WEBPACK_IMPORTED_MODULE_8__pull__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_9__pull_at__ = __webpack_require__(24);
            __webpack_require__.d(__webpack_exports__, "pullAt", function() {
              return __WEBPACK_IMPORTED_MODULE_9__pull_at__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_10__reduce__ = __webpack_require__(25);
            __webpack_require__.d(__webpack_exports__, "reduce", function() {
              return __WEBPACK_IMPORTED_MODULE_10__reduce__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_11__remove__ = __webpack_require__(47);
            __webpack_require__.d(__webpack_exports__, "remove", function() {
              return __WEBPACK_IMPORTED_MODULE_11__remove__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_12__sort_by__ = __webpack_require__(48);
            __webpack_require__.d(__webpack_exports__, "sortBy", function() {
              return __WEBPACK_IMPORTED_MODULE_12__sort_by__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_13__union__ = __webpack_require__(49);
            __webpack_require__.d(__webpack_exports__, "union", function() {
              return __WEBPACK_IMPORTED_MODULE_13__union__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_14__uniq__ = __webpack_require__(26);
            __webpack_require__.d(__webpack_exports__, "uniq", function() {
              return __WEBPACK_IMPORTED_MODULE_14__uniq__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_15__values_of_key__ = __webpack_require__(50);
            __webpack_require__.d(__webpack_exports__, "valuesOfKey", function() {
              return __WEBPACK_IMPORTED_MODULE_15__values_of_key__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_16__head__ = __webpack_require__(51);
            __webpack_require__.d(__webpack_exports__, "head", function() {
              return __WEBPACK_IMPORTED_MODULE_16__head__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_17__last__ = __webpack_require__(52);
            __webpack_require__.d(__webpack_exports__, "last", function() {
              return __WEBPACK_IMPORTED_MODULE_17__last__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_18__starts_with__ = __webpack_require__(53);
            __webpack_require__.d(__webpack_exports__, "startsWith", function() {
              return __WEBPACK_IMPORTED_MODULE_18__starts_with__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_19__ends_with__ = __webpack_require__(54);
            __webpack_require__.d(__webpack_exports__, "endsWith", function() {
              return __WEBPACK_IMPORTED_MODULE_19__ends_with__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_20__filter__ = __webpack_require__(19);
            __webpack_require__.d(__webpack_exports__, "filter", function() {
              return __WEBPACK_IMPORTED_MODULE_20__filter__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_21__every__ = __webpack_require__(55);
            __webpack_require__.d(__webpack_exports__, "every", function() {
              return __WEBPACK_IMPORTED_MODULE_21__every__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_22__some__ = __webpack_require__(56);
            __webpack_require__.d(__webpack_exports__, "some", function() {
              return __WEBPACK_IMPORTED_MODULE_22__some__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_23__group__ = __webpack_require__(57);
            __webpack_require__.d(__webpack_exports__, "group", function() {
              return __WEBPACK_IMPORTED_MODULE_23__group__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_24__group_by__ = __webpack_require__(28);
            __webpack_require__.d(__webpack_exports__, "groupBy", function() {
              return __WEBPACK_IMPORTED_MODULE_24__group_by__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_25__group_to_map__ = __webpack_require__(27);
            __webpack_require__.d(__webpack_exports__, "groupToMap", function() {
              return __WEBPACK_IMPORTED_MODULE_25__group_to_map__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_26__get_wrap_behavior__ = __webpack_require__(58);
            __webpack_require__.d(__webpack_exports__, "getWrapBehavior", function() {
              return __WEBPACK_IMPORTED_MODULE_26__get_wrap_behavior__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_27__wrap_behavior__ = __webpack_require__(59);
            __webpack_require__.d(__webpack_exports__, "wrapBehavior", function() {
              return __WEBPACK_IMPORTED_MODULE_27__wrap_behavior__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_28__number2color__ = __webpack_require__(60);
            __webpack_require__.d(__webpack_exports__, "number2color", function() {
              return __WEBPACK_IMPORTED_MODULE_28__number2color__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_29__parse_radius__ = __webpack_require__(61);
            __webpack_require__.d(__webpack_exports__, "parseRadius", function() {
              return __WEBPACK_IMPORTED_MODULE_29__parse_radius__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_30__clamp__ = __webpack_require__(62);
            __webpack_require__.d(__webpack_exports__, "clamp", function() {
              return __WEBPACK_IMPORTED_MODULE_30__clamp__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_31__fixed_base__ = __webpack_require__(63);
            __webpack_require__.d(__webpack_exports__, "fixedBase", function() {
              return __WEBPACK_IMPORTED_MODULE_31__fixed_base__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_32__is_decimal__ = __webpack_require__(64);
            __webpack_require__.d(__webpack_exports__, "isDecimal", function() {
              return __WEBPACK_IMPORTED_MODULE_32__is_decimal__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_33__is_even__ = __webpack_require__(65);
            __webpack_require__.d(__webpack_exports__, "isEven", function() {
              return __WEBPACK_IMPORTED_MODULE_33__is_even__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_34__is_integer__ = __webpack_require__(66);
            __webpack_require__.d(__webpack_exports__, "isInteger", function() {
              return __WEBPACK_IMPORTED_MODULE_34__is_integer__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_35__is_negative__ = __webpack_require__(67);
            __webpack_require__.d(__webpack_exports__, "isNegative", function() {
              return __WEBPACK_IMPORTED_MODULE_35__is_negative__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_36__is_number_equal__ = __webpack_require__(68);
            __webpack_require__.d(__webpack_exports__, "isNumberEqual", function() {
              return __WEBPACK_IMPORTED_MODULE_36__is_number_equal__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_37__is_odd__ = __webpack_require__(69);
            __webpack_require__.d(__webpack_exports__, "isOdd", function() {
              return __WEBPACK_IMPORTED_MODULE_37__is_odd__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_38__is_positive__ = __webpack_require__(70);
            __webpack_require__.d(__webpack_exports__, "isPositive", function() {
              return __WEBPACK_IMPORTED_MODULE_38__is_positive__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_39__max__ = __webpack_require__(22);
            __webpack_require__.d(__webpack_exports__, "max", function() {
              return __WEBPACK_IMPORTED_MODULE_39__max__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_40__max_by__ = __webpack_require__(71);
            __webpack_require__.d(__webpack_exports__, "maxBy", function() {
              return __WEBPACK_IMPORTED_MODULE_40__max_by__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_41__min__ = __webpack_require__(23);
            __webpack_require__.d(__webpack_exports__, "min", function() {
              return __WEBPACK_IMPORTED_MODULE_41__min__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_42__min_by__ = __webpack_require__(72);
            __webpack_require__.d(__webpack_exports__, "minBy", function() {
              return __WEBPACK_IMPORTED_MODULE_42__min_by__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_43__mod__ = __webpack_require__(73);
            __webpack_require__.d(__webpack_exports__, "mod", function() {
              return __WEBPACK_IMPORTED_MODULE_43__mod__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_44__to_degree__ = __webpack_require__(74);
            __webpack_require__.d(__webpack_exports__, "toDegree", function() {
              return __WEBPACK_IMPORTED_MODULE_44__to_degree__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_45__to_integer__ = __webpack_require__(75);
            __webpack_require__.d(__webpack_exports__, "toInteger", function() {
              return __WEBPACK_IMPORTED_MODULE_45__to_integer__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_46__to_radian__ = __webpack_require__(76);
            __webpack_require__.d(__webpack_exports__, "toRadian", function() {
              return __WEBPACK_IMPORTED_MODULE_46__to_radian__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_47__for_in__ = __webpack_require__(77);
            __webpack_require__.d(__webpack_exports__, "forIn", function() {
              return __WEBPACK_IMPORTED_MODULE_47__for_in__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_48__has__ = __webpack_require__(29);
            __webpack_require__.d(__webpack_exports__, "has", function() {
              return __WEBPACK_IMPORTED_MODULE_48__has__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_49__has_key__ = __webpack_require__(78);
            __webpack_require__.d(__webpack_exports__, "hasKey", function() {
              return __WEBPACK_IMPORTED_MODULE_49__has_key__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_50__has_value__ = __webpack_require__(79);
            __webpack_require__.d(__webpack_exports__, "hasValue", function() {
              return __WEBPACK_IMPORTED_MODULE_50__has_value__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_51__keys__ = __webpack_require__(21);
            __webpack_require__.d(__webpack_exports__, "keys", function() {
              return __WEBPACK_IMPORTED_MODULE_51__keys__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_52__is_match__ = __webpack_require__(20);
            __webpack_require__.d(__webpack_exports__, "isMatch", function() {
              return __WEBPACK_IMPORTED_MODULE_52__is_match__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_53__values__ = __webpack_require__(15);
            __webpack_require__.d(__webpack_exports__, "values", function() {
              return __WEBPACK_IMPORTED_MODULE_53__values__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_54__lower_case__ = __webpack_require__(80);
            __webpack_require__.d(__webpack_exports__, "lowerCase", function() {
              return __WEBPACK_IMPORTED_MODULE_54__lower_case__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_55__lower_first__ = __webpack_require__(81);
            __webpack_require__.d(__webpack_exports__, "lowerFirst", function() {
              return __WEBPACK_IMPORTED_MODULE_55__lower_first__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_56__substitute__ = __webpack_require__(82);
            __webpack_require__.d(__webpack_exports__, "substitute", function() {
              return __WEBPACK_IMPORTED_MODULE_56__substitute__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_57__upper_case__ = __webpack_require__(83);
            __webpack_require__.d(__webpack_exports__, "upperCase", function() {
              return __WEBPACK_IMPORTED_MODULE_57__upper_case__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_58__upper_first__ = __webpack_require__(84);
            __webpack_require__.d(__webpack_exports__, "upperFirst", function() {
              return __WEBPACK_IMPORTED_MODULE_58__upper_first__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_59__get_type__ = __webpack_require__(30);
            __webpack_require__.d(__webpack_exports__, "getType", function() {
              return __WEBPACK_IMPORTED_MODULE_59__get_type__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_60__is_arguments__ = __webpack_require__(85);
            __webpack_require__.d(__webpack_exports__, "isArguments", function() {
              return __WEBPACK_IMPORTED_MODULE_60__is_arguments__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_61__is_array__ = __webpack_require__(0);
            __webpack_require__.d(__webpack_exports__, "isArray", function() {
              return __WEBPACK_IMPORTED_MODULE_61__is_array__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_62__is_array_like__ = __webpack_require__(1);
            __webpack_require__.d(__webpack_exports__, "isArrayLike", function() {
              return __WEBPACK_IMPORTED_MODULE_62__is_array_like__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_63__is_boolean__ = __webpack_require__(86);
            __webpack_require__.d(__webpack_exports__, "isBoolean", function() {
              return __WEBPACK_IMPORTED_MODULE_63__is_boolean__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_64__is_date__ = __webpack_require__(87);
            __webpack_require__.d(__webpack_exports__, "isDate", function() {
              return __WEBPACK_IMPORTED_MODULE_64__is_date__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_65__is_error__ = __webpack_require__(88);
            __webpack_require__.d(__webpack_exports__, "isError", function() {
              return __WEBPACK_IMPORTED_MODULE_65__is_error__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_66__is_function__ = __webpack_require__(2);
            __webpack_require__.d(__webpack_exports__, "isFunction", function() {
              return __WEBPACK_IMPORTED_MODULE_66__is_function__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_67__is_finite__ = __webpack_require__(89);
            __webpack_require__.d(__webpack_exports__, "isFinite", function() {
              return __WEBPACK_IMPORTED_MODULE_67__is_finite__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_68__is_nil__ = __webpack_require__(7);
            __webpack_require__.d(__webpack_exports__, "isNil", function() {
              return __WEBPACK_IMPORTED_MODULE_68__is_nil__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_69__is_null__ = __webpack_require__(90);
            __webpack_require__.d(__webpack_exports__, "isNull", function() {
              return __WEBPACK_IMPORTED_MODULE_69__is_null__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_70__is_number__ = __webpack_require__(5);
            __webpack_require__.d(__webpack_exports__, "isNumber", function() {
              return __WEBPACK_IMPORTED_MODULE_70__is_number__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_71__is_object__ = __webpack_require__(12);
            __webpack_require__.d(__webpack_exports__, "isObject", function() {
              return __WEBPACK_IMPORTED_MODULE_71__is_object__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_72__is_object_like__ = __webpack_require__(14);
            __webpack_require__.d(__webpack_exports__, "isObjectLike", function() {
              return __WEBPACK_IMPORTED_MODULE_72__is_object_like__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_73__is_plain_object__ = __webpack_require__(10);
            __webpack_require__.d(__webpack_exports__, "isPlainObject", function() {
              return __WEBPACK_IMPORTED_MODULE_73__is_plain_object__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_74__is_prototype__ = __webpack_require__(31);
            __webpack_require__.d(__webpack_exports__, "isPrototype", function() {
              return __WEBPACK_IMPORTED_MODULE_74__is_prototype__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_75__is_reg_exp__ = __webpack_require__(91);
            __webpack_require__.d(__webpack_exports__, "isRegExp", function() {
              return __WEBPACK_IMPORTED_MODULE_75__is_reg_exp__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_76__is_string__ = __webpack_require__(4);
            __webpack_require__.d(__webpack_exports__, "isString", function() {
              return __WEBPACK_IMPORTED_MODULE_76__is_string__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_77__is_type__ = __webpack_require__(3);
            __webpack_require__.d(__webpack_exports__, "isType", function() {
              return __WEBPACK_IMPORTED_MODULE_77__is_type__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_78__is_undefined__ = __webpack_require__(92);
            __webpack_require__.d(__webpack_exports__, "isUndefined", function() {
              return __WEBPACK_IMPORTED_MODULE_78__is_undefined__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_79__is_element__ = __webpack_require__(93);
            __webpack_require__.d(__webpack_exports__, "isElement", function() {
              return __WEBPACK_IMPORTED_MODULE_79__is_element__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_80__request_animation_frame__ = __webpack_require__(94);
            __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() {
              return __WEBPACK_IMPORTED_MODULE_80__request_animation_frame__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_81__clear_animation_frame__ = __webpack_require__(95);
            __webpack_require__.d(__webpack_exports__, "clearAnimationFrame", function() {
              return __WEBPACK_IMPORTED_MODULE_81__clear_animation_frame__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_82__augment__ = __webpack_require__(96);
            __webpack_require__.d(__webpack_exports__, "augment", function() {
              return __WEBPACK_IMPORTED_MODULE_82__augment__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_83__clone__ = __webpack_require__(97);
            __webpack_require__.d(__webpack_exports__, "clone", function() {
              return __WEBPACK_IMPORTED_MODULE_83__clone__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_84__debounce__ = __webpack_require__(98);
            __webpack_require__.d(__webpack_exports__, "debounce", function() {
              return __WEBPACK_IMPORTED_MODULE_84__debounce__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_85__memoize__ = __webpack_require__(32);
            __webpack_require__.d(__webpack_exports__, "memoize", function() {
              return __WEBPACK_IMPORTED_MODULE_85__memoize__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_86__deep_mix__ = __webpack_require__(99);
            __webpack_require__.d(__webpack_exports__, "deepMix", function() {
              return __WEBPACK_IMPORTED_MODULE_86__deep_mix__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_87__each__ = __webpack_require__(8);
            __webpack_require__.d(__webpack_exports__, "each", function() {
              return __WEBPACK_IMPORTED_MODULE_87__each__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_88__extend__ = __webpack_require__(100);
            __webpack_require__.d(__webpack_exports__, "extend", function() {
              return __WEBPACK_IMPORTED_MODULE_88__extend__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_89__index_of__ = __webpack_require__(101);
            __webpack_require__.d(__webpack_exports__, "indexOf", function() {
              return __WEBPACK_IMPORTED_MODULE_89__index_of__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_90__is_empty__ = __webpack_require__(102);
            __webpack_require__.d(__webpack_exports__, "isEmpty", function() {
              return __WEBPACK_IMPORTED_MODULE_90__is_empty__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_91__is_equal__ = __webpack_require__(33);
            __webpack_require__.d(__webpack_exports__, "isEqual", function() {
              return __WEBPACK_IMPORTED_MODULE_91__is_equal__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_92__is_equal_with__ = __webpack_require__(103);
            __webpack_require__.d(__webpack_exports__, "isEqualWith", function() {
              return __WEBPACK_IMPORTED_MODULE_92__is_equal_with__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_93__map__ = __webpack_require__(104);
            __webpack_require__.d(__webpack_exports__, "map", function() {
              return __WEBPACK_IMPORTED_MODULE_93__map__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_94__map_values__ = __webpack_require__(105);
            __webpack_require__.d(__webpack_exports__, "mapValues", function() {
              return __WEBPACK_IMPORTED_MODULE_94__map_values__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_95__mix__ = __webpack_require__(16);
            __webpack_require__.d(__webpack_exports__, "mix", function() {
              return __WEBPACK_IMPORTED_MODULE_95__mix__["a"];
            });
            __webpack_require__.d(__webpack_exports__, "assign", function() {
              return __WEBPACK_IMPORTED_MODULE_95__mix__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_96__get__ = __webpack_require__(106);
            __webpack_require__.d(__webpack_exports__, "get", function() {
              return __WEBPACK_IMPORTED_MODULE_96__get__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_97__set__ = __webpack_require__(107);
            __webpack_require__.d(__webpack_exports__, "set", function() {
              return __WEBPACK_IMPORTED_MODULE_97__set__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_98__pick__ = __webpack_require__(108);
            __webpack_require__.d(__webpack_exports__, "pick", function() {
              return __WEBPACK_IMPORTED_MODULE_98__pick__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_99__omit__ = __webpack_require__(109);
            __webpack_require__.d(__webpack_exports__, "omit", function() {
              return __WEBPACK_IMPORTED_MODULE_99__omit__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_100__throttle__ = __webpack_require__(110);
            __webpack_require__.d(__webpack_exports__, "throttle", function() {
              return __WEBPACK_IMPORTED_MODULE_100__throttle__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_101__to_array__ = __webpack_require__(111);
            __webpack_require__.d(__webpack_exports__, "toArray", function() {
              return __WEBPACK_IMPORTED_MODULE_101__to_array__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_102__to_string__ = __webpack_require__(9);
            __webpack_require__.d(__webpack_exports__, "toString", function() {
              return __WEBPACK_IMPORTED_MODULE_102__to_string__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_103__unique_id__ = __webpack_require__(112);
            __webpack_require__.d(__webpack_exports__, "uniqueId", function() {
              return __WEBPACK_IMPORTED_MODULE_103__unique_id__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_104__noop__ = __webpack_require__(113);
            __webpack_require__.d(__webpack_exports__, "noop", function() {
              return __WEBPACK_IMPORTED_MODULE_104__noop__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_105__identity__ = __webpack_require__(114);
            __webpack_require__.d(__webpack_exports__, "identity", function() {
              return __WEBPACK_IMPORTED_MODULE_105__identity__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_106__size__ = __webpack_require__(115);
            __webpack_require__.d(__webpack_exports__, "size", function() {
              return __WEBPACK_IMPORTED_MODULE_106__size__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_107__measure_text_width__ = __webpack_require__(34);
            __webpack_require__.d(__webpack_exports__, "measureTextWidth", function() {
              return __WEBPACK_IMPORTED_MODULE_107__measure_text_width__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_108__get_ellipsis_text__ = __webpack_require__(117);
            __webpack_require__.d(__webpack_exports__, "getEllipsisText", function() {
              return __WEBPACK_IMPORTED_MODULE_108__get_ellipsis_text__["a"];
            });
            var __WEBPACK_IMPORTED_MODULE_109__cache__ = __webpack_require__(118);
            __webpack_require__.d(__webpack_exports__, "Cache", function() {
              return __WEBPACK_IMPORTED_MODULE_109__cache__["a"];
            });
          },
          /* 39 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__filter__ = __webpack_require__(19);
            var __WEBPACK_IMPORTED_MODULE_1__contains__ = __webpack_require__(13);
            var difference2 = function(arr, values2) {
              if (values2 === void 0) {
                values2 = [];
              }
              return Object(__WEBPACK_IMPORTED_MODULE_0__filter__[
                "a"
                /* default */
              ])(arr, function(value) {
                return !Object(__WEBPACK_IMPORTED_MODULE_1__contains__[
                  "a"
                  /* default */
                ])(values2, value);
              });
            };
            __webpack_exports__["a"] = difference2;
          },
          /* 40 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_function__ = __webpack_require__(2);
            var __WEBPACK_IMPORTED_MODULE_1__is_match__ = __webpack_require__(20);
            var __WEBPACK_IMPORTED_MODULE_2__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_3__is_plain_object__ = __webpack_require__(10);
            function find3(arr, predicate) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_2__is_array__[
                "a"
                /* default */
              ])(arr))
                return null;
              var _predicate;
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_function__[
                "a"
                /* default */
              ])(predicate)) {
                _predicate = predicate;
              }
              if (Object(__WEBPACK_IMPORTED_MODULE_3__is_plain_object__[
                "a"
                /* default */
              ])(predicate)) {
                _predicate = function(a3) {
                  return Object(__WEBPACK_IMPORTED_MODULE_1__is_match__[
                    "a"
                    /* default */
                  ])(a3, predicate);
                };
              }
              if (_predicate) {
                for (var i2 = 0; i2 < arr.length; i2 += 1) {
                  if (_predicate(arr[i2])) {
                    return arr[i2];
                  }
                }
              }
              return null;
            }
            __webpack_exports__["a"] = find3;
          },
          /* 41 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            function findIndex2(arr, predicate, fromIndex) {
              if (fromIndex === void 0) {
                fromIndex = 0;
              }
              for (var i2 = fromIndex; i2 < arr.length; i2++) {
                if (predicate(arr[i2], i2)) {
                  return i2;
                }
              }
              return -1;
            }
            __webpack_exports__["a"] = findIndex2;
          },
          /* 42 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__(7);
            var __WEBPACK_IMPORTED_MODULE_1__is_array__ = __webpack_require__(0);
            var firstValue2 = function(data, name) {
              var rst = null;
              for (var i2 = 0; i2 < data.length; i2++) {
                var obj = data[i2];
                var value = obj[name];
                if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__[
                  "a"
                  /* default */
                ])(value)) {
                  if (Object(__WEBPACK_IMPORTED_MODULE_1__is_array__[
                    "a"
                    /* default */
                  ])(value)) {
                    rst = value[0];
                  } else {
                    rst = value;
                  }
                  break;
                }
              }
              return rst;
            };
            __webpack_exports__["a"] = firstValue2;
          },
          /* 43 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var flatten2 = function(arr) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(arr)) {
                return [];
              }
              var rst = [];
              for (var i2 = 0; i2 < arr.length; i2++) {
                rst = rst.concat(arr[i2]);
              }
              return rst;
            };
            __webpack_exports__["a"] = flatten2;
          },
          /* 44 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var flattenDeep2 = function(arr, result) {
              if (result === void 0) {
                result = [];
              }
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(arr)) {
                result.push(arr);
              } else {
                for (var i2 = 0; i2 < arr.length; i2 += 1) {
                  flattenDeep2(arr[i2], result);
                }
              }
              return result;
            };
            __webpack_exports__["a"] = flattenDeep2;
          },
          /* 45 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__max__ = __webpack_require__(22);
            var __WEBPACK_IMPORTED_MODULE_2__min__ = __webpack_require__(23);
            var getRange2 = function(values2) {
              var filterValues = values2.filter(function(v2) {
                return !isNaN(v2);
              });
              if (!filterValues.length) {
                return {
                  min: 0,
                  max: 0
                };
              }
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(values2[0])) {
                var tmp = [];
                for (var i2 = 0; i2 < values2.length; i2++) {
                  tmp = tmp.concat(values2[i2]);
                }
                filterValues = tmp;
              }
              var max4 = Object(__WEBPACK_IMPORTED_MODULE_1__max__[
                "a"
                /* default */
              ])(filterValues);
              var min3 = Object(__WEBPACK_IMPORTED_MODULE_2__min__[
                "a"
                /* default */
              ])(filterValues);
              return {
                min: min3,
                max: max4
              };
            };
            __webpack_exports__["a"] = getRange2;
          },
          /* 46 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var arrPrototype2 = Array.prototype;
            var splice3 = arrPrototype2.splice;
            var indexOf3 = arrPrototype2.indexOf;
            var pull2 = function(arr) {
              var values2 = [];
              for (var _i2 = 1; _i2 < arguments.length; _i2++) {
                values2[_i2 - 1] = arguments[_i2];
              }
              for (var i2 = 0; i2 < values2.length; i2++) {
                var value = values2[i2];
                var fromIndex = -1;
                while ((fromIndex = indexOf3.call(arr, value)) > -1) {
                  splice3.call(arr, fromIndex, 1);
                }
              }
              return arr;
            };
            __webpack_exports__["a"] = pull2;
          },
          /* 47 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            var __WEBPACK_IMPORTED_MODULE_1__pull_at__ = __webpack_require__(24);
            var remove2 = function(arr, predicate) {
              var result = [];
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(arr)) {
                return result;
              }
              var i2 = -1;
              var indexes = [];
              var length = arr.length;
              while (++i2 < length) {
                var value = arr[i2];
                if (predicate(value, i2, arr)) {
                  result.push(value);
                  indexes.push(i2);
                }
              }
              Object(__WEBPACK_IMPORTED_MODULE_1__pull_at__[
                "a"
                /* default */
              ])(arr, indexes);
              return result;
            };
            __webpack_exports__["a"] = remove2;
          },
          /* 48 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_string__ = __webpack_require__(4);
            var __WEBPACK_IMPORTED_MODULE_2__is_function__ = __webpack_require__(2);
            function sortBy2(arr, key) {
              var comparer;
              if (Object(__WEBPACK_IMPORTED_MODULE_2__is_function__[
                "a"
                /* default */
              ])(key)) {
                comparer = function(a3, b2) {
                  return key(a3) - key(b2);
                };
              } else {
                var keys_1 = [];
                if (Object(__WEBPACK_IMPORTED_MODULE_1__is_string__[
                  "a"
                  /* default */
                ])(key)) {
                  keys_1.push(key);
                } else if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                  "a"
                  /* default */
                ])(key)) {
                  keys_1 = key;
                }
                comparer = function(a3, b2) {
                  for (var i2 = 0; i2 < keys_1.length; i2 += 1) {
                    var prop = keys_1[i2];
                    if (a3[prop] > b2[prop]) {
                      return 1;
                    }
                    if (a3[prop] < b2[prop]) {
                      return -1;
                    }
                  }
                  return 0;
                };
              }
              arr.sort(comparer);
              return arr;
            }
            __webpack_exports__["a"] = sortBy2;
          },
          /* 49 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__uniq__ = __webpack_require__(26);
            var union2 = function() {
              var sources = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                sources[_i2] = arguments[_i2];
              }
              return Object(__WEBPACK_IMPORTED_MODULE_0__uniq__[
                "a"
                /* default */
              ])([].concat.apply([], sources));
            };
            __webpack_exports__["a"] = union2;
          },
          /* 50 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_nil__ = __webpack_require__(7);
            __webpack_exports__["a"] = function(data, name) {
              var rst = [];
              var tmpMap = {};
              for (var i2 = 0; i2 < data.length; i2++) {
                var obj = data[i2];
                var value = obj[name];
                if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_nil__[
                  "a"
                  /* default */
                ])(value)) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                    "a"
                    /* default */
                  ])(value)) {
                    value = [value];
                  }
                  for (var j2 = 0; j2 < value.length; j2++) {
                    var val = value[j2];
                    if (!tmpMap[val]) {
                      rst.push(val);
                      tmpMap[val] = true;
                    }
                  }
                }
              }
              return rst;
            };
          },
          /* 51 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = head3;
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            function head3(o2) {
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(o2)) {
                return o2[0];
              }
              return void 0;
            }
          },
          /* 52 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = last2;
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            function last2(o2) {
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(o2)) {
                var arr = o2;
                return arr[arr.length - 1];
              }
              return void 0;
            }
          },
          /* 53 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_string__ = __webpack_require__(4);
            function startsWith2(arr, e8) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(arr) || Object(__WEBPACK_IMPORTED_MODULE_1__is_string__[
                "a"
                /* default */
              ])(arr) ? arr[0] === e8 : false;
            }
            __webpack_exports__["a"] = startsWith2;
          },
          /* 54 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_string__ = __webpack_require__(4);
            function endsWith2(arr, e8) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(arr) || Object(__WEBPACK_IMPORTED_MODULE_1__is_string__[
                "a"
                /* default */
              ])(arr) ? arr[arr.length - 1] === e8 : false;
            }
            __webpack_exports__["a"] = endsWith2;
          },
          /* 55 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var every2 = function(arr, func) {
              for (var i2 = 0; i2 < arr.length; i2++) {
                if (!func(arr[i2], i2))
                  return false;
              }
              return true;
            };
            __webpack_exports__["a"] = every2;
          },
          /* 56 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var some2 = function(arr, func) {
              for (var i2 = 0; i2 < arr.length; i2++) {
                if (func(arr[i2], i2))
                  return true;
              }
              return false;
            };
            __webpack_exports__["a"] = some2;
          },
          /* 57 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__group_to_map__ = __webpack_require__(27);
            __webpack_exports__["a"] = function(data, condition) {
              if (!condition) {
                return [data];
              }
              var groups = Object(__WEBPACK_IMPORTED_MODULE_0__group_to_map__[
                "a"
                /* default */
              ])(data, condition);
              var array = [];
              for (var i2 in groups) {
                array.push(groups[i2]);
              }
              return array;
            };
          },
          /* 58 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            function getWrapBehavior2(obj, action) {
              return obj["_wrap_" + action];
            }
            __webpack_exports__["a"] = getWrapBehavior2;
          },
          /* 59 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            function wrapBehavior2(obj, action) {
              if (obj["_wrap_" + action]) {
                return obj["_wrap_" + action];
              }
              var method = function(e8) {
                obj[action](e8);
              };
              obj["_wrap_" + action] = method;
              return method;
            }
            __webpack_exports__["a"] = wrapBehavior2;
          },
          /* 60 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var numColorCache2 = {};
            function numberToColor2(num) {
              var color2 = numColorCache2[num];
              if (!color2) {
                var str = num.toString(16);
                for (var i2 = str.length; i2 < 6; i2++) {
                  str = "0" + str;
                }
                color2 = "#" + str;
                numColorCache2[num] = color2;
              }
              return color2;
            }
            __webpack_exports__["a"] = numberToColor2;
          },
          /* 61 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            function parseRadius2(radius) {
              var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(radius)) {
                if (radius.length === 1) {
                  r1 = r2 = r3 = r4 = radius[0];
                } else if (radius.length === 2) {
                  r1 = r3 = radius[0];
                  r2 = r4 = radius[1];
                } else if (radius.length === 3) {
                  r1 = radius[0];
                  r2 = r4 = radius[1];
                  r3 = radius[2];
                } else {
                  r1 = radius[0];
                  r2 = radius[1];
                  r3 = radius[2];
                  r4 = radius[3];
                }
              } else {
                r1 = r2 = r3 = r4 = radius;
              }
              return {
                r1,
                r2,
                r3,
                r4
              };
            }
            __webpack_exports__["a"] = parseRadius2;
          },
          /* 62 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var clamp2 = function(a3, min3, max4) {
              if (a3 < min3) {
                return min3;
              } else if (a3 > max4) {
                return max4;
              }
              return a3;
            };
            __webpack_exports__["a"] = clamp2;
          },
          /* 63 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var fixedBase2 = function(v2, base) {
              var str = base.toString();
              var index2 = str.indexOf(".");
              if (index2 === -1) {
                return Math.round(v2);
              }
              var length = str.substr(index2 + 1).length;
              if (length > 20) {
                length = 20;
              }
              return parseFloat(v2.toFixed(length));
            };
            __webpack_exports__["a"] = fixedBase2;
          },
          /* 64 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__(5);
            var isDecimal2 = function(num) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__[
                "a"
                /* default */
              ])(num) && num % 1 !== 0;
            };
            __webpack_exports__["a"] = isDecimal2;
          },
          /* 65 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__(5);
            var isEven2 = function(num) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__[
                "a"
                /* default */
              ])(num) && num % 2 === 0;
            };
            __webpack_exports__["a"] = isEven2;
          },
          /* 66 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__(5);
            var isInteger2 = Number.isInteger ? Number.isInteger : function(num) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__[
                "a"
                /* default */
              ])(num) && num % 1 === 0;
            };
            __webpack_exports__["a"] = isInteger2;
          },
          /* 67 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__(5);
            var isNegative2 = function(num) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__[
                "a"
                /* default */
              ])(num) && num < 0;
            };
            __webpack_exports__["a"] = isNegative2;
          },
          /* 68 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = isNumberEqual2;
            var PRECISION2 = 1e-5;
            function isNumberEqual2(a3, b2, precision) {
              if (precision === void 0) {
                precision = PRECISION2;
              }
              return Math.abs(a3 - b2) < precision;
            }
            ;
          },
          /* 69 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__(5);
            var isOdd2 = function(num) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__[
                "a"
                /* default */
              ])(num) && num % 2 !== 0;
            };
            __webpack_exports__["a"] = isOdd2;
          },
          /* 70 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__(5);
            var isPositive2 = function(num) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__[
                "a"
                /* default */
              ])(num) && num > 0;
            };
            __webpack_exports__["a"] = isPositive2;
          },
          /* 71 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__(2);
            __webpack_exports__["a"] = function(arr, fn2) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(arr)) {
                return void 0;
              }
              var maxItem;
              var max4 = -Infinity;
              for (var i2 = 0; i2 < arr.length; i2++) {
                var item = arr[i2];
                var v2 = Object(__WEBPACK_IMPORTED_MODULE_1__is_function__[
                  "a"
                  /* default */
                ])(fn2) ? fn2(item) : item[fn2];
                if (v2 > max4) {
                  maxItem = item;
                  max4 = v2;
                }
              }
              return maxItem;
            };
          },
          /* 72 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__(2);
            __webpack_exports__["a"] = function(arr, fn2) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(arr)) {
                return void 0;
              }
              var minItem;
              var min3 = Infinity;
              for (var i2 = 0; i2 < arr.length; i2++) {
                var item = arr[i2];
                var v2 = Object(__WEBPACK_IMPORTED_MODULE_1__is_function__[
                  "a"
                  /* default */
                ])(fn2) ? fn2(item) : item[fn2];
                if (v2 < min3) {
                  minItem = item;
                  min3 = v2;
                }
              }
              return minItem;
            };
          },
          /* 73 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var mod2 = function(n2, m3) {
              return (n2 % m3 + m3) % m3;
            };
            __webpack_exports__["a"] = mod2;
          },
          /* 74 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var DEGREE2 = 180 / Math.PI;
            var toDegree2 = function(radian) {
              return DEGREE2 * radian;
            };
            __webpack_exports__["a"] = toDegree2;
          },
          /* 75 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = parseInt;
          },
          /* 76 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var RADIAN2 = Math.PI / 180;
            var toRadian2 = function(degree3) {
              return RADIAN2 * degree3;
            };
            __webpack_exports__["a"] = toRadian2;
          },
          /* 77 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__(8);
            __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__each__[
              "a"
              /* default */
            ];
          },
          /* 78 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__has__ = __webpack_require__(29);
            __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__has__[
              "a"
              /* default */
            ];
          },
          /* 79 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__contains__ = __webpack_require__(13);
            var __WEBPACK_IMPORTED_MODULE_1__values__ = __webpack_require__(15);
            __webpack_exports__["a"] = function(obj, value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__contains__[
                "a"
                /* default */
              ])(Object(__WEBPACK_IMPORTED_MODULE_1__values__[
                "a"
                /* default */
              ])(obj), value);
            };
          },
          /* 80 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__to_string__ = __webpack_require__(9);
            var lowerCase2 = function(str) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__to_string__[
                "a"
                /* default */
              ])(str).toLowerCase();
            };
            __webpack_exports__["a"] = lowerCase2;
          },
          /* 81 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__to_string__ = __webpack_require__(9);
            var lowerFirst2 = function(value) {
              var str = Object(__WEBPACK_IMPORTED_MODULE_0__to_string__[
                "a"
                /* default */
              ])(value);
              return str.charAt(0).toLowerCase() + str.substring(1);
            };
            __webpack_exports__["a"] = lowerFirst2;
          },
          /* 82 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            function substitute4(str, o2) {
              if (!str || !o2) {
                return str;
              }
              return str.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
                if (match.charAt(0) === "\\") {
                  return match.slice(1);
                }
                return o2[name] === void 0 ? "" : o2[name];
              });
            }
            __webpack_exports__["a"] = substitute4;
          },
          /* 83 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__to_string__ = __webpack_require__(9);
            var upperCase2 = function(str) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__to_string__[
                "a"
                /* default */
              ])(str).toUpperCase();
            };
            __webpack_exports__["a"] = upperCase2;
          },
          /* 84 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__to_string__ = __webpack_require__(9);
            var upperFirst2 = function(value) {
              var str = Object(__WEBPACK_IMPORTED_MODULE_0__to_string__[
                "a"
                /* default */
              ])(value);
              return str.charAt(0).toUpperCase() + str.substring(1);
            };
            __webpack_exports__["a"] = upperFirst2;
          },
          /* 85 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            var isArguments2 = function(value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(value, "Arguments");
            };
            __webpack_exports__["a"] = isArguments2;
          },
          /* 86 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            var isBoolean2 = function(value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(value, "Boolean");
            };
            __webpack_exports__["a"] = isBoolean2;
          },
          /* 87 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            var isDate2 = function(value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(value, "Date");
            };
            __webpack_exports__["a"] = isDate2;
          },
          /* 88 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            var isError2 = function(value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(value, "Error");
            };
            __webpack_exports__["a"] = isError2;
          },
          /* 89 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_number__ = __webpack_require__(5);
            __webpack_exports__["a"] = function(value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_number__[
                "a"
                /* default */
              ])(value) && isFinite(value);
            };
          },
          /* 90 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var isNull2 = function(value) {
              return value === null;
            };
            __webpack_exports__["a"] = isNull2;
          },
          /* 91 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_type__ = __webpack_require__(3);
            var isRegExp2 = function(str) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_type__[
                "a"
                /* default */
              ])(str, "RegExp");
            };
            __webpack_exports__["a"] = isRegExp2;
          },
          /* 92 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var isUndefined2 = function(value) {
              return value === void 0;
            };
            __webpack_exports__["a"] = isUndefined2;
          },
          /* 93 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var isElement2 = function(o2) {
              return o2 instanceof Element || o2 instanceof HTMLDocument;
            };
            __webpack_exports__["a"] = isElement2;
          },
          /* 94 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = requestAnimationFrame4;
            function requestAnimationFrame4(fn2) {
              var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || // @ts-ignore
              window.mozRequestAnimationFrame || // @ts-ignore
              window.msRequestAnimationFrame || function(f2) {
                return setTimeout(f2, 16);
              };
              return method(fn2);
            }
            ;
          },
          /* 95 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = cancelAnimationFrame4;
            function cancelAnimationFrame4(handler) {
              var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || // @ts-ignore
              window.mozCancelAnimationFrame || // @ts-ignore
              window.msCancelAnimationFrame || clearTimeout;
              method(handler);
            }
            ;
          },
          /* 96 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__mix__ = __webpack_require__(16);
            var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__(2);
            var augment2 = function() {
              var args = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                args[_i2] = arguments[_i2];
              }
              var c3 = args[0];
              for (var i2 = 1; i2 < args.length; i2++) {
                var obj = args[i2];
                if (Object(__WEBPACK_IMPORTED_MODULE_1__is_function__[
                  "a"
                  /* default */
                ])(obj)) {
                  obj = obj.prototype;
                }
                Object(__WEBPACK_IMPORTED_MODULE_0__mix__[
                  "a"
                  /* default */
                ])(c3.prototype, obj);
              }
            };
            __webpack_exports__["a"] = augment2;
          },
          /* 97 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var clone3 = function(obj) {
              if (typeof obj !== "object" || obj === null) {
                return obj;
              }
              var rst;
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                "a"
                /* default */
              ])(obj)) {
                rst = [];
                for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
                  if (typeof obj[i2] === "object" && obj[i2] != null) {
                    rst[i2] = clone3(obj[i2]);
                  } else {
                    rst[i2] = obj[i2];
                  }
                }
              } else {
                rst = {};
                for (var k2 in obj) {
                  if (typeof obj[k2] === "object" && obj[k2] != null) {
                    rst[k2] = clone3(obj[k2]);
                  } else {
                    rst[k2] = obj[k2];
                  }
                }
              }
              return rst;
            };
            __webpack_exports__["a"] = clone3;
          },
          /* 98 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            function debounce2(func, wait, immediate) {
              var timeout;
              return function() {
                var context = this, args = arguments;
                var later = function() {
                  timeout = null;
                  if (!immediate) {
                    func.apply(context, args);
                  }
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                  func.apply(context, args);
                }
              };
            }
            __webpack_exports__["a"] = debounce2;
          },
          /* 99 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array__ = __webpack_require__(0);
            var __WEBPACK_IMPORTED_MODULE_1__is_plain_object__ = __webpack_require__(10);
            var MAX_MIX_LEVEL2 = 5;
            function _deepMix2(dist, src, level, maxLevel) {
              level = level || 0;
              maxLevel = maxLevel || MAX_MIX_LEVEL2;
              for (var key in src) {
                if (src.hasOwnProperty(key)) {
                  var value = src[key];
                  if (value !== null && Object(__WEBPACK_IMPORTED_MODULE_1__is_plain_object__[
                    "a"
                    /* default */
                  ])(value)) {
                    if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_plain_object__[
                      "a"
                      /* default */
                    ])(dist[key])) {
                      dist[key] = {};
                    }
                    if (level < maxLevel) {
                      _deepMix2(dist[key], value, level + 1, maxLevel);
                    } else {
                      dist[key] = src[key];
                    }
                  } else if (Object(__WEBPACK_IMPORTED_MODULE_0__is_array__[
                    "a"
                    /* default */
                  ])(value)) {
                    dist[key] = [];
                    dist[key] = dist[key].concat(value);
                  } else if (value !== void 0) {
                    dist[key] = value;
                  }
                }
              }
            }
            var deepMix2 = function(rst) {
              var args = [];
              for (var _i2 = 1; _i2 < arguments.length; _i2++) {
                args[_i2 - 1] = arguments[_i2];
              }
              for (var i2 = 0; i2 < args.length; i2 += 1) {
                _deepMix2(rst, args[i2]);
              }
              return rst;
            };
            __webpack_exports__["a"] = deepMix2;
          },
          /* 100 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__mix__ = __webpack_require__(16);
            var __WEBPACK_IMPORTED_MODULE_1__is_function__ = __webpack_require__(2);
            var extend2 = function(subclass, superclass, overrides, staticOverrides) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_1__is_function__[
                "a"
                /* default */
              ])(superclass)) {
                overrides = superclass;
                superclass = subclass;
                subclass = function() {
                };
              }
              var create = Object.create ? function(proto, c3) {
                return Object.create(proto, {
                  constructor: {
                    value: c3
                  }
                });
              } : function(proto, c3) {
                function Tmp() {
                }
                Tmp.prototype = proto;
                var o2 = new Tmp();
                o2.constructor = c3;
                return o2;
              };
              var superObj = create(superclass.prototype, subclass);
              subclass.prototype = Object(__WEBPACK_IMPORTED_MODULE_0__mix__[
                "a"
                /* default */
              ])(superObj, subclass.prototype);
              subclass.superclass = create(superclass.prototype, superclass);
              Object(__WEBPACK_IMPORTED_MODULE_0__mix__[
                "a"
                /* default */
              ])(superObj, overrides);
              Object(__WEBPACK_IMPORTED_MODULE_0__mix__[
                "a"
                /* default */
              ])(subclass, staticOverrides);
              return subclass;
            };
            __webpack_exports__["a"] = extend2;
          },
          /* 101 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            var indexOf3 = function(arr, obj) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(arr)) {
                return -1;
              }
              var m3 = Array.prototype.indexOf;
              if (m3) {
                return m3.call(arr, obj);
              }
              var index2 = -1;
              for (var i2 = 0; i2 < arr.length; i2++) {
                if (arr[i2] === obj) {
                  index2 = i2;
                  break;
                }
              }
              return index2;
            };
            __webpack_exports__["a"] = indexOf3;
          },
          /* 102 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__(7);
            var __WEBPACK_IMPORTED_MODULE_1__is_array_like__ = __webpack_require__(1);
            var __WEBPACK_IMPORTED_MODULE_2__get_type__ = __webpack_require__(30);
            var __WEBPACK_IMPORTED_MODULE_3__is_prototype__ = __webpack_require__(31);
            var hasOwnProperty4 = Object.prototype.hasOwnProperty;
            function isEmpty2(value) {
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__[
                "a"
                /* default */
              ])(value)) {
                return true;
              }
              if (Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__[
                "a"
                /* default */
              ])(value)) {
                return !value.length;
              }
              var type = Object(__WEBPACK_IMPORTED_MODULE_2__get_type__[
                "a"
                /* default */
              ])(value);
              if (type === "Map" || type === "Set") {
                return !value.size;
              }
              if (Object(__WEBPACK_IMPORTED_MODULE_3__is_prototype__[
                "a"
                /* default */
              ])(value)) {
                return !Object.keys(value).length;
              }
              for (var key in value) {
                if (hasOwnProperty4.call(value, key)) {
                  return false;
                }
              }
              return true;
            }
            __webpack_exports__["a"] = isEmpty2;
          },
          /* 103 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_function__ = __webpack_require__(2);
            var __WEBPACK_IMPORTED_MODULE_1__is_equal__ = __webpack_require__(33);
            __webpack_exports__["a"] = function(value, other, fn2) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_function__[
                "a"
                /* default */
              ])(fn2)) {
                return Object(__WEBPACK_IMPORTED_MODULE_1__is_equal__[
                  "a"
                  /* default */
                ])(value, other);
              }
              return !!fn2(value, other);
            };
          },
          /* 104 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            var map3 = function(arr, func) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(arr)) {
                return arr;
              }
              var result = [];
              for (var index2 = 0; index2 < arr.length; index2++) {
                var value = arr[index2];
                result.push(func(value, index2));
              }
              return result;
            };
            __webpack_exports__["a"] = map3;
          },
          /* 105 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__(7);
            var __WEBPACK_IMPORTED_MODULE_1__is_object__ = __webpack_require__(12);
            var identity2 = function(v2) {
              return v2;
            };
            __webpack_exports__["a"] = function(object, func) {
              if (func === void 0) {
                func = identity2;
              }
              var r2 = {};
              if (Object(__WEBPACK_IMPORTED_MODULE_1__is_object__[
                "a"
                /* default */
              ])(object) && !Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__[
                "a"
                /* default */
              ])(object)) {
                Object.keys(object).forEach(function(key) {
                  r2[key] = func(object[key], key);
                });
              }
              return r2;
            };
          },
          /* 106 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_string__ = __webpack_require__(4);
            __webpack_exports__["a"] = function(obj, key, defaultValue) {
              var p2 = 0;
              var keyArr = Object(__WEBPACK_IMPORTED_MODULE_0__is_string__[
                "a"
                /* default */
              ])(key) ? key.split(".") : key;
              while (obj && p2 < keyArr.length) {
                obj = obj[keyArr[p2++]];
              }
              return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
            };
          },
          /* 107 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_object__ = __webpack_require__(12);
            var __WEBPACK_IMPORTED_MODULE_1__is_string__ = __webpack_require__(4);
            var __WEBPACK_IMPORTED_MODULE_2__is_number__ = __webpack_require__(5);
            __webpack_exports__["a"] = function(obj, path, value) {
              var o2 = obj;
              var keyArr = Object(__WEBPACK_IMPORTED_MODULE_1__is_string__[
                "a"
                /* default */
              ])(path) ? path.split(".") : path;
              keyArr.forEach(function(key, idx) {
                if (idx < keyArr.length - 1) {
                  if (!Object(__WEBPACK_IMPORTED_MODULE_0__is_object__[
                    "a"
                    /* default */
                  ])(o2[key])) {
                    o2[key] = Object(__WEBPACK_IMPORTED_MODULE_2__is_number__[
                      "a"
                      /* default */
                    ])(keyArr[idx + 1]) ? [] : {};
                  }
                  o2 = o2[key];
                } else {
                  o2[key] = value;
                }
              });
              return obj;
            };
          },
          /* 108 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__each__ = __webpack_require__(8);
            var __WEBPACK_IMPORTED_MODULE_1__is_plain_object__ = __webpack_require__(10);
            var hasOwnProperty4 = Object.prototype.hasOwnProperty;
            __webpack_exports__["a"] = function(object, keys2) {
              if (object === null || !Object(__WEBPACK_IMPORTED_MODULE_1__is_plain_object__[
                "a"
                /* default */
              ])(object)) {
                return {};
              }
              var result = {};
              Object(__WEBPACK_IMPORTED_MODULE_0__each__[
                "a"
                /* default */
              ])(keys2, function(key) {
                if (hasOwnProperty4.call(object, key)) {
                  result[key] = object[key];
                }
              });
              return result;
            };
          },
          /* 109 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__reduce__ = __webpack_require__(25);
            __webpack_exports__["a"] = function(obj, keys2) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__reduce__[
                "a"
                /* default */
              ])(obj, function(r2, curr, key) {
                if (!keys2.includes(key)) {
                  r2[key] = curr;
                }
                return r2;
              }, {});
            };
          },
          /* 110 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = function(func, wait, options) {
              var timeout, context, args, result;
              var previous = 0;
              if (!options)
                options = {};
              var later = function() {
                previous = options.leading === false ? 0 : Date.now();
                timeout = null;
                result = func.apply(context, args);
                if (!timeout)
                  context = args = null;
              };
              var throttled = function() {
                var now = Date.now();
                if (!previous && options.leading === false)
                  previous = now;
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0 || remaining > wait) {
                  if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                  }
                  previous = now;
                  result = func.apply(context, args);
                  if (!timeout)
                    context = args = null;
                } else if (!timeout && options.trailing !== false) {
                  timeout = setTimeout(later, remaining);
                }
                return result;
              };
              throttled.cancel = function() {
                clearTimeout(timeout);
                previous = 0;
                timeout = context = args = null;
              };
              return throttled;
            };
          },
          /* 111 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_array_like__ = __webpack_require__(1);
            __webpack_exports__["a"] = function(value) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__is_array_like__[
                "a"
                /* default */
              ])(value) ? Array.prototype.slice.call(value) : [];
            };
          },
          /* 112 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var map3 = {};
            __webpack_exports__["a"] = function(prefix) {
              prefix = prefix || "g";
              if (!map3[prefix]) {
                map3[prefix] = 1;
              } else {
                map3[prefix] += 1;
              }
              return prefix + map3[prefix];
            };
          },
          /* 113 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = function() {
            };
          },
          /* 114 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = function(v2) {
              return v2;
            };
          },
          /* 115 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = size3;
            var __WEBPACK_IMPORTED_MODULE_0__is_nil__ = __webpack_require__(7);
            var __WEBPACK_IMPORTED_MODULE_1__is_array_like__ = __webpack_require__(1);
            function size3(o2) {
              if (Object(__WEBPACK_IMPORTED_MODULE_0__is_nil__[
                "a"
                /* default */
              ])(o2)) {
                return 0;
              }
              if (Object(__WEBPACK_IMPORTED_MODULE_1__is_array_like__[
                "a"
                /* default */
              ])(o2)) {
                return o2.length;
              }
              return Object.keys(o2).length;
            }
          },
          /* 116 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_exports__["a"] = __spreadArrays;
            var extendStatics = function(d2, b2) {
              extendStatics = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function(d3, b3) {
                d3.__proto__ = b3;
              } || function(d3, b3) {
                for (var p2 in b3)
                  if (Object.prototype.hasOwnProperty.call(b3, p2))
                    d3[p2] = b3[p2];
              };
              return extendStatics(d2, b2);
            };
            function __extends15(d2, b2) {
              if (typeof b2 !== "function" && b2 !== null)
                throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
              extendStatics(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            }
            var __assign14 = function() {
              __assign14 = Object.assign || function __assign15(t2) {
                for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
                  s2 = arguments[i2];
                  for (var p2 in s2)
                    if (Object.prototype.hasOwnProperty.call(s2, p2))
                      t2[p2] = s2[p2];
                }
                return t2;
              };
              return __assign14.apply(this, arguments);
            };
            function __rest4(s2, e8) {
              var t2 = {};
              for (var p2 in s2)
                if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
                  t2[p2] = s2[p2];
              if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
                for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
                  if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                    t2[p2[i2]] = s2[p2[i2]];
                }
              return t2;
            }
            function __decorate(decorators, target, key, desc) {
              var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
              if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
                r2 = Reflect.decorate(decorators, target, key, desc);
              else
                for (var i2 = decorators.length - 1; i2 >= 0; i2--)
                  if (d2 = decorators[i2])
                    r2 = (c3 < 3 ? d2(r2) : c3 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
              return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
            }
            function __param(paramIndex, decorator) {
              return function(target, key) {
                decorator(target, key, paramIndex);
              };
            }
            function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
              function accept(f2) {
                if (f2 !== void 0 && typeof f2 !== "function")
                  throw new TypeError("Function expected");
                return f2;
              }
              var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
              var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
              var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
              var _2, done = false;
              for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
                var context = {};
                for (var p2 in contextIn)
                  context[p2] = p2 === "access" ? {} : contextIn[p2];
                for (var p2 in contextIn.access)
                  context.access[p2] = contextIn.access[p2];
                context.addInitializer = function(f2) {
                  if (done)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                  extraInitializers.push(accept(f2 || null));
                };
                var result = (0, decorators[i2])(kind === "accessor" ? {
                  get: descriptor.get,
                  set: descriptor.set
                } : descriptor[key], context);
                if (kind === "accessor") {
                  if (result === void 0)
                    continue;
                  if (result === null || typeof result !== "object")
                    throw new TypeError("Object expected");
                  if (_2 = accept(result.get))
                    descriptor.get = _2;
                  if (_2 = accept(result.set))
                    descriptor.set = _2;
                  if (_2 = accept(result.init))
                    initializers.push(_2);
                } else if (_2 = accept(result)) {
                  if (kind === "field")
                    initializers.push(_2);
                  else
                    descriptor[key] = _2;
                }
              }
              if (target)
                Object.defineProperty(target, contextIn.name, descriptor);
              done = true;
            }
            ;
            function __runInitializers(thisArg, initializers, value) {
              var useValue = arguments.length > 2;
              for (var i2 = 0; i2 < initializers.length; i2++) {
                value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
              }
              return useValue ? value : void 0;
            }
            ;
            function __propKey(x4) {
              return typeof x4 === "symbol" ? x4 : "".concat(x4);
            }
            ;
            function __setFunctionName(f2, name, prefix) {
              if (typeof name === "symbol")
                name = name.description ? "[".concat(name.description, "]") : "";
              return Object.defineProperty(f2, "name", {
                configurable: true,
                value: prefix ? "".concat(prefix, " ", name) : name
              });
            }
            ;
            function __metadata(metadataKey, metadataValue) {
              if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
                return Reflect.metadata(metadataKey, metadataValue);
            }
            function __awaiter2(thisArg, _arguments, P2, generator) {
              function adopt(value) {
                return value instanceof P2 ? value : new P2(function(resolve) {
                  resolve(value);
                });
              }
              return new (P2 || (P2 = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e8) {
                    reject(e8);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e8) {
                    reject(e8);
                  }
                }
                function step(result) {
                  result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            }
            function __generator2(thisArg, body) {
              var _2 = {
                label: 0,
                sent: function() {
                  if (t2[0] & 1)
                    throw t2[1];
                  return t2[1];
                },
                trys: [],
                ops: []
              }, f2, y4, t2, g2;
              return g2 = {
                next: verb(0),
                "throw": verb(1),
                "return": verb(2)
              }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
                return this;
              }), g2;
              function verb(n2) {
                return function(v2) {
                  return step([n2, v2]);
                };
              }
              function step(op) {
                if (f2)
                  throw new TypeError("Generator is already executing.");
                while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
                  try {
                    if (f2 = 1, y4 && (t2 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t2 = y4["return"]) && t2.call(y4), 0) : y4.next) && !(t2 = t2.call(y4, op[1])).done)
                      return t2;
                    if (y4 = 0, t2)
                      op = [op[0] & 2, t2.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t2 = op;
                        break;
                      case 4:
                        _2.label++;
                        return {
                          value: op[1],
                          done: false
                        };
                      case 5:
                        _2.label++;
                        y4 = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _2.ops.pop();
                        _2.trys.pop();
                        continue;
                      default:
                        if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                          _2 = 0;
                          continue;
                        }
                        if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                          _2.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _2.label < t2[1]) {
                          _2.label = t2[1];
                          t2 = op;
                          break;
                        }
                        if (t2 && _2.label < t2[2]) {
                          _2.label = t2[2];
                          _2.ops.push(op);
                          break;
                        }
                        if (t2[2])
                          _2.ops.pop();
                        _2.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _2);
                  } catch (e8) {
                    op = [6, e8];
                    y4 = 0;
                  } finally {
                    f2 = t2 = 0;
                  }
                if (op[0] & 5)
                  throw op[1];
                return {
                  value: op[0] ? op[1] : void 0,
                  done: true
                };
              }
            }
            var __createBinding = Object.create ? function(o2, m3, k2, k22) {
              if (k22 === void 0)
                k22 = k2;
              var desc = Object.getOwnPropertyDescriptor(m3, k2);
              if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
                desc = {
                  enumerable: true,
                  get: function() {
                    return m3[k2];
                  }
                };
              }
              Object.defineProperty(o2, k22, desc);
            } : function(o2, m3, k2, k22) {
              if (k22 === void 0)
                k22 = k2;
              o2[k22] = m3[k2];
            };
            function __exportStar(m3, o2) {
              for (var p2 in m3)
                if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
                  __createBinding(o2, m3, p2);
            }
            function __values(o2) {
              var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o2[s2], i2 = 0;
              if (m3)
                return m3.call(o2);
              if (o2 && typeof o2.length === "number")
                return {
                  next: function() {
                    if (o2 && i2 >= o2.length)
                      o2 = void 0;
                    return {
                      value: o2 && o2[i2++],
                      done: !o2
                    };
                  }
                };
              throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }
            function __read(o2, n2) {
              var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
              if (!m3)
                return o2;
              var i2 = m3.call(o2), r2, ar2 = [], e8;
              try {
                while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
                  ar2.push(r2.value);
              } catch (error) {
                e8 = {
                  error
                };
              } finally {
                try {
                  if (r2 && !r2.done && (m3 = i2["return"]))
                    m3.call(i2);
                } finally {
                  if (e8)
                    throw e8.error;
                }
              }
              return ar2;
            }
            function __spread() {
              for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
                ar2 = ar2.concat(__read(arguments[i2]));
              return ar2;
            }
            function __spreadArrays() {
              for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
                s2 += arguments[i2].length;
              for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
                for (var a3 = arguments[i2], j2 = 0, jl = a3.length; j2 < jl; j2++, k2++)
                  r2[k2] = a3[j2];
              return r2;
            }
            function __spreadArray3(to2, from, pack) {
              if (pack || arguments.length === 2)
                for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
                  if (ar2 || !(i2 in from)) {
                    if (!ar2)
                      ar2 = Array.prototype.slice.call(from, 0, i2);
                    ar2[i2] = from[i2];
                  }
                }
              return to2.concat(ar2 || Array.prototype.slice.call(from));
            }
            function __await(v2) {
              return this instanceof __await ? (this.v = v2, this) : new __await(v2);
            }
            function __asyncGenerator(thisArg, _arguments, generator) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
              return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
                return this;
              }, i2;
              function verb(n2) {
                if (g2[n2])
                  i2[n2] = function(v2) {
                    return new Promise(function(a3, b2) {
                      q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
                    });
                  };
              }
              function resume(n2, v2) {
                try {
                  step(g2[n2](v2));
                } catch (e8) {
                  settle(q2[0][3], e8);
                }
              }
              function step(r2) {
                r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
              }
              function fulfill(value) {
                resume("next", value);
              }
              function reject(value) {
                resume("throw", value);
              }
              function settle(f2, v2) {
                if (f2(v2), q2.shift(), q2.length)
                  resume(q2[0][0], q2[0][1]);
              }
            }
            function __asyncDelegator(o2) {
              var i2, p2;
              return i2 = {}, verb("next"), verb("throw", function(e8) {
                throw e8;
              }), verb("return"), i2[Symbol.iterator] = function() {
                return this;
              }, i2;
              function verb(n2, f2) {
                i2[n2] = o2[n2] ? function(v2) {
                  return (p2 = !p2) ? {
                    value: __await(o2[n2](v2)),
                    done: false
                  } : f2 ? f2(v2) : v2;
                } : f2;
              }
            }
            function __asyncValues(o2) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var m3 = o2[Symbol.asyncIterator], i2;
              return m3 ? m3.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
                return this;
              }, i2);
              function verb(n2) {
                i2[n2] = o2[n2] && function(v2) {
                  return new Promise(function(resolve, reject) {
                    v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
                  });
                };
              }
              function settle(resolve, reject, d2, v2) {
                Promise.resolve(v2).then(function(v3) {
                  resolve({
                    value: v3,
                    done: d2
                  });
                }, reject);
              }
            }
            function __makeTemplateObject(cooked, raw) {
              if (Object.defineProperty) {
                Object.defineProperty(cooked, "raw", {
                  value: raw
                });
              } else {
                cooked.raw = raw;
              }
              return cooked;
            }
            ;
            var __setModuleDefault = Object.create ? function(o2, v2) {
              Object.defineProperty(o2, "default", {
                enumerable: true,
                value: v2
              });
            } : function(o2, v2) {
              o2["default"] = v2;
            };
            function __importStar(mod2) {
              if (mod2 && mod2.__esModule)
                return mod2;
              var result = {};
              if (mod2 != null) {
                for (var k2 in mod2)
                  if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
                    __createBinding(result, mod2, k2);
              }
              __setModuleDefault(result, mod2);
              return result;
            }
            function __importDefault(mod2) {
              return mod2 && mod2.__esModule ? mod2 : {
                default: mod2
              };
            }
            function __classPrivateFieldGet(receiver, state, kind, f2) {
              if (kind === "a" && !f2)
                throw new TypeError("Private accessor was defined without a getter");
              if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
              return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
            }
            function __classPrivateFieldSet(receiver, state, value, kind, f2) {
              if (kind === "m")
                throw new TypeError("Private method is not writable");
              if (kind === "a" && !f2)
                throw new TypeError("Private accessor was defined without a setter");
              if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
              return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
            }
            function __classPrivateFieldIn(state, receiver) {
              if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
                throw new TypeError("Cannot use 'in' operator on non-object");
              return typeof state === "function" ? receiver === state : state.has(receiver);
            }
          },
          /* 117 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var __WEBPACK_IMPORTED_MODULE_0__is_string__ = __webpack_require__(4);
            var __WEBPACK_IMPORTED_MODULE_1__to_string__ = __webpack_require__(9);
            var __WEBPACK_IMPORTED_MODULE_2__measure_text_width__ = __webpack_require__(34);
            __webpack_exports__["a"] = function(text, maxWidth, font, str) {
              if (str === void 0) {
                str = "...";
              }
              var STEP = 16;
              var PLACEHOLDER_WIDTH = Object(__WEBPACK_IMPORTED_MODULE_2__measure_text_width__[
                "a"
                /* default */
              ])(str, font);
              var leftText = !Object(__WEBPACK_IMPORTED_MODULE_0__is_string__[
                "a"
                /* default */
              ])(text) ? Object(__WEBPACK_IMPORTED_MODULE_1__to_string__[
                "a"
                /* default */
              ])(text) : text;
              var leftWidth = maxWidth;
              var r2 = [];
              var currentText;
              var currentWidth;
              if (Object(__WEBPACK_IMPORTED_MODULE_2__measure_text_width__[
                "a"
                /* default */
              ])(text, font) <= maxWidth) {
                return text;
              }
              while (true) {
                currentText = leftText.substr(0, STEP);
                currentWidth = Object(__WEBPACK_IMPORTED_MODULE_2__measure_text_width__[
                  "a"
                  /* default */
                ])(currentText, font);
                if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
                  if (currentWidth > leftWidth) {
                    break;
                  }
                }
                r2.push(currentText);
                leftWidth -= currentWidth;
                leftText = leftText.substr(STEP);
                if (!leftText) {
                  return r2.join("");
                }
              }
              while (true) {
                currentText = leftText.substr(0, 1);
                currentWidth = Object(__WEBPACK_IMPORTED_MODULE_2__measure_text_width__[
                  "a"
                  /* default */
                ])(currentText, font);
                if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
                  break;
                }
                r2.push(currentText);
                leftWidth -= currentWidth;
                leftText = leftText.substr(1);
                if (!leftText) {
                  return r2.join("");
                }
              }
              return "" + r2.join("") + str;
            };
          },
          /* 118 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            var default_12 = (
              /** @class */
              function() {
                function default_13() {
                  this.map = {};
                }
                default_13.prototype.has = function(key) {
                  return this.map[key] !== void 0;
                };
                default_13.prototype.get = function(key, def) {
                  var v2 = this.map[key];
                  return v2 === void 0 ? def : v2;
                };
                default_13.prototype.set = function(key, value) {
                  this.map[key] = value;
                };
                default_13.prototype.clear = function() {
                  this.map = {};
                };
                default_13.prototype.delete = function(key) {
                  delete this.map[key];
                };
                default_13.prototype.size = function() {
                  return Object.keys(this.map).length;
                };
                return default_13;
              }()
            );
            __webpack_exports__["a"] = default_12;
          },
          /* 119 */
          /***/
          function(module2, exports2) {
            function WrappedTree(w2, h2, y4, c3) {
              if (c3 === void 0) {
                c3 = [];
              }
              var me2 = this;
              me2.w = w2 || 0;
              me2.h = h2 || 0;
              me2.y = y4 || 0;
              me2.x = 0;
              me2.c = c3 || [];
              me2.cs = c3.length;
              me2.prelim = 0;
              me2.mod = 0;
              me2.shift = 0;
              me2.change = 0;
              me2.tl = null;
              me2.tr = null;
              me2.el = null;
              me2.er = null;
              me2.msel = 0;
              me2.mser = 0;
            }
            WrappedTree.fromNode = function(root, isHorizontal) {
              if (!root)
                return null;
              var children = [];
              root.children.forEach(function(child) {
                children.push(WrappedTree.fromNode(child, isHorizontal));
              });
              if (isHorizontal)
                return new WrappedTree(root.height, root.width, root.x, children);
              return new WrappedTree(root.width, root.height, root.y, children);
            };
            function moveRight(node, move3, isHorizontal) {
              if (isHorizontal) {
                node.y += move3;
              } else {
                node.x += move3;
              }
              node.children.forEach(function(child) {
                moveRight(child, move3, isHorizontal);
              });
            }
            function getMin(node, isHorizontal) {
              var res = isHorizontal ? node.y : node.x;
              node.children.forEach(function(child) {
                res = Math.min(getMin(child, isHorizontal), res);
              });
              return res;
            }
            function normalize(node, isHorizontal) {
              var min3 = getMin(node, isHorizontal);
              moveRight(node, -min3, isHorizontal);
            }
            function convertBack(converted, root, isHorizontal) {
              if (isHorizontal) {
                root.y = converted.x;
              } else {
                root.x = converted.x;
              }
              converted.c.forEach(function(child, i2) {
                convertBack(child, root.children[i2], isHorizontal);
              });
            }
            function layer(node, isHorizontal, d2) {
              if (d2 === void 0) {
                d2 = 0;
              }
              if (isHorizontal) {
                node.x = d2;
                d2 += node.width;
              } else {
                node.y = d2;
                d2 += node.height;
              }
              node.children.forEach(function(child) {
                layer(child, isHorizontal, d2);
              });
            }
            module2.exports = function(root, options) {
              if (options === void 0) {
                options = {};
              }
              var isHorizontal = options.isHorizontal;
              function firstWalk(t2) {
                if (t2.cs === 0) {
                  setExtremes(t2);
                  return;
                }
                firstWalk(t2.c[0]);
                var ih = updateIYL(bottom(t2.c[0].el), 0, null);
                for (var i2 = 1; i2 < t2.cs; ++i2) {
                  firstWalk(t2.c[i2]);
                  var min3 = bottom(t2.c[i2].er);
                  separate(t2, i2, ih);
                  ih = updateIYL(min3, i2, ih);
                }
                positionRoot(t2);
                setExtremes(t2);
              }
              function setExtremes(t2) {
                if (t2.cs === 0) {
                  t2.el = t2;
                  t2.er = t2;
                  t2.msel = t2.mser = 0;
                } else {
                  t2.el = t2.c[0].el;
                  t2.msel = t2.c[0].msel;
                  t2.er = t2.c[t2.cs - 1].er;
                  t2.mser = t2.c[t2.cs - 1].mser;
                }
              }
              function separate(t2, i2, ih) {
                var sr2 = t2.c[i2 - 1];
                var mssr = sr2.mod;
                var cl = t2.c[i2];
                var mscl = cl.mod;
                while (sr2 !== null && cl !== null) {
                  if (bottom(sr2) > ih.low)
                    ih = ih.nxt;
                  var dist = mssr + sr2.prelim + sr2.w - (mscl + cl.prelim);
                  if (dist > 0) {
                    mscl += dist;
                    moveSubtree(t2, i2, ih.index, dist);
                  }
                  var sy = bottom(sr2);
                  var cy = bottom(cl);
                  if (sy <= cy) {
                    sr2 = nextRightContour(sr2);
                    if (sr2 !== null)
                      mssr += sr2.mod;
                  }
                  if (sy >= cy) {
                    cl = nextLeftContour(cl);
                    if (cl !== null)
                      mscl += cl.mod;
                  }
                }
                if (!sr2 && !!cl) {
                  setLeftThread(t2, i2, cl, mscl);
                } else if (!!sr2 && !cl) {
                  setRightThread(t2, i2, sr2, mssr);
                }
              }
              function moveSubtree(t2, i2, si2, dist) {
                t2.c[i2].mod += dist;
                t2.c[i2].msel += dist;
                t2.c[i2].mser += dist;
                distributeExtra(t2, i2, si2, dist);
              }
              function nextLeftContour(t2) {
                return t2.cs === 0 ? t2.tl : t2.c[0];
              }
              function nextRightContour(t2) {
                return t2.cs === 0 ? t2.tr : t2.c[t2.cs - 1];
              }
              function bottom(t2) {
                return t2.y + t2.h;
              }
              function setLeftThread(t2, i2, cl, modsumcl) {
                var li2 = t2.c[0].el;
                li2.tl = cl;
                var diff = modsumcl - cl.mod - t2.c[0].msel;
                li2.mod += diff;
                li2.prelim -= diff;
                t2.c[0].el = t2.c[i2].el;
                t2.c[0].msel = t2.c[i2].msel;
              }
              function setRightThread(t2, i2, sr2, modsumsr) {
                var ri2 = t2.c[i2].er;
                ri2.tr = sr2;
                var diff = modsumsr - sr2.mod - t2.c[i2].mser;
                ri2.mod += diff;
                ri2.prelim -= diff;
                t2.c[i2].er = t2.c[i2 - 1].er;
                t2.c[i2].mser = t2.c[i2 - 1].mser;
              }
              function positionRoot(t2) {
                t2.prelim = (t2.c[0].prelim + t2.c[0].mod + t2.c[t2.cs - 1].mod + t2.c[t2.cs - 1].prelim + t2.c[t2.cs - 1].w) / 2 - t2.w / 2;
              }
              function secondWalk(t2, modsum) {
                modsum += t2.mod;
                t2.x = t2.prelim + modsum;
                addChildSpacing(t2);
                for (var i2 = 0; i2 < t2.cs; i2++) {
                  secondWalk(t2.c[i2], modsum);
                }
              }
              function distributeExtra(t2, i2, si2, dist) {
                if (si2 !== i2 - 1) {
                  var nr2 = i2 - si2;
                  t2.c[si2 + 1].shift += dist / nr2;
                  t2.c[i2].shift -= dist / nr2;
                  t2.c[i2].change -= dist - dist / nr2;
                }
              }
              function addChildSpacing(t2) {
                var d2 = 0;
                var modsumdelta = 0;
                for (var i2 = 0; i2 < t2.cs; i2++) {
                  d2 += t2.c[i2].shift;
                  modsumdelta += d2 + t2.c[i2].change;
                  t2.c[i2].mod += modsumdelta;
                }
              }
              function updateIYL(low, index2, ih) {
                while (ih !== null && low >= ih.low) {
                  ih = ih.nxt;
                }
                return {
                  low,
                  index: index2,
                  nxt: ih
                };
              }
              layer(root, isHorizontal);
              var wt2 = WrappedTree.fromNode(root, isHorizontal);
              firstWalk(wt2);
              secondWalk(wt2, 0);
              convertBack(wt2, root, isHorizontal);
              normalize(root, isHorizontal);
              return root;
            };
          },
          /* 120 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf3(subClass, superClass);
            }
            function _setPrototypeOf3(o2, p2) {
              _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o3, p3) {
                o3.__proto__ = p3;
                return o3;
              };
              return _setPrototypeOf3(o2, p2);
            }
            var TreeLayout2 = __webpack_require__(11);
            var dendrogram = __webpack_require__(121);
            var doTreeLayout = __webpack_require__(17);
            var util = __webpack_require__(6);
            var DendrogramLayout = function(_TreeLayout) {
              _inheritsLoose(DendrogramLayout2, _TreeLayout);
              function DendrogramLayout2() {
                return _TreeLayout.apply(this, arguments) || this;
              }
              var _proto = DendrogramLayout2.prototype;
              _proto.execute = function execute() {
                var me2 = this;
                me2.rootNode.width = 0;
                return doTreeLayout(me2.rootNode, me2.options, dendrogram);
              };
              return DendrogramLayout2;
            }(TreeLayout2);
            var DEFAULT_OPTIONS = {};
            function dendrogramLayout(root, options) {
              options = util.assign({}, DEFAULT_OPTIONS, options);
              return new DendrogramLayout(root, options).execute();
            }
            module2.exports = dendrogramLayout;
          },
          /* 121 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var util = __webpack_require__(6);
            function WrappedTree(height, children) {
              if (height === void 0) {
                height = 0;
              }
              if (children === void 0) {
                children = [];
              }
              var me2 = this;
              me2.x = me2.y = 0;
              me2.leftChild = me2.rightChild = null;
              me2.height = 0;
              me2.children = children;
            }
            var DEFAULT_OPTIONS = {
              isHorizontal: true,
              nodeSep: 20,
              nodeSize: 20,
              rankSep: 200,
              subTreeSep: 10
            };
            function convertBack(converted, root, isHorizontal) {
              if (isHorizontal) {
                root.x = converted.x;
                root.y = converted.y;
              } else {
                root.x = converted.y;
                root.y = converted.x;
              }
              converted.children.forEach(function(child, i2) {
                convertBack(child, root.children[i2], isHorizontal);
              });
            }
            module2.exports = function(root, options) {
              if (options === void 0) {
                options = {};
              }
              options = util.assign({}, DEFAULT_OPTIONS, options);
              var maxDepth = 0;
              function wrappedTreeFromNode(n2) {
                if (!n2)
                  return null;
                n2.width = 0;
                if (n2.depth && n2.depth > maxDepth) {
                  maxDepth = n2.depth;
                }
                var children = n2.children;
                var childrenCount = children.length;
                var t2 = new WrappedTree(n2.height, []);
                children.forEach(function(child, i2) {
                  var childWT = wrappedTreeFromNode(child);
                  t2.children.push(childWT);
                  if (i2 === 0) {
                    t2.leftChild = childWT;
                  }
                  if (i2 === childrenCount - 1) {
                    t2.rightChild = childWT;
                  }
                });
                t2.originNode = n2;
                t2.isLeaf = n2.isLeaf();
                return t2;
              }
              function getDrawingDepth(t2) {
                if (t2.isLeaf || t2.children.length === 0) {
                  t2.drawingDepth = maxDepth;
                } else {
                  var depths = t2.children.map(function(child) {
                    return getDrawingDepth(child);
                  });
                  var minChildDepth = Math.min.apply(null, depths);
                  t2.drawingDepth = minChildDepth - 1;
                }
                return t2.drawingDepth;
              }
              var prevLeaf;
              function position(t2) {
                t2.x = t2.drawingDepth * options.rankSep;
                if (t2.isLeaf) {
                  t2.y = 0;
                  if (prevLeaf) {
                    t2.y = prevLeaf.y + prevLeaf.height + options.nodeSep;
                    if (t2.originNode.parent !== prevLeaf.originNode.parent) {
                      t2.y += options.subTreeSep;
                    }
                  }
                  prevLeaf = t2;
                } else {
                  t2.children.forEach(function(child) {
                    position(child);
                  });
                  t2.y = (t2.leftChild.y + t2.rightChild.y) / 2;
                }
              }
              var wt2 = wrappedTreeFromNode(root);
              getDrawingDepth(wt2);
              position(wt2);
              convertBack(wt2, root, options.isHorizontal);
              return root;
            };
          },
          /* 122 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf3(subClass, superClass);
            }
            function _setPrototypeOf3(o2, p2) {
              _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o3, p3) {
                o3.__proto__ = p3;
                return o3;
              };
              return _setPrototypeOf3(o2, p2);
            }
            var TreeLayout2 = __webpack_require__(11);
            var indentedTree = __webpack_require__(123);
            var separateTree = __webpack_require__(35);
            var util = __webpack_require__(6);
            var VALID_DIRECTIONS = [
              "LR",
              // left to right
              "RL",
              // right to left
              "H"
              // horizontal
            ];
            var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
            var IndentedLayout = function(_TreeLayout) {
              _inheritsLoose(IndentedLayout2, _TreeLayout);
              function IndentedLayout2() {
                return _TreeLayout.apply(this, arguments) || this;
              }
              var _proto = IndentedLayout2.prototype;
              _proto.execute = function execute() {
                var me2 = this;
                var options = me2.options;
                var root = me2.rootNode;
                options.isHorizontal = true;
                var _options$indent = options.indent, indent2 = _options$indent === void 0 ? 20 : _options$indent, _options$dropCap = options.dropCap, dropCap = _options$dropCap === void 0 ? true : _options$dropCap, _options$direction = options.direction, direction2 = _options$direction === void 0 ? DEFAULT_DIRECTION : _options$direction, align = options.align;
                if (direction2 && VALID_DIRECTIONS.indexOf(direction2) === -1) {
                  throw new TypeError("Invalid direction: " + direction2);
                }
                if (direction2 === VALID_DIRECTIONS[0]) {
                  indentedTree(root, indent2, dropCap, align);
                } else if (direction2 === VALID_DIRECTIONS[1]) {
                  indentedTree(root, indent2, dropCap, align);
                  root.right2left();
                } else if (direction2 === VALID_DIRECTIONS[2]) {
                  var _separateTree = separateTree(root, options), left = _separateTree.left, right = _separateTree.right;
                  indentedTree(left, indent2, dropCap, align);
                  left.right2left();
                  indentedTree(right, indent2, dropCap, align);
                  var bbox = left.getBoundingBox();
                  right.translate(bbox.width, 0);
                  root.x = right.x - root.width / 2;
                }
                return root;
              };
              return IndentedLayout2;
            }(TreeLayout2);
            var DEFAULT_OPTIONS = {};
            function indentedLayout(root, options) {
              options = util.assign({}, DEFAULT_OPTIONS, options);
              return new IndentedLayout(root, options).execute();
            }
            module2.exports = indentedLayout;
          },
          /* 123 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var util = __webpack_require__(6);
            function positionNode(node, previousNode, indent2, dropCap, align) {
              var displacementX = typeof indent2 === "function" ? indent2(node) : indent2 * node.depth;
              if (!dropCap) {
                try {
                  if (node.id === node.parent.children[0].id) {
                    node.x += displacementX;
                    node.y = previousNode ? previousNode.y : 0;
                    return;
                  }
                } catch (e8) {
                }
              }
              node.x += displacementX;
              if (previousNode) {
                node.y = previousNode.y + util.getHeight(previousNode, node, align);
                if (previousNode.parent && node.parent.id !== previousNode.parent.id) {
                  var prevParent = previousNode.parent;
                  var preY = prevParent.y + util.getHeight(prevParent, node, align);
                  node.y = preY > node.y ? preY : node.y;
                }
              } else {
                node.y = 0;
              }
              return;
            }
            module2.exports = function(root, indent2, dropCap, align) {
              var previousNode = null;
              root.eachNode(function(node) {
                positionNode(node, previousNode, indent2, dropCap, align);
                previousNode = node;
              });
            };
          },
          /* 124 */
          /***/
          function(module2, exports2, __webpack_require__) {
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf3(subClass, superClass);
            }
            function _setPrototypeOf3(o2, p2) {
              _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o3, p3) {
                o3.__proto__ = p3;
                return o3;
              };
              return _setPrototypeOf3(o2, p2);
            }
            var TreeLayout2 = __webpack_require__(11);
            var mindmap = __webpack_require__(125);
            var doTreeLayout = __webpack_require__(17);
            var util = __webpack_require__(6);
            var MindmapLayout = function(_TreeLayout) {
              _inheritsLoose(MindmapLayout2, _TreeLayout);
              function MindmapLayout2() {
                return _TreeLayout.apply(this, arguments) || this;
              }
              var _proto = MindmapLayout2.prototype;
              _proto.execute = function execute() {
                var me2 = this;
                return doTreeLayout(me2.rootNode, me2.options, mindmap);
              };
              return MindmapLayout2;
            }(TreeLayout2);
            var DEFAULT_OPTIONS = {};
            function mindmapLayout(root, options) {
              options = util.assign({}, DEFAULT_OPTIONS, options);
              return new MindmapLayout(root, options).execute();
            }
            module2.exports = mindmapLayout;
          },
          /* 125 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var util = __webpack_require__(6);
            function secondWalk(node, options) {
              var totalHeight = 0;
              if (!node.children.length) {
                totalHeight = node.height;
              } else {
                node.children.forEach(function(c3) {
                  totalHeight += secondWalk(c3, options);
                });
              }
              node._subTreeSep = options.getSubTreeSep(node.data);
              node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;
              return node.totalHeight;
            }
            function thirdWalk(node) {
              var children = node.children;
              var len = children.length;
              if (len) {
                children.forEach(function(c3) {
                  thirdWalk(c3);
                });
                var first = children[0];
                var last2 = children[len - 1];
                var childrenHeight = last2.y - first.y + last2.height;
                var childrenTotalHeight = 0;
                children.forEach(function(child) {
                  childrenTotalHeight += child.totalHeight;
                });
                if (childrenHeight > node.height) {
                  node.y = first.y + childrenHeight / 2 - node.height / 2;
                } else if (children.length !== 1 || node.height > childrenTotalHeight) {
                  var offset = node.y + (node.height - childrenHeight) / 2 - first.y;
                  children.forEach(function(c3) {
                    c3.translate(0, offset);
                  });
                } else {
                  node.y = (first.y + first.height / 2 + last2.y + last2.height / 2) / 2 - node.height / 2;
                }
              }
            }
            var DEFAULT_OPTIONS = {
              getSubTreeSep: function getSubTreeSep() {
                return 0;
              }
            };
            module2.exports = function(root, options) {
              if (options === void 0) {
                options = {};
              }
              options = util.assign({}, DEFAULT_OPTIONS, options);
              root.parent = {
                x: 0,
                width: 0,
                height: 0,
                y: 0
              };
              root.BFTraverse(function(node) {
                node.x = node.parent.x + node.parent.width;
              });
              root.parent = null;
              secondWalk(root, options);
              root.startY = 0;
              root.y = root.totalHeight / 2 - root.height / 2;
              root.eachNode(function(node) {
                var children = node.children;
                var len = children.length;
                if (len) {
                  var first = children[0];
                  first.startY = node.startY + node._subTreeSep;
                  if (len === 1) {
                    first.y = node.y + node.height / 2 - first.height / 2;
                  } else {
                    first.y = first.startY + first.totalHeight / 2 - first.height / 2;
                    for (var i2 = 1; i2 < len; i2++) {
                      var c3 = children[i2];
                      c3.startY = children[i2 - 1].startY + children[i2 - 1].totalHeight;
                      c3.y = c3.startY + c3.totalHeight / 2 - c3.height / 2;
                    }
                  }
                }
              });
              thirdWalk(root);
            };
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/insert-css/index.js
var require_insert_css = __commonJS({
  "node_modules/insert-css/index.js"(exports, module) {
    var containers = [];
    var styleElements = [];
    var usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";
    function insertCss5(css, options) {
      options = options || {};
      if (css === void 0) {
        throw new Error(usage);
      }
      var position = options.prepend === true ? "prepend" : "append";
      var container = options.container !== void 0 ? options.container : document.querySelector("head");
      var containerId = containers.indexOf(container);
      if (containerId === -1) {
        containerId = containers.push(container) - 1;
        styleElements[containerId] = {};
      }
      var styleElement;
      if (styleElements[containerId] !== void 0 && styleElements[containerId][position] !== void 0) {
        styleElement = styleElements[containerId][position];
      } else {
        styleElement = styleElements[containerId][position] = createStyleElement();
        if (position === "prepend") {
          container.insertBefore(styleElement, container.childNodes[0]);
        } else {
          container.appendChild(styleElement);
        }
      }
      if (css.charCodeAt(0) === 65279) {
        css = css.substr(1, css.length);
      }
      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css;
      } else {
        styleElement.textContent += css;
      }
      return styleElement;
    }
    function createStyleElement() {
      var styleElement = document.createElement("style");
      styleElement.setAttribute("type", "text/css");
      return styleElement;
    }
    module.exports = insertCss5;
    module.exports.insertCss = insertCss5;
  }
});

// node_modules/@antv/g6-pc/es/index.js
init_tslib_es6();

// node_modules/@antv/g6-core/es/behavior/behavior.js
init_esm();

// node_modules/@antv/g6-core/es/behavior/behaviorOption.js
init_esm();
var behaviorOption_default = {
  getDefaultCfg: function getDefaultCfg() {
    return {};
  },
  /**
   * register event handler, behavior will auto bind events
   * for example:
   * return {
   *  click: 'onClick'
   * }
   */
  getEvents: function getEvents() {
    return {};
  },
  updateCfg: function updateCfg(cfg) {
    Object.assign(this, cfg);
    return true;
  },
  shouldBegin: function shouldBegin() {
    return true;
  },
  shouldUpdate: function shouldUpdate() {
    return true;
  },
  shouldEnd: function shouldEnd() {
    return true;
  },
  /**
   * auto bind events when register behavior
   * @param graph Graph instance
   */
  bind: function bind(graph) {
    var _this = this;
    var events = this.events;
    this.graph = graph;
    if (this.type === "drag-canvas" || this.type === "brush-select" || this.type === "lasso-select") {
      graph.get("canvas").set("draggable", true);
    }
    each_default(events, function(handler, event) {
      graph.on(event, handler);
    });
    document.addEventListener("visibilitychange", function() {
      _this.keydown = false;
    });
  },
  unbind: function unbind(graph) {
    var events = this.events;
    var draggable = graph.get("canvas").get("draggable");
    if (this.type === "drag-canvas" || this.type === "brush-select" || this.type === "lasso-select") {
      graph.get("canvas").set("draggable", false);
    }
    each_default(events, function(handler, event) {
      graph.off(event, handler);
    });
    graph.get("canvas").set("draggable", draggable);
  },
  get: function get(val) {
    return this[val];
  },
  set: function set(key, val) {
    this[key] = val;
    return this;
  }
};

// node_modules/@antv/g6-core/es/behavior/behavior.js
var Behavior = (
  /** @class */
  function() {
    function Behavior2() {
    }
    Behavior2.registerBehavior = function(type, behavior) {
      if (!behavior) {
        throw new Error("please specify handler for this behavior: ".concat(type));
      }
      var prototype = clone_default(behaviorOption_default);
      Object.assign(prototype, behavior);
      var base = function base2(cfg) {
        var _this = this;
        Object.assign(this, this.getDefaultCfg(), cfg);
        var events = this.getEvents();
        this.events = null;
        var eventsToBind = {};
        if (events) {
          each_default(events, function(handle, event) {
            eventsToBind[event] = wrap_behavior_default(_this, handle);
          });
          this.events = eventsToBind;
        }
      };
      base.prototype = prototype;
      Behavior2.types[type] = base;
    };
    Behavior2.hasBehavior = function(type) {
      return !!Behavior2.types[type];
    };
    Behavior2.getBehavior = function(type) {
      return Behavior2.types[type];
    };
    Behavior2.types = {};
    return Behavior2;
  }()
);
var behavior_default = Behavior;

// node_modules/@antv/g6-core/es/behavior/index.js
var behavior_default2 = behavior_default;

// node_modules/@antv/g6-core/es/graph/graph.js
init_tslib_es6();
init_esm();

// node_modules/@antv/algorithm/es/index.js
var es_exports = {};
__export(es_exports, {
  GADDI: () => gaddi_default,
  Stack: () => stack_default,
  breadthFirstSearch: () => bfs_default,
  connectedComponent: () => getConnectedComponents,
  cosineSimilarity: () => cosine_similarity_default,
  default: () => es_default,
  depthFirstSearch: () => depthFirstSearch,
  detectAllCycles: () => detectAllCycles,
  detectAllDirectedCycle: () => detectAllDirectedCycle,
  detectAllUndirectedCycle: () => detectAllUndirectedCycle,
  detectCycle: () => detect_cycle_default,
  detectDirectedCycle: () => detectDirectedCycle3,
  dijkstra: () => dijkstra_default,
  findAllPath: () => findAllPath,
  findShortestPath: () => findShortestPath,
  floydWarshall: () => floydWarshall_default,
  getAdjMatrix: () => adjacent_matrix_default,
  getDegree: () => degree_default,
  getInDegree: () => getInDegree,
  getNeighbors: () => getNeighbors,
  getOutDegree: () => getOutDegree,
  iLouvain: () => i_louvain_default,
  kCore: () => k_core_default,
  kMeans: () => k_means_default,
  labelPropagation: () => label_propagation_default,
  louvain: () => louvain_default,
  minimumSpanningTree: () => mts_default,
  nodesCosineSimilarity: () => nodes_cosine_similarity_default,
  pageRank: () => pageRank_default
});

// node_modules/@antv/algorithm/es/adjacent-matrix.js
var adjMatrix = function adjMatrix2(graphData, directed) {
  var nodes = graphData.nodes, edges = graphData.edges;
  var matrix = [];
  var nodeMap = {};
  if (!nodes) {
    throw new Error("invalid nodes data!");
  }
  if (nodes) {
    nodes.forEach(function(node, i2) {
      nodeMap[node.id] = i2;
      var row = [];
      matrix.push(row);
    });
  }
  if (edges) {
    edges.forEach(function(edge) {
      var source = edge.source, target = edge.target;
      var sIndex = nodeMap[source];
      var tIndex = nodeMap[target];
      if (!sIndex && sIndex !== 0 || !tIndex && tIndex !== 0)
        return;
      matrix[sIndex][tIndex] = 1;
      if (!directed) {
        matrix[tIndex][sIndex] = 1;
      }
    });
  }
  return matrix;
};
var adjacent_matrix_default = adjMatrix;

// node_modules/@antv/algorithm/es/structs/linked-list.js
var defaultComparator = function defaultComparator2(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  return false;
};
var LinkedListNode = (
  /** @class */
  function() {
    function LinkedListNode2(value, next) {
      if (next === void 0) {
        next = null;
      }
      this.value = value;
      this.next = next;
    }
    LinkedListNode2.prototype.toString = function(callback) {
      return callback ? callback(this.value) : "".concat(this.value);
    };
    return LinkedListNode2;
  }()
);
var LinkedList = (
  /** @class */
  function() {
    function LinkedList2(comparator) {
      if (comparator === void 0) {
        comparator = defaultComparator;
      }
      this.head = null;
      this.tail = null;
      this.compare = comparator;
    }
    LinkedList2.prototype.prepend = function(value) {
      var newNode = new LinkedListNode(value, this.head);
      this.head = newNode;
      if (!this.tail) {
        this.tail = newNode;
      }
      return this;
    };
    LinkedList2.prototype.append = function(value) {
      var newNode = new LinkedListNode(value);
      if (!this.head) {
        this.head = newNode;
        this.tail = newNode;
        return this;
      }
      this.tail.next = newNode;
      this.tail = newNode;
      return this;
    };
    LinkedList2.prototype.delete = function(value) {
      if (!this.head) {
        return null;
      }
      var deleteNode = null;
      while (this.head && this.compare(this.head.value, value)) {
        deleteNode = this.head;
        this.head = this.head.next;
      }
      var currentNode = this.head;
      if (currentNode !== null) {
        while (currentNode.next) {
          if (this.compare(currentNode.next.value, value)) {
            deleteNode = currentNode.next;
            currentNode.next = currentNode.next.next;
          } else {
            currentNode = currentNode.next;
          }
        }
      }
      if (this.compare(this.tail.value, value)) {
        this.tail = currentNode;
      }
      return deleteNode;
    };
    LinkedList2.prototype.find = function(_a2) {
      var _b = _a2.value, value = _b === void 0 ? void 0 : _b, _c = _a2.callback, callback = _c === void 0 ? void 0 : _c;
      if (!this.head) {
        return null;
      }
      var currentNode = this.head;
      while (currentNode) {
        if (callback && callback(currentNode.value)) {
          return currentNode;
        }
        if (value !== void 0 && this.compare(currentNode.value, value)) {
          return currentNode;
        }
        currentNode = currentNode.next;
      }
      return null;
    };
    LinkedList2.prototype.deleteTail = function() {
      var deletedTail = this.tail;
      if (this.head === this.tail) {
        this.head = null;
        this.tail = null;
        return deletedTail;
      }
      var currentNode = this.head;
      while (currentNode.next) {
        if (!currentNode.next.next) {
          currentNode.next = null;
        } else {
          currentNode = currentNode.next;
        }
      }
      this.tail = currentNode;
      return deletedTail;
    };
    LinkedList2.prototype.deleteHead = function() {
      if (!this.head) {
        return null;
      }
      var deletedHead = this.head;
      if (this.head.next) {
        this.head = this.head.next;
      } else {
        this.head = null;
        this.tail = null;
      }
      return deletedHead;
    };
    LinkedList2.prototype.fromArray = function(values2) {
      var _this = this;
      values2.forEach(function(value) {
        return _this.append(value);
      });
      return this;
    };
    LinkedList2.prototype.toArray = function() {
      var nodes = [];
      var currentNode = this.head;
      while (currentNode) {
        nodes.push(currentNode);
        currentNode = currentNode.next;
      }
      return nodes;
    };
    LinkedList2.prototype.reverse = function() {
      var currentNode = this.head;
      var prevNode = null;
      var nextNode = null;
      while (currentNode) {
        nextNode = currentNode.next;
        currentNode.next = prevNode;
        prevNode = currentNode;
        currentNode = nextNode;
      }
      this.tail = this.head;
      this.head = prevNode;
    };
    LinkedList2.prototype.toString = function(callback) {
      if (callback === void 0) {
        callback = void 0;
      }
      return this.toArray().map(function(node) {
        return node.toString(callback);
      }).toString();
    };
    return LinkedList2;
  }()
);
var linked_list_default = LinkedList;

// node_modules/@antv/algorithm/es/structs/queue.js
var Queue = (
  /** @class */
  function() {
    function Queue2() {
      this.linkedList = new linked_list_default();
    }
    Queue2.prototype.isEmpty = function() {
      return !this.linkedList.head;
    };
    Queue2.prototype.peek = function() {
      if (!this.linkedList.head) {
        return null;
      }
      return this.linkedList.head.value;
    };
    Queue2.prototype.enqueue = function(value) {
      this.linkedList.append(value);
    };
    Queue2.prototype.dequeue = function() {
      var removeHead = this.linkedList.deleteHead();
      return removeHead ? removeHead.value : null;
    };
    Queue2.prototype.toString = function(callback) {
      return this.linkedList.toString(callback);
    };
    return Queue2;
  }()
);
var queue_default = Queue;

// node_modules/@antv/algorithm/es/util.js
var getNeighbors = function getNeighbors2(nodeId, edges, type) {
  if (edges === void 0) {
    edges = [];
  }
  var currentEdges = edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
  if (type === "target") {
    var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
      return edge.source === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
      return edge.target;
    });
  }
  if (type === "source") {
    var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
      return edge.target === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
      return edge.source;
    });
  }
  var neighhborsConverter = function neighhborsConverter2(edge) {
    return edge.source === nodeId ? edge.target : edge.source;
  };
  return currentEdges.map(neighhborsConverter);
};
var getOutEdgesNodeId = function getOutEdgesNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId;
  });
};
var getEdgesByNodeId = function getEdgesByNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
};
var uniqueId = function uniqueId2(index2) {
  if (index2 === void 0) {
    index2 = 0;
  }
  var random1 = "".concat(Math.random()).split(".")[1].substr(0, 5);
  var random2 = "".concat(Math.random()).split(".")[1].substr(0, 5);
  return "".concat(index2, "-").concat(random1).concat(random2);
};

// node_modules/@antv/algorithm/es/bfs.js
function initCallbacks(callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var initiatedCallback = callbacks;
  var stubCallback = function stubCallback2() {
  };
  var allowTraversalCallback = function() {
    var seen = {};
    return function(_a2) {
      var next = _a2.next;
      var id = next;
      if (!seen[id]) {
        seen[id] = true;
        return true;
      }
      return false;
    };
  }();
  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
  initiatedCallback.enter = callbacks.enter || stubCallback;
  initiatedCallback.leave = callbacks.leave || stubCallback;
  return initiatedCallback;
}
var breadthFirstSearch = function breadthFirstSearch2(graphData, startNodeId, originalCallbacks, directed) {
  if (directed === void 0) {
    directed = true;
  }
  var callbacks = initCallbacks(originalCallbacks);
  var nodeQueue = new queue_default();
  var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
  nodeQueue.enqueue(startNodeId);
  var previousNode = "";
  var _loop_1 = function _loop_12() {
    var currentNode = nodeQueue.dequeue();
    callbacks.enter({
      current: currentNode,
      previous: previousNode
    });
    getNeighbors(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
      if (callbacks.allowTraversal({
        previous: previousNode,
        current: currentNode,
        next: nextNode
      })) {
        nodeQueue.enqueue(nextNode);
      }
    });
    callbacks.leave({
      current: currentNode,
      previous: previousNode
    });
    previousNode = currentNode;
  };
  while (!nodeQueue.isEmpty()) {
    _loop_1();
  }
};
var bfs_default = breadthFirstSearch;

// node_modules/@antv/algorithm/es/connected-component.js
var detectConnectedComponents = function detectConnectedComponents2(graphData) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var allComponents = [];
  var visited = {};
  var nodeStack = [];
  var getComponent = function getComponent2(node2) {
    nodeStack.push(node2);
    visited[node2.id] = true;
    var neighbors = getNeighbors(node2.id, edges);
    var _loop_1 = function _loop_12(i4) {
      var neighbor = neighbors[i4];
      if (!visited[neighbor]) {
        var targetNode = nodes.filter(function(node3) {
          return node3.id === neighbor;
        });
        if (targetNode.length > 0) {
          getComponent2(targetNode[0]);
        }
      }
    };
    for (var i3 = 0; i3 < neighbors.length; ++i3) {
      _loop_1(i3);
    }
  };
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var node = nodes[i2];
    if (!visited[node.id]) {
      getComponent(node);
      var component = [];
      while (nodeStack.length > 0) {
        component.push(nodeStack.pop());
      }
      allComponents.push(component);
    }
  }
  return allComponents;
};
var detectStrongConnectComponents = function detectStrongConnectComponents2(graphData) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodeStack = [];
  var inStack = {};
  var indices = {};
  var lowLink = {};
  var allComponents = [];
  var index2 = 0;
  var getComponent = function getComponent2(node2) {
    indices[node2.id] = index2;
    lowLink[node2.id] = index2;
    index2 += 1;
    nodeStack.push(node2);
    inStack[node2.id] = true;
    var neighbors = getNeighbors(node2.id, edges, "target").filter(function(n2) {
      return nodes.map(function(node3) {
        return node3.id;
      }).indexOf(n2) > -1;
    });
    var _loop_2 = function _loop_22(i3) {
      var targetNodeID = neighbors[i3];
      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {
        var targetNode = nodes.filter(function(node3) {
          return node3.id === targetNodeID;
        });
        if (targetNode.length > 0) {
          getComponent2(targetNode[0]);
        }
        lowLink[node2.id] = Math.min(lowLink[node2.id], lowLink[targetNodeID]);
      } else if (inStack[targetNodeID]) {
        lowLink[node2.id] = Math.min(lowLink[node2.id], indices[targetNodeID]);
      }
    };
    for (var i2 = 0; i2 < neighbors.length; i2++) {
      _loop_2(i2);
    }
    if (lowLink[node2.id] === indices[node2.id]) {
      var component = [];
      while (nodeStack.length > 0) {
        var tmpNode = nodeStack.pop();
        inStack[tmpNode.id] = false;
        component.push(tmpNode);
        if (tmpNode === node2)
          break;
      }
      if (component.length > 0) {
        allComponents.push(component);
      }
    }
  };
  for (var _i2 = 0, nodes_1 = nodes; _i2 < nodes_1.length; _i2++) {
    var node = nodes_1[_i2];
    if (!indices[node.id] && indices[node.id] !== 0) {
      getComponent(node);
    }
  }
  return allComponents;
};
function getConnectedComponents(graphData, directed) {
  if (directed)
    return detectStrongConnectComponents(graphData);
  return detectConnectedComponents(graphData);
}

// node_modules/@antv/algorithm/es/degree.js
var degree = function degree2(graphData) {
  var degrees = {};
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  nodes.forEach(function(node) {
    degrees[node.id] = {
      degree: 0,
      inDegree: 0,
      outDegree: 0
    };
  });
  edges.forEach(function(edge) {
    degrees[edge.source].degree++;
    degrees[edge.source].outDegree++;
    degrees[edge.target].degree++;
    degrees[edge.target].inDegree++;
  });
  return degrees;
};
var degree_default = degree;
var getInDegree = function getInDegree2(graphData, nodeId) {
  var nodeDegree = degree(graphData);
  if (nodeDegree[nodeId]) {
    return degree(graphData)[nodeId].inDegree;
  }
  return 0;
};
var getOutDegree = function getOutDegree2(graphData, nodeId) {
  var nodeDegree = degree(graphData);
  if (nodeDegree[nodeId]) {
    return degree(graphData)[nodeId].outDegree;
  }
  return 0;
};

// node_modules/@antv/algorithm/es/dfs.js
function initCallbacks2(callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var initiatedCallback = callbacks;
  var stubCallback = function stubCallback2() {
  };
  var allowTraversalCallback = function() {
    var seen = {};
    return function(_a2) {
      var next = _a2.next;
      if (!seen[next]) {
        seen[next] = true;
        return true;
      }
      return false;
    };
  }();
  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
  initiatedCallback.enter = callbacks.enter || stubCallback;
  initiatedCallback.leave = callbacks.leave || stubCallback;
  return initiatedCallback;
}
function depthFirstSearchRecursive(graphData, currentNode, previousNode, callbacks, directed) {
  if (directed === void 0) {
    directed = true;
  }
  callbacks.enter({
    current: currentNode,
    previous: previousNode
  });
  var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
  getNeighbors(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
    if (callbacks.allowTraversal({
      previous: previousNode,
      current: currentNode,
      next: nextNode
    })) {
      depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks, directed);
    }
  });
  callbacks.leave({
    current: currentNode,
    previous: previousNode
  });
}
function depthFirstSearch(graphData, startNodeId, callbacks, directed) {
  if (directed === void 0) {
    directed = true;
  }
  depthFirstSearchRecursive(graphData, startNodeId, "", initCallbacks2(callbacks), directed);
}

// node_modules/@antv/algorithm/es/detect-cycle.js
var detectDirectedCycle = function detectDirectedCycle2(graphData) {
  var cycle = null;
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
  var dfsParentMap = {};
  var unvisitedSet = {};
  var visitingSet = {};
  var visitedSet = {};
  nodes.forEach(function(node) {
    unvisitedSet[node.id] = node;
  });
  var callbacks = {
    enter: function enter(_a3) {
      var currentNode = _a3.current, previousNode = _a3.previous;
      if (visitingSet[currentNode]) {
        cycle = {};
        var currentCycleNode = currentNode;
        var previousCycleNode = previousNode;
        while (previousCycleNode !== currentNode) {
          cycle[currentCycleNode] = previousCycleNode;
          currentCycleNode = previousCycleNode;
          previousCycleNode = dfsParentMap[previousCycleNode];
        }
        cycle[currentCycleNode] = previousCycleNode;
      } else {
        visitingSet[currentNode] = currentNode;
        delete unvisitedSet[currentNode];
        dfsParentMap[currentNode] = previousNode;
      }
    },
    leave: function leave(_a3) {
      var currentNode = _a3.current;
      visitedSet[currentNode] = currentNode;
      delete visitingSet[currentNode];
    },
    allowTraversal: function allowTraversal(_a3) {
      var nextNode = _a3.next;
      if (cycle) {
        return false;
      }
      return !visitedSet[nextNode];
    }
  };
  while (Object.keys(unvisitedSet).length) {
    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];
    depthFirstSearch(graphData, firsetUnVisitedKey, callbacks);
  }
  return cycle;
};
var detectAllUndirectedCycle = function detectAllUndirectedCycle2(graphData, nodeIds, include) {
  var _a2, _b;
  if (include === void 0) {
    include = true;
  }
  var allCycles = [];
  var components3 = getConnectedComponents(graphData, false);
  for (var _i2 = 0, components_1 = components3; _i2 < components_1.length; _i2++) {
    var component = components_1[_i2];
    if (!component.length)
      continue;
    var root = component[0];
    var rootId = root.id;
    var stack = [root];
    var parent_1 = (_a2 = {}, _a2[rootId] = root, _a2);
    var used = (_b = {}, _b[rootId] = /* @__PURE__ */ new Set(), _b);
    while (stack.length > 0) {
      var curNode = stack.pop();
      var curNodeId = curNode.id;
      var neighbors = getNeighbors(curNodeId, graphData.edges);
      var _loop_1 = function _loop_12(i3) {
        var _c;
        var neighborId = neighbors[i3];
        var neighbor = graphData.nodes.find(function(node) {
          return node.id === neighborId;
        });
        if (neighborId === curNodeId) {
          allCycles.push((_c = {}, _c[neighborId] = curNode, _c));
        } else if (!(neighborId in used)) {
          parent_1[neighborId] = curNode;
          stack.push(neighbor);
          used[neighborId] = /* @__PURE__ */ new Set([curNode]);
        } else if (!used[curNodeId].has(neighbor)) {
          var cycleValid = true;
          var cyclePath = [neighbor, curNode];
          var p2 = parent_1[curNodeId];
          while (used[neighborId].size && !used[neighborId].has(p2)) {
            cyclePath.push(p2);
            if (p2 === parent_1[p2.id])
              break;
            else
              p2 = parent_1[p2.id];
          }
          cyclePath.push(p2);
          if (nodeIds && include) {
            cycleValid = false;
            if (cyclePath.findIndex(function(node) {
              return nodeIds.indexOf(node.id) > -1;
            }) > -1) {
              cycleValid = true;
            }
          } else if (nodeIds && !include) {
            if (cyclePath.findIndex(function(node) {
              return nodeIds.indexOf(node.id) > -1;
            }) > -1) {
              cycleValid = false;
            }
          }
          if (cycleValid) {
            var cycle = {};
            for (var index2 = 1; index2 < cyclePath.length; index2 += 1) {
              cycle[cyclePath[index2 - 1].id] = cyclePath[index2];
            }
            if (cyclePath.length) {
              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];
            }
            allCycles.push(cycle);
          }
          used[neighborId].add(curNode);
        }
      };
      for (var i2 = 0; i2 < neighbors.length; i2 += 1) {
        _loop_1(i2);
      }
    }
  }
  return allCycles;
};
var detectAllDirectedCycle = function detectAllDirectedCycle2(graphData, nodeIds, include) {
  if (include === void 0) {
    include = true;
  }
  var path = [];
  var blocked = /* @__PURE__ */ new Set();
  var B2 = [];
  var allCycles = [];
  var idx2Node = {};
  var node2Idx = {};
  var unblock = function unblock2(thisNode) {
    var stack = [thisNode];
    while (stack.length > 0) {
      var node2 = stack.pop();
      if (blocked.has(node2)) {
        blocked.delete(node2);
        B2[node2.id].forEach(function(n2) {
          stack.push(n2);
        });
        B2[node2.id].clear();
      }
    }
  };
  var circuit = function circuit2(node2, start, adjList2) {
    var closed = false;
    if (nodeIds && include === false && nodeIds.indexOf(node2.id) > -1)
      return closed;
    path.push(node2);
    blocked.add(node2);
    var neighbors = adjList2[node2.id];
    for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
      var neighbor = idx2Node[neighbors[i3]];
      if (neighbor === start) {
        var cycle = {};
        for (var index2 = 1; index2 < path.length; index2 += 1) {
          cycle[path[index2 - 1].id] = path[index2];
        }
        if (path.length) {
          cycle[path[path.length - 1].id] = path[0];
        }
        allCycles.push(cycle);
        closed = true;
      } else if (!blocked.has(neighbor)) {
        if (circuit2(neighbor, start, adjList2)) {
          closed = true;
        }
      }
    }
    if (closed) {
      unblock(node2);
    } else {
      for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
        var neighbor = idx2Node[neighbors[i3]];
        if (!B2[neighbor.id].has(node2)) {
          B2[neighbor.id].add(node2);
        }
      }
    }
    path.pop();
    return closed;
  };
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
  for (var i2 = 0; i2 < nodes.length; i2 += 1) {
    var node = nodes[i2];
    var nodeId = node.id;
    node2Idx[nodeId] = i2;
    idx2Node[i2] = node;
  }
  if (nodeIds && include) {
    var _loop_2 = function _loop_22(i3) {
      var nodeId2 = nodeIds[i3];
      node2Idx[nodes[i3].id] = node2Idx[nodeId2];
      node2Idx[nodeId2] = 0;
      idx2Node[0] = nodes.find(function(node2) {
        return node2.id === nodeId2;
      });
      idx2Node[node2Idx[nodes[i3].id]] = nodes[i3];
    };
    for (var i2 = 0; i2 < nodeIds.length; i2++) {
      _loop_2(i2);
    }
  }
  var getMinComponentAdj = function getMinComponentAdj2(components3) {
    var _a3;
    var minCompIdx;
    var minIdx2 = Infinity;
    for (var i3 = 0; i3 < components3.length; i3 += 1) {
      var comp = components3[i3];
      for (var j2 = 0; j2 < comp.length; j2++) {
        var nodeIdx_1 = node2Idx[comp[j2].id];
        if (nodeIdx_1 < minIdx2) {
          minIdx2 = nodeIdx_1;
          minCompIdx = i3;
        }
      }
    }
    var component2 = components3[minCompIdx];
    var adjList2 = [];
    for (var i3 = 0; i3 < component2.length; i3 += 1) {
      var node2 = component2[i3];
      adjList2[node2.id] = [];
      for (var _i2 = 0, _b = getNeighbors(node2.id, graphData.edges, "target").filter(function(n2) {
        return component2.map(function(c3) {
          return c3.id;
        }).indexOf(n2) > -1;
      }); _i2 < _b.length; _i2++) {
        var neighbor = _b[_i2];
        if (neighbor === node2.id && !(include === false && nodeIds.indexOf(node2.id) > -1)) {
          allCycles.push((_a3 = {}, _a3[node2.id] = node2, _a3));
        } else {
          adjList2[node2.id].push(node2Idx[neighbor]);
        }
      }
    }
    return {
      component: component2,
      adjList: adjList2,
      minIdx: minIdx2
    };
  };
  var nodeIdx = 0;
  while (nodeIdx < nodes.length) {
    var subgraphNodes = nodes.filter(function(n2) {
      return node2Idx[n2.id] >= nodeIdx;
    });
    var sccs = detectStrongConnectComponents({
      nodes: subgraphNodes,
      edges: graphData.edges
    }).filter(function(component2) {
      return component2.length > 1;
    });
    if (sccs.length === 0)
      break;
    var scc = getMinComponentAdj(sccs);
    var minIdx = scc.minIdx, adjList = scc.adjList, component = scc.component;
    if (component.length > 1) {
      component.forEach(function(node2) {
        B2[node2.id] = /* @__PURE__ */ new Set();
      });
      var startNode = idx2Node[minIdx];
      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1)
        return allCycles;
      circuit(startNode, startNode, adjList);
      nodeIdx = minIdx + 1;
    } else {
      break;
    }
  }
  return allCycles;
};
var detectAllCycles = function detectAllCycles2(graphData, directed, nodeIds, include) {
  if (include === void 0) {
    include = true;
  }
  if (directed)
    return detectAllDirectedCycle(graphData, nodeIds, include);
  return detectAllUndirectedCycle(graphData, nodeIds, include);
};
var detect_cycle_default = detectDirectedCycle;

// node_modules/@antv/algorithm/es/dijkstra.js
init_tslib_es6();
init_esm();
var minVertex = function minVertex2(D2, nodes, marks) {
  var minDis = Infinity;
  var minNode;
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var nodeId = nodes[i2].id;
    if (!marks[nodeId] && D2[nodeId] <= minDis) {
      minDis = D2[nodeId];
      minNode = nodes[i2];
    }
  }
  return minNode;
};
var dijkstra = function dijkstra2(graphData, source, directed, weightPropertyName) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodeIds = [];
  var marks = {};
  var D2 = {};
  var prevs = {};
  nodes.forEach(function(node, i3) {
    var id = node.id;
    nodeIds.push(id);
    D2[id] = Infinity;
    if (id === source)
      D2[id] = 0;
  });
  var nodeNum = nodes.length;
  var _loop_1 = function _loop_12(i3) {
    var minNode = minVertex(D2, nodes, marks);
    var minNodeId = minNode.id;
    marks[minNodeId] = true;
    if (D2[minNodeId] === Infinity)
      return "continue";
    var relatedEdges = [];
    if (directed)
      relatedEdges = getOutEdgesNodeId(minNodeId, edges);
    else
      relatedEdges = getEdgesByNodeId(minNodeId, edges);
    relatedEdges.forEach(function(edge) {
      var edgeTarget = edge.target;
      var edgeSource = edge.source;
      var w2 = edgeTarget === minNodeId ? edgeSource : edgeTarget;
      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
      if (D2[w2] > D2[minNode.id] + weight) {
        D2[w2] = D2[minNode.id] + weight;
        prevs[w2] = [minNode.id];
      } else if (D2[w2] === D2[minNode.id] + weight) {
        prevs[w2].push(minNode.id);
      }
    });
  };
  for (var i2 = 0; i2 < nodeNum; i2++) {
    _loop_1(i2);
  }
  prevs[source] = [source];
  var paths = {};
  for (var target in D2) {
    if (D2[target] !== Infinity) {
      findAllPaths(source, target, prevs, paths);
    }
  }
  var path = {};
  for (var target in paths) {
    path[target] = paths[target][0];
  }
  return {
    length: D2,
    path,
    allPath: paths
  };
};
var dijkstra_default = dijkstra;
function findAllPaths(source, target, prevs, foundPaths) {
  if (source === target) {
    return [source];
  }
  if (foundPaths[target]) {
    return foundPaths[target];
  }
  var paths = [];
  for (var _i2 = 0, _a2 = prevs[target]; _i2 < _a2.length; _i2++) {
    var prev = _a2[_i2];
    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);
    if (!prevPaths)
      return;
    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
      var prePath = prevPaths_1[_b];
      if (is_array_default(prePath))
        paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));
      else
        paths.push([prePath, target]);
    }
  }
  foundPaths[target] = paths;
  return foundPaths[target];
}

// node_modules/@antv/algorithm/es/find-path.js
var findShortestPath = function findShortestPath2(graphData, start, end2, directed, weightPropertyName) {
  var _a2 = dijkstra_default(graphData, start, directed, weightPropertyName), length = _a2.length, path = _a2.path, allPath = _a2.allPath;
  return {
    length: length[end2],
    path: path[end2],
    allPath: allPath[end2]
  };
};
var findAllPath = function findAllPath2(graphData, start, end2, directed) {
  var _a2;
  if (start === end2)
    return [[start]];
  var _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var visited = [start];
  var isVisited = (_a2 = {}, _a2[start] = true, _a2);
  var stack = [];
  var allPath = [];
  var neighbors = directed ? getNeighbors(start, edges, "target") : getNeighbors(start, edges);
  stack.push(neighbors);
  while (visited.length > 0 && stack.length > 0) {
    var children = stack[stack.length - 1];
    if (children.length) {
      var child = children.shift();
      if (child) {
        visited.push(child);
        isVisited[child] = true;
        neighbors = directed ? getNeighbors(child, edges, "target") : getNeighbors(child, edges);
        stack.push(neighbors.filter(function(neighbor) {
          return !isVisited[neighbor];
        }));
      }
    } else {
      var node = visited.pop();
      isVisited[node] = false;
      stack.pop();
      continue;
    }
    if (visited[visited.length - 1] === end2) {
      var path = visited.map(function(node2) {
        return node2;
      });
      allPath.push(path);
      var node = visited.pop();
      isVisited[node] = false;
      stack.pop();
    }
  }
  return allPath;
};

// node_modules/@antv/algorithm/es/floydWarshall.js
var floydWarshall = function floydWarshall2(graphData, directed) {
  var adjacentMatrix = adjacent_matrix_default(graphData, directed);
  var dist = [];
  var size3 = adjacentMatrix.length;
  for (var i2 = 0; i2 < size3; i2 += 1) {
    dist[i2] = [];
    for (var j2 = 0; j2 < size3; j2 += 1) {
      if (i2 === j2) {
        dist[i2][j2] = 0;
      } else if (adjacentMatrix[i2][j2] === 0 || !adjacentMatrix[i2][j2]) {
        dist[i2][j2] = Infinity;
      } else {
        dist[i2][j2] = adjacentMatrix[i2][j2];
      }
    }
  }
  for (var k2 = 0; k2 < size3; k2 += 1) {
    for (var i2 = 0; i2 < size3; i2 += 1) {
      for (var j2 = 0; j2 < size3; j2 += 1) {
        if (dist[i2][j2] > dist[i2][k2] + dist[k2][j2]) {
          dist[i2][j2] = dist[i2][k2] + dist[k2][j2];
        }
      }
    }
  }
  return dist;
};
var floydWarshall_default = floydWarshall;

// node_modules/@antv/algorithm/es/label-propagation.js
var labelPropagation = function labelPropagation2(graphData, directed, weightPropertyName, maxIteration) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (maxIteration === void 0) {
    maxIteration = 1e3;
  }
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var clusters = {};
  var nodeMap = {};
  nodes.forEach(function(node, i2) {
    var cid = uniqueId();
    node.clusterId = cid;
    clusters[cid] = {
      id: cid,
      nodes: [node]
    };
    nodeMap[node.id] = {
      node,
      idx: i2
    };
  });
  var adjMatrix3 = adjacent_matrix_default(graphData, directed);
  var ks = [];
  var neighbors = {};
  adjMatrix3.forEach(function(row, i2) {
    var k2 = 0;
    var iid = nodes[i2].id;
    neighbors[iid] = {};
    row.forEach(function(entry, j2) {
      if (!entry)
        return;
      k2 += entry;
      var jid = nodes[j2].id;
      neighbors[iid][jid] = entry;
    });
    ks.push(k2);
  });
  var iter = 0;
  var _loop_1 = function _loop_12() {
    var changed = false;
    nodes.forEach(function(node) {
      var neighborClusters = {};
      Object.keys(neighbors[node.id]).forEach(function(neighborId) {
        var neighborWeight = neighbors[node.id][neighborId];
        var neighborNode = nodeMap[neighborId].node;
        var neighborClusterId = neighborNode.clusterId;
        if (!neighborClusters[neighborClusterId])
          neighborClusters[neighborClusterId] = 0;
        neighborClusters[neighborClusterId] += neighborWeight;
      });
      var maxWeight = -Infinity;
      var bestClusterIds = [];
      Object.keys(neighborClusters).forEach(function(clusterId) {
        if (maxWeight < neighborClusters[clusterId]) {
          maxWeight = neighborClusters[clusterId];
          bestClusterIds = [clusterId];
        } else if (maxWeight === neighborClusters[clusterId]) {
          bestClusterIds.push(clusterId);
        }
      });
      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId)
        return;
      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);
      if (selfClusterIdx >= 0)
        bestClusterIds.splice(selfClusterIdx, 1);
      if (bestClusterIds && bestClusterIds.length) {
        changed = true;
        var selfCluster = clusters[node.clusterId];
        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);
        var bestCluster = clusters[bestClusterIds[randomIdx]];
        bestCluster.nodes.push(node);
        node.clusterId = bestCluster.id;
      }
    });
    if (!changed)
      return "break";
    iter++;
  };
  while (iter < maxIteration) {
    var state_1 = _loop_1();
    if (state_1 === "break")
      break;
  }
  Object.keys(clusters).forEach(function(clusterId) {
    var cluster = clusters[clusterId];
    if (!cluster.nodes || !cluster.nodes.length) {
      delete clusters[clusterId];
    }
  });
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var source = edge.source, target = edge.target;
    var weight = edge[weightPropertyName] || 1;
    var sourceClusterId = nodeMap[source].node.clusterId;
    var targetClusterId = nodeMap[target].node.clusterId;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].weight += weight;
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        weight,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  var clustersArray = [];
  Object.keys(clusters).forEach(function(clusterId) {
    clustersArray.push(clusters[clusterId]);
  });
  return {
    clusters: clustersArray,
    clusterEdges
  };
};
var label_propagation_default = labelPropagation;

// node_modules/@antv/algorithm/es/louvain.js
init_esm();

// node_modules/@antv/algorithm/es/utils/vector.js
init_esm();
var Vector = (
  /** @class */
  function() {
    function Vector2(arr) {
      this.arr = arr;
    }
    Vector2.prototype.getArr = function() {
      return this.arr || [];
    };
    Vector2.prototype.add = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
        return new Vector2(otherArr);
      }
      if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return new Vector2(this.arr);
      }
      if (this.arr.length === otherArr.length) {
        var res = [];
        for (var index2 in this.arr) {
          res[index2] = this.arr[index2] + otherArr[index2];
        }
        return new Vector2(res);
      }
    };
    Vector2.prototype.subtract = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
        return new Vector2(otherArr);
      }
      if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return new Vector2(this.arr);
      }
      if (this.arr.length === otherArr.length) {
        var res = [];
        for (var index2 in this.arr) {
          res[index2] = this.arr[index2] - otherArr[index2];
        }
        return new Vector2(res);
      }
    };
    Vector2.prototype.avg = function(length) {
      var res = [];
      if (length !== 0) {
        for (var index2 in this.arr) {
          res[index2] = this.arr[index2] / length;
        }
      }
      return new Vector2(res);
    };
    Vector2.prototype.negate = function() {
      var res = [];
      for (var index2 in this.arr) {
        res[index2] = -this.arr[index2];
      }
      return new Vector2(res);
    };
    Vector2.prototype.squareEuclideanDistance = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index2 in this.arr) {
          res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
        }
        return res;
      }
    };
    Vector2.prototype.euclideanDistance = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index2 in this.arr) {
          res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
        }
        return Math.sqrt(res);
      } else {
        console.error("The two vectors are unequal in length.");
      }
    };
    Vector2.prototype.normalize = function() {
      var res = [];
      var cloneArr = clone_default(this.arr);
      cloneArr.sort(function(a3, b2) {
        return a3 - b2;
      });
      var max4 = cloneArr[cloneArr.length - 1];
      var min3 = cloneArr[0];
      for (var index2 in this.arr) {
        res[index2] = (this.arr[index2] - min3) / (max4 - min3);
      }
      return new Vector2(res);
    };
    Vector2.prototype.norm2 = function() {
      var _a2;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
        return 0;
      }
      var res = 0;
      for (var index2 in this.arr) {
        res += Math.pow(this.arr[index2], 2);
      }
      return Math.sqrt(res);
    };
    Vector2.prototype.dot = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return 0;
      }
      if (this.arr.length === otherArr.length) {
        var res = 0;
        for (var index2 in this.arr) {
          res += this.arr[index2] * otherVector.arr[index2];
        }
        return res;
      } else {
        console.error("The two vectors are unequal in length.");
      }
    };
    Vector2.prototype.equal = function(otherVector) {
      var _a2;
      var otherArr = otherVector.arr;
      if (((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
        return false;
      }
      for (var index2 in this.arr) {
        if (this.arr[index2] !== otherArr[index2]) {
          return false;
        }
      }
      return true;
    };
    return Vector2;
  }()
);
var vector_default = Vector;

// node_modules/@antv/algorithm/es/utils/node-properties.js
var getAllProperties = function getAllProperties2(nodes, key) {
  if (key === void 0) {
    key = void 0;
  }
  var allProperties = [];
  nodes.forEach(function(node) {
    if (key === void 0) {
      allProperties.push(node);
    }
    if (node[key] !== void 0) {
      allProperties.push(node[key]);
    }
  });
  return allProperties;
};

// node_modules/@antv/algorithm/es/utils/data-preprocessing.js
init_esm();

// node_modules/@antv/algorithm/es/types.js
var DistanceType;
(function(DistanceType2) {
  DistanceType2["EuclideanDistance"] = "euclideanDistance";
})(DistanceType || (DistanceType = {}));

// node_modules/@antv/algorithm/es/utils/data-preprocessing.js
var getAllKeyValueMap = function getAllKeyValueMap2(dataList, involvedKeys, uninvolvedKeys) {
  var keys2 = [];
  if (involvedKeys === null || involvedKeys === void 0 ? void 0 : involvedKeys.length) {
    keys2 = involvedKeys;
  } else {
    dataList.forEach(function(data) {
      keys2 = keys2.concat(Object.keys(data));
    });
    keys2 = uniq(keys2);
  }
  var allKeyValueMap = {};
  keys2.forEach(function(key) {
    var value = [];
    dataList.forEach(function(data) {
      if (data[key] !== void 0 && data[key] !== "") {
        value.push(data[key]);
      }
    });
    if (value.length && !(uninvolvedKeys === null || uninvolvedKeys === void 0 ? void 0 : uninvolvedKeys.includes(key))) {
      allKeyValueMap[key] = uniq(value);
    }
  });
  return allKeyValueMap;
};
var oneHot = function oneHot2(dataList, involvedKeys, uninvolvedKeys) {
  var allKeyValueMap = getAllKeyValueMap(dataList, involvedKeys, uninvolvedKeys);
  var oneHotCode = [];
  if (!Object.keys(allKeyValueMap).length) {
    return oneHotCode;
  }
  var allValue = Object.values(allKeyValueMap);
  var isAllNumber = allValue.every(function(value) {
    return value.every(function(item) {
      return typeof item === "number";
    });
  });
  dataList.forEach(function(data, index2) {
    var code = [];
    Object.keys(allKeyValueMap).forEach(function(key) {
      var keyValue = data[key];
      var allKeyValue = allKeyValueMap[key];
      var valueIndex = allKeyValue.findIndex(function(value) {
        return keyValue === value;
      });
      var subCode = [];
      if (isAllNumber) {
        subCode.push(keyValue);
      } else {
        for (var i2 = 0; i2 < allKeyValue.length; i2++) {
          if (i2 === valueIndex) {
            subCode.push(1);
          } else {
            subCode.push(0);
          }
        }
      }
      code = code.concat(subCode);
    });
    oneHotCode[index2] = code;
  });
  return oneHotCode;
};
var getDistance = function getDistance2(item, otherItem, distanceType, graphData) {
  if (distanceType === void 0) {
    distanceType = DistanceType.EuclideanDistance;
  }
  var distance6 = 0;
  switch (distanceType) {
    case DistanceType.EuclideanDistance:
      distance6 = new vector_default(item).euclideanDistance(new vector_default(otherItem));
      break;
    default:
      break;
  }
  return distance6;
};

// node_modules/@antv/algorithm/es/louvain.js
var getModularity = function getModularity2(nodes, adjMatrix3, ks, m3) {
  var length = adjMatrix3.length;
  var param = 2 * m3;
  var modularity = 0;
  for (var i2 = 0; i2 < length; i2++) {
    var clusteri = nodes[i2].clusterId;
    for (var j2 = 0; j2 < length; j2++) {
      var clusterj = nodes[j2].clusterId;
      if (clusteri !== clusterj)
        continue;
      var entry = adjMatrix3[i2][j2] || 0;
      var ki2 = ks[i2] || 0;
      var kj = ks[j2] || 0;
      modularity += entry - ki2 * kj / param;
    }
  }
  modularity *= 1 / param;
  return modularity;
};
var getInertialModularity = function getInertialModularity2(nodes, allPropertiesWeight) {
  if (nodes === void 0) {
    nodes = [];
  }
  var length = nodes.length;
  var totalProperties = new vector_default([]);
  for (var i2 = 0; i2 < length; i2++) {
    totalProperties = totalProperties.add(new vector_default(allPropertiesWeight[i2]));
  }
  var avgProperties = totalProperties.avg(length);
  avgProperties.normalize();
  var variance = 0;
  for (var i2 = 0; i2 < length; i2++) {
    var propertiesi = new vector_default(allPropertiesWeight[i2]);
    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);
    variance += squareEuclideanDistance;
  }
  var squareEuclideanDistanceInfo = [];
  nodes.forEach(function() {
    squareEuclideanDistanceInfo.push([]);
  });
  for (var i2 = 0; i2 < length; i2++) {
    var propertiesi = new vector_default(allPropertiesWeight[i2]);
    nodes[i2]["clusterInertial"] = 0;
    for (var j2 = 0; j2 < length; j2++) {
      if (i2 === j2) {
        squareEuclideanDistanceInfo[i2][j2] = 0;
        continue;
      }
      var propertiesj = new vector_default(allPropertiesWeight[j2]);
      squareEuclideanDistanceInfo[i2][j2] = propertiesi.squareEuclideanDistance(propertiesj);
      nodes[i2]["clusterInertial"] += squareEuclideanDistanceInfo[i2][j2];
    }
  }
  var inertialModularity = 0;
  var param = 2 * length * variance;
  for (var i2 = 0; i2 < length; i2++) {
    var clusteri = nodes[i2].clusterId;
    for (var j2 = 0; j2 < length; j2++) {
      var clusterj = nodes[j2].clusterId;
      if (i2 === j2 || clusteri !== clusterj)
        continue;
      var inertial = nodes[i2].clusterInertial * nodes[j2].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i2][j2] / param;
      inertialModularity += inertial;
    }
  }
  return Number(inertialModularity.toFixed(4));
};
var louvain = function louvain2(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (threshold === void 0) {
    threshold = 1e-4;
  }
  if (inertialModularity === void 0) {
    inertialModularity = false;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (inertialWeight === void 0) {
    inertialWeight = 1;
  }
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var allPropertiesWeight = [];
  if (inertialModularity) {
    nodes.forEach(function(node, index2) {
      node.properties = node.properties || {};
      node.originIndex = index2;
    });
    var nodeTypeInfo_1 = [];
    if (nodes.every(function(node) {
      return node.hasOwnProperty("nodeType");
    })) {
      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function(node) {
        return node.nodeType;
      })));
      nodes.forEach(function(node) {
        node.properties.nodeType = nodeTypeInfo_1.findIndex(function(nodeType) {
          return nodeType === node.nodeType;
        });
      });
    }
    var properties = getAllProperties(nodes, propertyKey);
    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  }
  var uniqueId5 = 1;
  var clusters = {};
  var nodeMap = {};
  nodes.forEach(function(node, i2) {
    var cid = String(uniqueId5++);
    node.clusterId = cid;
    clusters[cid] = {
      id: cid,
      nodes: [node]
    };
    nodeMap[node.id] = {
      node,
      idx: i2
    };
  });
  var adjMatrix3 = adjacent_matrix_default(graphData, directed);
  var ks = [];
  var neighbors = {};
  var m3 = 0;
  adjMatrix3.forEach(function(row, i2) {
    var k2 = 0;
    var iid = nodes[i2].id;
    neighbors[iid] = {};
    row.forEach(function(entry, j2) {
      if (!entry)
        return;
      k2 += entry;
      var jid = nodes[j2].id;
      neighbors[iid][jid] = entry;
      m3 += entry;
    });
    ks.push(k2);
  });
  m3 /= 2;
  var totalModularity = Infinity;
  var previousModularity = Infinity;
  var iter = 0;
  var finalNodes = [];
  var finalClusters = {};
  while (true) {
    if (inertialModularity && nodes.every(function(node) {
      return node.hasOwnProperty("properties");
    })) {
      totalModularity = getModularity(nodes, adjMatrix3, ks, m3) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;
    } else {
      totalModularity = getModularity(nodes, adjMatrix3, ks, m3);
    }
    if (iter === 0) {
      previousModularity = totalModularity;
      finalNodes = nodes;
      finalClusters = clusters;
    }
    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;
    if (totalModularity > previousModularity) {
      finalNodes = nodes.map(function(node) {
        return {
          node,
          clusterId: node.clusterId
        };
      });
      finalClusters = clone_default(clusters);
      previousModularity = totalModularity;
    }
    if (increaseWithinThreshold || iter > 100) {
      break;
    }
    ;
    iter++;
    Object.keys(clusters).forEach(function(clusterId) {
      var sumTot = 0;
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {
          sumTot = sumTot + (edge[weightPropertyName] || 1);
        }
      });
      clusters[clusterId].sumTot = sumTot;
    });
    nodes.forEach(function(node, i2) {
      var selfCluster = clusters[node.clusterId];
      var bestIncrease = 0;
      var bestCluster;
      var commonParam = ks[i2] / (2 * m3);
      var kiin = 0;
      var selfClusterNodes = selfCluster.nodes;
      selfClusterNodes.forEach(function(scNode) {
        var scNodeIdx = nodeMap[scNode.id].idx;
        kiin += adjMatrix3[i2][scNodeIdx] || 0;
      });
      var removeModurarity = kiin - selfCluster.sumTot * commonParam;
      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function(scNode) {
        return scNode.id !== node.id;
      });
      var propertiesWeightRemove = [];
      selfClusterNodesAfterRemove.forEach(function(nodeRemove, index2) {
        propertiesWeightRemove[index2] = allPropertiesWeight[nodeRemove.originIndex];
      });
      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;
      var nodeNeighborIds = neighbors[node.id];
      Object.keys(nodeNeighborIds).forEach(function(neighborNodeId) {
        var neighborNode = nodeMap[neighborNodeId].node;
        var neighborClusterId = neighborNode.clusterId;
        if (neighborClusterId === node.clusterId)
          return;
        var neighborCluster = clusters[neighborClusterId];
        var clusterNodes = neighborCluster.nodes;
        if (!clusterNodes || !clusterNodes.length)
          return;
        var neighborClusterKiin = 0;
        clusterNodes.forEach(function(cNode) {
          var cNodeIdx = nodeMap[cNode.id].idx;
          neighborClusterKiin += adjMatrix3[i2][cNodeIdx] || 0;
        });
        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;
        var clusterNodesAfterAdd = clusterNodes.concat([node]);
        var propertiesWeightAdd = [];
        clusterNodesAfterAdd.forEach(function(nodeAdd, index2) {
          propertiesWeightAdd[index2] = allPropertiesWeight[nodeAdd.originIndex];
        });
        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;
        var increase = addModurarity - removeModurarity;
        if (inertialModularity) {
          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);
        }
        if (increase > bestIncrease) {
          bestIncrease = increase;
          bestCluster = neighborCluster;
        }
      });
      if (bestIncrease > 0) {
        bestCluster.nodes.push(node);
        var previousClusterId_1 = node.clusterId;
        node.clusterId = bestCluster.id;
        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
        var neighborClusterSumTot_1 = 0;
        var selfClusterSumTot_1 = 0;
        edges.forEach(function(edge) {
          var source = edge.source, target = edge.target;
          var sourceClusterId = nodeMap[source].node.clusterId;
          var targetClusterId = nodeMap[target].node.clusterId;
          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {
            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);
          }
          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {
            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);
          }
        });
        bestCluster.sumTot = neighborClusterSumTot_1;
        selfCluster.sumTot = selfClusterSumTot_1;
      }
    });
  }
  var newClusterIdMap = {};
  var clusterIdx = 0;
  Object.keys(finalClusters).forEach(function(clusterId) {
    var cluster = finalClusters[clusterId];
    if (!cluster.nodes || !cluster.nodes.length) {
      delete finalClusters[clusterId];
      return;
    }
    var newId = String(clusterIdx + 1);
    if (newId === clusterId) {
      return;
    }
    cluster.id = newId;
    cluster.nodes = cluster.nodes.map(function(item) {
      return {
        id: item.id,
        clusterId: newId
      };
    });
    finalClusters[newId] = cluster;
    newClusterIdMap[clusterId] = newId;
    delete finalClusters[clusterId];
    clusterIdx++;
  });
  finalNodes.forEach(function(nodeInfo) {
    var node = nodeInfo.node, clusterId = nodeInfo.clusterId;
    if (!node)
      return;
    node.clusterId = clusterId;
    if (node.clusterId && newClusterIdMap[node.clusterId])
      node.clusterId = newClusterIdMap[node.clusterId];
  });
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var source = edge.source, target = edge.target;
    var weight = edge[weightPropertyName] || 1;
    var sourceClusterId = nodeMap[source].node.clusterId;
    var targetClusterId = nodeMap[target].node.clusterId;
    if (!sourceClusterId || !targetClusterId)
      return;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].weight += weight;
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        weight,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  var clustersArray = [];
  Object.keys(finalClusters).forEach(function(clusterId) {
    clustersArray.push(finalClusters[clusterId]);
  });
  return {
    clusters: clustersArray,
    clusterEdges
  };
};
var louvain_default = louvain;

// node_modules/@antv/algorithm/es/i-louvain.js
var iLouvain = function iLouvain2(graphData, directed, weightPropertyName, threshold, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (threshold === void 0) {
    threshold = 1e-4;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (inertialWeight === void 0) {
    inertialWeight = 1;
  }
  return louvain_default(graphData, directed, weightPropertyName, threshold, true, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight);
};
var i_louvain_default = iLouvain;

// node_modules/@antv/algorithm/es/k-core.js
init_esm();
var kCore = function kCore2(graphData, k2) {
  var _a2;
  if (k2 === void 0) {
    k2 = 1;
  }
  var data = clone_default(graphData);
  var _b = data.nodes, nodes = _b === void 0 ? [] : _b;
  var _c = data.edges, edges = _c === void 0 ? [] : _c;
  var _loop_1 = function _loop_12() {
    var degrees = degree_default({
      nodes,
      edges
    });
    var nodeIds = Object.keys(degrees);
    nodeIds.sort(function(a3, b2) {
      var _a3, _b2;
      return ((_a3 = degrees[a3]) === null || _a3 === void 0 ? void 0 : _a3.degree) - ((_b2 = degrees[b2]) === null || _b2 === void 0 ? void 0 : _b2.degree);
    });
    var minIndexId = nodeIds[0];
    if (!nodes.length || ((_a2 = degrees[minIndexId]) === null || _a2 === void 0 ? void 0 : _a2.degree) >= k2) {
      return "break";
    }
    var originIndex = nodes.findIndex(function(node) {
      return node.id === minIndexId;
    });
    nodes.splice(originIndex, 1);
    edges = edges.filter(function(edge) {
      return !(edge.source === minIndexId || edge.target === minIndexId);
    });
  };
  while (true) {
    var state_1 = _loop_1();
    if (state_1 === "break")
      break;
  }
  return {
    nodes,
    edges
  };
};
var k_core_default = kCore;

// node_modules/@antv/algorithm/es/k-means.js
init_esm();
var getCentroid = function getCentroid2(distanceType, allPropertiesWeight, index2) {
  var centroid = [];
  switch (distanceType) {
    case DistanceType.EuclideanDistance:
      centroid = allPropertiesWeight[index2];
      break;
    default:
      centroid = [];
      break;
  }
  return centroid;
};
var kMeans = function kMeans2(data, k2, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {
  if (k2 === void 0) {
    k2 = 3;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (distanceType === void 0) {
    distanceType = DistanceType.EuclideanDistance;
  }
  var _a2 = data.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = data.edges, edges = _b === void 0 ? [] : _b;
  var defaultClusterInfo = {
    clusters: [{
      id: "0",
      nodes
    }],
    clusterEdges: []
  };
  if (distanceType === DistanceType.EuclideanDistance && !nodes.every(function(node) {
    return node.hasOwnProperty(propertyKey);
  })) {
    return defaultClusterInfo;
  }
  var properties = [];
  var allPropertiesWeight = [];
  if (distanceType === DistanceType.EuclideanDistance) {
    properties = getAllProperties(nodes, propertyKey);
    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  }
  if (!allPropertiesWeight.length) {
    return defaultClusterInfo;
  }
  var allPropertiesWeightUniq = uniq(allPropertiesWeight.map(function(item) {
    return item.join("");
  }));
  var finalK = Math.min(k2, nodes.length, allPropertiesWeightUniq.length);
  for (var i2 = 0; i2 < nodes.length; i2++) {
    nodes[i2].originIndex = i2;
  }
  var centroids = [];
  var centroidIndexList = [];
  var clusters = [];
  for (var i2 = 0; i2 < finalK; i2++) {
    if (i2 === 0) {
      var randomIndex = Math.floor(Math.random() * nodes.length);
      switch (distanceType) {
        case DistanceType.EuclideanDistance:
          centroids[i2] = allPropertiesWeight[randomIndex];
          break;
        default:
          centroids[i2] = [];
          break;
      }
      centroidIndexList.push(randomIndex);
      clusters[i2] = [nodes[randomIndex]];
      nodes[randomIndex].clusterId = String(i2);
    } else {
      var maxDistance = -Infinity;
      var maxDistanceNodeIndex = 0;
      var _loop_1 = function _loop_12(m4) {
        if (!centroidIndexList.includes(m4)) {
          var totalDistance = 0;
          for (var j3 = 0; j3 < centroids.length; j3++) {
            var distance7 = 0;
            switch (distanceType) {
              case DistanceType.EuclideanDistance:
                distance7 = getDistance(allPropertiesWeight[nodes[m4].originIndex], centroids[j3], distanceType);
                break;
              default:
                break;
            }
            totalDistance += distance7;
          }
          var avgDistance = totalDistance / centroids.length;
          if (avgDistance > maxDistance && !centroids.find(function(centroid) {
            return is_equal_default(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m4].originIndex));
          })) {
            maxDistance = avgDistance;
            maxDistanceNodeIndex = m4;
          }
        }
      };
      for (var m3 = 0; m3 < nodes.length; m3++) {
        _loop_1(m3);
      }
      centroids[i2] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);
      centroidIndexList.push(maxDistanceNodeIndex);
      clusters[i2] = [nodes[maxDistanceNodeIndex]];
      nodes[maxDistanceNodeIndex].clusterId = String(i2);
    }
  }
  var iterations = 0;
  while (true) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var minDistanceIndex = 0;
      var minDistance = Infinity;
      if (!(iterations === 0 && centroidIndexList.includes(i2))) {
        for (var j2 = 0; j2 < centroids.length; j2++) {
          var distance6 = 0;
          switch (distanceType) {
            case DistanceType.EuclideanDistance:
              distance6 = getDistance(allPropertiesWeight[i2], centroids[j2], distanceType);
              break;
            default:
              break;
          }
          if (distance6 < minDistance) {
            minDistance = distance6;
            minDistanceIndex = j2;
          }
        }
        if (nodes[i2].clusterId !== void 0) {
          for (var n2 = clusters[Number(nodes[i2].clusterId)].length - 1; n2 >= 0; n2--) {
            if (clusters[Number(nodes[i2].clusterId)][n2].id === nodes[i2].id) {
              clusters[Number(nodes[i2].clusterId)].splice(n2, 1);
            }
          }
        }
        nodes[i2].clusterId = String(minDistanceIndex);
        clusters[minDistanceIndex].push(nodes[i2]);
      }
    }
    var centroidsEqualAvg = false;
    for (var i2 = 0; i2 < clusters.length; i2++) {
      var clusterNodes = clusters[i2];
      var totalVector = new vector_default([]);
      for (var j2 = 0; j2 < clusterNodes.length; j2++) {
        totalVector = totalVector.add(new vector_default(allPropertiesWeight[clusterNodes[j2].originIndex]));
      }
      var avgVector = totalVector.avg(clusterNodes.length);
      if (!avgVector.equal(new vector_default(centroids[i2]))) {
        centroidsEqualAvg = true;
        centroids[i2] = avgVector.getArr();
      }
    }
    iterations++;
    if (nodes.every(function(node) {
      return node.clusterId !== void 0;
    }) && centroidsEqualAvg || iterations >= 1e3) {
      break;
    }
  }
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var _a3, _b2;
    var source = edge.source, target = edge.target;
    var sourceClusterId = (_a3 = nodes.find(function(node) {
      return node.id === source;
    })) === null || _a3 === void 0 ? void 0 : _a3.clusterId;
    var targetClusterId = (_b2 = nodes.find(function(node) {
      return node.id === target;
    })) === null || _b2 === void 0 ? void 0 : _b2.clusterId;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  return {
    clusters,
    clusterEdges
  };
};
var k_means_default = kMeans;

// node_modules/@antv/algorithm/es/cosine-similarity.js
var cosineSimilarity = function cosineSimilarity2(item, targetItem) {
  var targetItemVector = new vector_default(targetItem);
  var targetNodeNorm2 = targetItemVector.norm2();
  var itemVector = new vector_default(item);
  var itemNorm2 = itemVector.norm2();
  var dot = targetItemVector.dot(itemVector);
  var norm2Product = targetNodeNorm2 * itemNorm2;
  var cosineSimilarity3 = norm2Product ? dot / norm2Product : 0;
  return cosineSimilarity3;
};
var cosine_similarity_default = cosineSimilarity;

// node_modules/@antv/algorithm/es/nodes-cosine-similarity.js
init_esm();
var nodesCosineSimilarity = function nodesCosineSimilarity2(nodes, seedNode, propertyKey, involvedKeys, uninvolvedKeys) {
  if (nodes === void 0) {
    nodes = [];
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = [];
  }
  var similarNodes = clone_default(nodes.filter(function(node) {
    return node.id !== seedNode.id;
  }));
  var seedNodeIndex = nodes.findIndex(function(node) {
    return node.id === seedNode.id;
  });
  var properties = getAllProperties(nodes, propertyKey);
  var allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  var seedNodeProperties = allPropertiesWeight[seedNodeIndex];
  var allCosineSimilarity = [];
  similarNodes.forEach(function(node, index2) {
    if (node.id !== seedNode.id) {
      var nodeProperties = allPropertiesWeight[index2];
      var cosineSimilarityValue = cosine_similarity_default(nodeProperties, seedNodeProperties);
      allCosineSimilarity.push(cosineSimilarityValue);
      node.cosineSimilarity = cosineSimilarityValue;
    }
  });
  similarNodes.sort(function(a3, b2) {
    return b2.cosineSimilarity - a3.cosineSimilarity;
  });
  return {
    allCosineSimilarity,
    similarNodes
  };
};
var nodes_cosine_similarity_default = nodesCosineSimilarity;

// node_modules/@antv/algorithm/es/structs/union-find.js
var UnionFind = (
  /** @class */
  function() {
    function UnionFind2(items) {
      this.count = items.length;
      this.parent = {};
      for (var _i2 = 0, items_1 = items; _i2 < items_1.length; _i2++) {
        var i2 = items_1[_i2];
        this.parent[i2] = i2;
      }
    }
    UnionFind2.prototype.find = function(item) {
      while (this.parent[item] !== item) {
        item = this.parent[item];
      }
      return item;
    };
    UnionFind2.prototype.union = function(a3, b2) {
      var rootA = this.find(a3);
      var rootB = this.find(b2);
      if (rootA === rootB)
        return;
      if (rootA < rootB) {
        if (this.parent[b2] !== b2)
          this.union(this.parent[b2], a3);
        this.parent[b2] = this.parent[a3];
      } else {
        if (this.parent[a3] !== a3)
          this.union(this.parent[a3], b2);
        this.parent[a3] = this.parent[b2];
      }
    };
    UnionFind2.prototype.connected = function(a3, b2) {
      return this.find(a3) === this.find(b2);
    };
    return UnionFind2;
  }()
);
var union_find_default = UnionFind;

// node_modules/@antv/algorithm/es/structs/binary-heap.js
var defaultCompare = function defaultCompare2(a3, b2) {
  return a3 - b2;
};
var MinBinaryHeap = (
  /** @class */
  function() {
    function MinBinaryHeap2(compareFn) {
      if (compareFn === void 0) {
        compareFn = defaultCompare;
      }
      this.compareFn = compareFn;
      this.list = [];
    }
    MinBinaryHeap2.prototype.getLeft = function(index2) {
      return 2 * index2 + 1;
    };
    MinBinaryHeap2.prototype.getRight = function(index2) {
      return 2 * index2 + 2;
    };
    MinBinaryHeap2.prototype.getParent = function(index2) {
      if (index2 === 0) {
        return null;
      }
      return Math.floor((index2 - 1) / 2);
    };
    MinBinaryHeap2.prototype.isEmpty = function() {
      return this.list.length <= 0;
    };
    MinBinaryHeap2.prototype.top = function() {
      return this.isEmpty() ? void 0 : this.list[0];
    };
    MinBinaryHeap2.prototype.delMin = function() {
      var top = this.top();
      var bottom = this.list.pop();
      if (this.list.length > 0) {
        this.list[0] = bottom;
        this.moveDown(0);
      }
      return top;
    };
    MinBinaryHeap2.prototype.insert = function(value) {
      if (value !== null) {
        this.list.push(value);
        var index2 = this.list.length - 1;
        this.moveUp(index2);
        return true;
      }
      return false;
    };
    MinBinaryHeap2.prototype.moveUp = function(index2) {
      var parent = this.getParent(index2);
      while (index2 && index2 > 0 && this.compareFn(this.list[parent], this.list[index2]) > 0) {
        var tmp = this.list[parent];
        this.list[parent] = this.list[index2];
        this.list[index2] = tmp;
        index2 = parent;
        parent = this.getParent(index2);
      }
    };
    MinBinaryHeap2.prototype.moveDown = function(index2) {
      var _a2;
      var element = index2;
      var left = this.getLeft(index2);
      var right = this.getRight(index2);
      var size3 = this.list.length;
      if (left !== null && left < size3 && this.compareFn(this.list[element], this.list[left]) > 0) {
        element = left;
      } else if (right !== null && right < size3 && this.compareFn(this.list[element], this.list[right]) > 0) {
        element = right;
      }
      if (index2 !== element) {
        _a2 = [this.list[element], this.list[index2]], this.list[index2] = _a2[0], this.list[element] = _a2[1];
        this.moveDown(element);
      }
    };
    return MinBinaryHeap2;
  }()
);
var binary_heap_default = MinBinaryHeap;

// node_modules/@antv/algorithm/es/mts.js
var primMST = function primMST2(graphData, weight) {
  var selectedEdges = [];
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  if (nodes.length === 0) {
    return selectedEdges;
  }
  var currNode = nodes[0];
  var visited = /* @__PURE__ */ new Set();
  visited.add(currNode);
  var compareWeight = function compareWeight2(a3, b2) {
    if (weight) {
      return a3.weight - b2.weight;
    }
    return 0;
  };
  var edgeQueue = new binary_heap_default(compareWeight);
  getEdgesByNodeId(currNode.id, edges).forEach(function(edge) {
    edgeQueue.insert(edge);
  });
  while (!edgeQueue.isEmpty()) {
    var currEdge = edgeQueue.delMin();
    var source = currEdge.source;
    var target = currEdge.target;
    if (visited.has(source) && visited.has(target))
      continue;
    selectedEdges.push(currEdge);
    if (!visited.has(source)) {
      visited.add(source);
      getEdgesByNodeId(source, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
    }
    if (!visited.has(target)) {
      visited.add(target);
      getEdgesByNodeId(target, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
    }
  }
  return selectedEdges;
};
var kruskalMST = function kruskalMST2(graphData, weight) {
  var selectedEdges = [];
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  if (nodes.length === 0) {
    return selectedEdges;
  }
  var weightEdges = edges.map(function(edge) {
    return edge;
  });
  if (weight) {
    weightEdges.sort(function(a3, b2) {
      return a3.weight - b2.weight;
    });
  }
  var disjointSet = new union_find_default(nodes.map(function(n2) {
    return n2.id;
  }));
  while (weightEdges.length > 0) {
    var curEdge = weightEdges.shift();
    var source = curEdge.source;
    var target = curEdge.target;
    if (!disjointSet.connected(source, target)) {
      selectedEdges.push(curEdge);
      disjointSet.union(source, target);
    }
  }
  return selectedEdges;
};
var minimumSpanningTree = function minimumSpanningTree2(graphData, weight, algo) {
  var algos = {
    prim: primMST,
    kruskal: kruskalMST
  };
  if (!algo)
    return kruskalMST(graphData, weight);
  return algos[algo](graphData, weight);
};
var mts_default = minimumSpanningTree;

// node_modules/@antv/algorithm/es/pageRank.js
var pageRank = function pageRank2(graphData, epsilon, linkProb) {
  if (typeof epsilon !== "number")
    epsilon = 1e-6;
  if (typeof linkProb !== "number")
    linkProb = 0.85;
  var distance6 = 1;
  var leakedRank = 0;
  var maxIterations = 1e3;
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodesCount = nodes.length;
  var currentRank;
  var curRanks = {};
  var prevRanks = {};
  for (var j2 = 0; j2 < nodesCount; ++j2) {
    var node = nodes[j2];
    var nodeId = node.id;
    curRanks[nodeId] = 1 / nodesCount;
    prevRanks[nodeId] = 1 / nodesCount;
  }
  var nodeDegree = degree_default(graphData);
  while (maxIterations > 0 && distance6 > epsilon) {
    leakedRank = 0;
    for (var j2 = 0; j2 < nodesCount; ++j2) {
      var node = nodes[j2];
      var nodeId = node.id;
      currentRank = 0;
      if (nodeDegree[node.id].inDegree === 0) {
        curRanks[nodeId] = 0;
      } else {
        var neighbors = getNeighbors(nodeId, edges, "source");
        for (var i2 = 0; i2 < neighbors.length; ++i2) {
          var neighbor = neighbors[i2];
          var outDegree = nodeDegree[neighbor].outDegree;
          if (outDegree > 0)
            currentRank += prevRanks[neighbor] / outDegree;
        }
        curRanks[nodeId] = linkProb * currentRank;
        leakedRank += curRanks[nodeId];
      }
    }
    leakedRank = (1 - leakedRank) / nodesCount;
    distance6 = 0;
    for (var j2 = 0; j2 < nodesCount; ++j2) {
      var node = nodes[j2];
      var nodeId = node.id;
      currentRank = curRanks[nodeId] + leakedRank;
      distance6 += Math.abs(currentRank - prevRanks[nodeId]);
      prevRanks[nodeId] = currentRank;
    }
    maxIterations -= 1;
  }
  return prevRanks;
};
var pageRank_default = pageRank;

// node_modules/@antv/algorithm/es/gaddi.js
init_tslib_es6();

// node_modules/@antv/algorithm/es/gSpan/gSpan.js
init_esm();

// node_modules/@antv/algorithm/es/gSpan/struct.js
var VACANT_EDGE_ID = -1;
var VACANT_NODE_ID = -1;
var VACANT_EDGE_LABEL = "-1";
var VACANT_NODE_LABEL = "-1";
var VACANT_GRAPH_ID = -1;
var Edge = (
  /** @class */
  function() {
    function Edge3(id, from, to2, label) {
      if (id === void 0) {
        id = VACANT_EDGE_ID;
      }
      if (from === void 0) {
        from = VACANT_NODE_ID;
      }
      if (to2 === void 0) {
        to2 = VACANT_NODE_ID;
      }
      if (label === void 0) {
        label = VACANT_EDGE_LABEL;
      }
      this.id = id;
      this.from = from;
      this.to = to2;
      this.label = label;
    }
    return Edge3;
  }()
);
var Node = (
  /** @class */
  function() {
    function Node3(id, label) {
      if (id === void 0) {
        id = VACANT_NODE_ID;
      }
      if (label === void 0) {
        label = VACANT_NODE_LABEL;
      }
      this.id = id;
      this.label = label;
      this.edges = [];
      this.edgeMap = {};
    }
    Node3.prototype.addEdge = function(edge) {
      this.edges.push(edge);
      this.edgeMap[edge.id] = edge;
    };
    return Node3;
  }()
);
var Graph = (
  /** @class */
  function() {
    function Graph4(id, edgeIdAutoIncrease, directed) {
      if (id === void 0) {
        id = VACANT_NODE_ID;
      }
      if (edgeIdAutoIncrease === void 0) {
        edgeIdAutoIncrease = true;
      }
      if (directed === void 0) {
        directed = false;
      }
      this.id = id;
      this.edgeIdAutoIncrease = edgeIdAutoIncrease;
      this.edges = [];
      this.nodes = [];
      this.nodeMap = {};
      this.edgeMap = {};
      this.nodeLabelMap = {};
      this.edgeLabelMap = {};
      this.counter = 0;
      this.directed = directed;
    }
    Graph4.prototype.getNodeNum = function() {
      return this.nodes.length;
    };
    Graph4.prototype.addNode = function(id, label) {
      if (this.nodeMap[id])
        return;
      var node = new Node(id, label);
      this.nodes.push(node);
      this.nodeMap[id] = node;
      if (!this.nodeLabelMap[label])
        this.nodeLabelMap[label] = [];
      this.nodeLabelMap[label].push(id);
    };
    Graph4.prototype.addEdge = function(id, from, to2, label) {
      if (this.edgeIdAutoIncrease || id === void 0)
        id = this.counter++;
      if (this.nodeMap[from] && this.nodeMap[to2] && this.nodeMap[to2].edgeMap[id])
        return;
      var edge = new Edge(id, from, to2, label);
      this.edges.push(edge);
      this.edgeMap[id] = edge;
      this.nodeMap[from].addEdge(edge);
      if (!this.edgeLabelMap[label])
        this.edgeLabelMap[label] = [];
      this.edgeLabelMap[label].push(edge);
      if (!this.directed) {
        var rEdge = new Edge(id, to2, from, label);
        this.nodeMap[to2].addEdge(rEdge);
        this.edgeLabelMap[label].push(rEdge);
      }
    };
    return Graph4;
  }()
);

// node_modules/@antv/algorithm/es/gSpan/gSpan.js
var DFSedge = (
  /** @class */
  function() {
    function DFSedge2(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
      this.fromNode = fromNode;
      this.toNode = toNode;
      this.nodeEdgeNodeLabel = {
        nodeLabel1: fromNodeLabel || VACANT_NODE_LABEL,
        edgeLabel: edgeLabel || VACANT_EDGE_LABEL,
        nodeLabel2: toNodeLabel || VACANT_NODE_LABEL
      };
    }
    DFSedge2.prototype.equalTo = function(other) {
      return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;
    };
    DFSedge2.prototype.notEqualTo = function(other) {
      return !this.equalTo(other);
    };
    return DFSedge2;
  }()
);
var DFScode = (
  /** @class */
  function() {
    function DFScode2() {
      this.rmpath = [];
      this.dfsEdgeList = [];
    }
    DFScode2.prototype.equalTo = function(other) {
      var aLength = this.dfsEdgeList.length;
      var bLength = other.length;
      if (aLength !== bLength)
        return false;
      for (var i2 = 0; i2 < aLength; i2++) {
        if (this.dfsEdgeList[i2] !== other[i2])
          return false;
      }
      return true;
    };
    DFScode2.prototype.notEqualTo = function(other) {
      return !this.equalTo(other);
    };
    DFScode2.prototype.pushBack = function(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
      this.dfsEdgeList.push(new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));
      return this.dfsEdgeList;
    };
    DFScode2.prototype.toGraph = function(graphId, directed) {
      if (graphId === void 0) {
        graphId = VACANT_GRAPH_ID;
      }
      if (directed === void 0) {
        directed = false;
      }
      var graph = new Graph(graphId, true, directed);
      this.dfsEdgeList.forEach(function(dfsEdge) {
        var fromNodeId = dfsEdge.fromNode;
        var toNodeId = dfsEdge.toNode;
        var _a2 = dfsEdge.nodeEdgeNodeLabel, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
        if (nodeLabel1 !== VACANT_NODE_LABEL)
          graph.addNode(fromNodeId, nodeLabel1);
        if (nodeLabel2 !== VACANT_NODE_LABEL)
          graph.addNode(toNodeId, nodeLabel2);
        if (nodeLabel1 !== VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1)
          graph.addEdge(void 0, fromNodeId, toNodeId, edgeLabel);
      });
      return graph;
    };
    DFScode2.prototype.buildRmpath = function() {
      this.rmpath = [];
      var oldFrom = void 0;
      var selfLength = this.dfsEdgeList.length;
      for (var i2 = selfLength - 1; i2 >= 0; i2--) {
        var dfsEdge = this.dfsEdgeList[i2];
        var fromNodeIdx = dfsEdge.fromNode;
        var toNodeIdx = dfsEdge.toNode;
        if (fromNodeIdx < toNodeIdx && (oldFrom === void 0 || toNodeIdx === oldFrom)) {
          this.rmpath.push(i2);
          oldFrom = fromNodeIdx;
        }
      }
      return this.rmpath;
    };
    DFScode2.prototype.getNodeNum = function() {
      var nodeMap = {};
      this.dfsEdgeList.forEach(function(dfsEdge) {
        if (!nodeMap[dfsEdge.fromNode])
          nodeMap[dfsEdge.fromNode] = true;
        if (!nodeMap[dfsEdge.toNode])
          nodeMap[dfsEdge.toNode] = true;
      });
      return Object.keys(nodeMap).length;
    };
    return DFScode2;
  }()
);
var History = (
  /** @class */
  function() {
    function History2(pdfs) {
      this.his = {};
      this.nodesUsed = {};
      this.edgesUsed = {};
      this.edges = [];
      if (!pdfs)
        return;
      while (pdfs) {
        var e8 = pdfs.edge;
        this.edges.push(e8);
        this.nodesUsed[e8.from] = 1;
        this.nodesUsed[e8.to] = 1;
        this.edgesUsed[e8.id] = 1;
        pdfs = pdfs.preNode;
      }
      this.edges = this.edges.reverse();
    }
    History2.prototype.hasNode = function(node) {
      return this.nodesUsed[node.id] === 1;
    };
    History2.prototype.hasEdge = function(edge) {
      return this.edgesUsed[edge.id] === 1;
    };
    return History2;
  }()
);
var GSpan = (
  /** @class */
  function() {
    function GSpan2(_a2) {
      var graphs = _a2.graphs, _b = _a2.minSupport, minSupport = _b === void 0 ? 2 : _b, _c = _a2.minNodeNum, minNodeNum = _c === void 0 ? 1 : _c, _d = _a2.maxNodeNum, maxNodeNum = _d === void 0 ? 4 : _d, _e2 = _a2.top, top = _e2 === void 0 ? 10 : _e2, _f = _a2.directed, directed = _f === void 0 ? false : _f, _g = _a2.verbose, verbose = _g === void 0 ? false : _g;
      this.graphs = graphs;
      this.dfsCode = new DFScode();
      this.support = 0;
      this.frequentSize1Subgraphs = [];
      this.frequentSubgraphs = [];
      this.minSupport = minSupport;
      this.top = top;
      this.directed = directed;
      this.counter = 0;
      this.maxNodeNum = maxNodeNum;
      this.minNodeNum = minNodeNum;
      this.verbose = verbose;
      if (this.maxNodeNum < this.minNodeNum)
        this.maxNodeNum = this.minNodeNum;
      this.reportDF = [];
    }
    GSpan2.prototype.findForwardRootEdges = function(graph, fromNode) {
      var _this = this;
      var result = [];
      var nodeMap = graph.nodeMap;
      fromNode.edges.forEach(function(edge) {
        if (_this.directed || fromNode.label <= nodeMap[edge.to].label)
          result.push(edge);
      });
      return result;
    };
    GSpan2.prototype.findBackwardEdge = function(graph, edge1, edge2, history) {
      if (!this.directed && edge1 === edge2)
        return null;
      var nodeMap = graph.nodeMap;
      var edge2To = nodeMap[edge2.to];
      var edge2ToEdges = edge2To.edges;
      var edgeLength = edge2ToEdges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edge2ToEdges[i2];
        if (history.hasEdge(edge) || edge.to !== edge1.from)
          continue;
        if (!this.directed) {
          if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {
            return edge;
          }
        } else {
          if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {
            return edge;
          }
        }
      }
      return null;
    };
    GSpan2.prototype.findForwardPureEdges = function(graph, rightmostEdge, minNodeLabel, history) {
      var result = [];
      var rightmostEdgeToId = rightmostEdge.to;
      var edges = graph.nodeMap[rightmostEdgeToId].edges;
      var edgeLength = edges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edges[i2];
        var toNode = graph.nodeMap[edge.to];
        if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {
          result.push(edge);
        }
      }
      return result;
    };
    GSpan2.prototype.findForwardRmpathEdges = function(graph, rightmostEdge, minNodeLabel, history) {
      var result = [];
      var nodeMap = graph.nodeMap;
      var toNodeLabel = nodeMap[rightmostEdge.to].label;
      var fromNode = nodeMap[rightmostEdge.from];
      var edges = fromNode.edges;
      var edgeLength = edges.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edge = edges[i2];
        var newToNodeLabel = nodeMap[edge.to].label;
        if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {
          continue;
        }
        if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {
          result.push(edge);
        }
      }
      return result;
    };
    GSpan2.prototype.getSupport = function(projected) {
      var graphMap = {};
      projected.forEach(function(pro) {
        if (!graphMap[pro.graphId])
          graphMap[pro.graphId] = true;
      });
      return Object.keys(graphMap).length;
    };
    GSpan2.prototype.findMinLabel = function(obj) {
      var minLabel = void 0;
      Object.keys(obj).forEach(function(nodeEdgeNodeLabel) {
        var _a2 = obj[nodeEdgeNodeLabel], nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
        if (!minLabel) {
          minLabel = {
            nodeLabel1,
            edgeLabel,
            nodeLabel2
          };
          return;
        }
        if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {
          minLabel = {
            nodeLabel1,
            edgeLabel,
            nodeLabel2
          };
        }
      });
      return minLabel;
    };
    GSpan2.prototype.isMin = function() {
      var _this = this;
      var dfsCode = this.dfsCode;
      if (this.verbose)
        console.log("isMin checking", dfsCode);
      if (dfsCode.dfsEdgeList.length === 1)
        return true;
      var directed = this.directed;
      var graph = dfsCode.toGraph(VACANT_GRAPH_ID, directed);
      var nodeMap = graph.nodeMap;
      var dfsCodeMin = new DFScode();
      var root = {};
      graph.nodes.forEach(function(node) {
        var forwardEdges = _this.findForwardRootEdges(graph, node);
        forwardEdges.forEach(function(edge) {
          var otherNode = nodeMap[edge.to];
          var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(otherNode.label);
          if (!root[nodeEdgeNodeLabel])
            root[nodeEdgeNodeLabel] = {
              projected: [],
              nodeLabel1: node.label,
              edgeLabel: edge.label,
              nodeLabel2: otherNode.label
            };
          var pdfs = {
            graphId: graph.id,
            edge,
            preNode: null
          };
          root[nodeEdgeNodeLabel].projected.push(pdfs);
        });
      });
      var minLabel = this.findMinLabel(root);
      if (!minLabel)
        return;
      dfsCodeMin.dfsEdgeList.push(new DFSedge(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2));
      var projectIsMin = function projectIsMin2(projected) {
        var rmpath = dfsCodeMin.buildRmpath();
        var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
        var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode;
        var backwardRoot = {};
        var flag = false, newTo = 0;
        var end2 = directed ? -1 : 0;
        var _loop_1 = function _loop_12(i3) {
          if (flag)
            return "break";
          projected.forEach(function(p2) {
            var history = new History(p2);
            var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i3]], history.edges[rmpath[0]], history);
            if (backwardEdge) {
              if (!backwardRoot[backwardEdge.label]) {
                backwardRoot[backwardEdge.label] = {
                  projected: [],
                  edgeLabel: backwardEdge.label
                };
              }
              backwardRoot[backwardEdge.label].projected.push({
                graphId: graph.id,
                edge: backwardRoot,
                preNode: p2
              });
              newTo = dfsCodeMin.dfsEdgeList[rmpath[i3]].fromNode;
              flag = true;
            }
          });
        };
        for (var i2 = rmpath.length - 1; i2 > end2; i2--) {
          var state_1 = _loop_1(i2);
          if (state_1 === "break")
            break;
        }
        if (flag) {
          var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);
          dfsCodeMin.dfsEdgeList.push(new DFSedge(maxToC, newTo, VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, VACANT_NODE_LABEL));
          var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;
          if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1])
            return false;
          return projectIsMin2(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);
        }
        var forwardRoot = {};
        flag = false;
        var newFrom = 0;
        projected.forEach(function(p2) {
          var history = new History(p2);
          var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
          if (forwardPureEdges.length > 0) {
            flag = true;
            newFrom = maxToC;
            forwardPureEdges.forEach(function(edge) {
              var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
              if (!forwardRoot[key2])
                forwardRoot[key2] = {
                  projected: [],
                  edgeLabel: edge.label,
                  nodeLabel2: nodeMap[edge.to].label
                };
              forwardRoot[key2].projected.push({
                graphId: graph.id,
                edge,
                preNode: p2
              });
            });
          }
        });
        var pathLength = rmpath.length;
        var _loop_2 = function _loop_22(i3) {
          if (flag)
            return "break";
          var value = rmpath[i3];
          projected.forEach(function(p2) {
            var history = new History(p2);
            var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);
            if (forwardRmpathEdges.length > 0) {
              flag = true;
              newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;
              forwardRmpathEdges.forEach(function(edge) {
                var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                if (!forwardRoot[key2])
                  forwardRoot[key2] = {
                    projected: [],
                    edgeLabel: edge.label,
                    nodeLabel2: nodeMap[edge.to].label
                  };
                forwardRoot[key2].projected.push({
                  graphId: graph.id,
                  edge,
                  preNode: p2
                });
              });
            }
          });
        };
        for (var i2 = 0; i2 < pathLength; i2++) {
          var state_2 = _loop_2(i2);
          if (state_2 === "break")
            break;
        }
        if (!flag)
          return true;
        var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);
        dfsCodeMin.dfsEdgeList.push(new DFSedge(newFrom, maxToC + 1, VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));
        var idx = dfsCodeMin.dfsEdgeList.length - 1;
        if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])
          return false;
        return projectIsMin2(forwardRoot["".concat(forwardMinEdgeNodeLabel.edgeLabel, "-").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);
      };
      var key = "".concat(minLabel.nodeLabel1, "-").concat(minLabel.edgeLabel, "-").concat(minLabel.nodeLabel2);
      return projectIsMin(root[key].projected);
    };
    GSpan2.prototype.report = function() {
      if (this.dfsCode.getNodeNum() < this.minNodeNum)
        return;
      this.counter++;
      var graph = this.dfsCode.toGraph(this.counter, this.directed);
      this.frequentSubgraphs.push(clone_default(graph));
    };
    GSpan2.prototype.subGraphMining = function(projected) {
      var _this = this;
      var support = this.getSupport(projected);
      if (support < this.minSupport)
        return;
      if (!this.isMin())
        return;
      this.report();
      var nodeNum = this.dfsCode.getNodeNum();
      var rmpath = this.dfsCode.buildRmpath();
      var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;
      var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
      var forwardRoot = {};
      var backwardRoot = {};
      projected.forEach(function(p2) {
        var graph = _this.graphs[p2.graphId];
        var nodeMap = graph.nodeMap;
        var history = new History(p2);
        for (var i2 = rmpath.length - 1; i2 >= 0; i2--) {
          var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i2]], history.edges[rmpath[0]], history);
          if (backwardEdge) {
            var key = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode, "-").concat(backwardEdge.label);
            if (!backwardRoot[key])
              backwardRoot[key] = {
                projected: [],
                toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode,
                edgeLabel: backwardEdge.label
              };
            backwardRoot[key].projected.push({
              graphId: p2.graphId,
              edge: backwardEdge,
              preNode: p2
            });
          }
        }
        if (nodeNum >= _this.maxNodeNum)
          return;
        var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
        forwardPureEdges.forEach(function(edge) {
          var key2 = "".concat(maxToC, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
          if (!forwardRoot[key2])
            forwardRoot[key2] = {
              projected: [],
              fromNodeId: maxToC,
              edgeLabel: edge.label,
              nodeLabel2: nodeMap[edge.to].label
            };
          forwardRoot[key2].projected.push({
            graphId: p2.graphId,
            edge,
            preNode: p2
          });
        });
        var _loop_3 = function _loop_32(i3) {
          var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i3]], minNodeLabel, history);
          forwardRmpathEdges.forEach(function(edge) {
            var key2 = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
            if (!forwardRoot[key2])
              forwardRoot[key2] = {
                projected: [],
                fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode,
                edgeLabel: edge.label,
                nodeLabel2: nodeMap[edge.to].label
              };
            forwardRoot[key2].projected.push({
              graphId: p2.graphId,
              edge,
              preNode: p2
            });
          });
        };
        for (var i2 = 0; i2 < rmpath.length; i2++) {
          _loop_3(i2);
        }
      });
      Object.keys(backwardRoot).forEach(function(key) {
        var _a2 = backwardRoot[key], toNodeId = _a2.toNodeId, edgeLabel = _a2.edgeLabel;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(maxToC, toNodeId, "-1", edgeLabel, "-1"));
        _this.subGraphMining(backwardRoot[key].projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
      Object.keys(forwardRoot).forEach(function(key) {
        var _a2 = forwardRoot[key], fromNodeId = _a2.fromNodeId, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(fromNodeId, maxToC + 1, VACANT_NODE_LABEL, edgeLabel, nodeLabel2));
        _this.subGraphMining(forwardRoot[key].projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
    };
    GSpan2.prototype.generate1EdgeFrequentSubGraphs = function() {
      var graphs = this.graphs;
      var directed = this.directed;
      var minSupport = this.minSupport;
      var frequentSize1Subgraphs = this.frequentSize1Subgraphs;
      var nodeLabelCounter = {}, nodeEdgeNodeCounter = {};
      var nodeLableCounted = {};
      var nodeEdgeNodeLabelCounted = {};
      Object.keys(graphs).forEach(function(key) {
        var graph = graphs[key];
        var nodeMap = graph.nodeMap;
        graph.nodes.forEach(function(node, i2) {
          var nodeLabel = node.label;
          var graphNodeKey = "".concat(key, "-").concat(nodeLabel);
          if (!nodeLableCounted[graphNodeKey]) {
            var counter = nodeLabelCounter[nodeLabel] || 0;
            counter++;
            nodeLabelCounter[nodeLabel] = counter;
          }
          nodeLableCounted[graphNodeKey] = {
            graphKey: key,
            label: nodeLabel
          };
          node.edges.forEach(function(edge) {
            var nodeLabel1 = nodeLabel;
            var nodeLabel2 = nodeMap[edge.to].label;
            if (!directed && nodeLabel1 > nodeLabel2) {
              var tmp = nodeLabel2;
              nodeLabel2 = nodeLabel1;
              nodeLabel1 = tmp;
            }
            var edgeLabel = edge.label;
            var graphNodeEdgeNodeKey = "".concat(key, "-").concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
            var nodeEdgeNodeKey = "".concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
            if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {
              var counter2 = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;
              counter2++;
              nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter2;
            }
            nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {
              graphId: key,
              nodeLabel1,
              edgeLabel,
              nodeLabel2
            };
          });
        });
      });
      Object.keys(nodeLabelCounter).forEach(function(label) {
        var count = nodeLabelCounter[label];
        if (count < minSupport)
          return;
        var g2 = {
          nodes: [],
          edges: []
        };
        g2.nodes.push({
          id: "0",
          label
        });
        frequentSize1Subgraphs.push(g2);
      });
      return frequentSize1Subgraphs;
    };
    GSpan2.prototype.run = function() {
      var _this = this;
      this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();
      if (this.maxNodeNum < 2)
        return;
      var graphs = this.graphs;
      var directed = this.directed;
      var root = {};
      Object.keys(graphs).forEach(function(graphId) {
        var graph = graphs[graphId];
        var nodeMap = graph.nodeMap;
        graph.nodes.forEach(function(node) {
          var forwardRootEdges = _this.findForwardRootEdges(graph, node);
          forwardRootEdges.forEach(function(edge) {
            var toNode = nodeMap[edge.to];
            var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(toNode.label);
            if (!root[nodeEdgeNodeLabel])
              root[nodeEdgeNodeLabel] = {
                projected: [],
                nodeLabel1: node.label,
                edgeLabel: edge.label,
                nodeLabel2: toNode.label
              };
            var pdfs = {
              graphId,
              edge,
              preNode: null
            };
            root[nodeEdgeNodeLabel].projected.push(pdfs);
          });
        });
      });
      Object.keys(root).forEach(function(nodeEdgeNodeLabel) {
        var _a2 = root[nodeEdgeNodeLabel], projected = _a2.projected, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
        _this.dfsCode.dfsEdgeList.push(new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2));
        _this.subGraphMining(projected);
        _this.dfsCode.dfsEdgeList.pop();
      });
    };
    return GSpan2;
  }()
);
var formatGraphs = function formatGraphs2(graphs, directed, nodeLabelProp, edgeLabelProp) {
  var result = {};
  Object.keys(graphs).forEach(function(key, i2) {
    var graph = graphs[key];
    var fGraph = new Graph(i2, true, directed);
    var nodeIdxMap = {};
    graph.nodes.forEach(function(node, j2) {
      fGraph.addNode(j2, node[nodeLabelProp]);
      nodeIdxMap[node.id] = j2;
    });
    graph.edges.forEach(function(edge, k2) {
      var sourceIdx = nodeIdxMap[edge.source];
      var targetIdx = nodeIdxMap[edge.target];
      fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);
    });
    if (fGraph && fGraph.getNodeNum())
      result[fGraph.id] = fGraph;
  });
  return result;
};
var toGraphDatas = function toGraphDatas2(graphs, nodeLabelProp, edgeLabelProp) {
  var result = [];
  graphs.forEach(function(graph) {
    var graphData = {
      nodes: [],
      edges: []
    };
    graph.nodes.forEach(function(node) {
      var _a2;
      graphData.nodes.push((_a2 = {
        id: "".concat(node.id)
      }, _a2[nodeLabelProp] = node.label, _a2));
    });
    graph.edges.forEach(function(edge) {
      var _a2;
      graphData.edges.push((_a2 = {
        source: "".concat(edge.from),
        target: "".concat(edge.to)
      }, _a2[edgeLabelProp] = edge.label, _a2));
    });
    result.push(graphData);
  });
  return result;
};
var DEFAULT_LABEL_NAME = "cluster";
var gSpan = function gSpan2(params) {
  var graphs = params.graphs, _a2 = params.directed, directed = _a2 === void 0 ? false : _a2, _b = params.nodeLabelProp, nodeLabelProp = _b === void 0 ? DEFAULT_LABEL_NAME : _b, _c = params.edgeLabelProp, edgeLabelProp = _c === void 0 ? DEFAULT_LABEL_NAME : _c;
  var formattedGraphs = formatGraphs(graphs, directed, nodeLabelProp, edgeLabelProp);
  var minSupport = params.minSupport, maxNodeNum = params.maxNodeNum, minNodeNum = params.minNodeNum, verbose = params.verbose, top = params.top;
  var algoParams = {
    graphs: formattedGraphs,
    minSupport,
    maxNodeNum,
    minNodeNum,
    top,
    verbose,
    directed
  };
  var calculator = new GSpan(algoParams);
  calculator.run();
  var result = toGraphDatas(calculator.frequentSubgraphs, nodeLabelProp, edgeLabelProp);
  return result;
};
var gSpan_default = gSpan;

// node_modules/@antv/algorithm/es/gaddi.js
var findKNeighborUnits = function findKNeighborUnits2(graphData, spm, nodeLabelProp, k2) {
  if (nodeLabelProp === void 0) {
    nodeLabelProp = "cluster";
  }
  if (k2 === void 0) {
    k2 = 2;
  }
  var units = [];
  var nodes = graphData.nodes;
  spm.forEach(function(row, i2) {
    units.push(findKNeighborUnit(nodes, row, i2, nodeLabelProp, k2));
  });
  return units;
};
var findKNeighborUnit = function findKNeighborUnit2(nodes, row, i2, nodeLabelProp, k2) {
  var unitNodeIdxs = [i2];
  var neighbors = [];
  var labelCountMap = {};
  row.forEach(function(v2, j2) {
    if (v2 <= k2 && i2 !== j2) {
      unitNodeIdxs.push(j2);
      neighbors.push(nodes[j2]);
      var label = nodes[j2][nodeLabelProp];
      if (!labelCountMap[label])
        labelCountMap[label] = {
          count: 1,
          dists: [v2]
        };
      else {
        labelCountMap[label].count++;
        labelCountMap[label].dists.push(v2);
      }
    }
  });
  Object.keys(labelCountMap).forEach(function(label) {
    labelCountMap[label].dists = labelCountMap[label].dists.sort(function(a3, b2) {
      return a3 - b2;
    });
  });
  return {
    nodeIdx: i2,
    nodeId: nodes[i2].id,
    nodeIdxs: unitNodeIdxs,
    neighbors,
    neighborNum: unitNodeIdxs.length - 1,
    nodeLabelCountMap: labelCountMap
  };
};
var findNodePairsRandomly = function findNodePairsRandomly2(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm) {
  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);
  var nodePairMap = {};
  var foundNodePairCount = 0;
  kNeighborUnits.forEach(function(unit, i2) {
    var nodePairForICount = 0;
    var outerLoopCount = 0;
    var neighbors = unit.nodeIdxs;
    var neighborNum = unit.neighborNum - 1;
    while (nodePairForICount < nodePairNumEachNode) {
      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];
      var innerLoopCount = 0;
      while (nodePairMap["".concat(i2, "-").concat(oidx)] || nodePairMap["".concat(oidx, "-").concat(i2)]) {
        oidx = Math.floor(Math.random() * nodeNum);
        innerLoopCount++;
        if (innerLoopCount > 2 * nodeNum)
          break;
      }
      if (innerLoopCount < 2 * nodeNum) {
        nodePairMap["".concat(i2, "-").concat(oidx)] = {
          start: i2,
          end: oidx,
          distance: spm[i2][oidx]
        };
        nodePairForICount++;
        foundNodePairCount++;
        if (foundNodePairCount >= maxNodePairNum)
          return nodePairMap;
      }
      outerLoopCount++;
      if (outerLoopCount > 2 * nodeNum)
        break;
    }
    if (nodePairForICount < nodePairNumEachNode) {
      var gap = nodePairNumEachNode - nodePairForICount;
      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i2 - 1);
    }
  });
  return nodePairMap;
};
var getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph2(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {
  var nodes = graphData.nodes;
  if (!cachedInducedGraphMap)
    cachedInducedGraphMap = {};
  Object.keys(nodePairMap).forEach(function(key) {
    var _a2, _b;
    if (cachedInducedGraphMap && cachedInducedGraphMap[key])
      return;
    cachedInducedGraphMap[key] = {
      nodes: [],
      edges: []
    };
    var pair = nodePairMap[key];
    var startUnitNodeIds = (_a2 = neighborUnits[pair.start]) === null || _a2 === void 0 ? void 0 : _a2.nodeIdxs;
    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;
    if (!startUnitNodeIds || !endUnitNodeIds)
      return;
    var endSet = new Set(endUnitNodeIds);
    var intersect = startUnitNodeIds.filter(function(x4) {
      return endSet.has(x4);
    });
    if (!intersect || !intersect.length)
      return;
    var intersectIdMap = {};
    var intersectLength = intersect.length;
    for (var i2 = 0; i2 < intersectLength; i2++) {
      var node = nodes[intersect[i2]];
      cachedInducedGraphMap[key].nodes.push(node);
      intersectIdMap[node.id] = true;
    }
    graphData.edges.forEach(function(edge) {
      if (intersectIdMap[edge.source] && intersectIdMap[edge.target])
        cachedInducedGraphMap[key].edges.push(edge);
    });
  });
  return cachedInducedGraphMap;
};
var getMatchedCount = function getMatchedCount2(graph, structure, nodeLabelProp, edgeLabelProp) {
  var _a2, _b;
  var nodeMap = {};
  graph.nodes.forEach(function(node) {
    nodeMap[node.id] = node;
  });
  var count = 0;
  if (!((_a2 = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2)
    return 0;
  graph.edges.forEach(function(e8) {
    var sourceLabel = nodeMap[e8.source][nodeLabelProp];
    var targetLabel = nodeMap[e8.target][nodeLabelProp];
    var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];
    var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];
    var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];
    if (e8[edgeLabelProp] !== strEdgeLabel)
      return;
    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {
      count++;
    }
  });
  return count;
};
var findRepresentStructure = function findRepresentStructure2(matchedCountMap, structureNum, structures) {
  var maxOffset = Infinity, representClusterType = 0;
  var _loop_1 = function _loop_12(i3) {
    var countMapI = matchedCountMap[i3];
    var sortedGraphKeys = Object.keys(countMapI).sort(function(a3, b2) {
      return countMapI[a3] - countMapI[b2];
    });
    var groupNum = 10;
    var clusters = [];
    sortedGraphKeys.forEach(function(key, j2) {
      if (!clusters[j2 % groupNum])
        clusters[j2 % groupNum] = {
          graphs: [],
          totalCount: 0,
          aveCount: 0
        };
      clusters[j2 % groupNum].graphs.push(key);
      clusters[j2 % groupNum].totalCount += countMapI[key];
    });
    var aveIntraDist = 0;
    var aveCounts = [];
    clusters.forEach(function(graphsInCluster) {
      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;
      graphsInCluster.aveCount = aveCount;
      aveCounts.push(aveCount);
      var aveIntraPerCluster = 0;
      var graphsNum = graphsInCluster.length;
      graphsInCluster.graphs.forEach(function(graphKey1, j2) {
        var graph1Count = countMapI[graphKey1];
        graphsInCluster.graphs.forEach(function(graphKey2, k2) {
          if (j2 === k2)
            return;
          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);
        });
      });
      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;
      aveIntraDist += aveIntraPerCluster;
    });
    aveIntraDist /= clusters.length;
    var aveInterDist = 0;
    aveCounts.forEach(function(aveCount1, j2) {
      aveCounts.forEach(function(aveCount2, k2) {
        if (j2 === k2)
          return;
        aveInterDist += Math.abs(aveCount1 - aveCount2);
      });
      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;
    });
    var offset = aveInterDist - aveIntraDist;
    if (maxOffset < offset) {
      maxOffset = offset;
      representClusterType = i3;
    }
  };
  for (var i2 = 0; i2 < structureNum; i2++) {
    _loop_1(i2);
  }
  return {
    structure: structures[representClusterType],
    structureCountMap: matchedCountMap[representClusterType]
  };
};
var getNodeMaps = function getNodeMaps2(nodes, nodeLabelProp) {
  var nodeMap = {}, nodeLabelMap = {};
  nodes.forEach(function(node, i2) {
    nodeMap[node.id] = {
      idx: i2,
      node,
      degree: 0,
      inDegree: 0,
      outDegree: 0
    };
    var label = node[nodeLabelProp];
    if (!nodeLabelMap[label])
      nodeLabelMap[label] = [];
    nodeLabelMap[label].push(node);
  });
  return {
    nodeMap,
    nodeLabelMap
  };
};
var getEdgeMaps = function getEdgeMaps2(edges, edgeLabelProp, nodeMap) {
  var edgeMap = {}, edgeLabelMap = {};
  edges.forEach(function(edge, i2) {
    edgeMap["".concat(uniqueId)] = {
      idx: i2,
      edge
    };
    var label = edge[edgeLabelProp];
    if (!edgeLabelMap[label])
      edgeLabelMap[label] = [];
    edgeLabelMap[label].push(edge);
    var sourceNode = nodeMap[edge.source];
    if (sourceNode) {
      sourceNode.degree++;
      sourceNode.outDegree++;
    }
    var targetNode = nodeMap[edge.target];
    if (targetNode) {
      targetNode.degree++;
      targetNode.inDegree++;
    }
  });
  return {
    edgeMap,
    edgeLabelMap
  };
};
var getSpmMap = function getSpmMap2(nodes, spm, directed) {
  var length = spm.length;
  var map3 = {};
  spm.forEach(function(row, i2) {
    var start = directed ? 0 : i2 + 1;
    var iId = nodes[i2].id;
    for (var j2 = start; j2 < length; j2++) {
      if (i2 === j2)
        continue;
      var jId = nodes[j2].id;
      var dist = row[j2];
      map3["".concat(iId, "-").concat(jId)] = dist;
      if (!directed)
        map3["".concat(jId, "-").concat(iId)] = dist;
    }
  });
  return map3;
};
var getNDSDist = function getNDSDist2(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {
  var _a2;
  var key = "".concat(node1.id, "-").concat(node2.id);
  if (cachedNDSMap && cachedNDSMap[key])
    return cachedNDSMap[key];
  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : void 0;
  if (!interInducedGraph) {
    var pairMap = (_a2 = {}, _a2[key] = {
      start: nodeMap[node1.id].idx,
      end: nodeMap[node2.id].idx,
      distance: spDist
    }, _a2);
    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);
    interInducedGraph = cachedInterInducedGraph[key];
  }
  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);
};
var stashPatternNodeLabelDegreeMap = function stashPatternNodeLabelDegreeMap2(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {
  var _a2, _b, _c;
  var minPatternNodeLabelDegree = (_a2 = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a2 === void 0 ? void 0 : _a2.degree;
  var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;
  var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;
  if (minPatternNodeLabelDegreeMap[neighborLabel] === void 0) {
    minPatternNodeLabelDegree = Infinity;
    minPatternNodeLabelInDegree = Infinity;
    minPatternNodeLabelOutDegree = Infinity;
    patternNodeLabelMap[neighborLabel].forEach(function(patternNodeWithLabel) {
      var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;
      if (minPatternNodeLabelDegree > patternNodeDegree)
        minPatternNodeLabelDegree = patternNodeDegree;
      var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;
      if (minPatternNodeLabelInDegree > patternNodeInDegree)
        minPatternNodeLabelInDegree = patternNodeInDegree;
      var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;
      if (minPatternNodeLabelOutDegree > patternNodeOutDegree)
        minPatternNodeLabelOutDegree = patternNodeOutDegree;
    });
    minPatternNodeLabelDegreeMap[neighborLabel] = {
      degree: minPatternNodeLabelDegree,
      inDegree: minPatternNodeLabelInDegree,
      outDegree: minPatternNodeLabelOutDegree
    };
  }
  return {
    minPatternNodeLabelDegree,
    minPatternNodeLabelInDegree,
    minPatternNodeLabelOutDegree
  };
};
var GADDI = function GADDI2(graphData, pattern, directed, k2, length, nodeLabelProp, edgeLabelProp) {
  var _a2;
  if (directed === void 0) {
    directed = false;
  }
  if (nodeLabelProp === void 0) {
    nodeLabelProp = "cluster";
  }
  if (edgeLabelProp === void 0) {
    edgeLabelProp = "cluster";
  }
  if (!graphData || !graphData.nodes)
    return;
  var nodeNum = graphData.nodes.length;
  if (!nodeNum)
    return;
  var spm = floydWarshall_default(graphData, directed);
  var patternSpm = floydWarshall_default(pattern, directed);
  var spmMap = getSpmMap(graphData.nodes, spm, directed);
  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed);
  var _b = getNodeMaps(graphData.nodes, nodeLabelProp), nodeMap = _b.nodeMap, nodeLabelMap = _b.nodeLabelMap;
  var _c = getNodeMaps(pattern.nodes, nodeLabelProp), patternNodeMap = _c.nodeMap, patternNodeLabelMap = _c.nodeLabelMap;
  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);
  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap;
  var patternSpmSpread = [];
  patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function(row) {
    patternSpmSpread = patternSpmSpread.concat(row);
  });
  if (!length)
    length = Math.max.apply(Math, __spreadArray(__spreadArray([], patternSpmSpread, false), [2], false));
  if (!k2)
    k2 = length;
  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k2);
  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k2);
  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);
  var nodePairsMap = findNodePairsRandomly(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm);
  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData);
  var top = 10, minSupport = 1, minNodeNum = 1, maxNodeNum = 4;
  var params = {
    graphs: intGMap,
    nodeLabelProp,
    edgeLabelProp,
    minSupport,
    minNodeNum,
    maxNodeNum,
    directed
  };
  var freStructures = gSpan_default(params).slice(0, top);
  var structureNum = freStructures.length;
  var matchedCountMap = [];
  freStructures.forEach(function(structure, i3) {
    matchedCountMap[i3] = {};
    Object.keys(intGMap).forEach(function(key) {
      var graph = intGMap[key];
      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);
      matchedCountMap[i3][key] = subStructureCount;
    });
  });
  var _d = findRepresentStructure(matchedCountMap, structureNum, freStructures), dsG = _d.structure, ndsDist = _d.structureCountMap;
  var beginPNode = pattern.nodes[0], candidates = [], label = (_a2 = pattern.nodes[0]) === null || _a2 === void 0 ? void 0 : _a2[nodeLabelProp], maxNodeNumWithSameLabel = -Infinity;
  pattern.nodes.forEach(function(node) {
    var pLabel = node[nodeLabelProp];
    var nodesWithSameLabel = nodeLabelMap[pLabel];
    if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {
      maxNodeNumWithSameLabel = nodesWithSameLabel.length;
      candidates = nodesWithSameLabel;
      label = pLabel;
      beginPNode = node;
    }
  });
  var minPatternNodeLabelDegreeMap = {};
  var patternIntGraphMap = {}, patternNDSDist = {}, patternNDSDistMap = {};
  var patternSpDist = {};
  var patternSpDistBack = {};
  Object.keys(patternNodeLabelMap).forEach(function(label2, j2) {
    patternSpDist[label2] = [];
    if (directed) {
      patternSpDistBack[label2] = [];
    }
    var maxDist = -Infinity;
    var patternNodesWithLabel2 = patternNodeLabelMap[label2];
    var patternNodePairMap = {};
    patternNodesWithLabel2.forEach(function(nodeWithLabel2) {
      var dist = patternSpmMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)];
      dist && patternSpDist[label2].push(dist);
      if (maxDist < dist)
        maxDist = dist;
      patternNodePairMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)] = {
        start: 0,
        end: patternNodeMap[nodeWithLabel2.id].idx,
        distance: dist
      };
      if (directed) {
        var distBack = patternSpmMap["".concat(nodeWithLabel2.id, "-").concat(beginPNode.id)];
        distBack && patternSpDistBack[label2].push(distBack);
      }
    });
    patternSpDist[label2] = patternSpDist[label2].sort(function(a3, b2) {
      return a3 - b2;
    });
    if (directed)
      patternSpDistBack[label2] = patternSpDistBack[label2].sort(function(a3, b2) {
        return a3 - b2;
      });
    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap);
    var currentPatternNDSDistArray = [];
    Object.keys(patternNodePairMap).forEach(function(key) {
      if (patternNDSDist[key]) {
        currentPatternNDSDistArray.push(patternNDSDist[key]);
        return;
      }
      var patternIntGraph = patternIntGraphMap[key];
      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);
      currentPatternNDSDistArray.push(patternNDSDist[key]);
    });
    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function(a3, b2) {
      return b2 - a3;
    });
    patternNDSDistMap["".concat(beginPNode.id, "-").concat(label2)] = currentPatternNDSDistArray;
    if (label2 === label)
      return;
    var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;
    var _loop_4 = function _loop_42(m4) {
      var cNode = candidates[m4];
      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];
      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];
      var patternLabel2Num = patternNodeLabelMap[label2].length;
      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {
        candidates.splice(m4, 1);
        return "continue";
      }
      var prune2Invalid = false;
      for (var n2 = 0; n2 < patternLabel2Num; n2++) {
        if (graphNeighborUnitCountMap.dists[n2] > patternSpDist[label2][n2]) {
          prune2Invalid = true;
          break;
        }
      }
      if (prune2Invalid) {
        candidates.splice(m4, 1);
        return "continue";
      }
      var cNodePairMap = {};
      graphNeighborUnit.neighbors.forEach(function(neighborNode) {
        var dist = spmMap["".concat(cNode.id, "-").concat(neighborNode.id)];
        cNodePairMap["".concat(cNode.id, "-").concat(neighborNode.id)] = {
          start: nodeMap[cNode.id].idx,
          end: nodeMap[neighborNode.id].idx,
          distance: dist
        };
      });
      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap);
      var currentNDSDistArray = [];
      Object.keys(cNodePairMap).forEach(function(key) {
        if (ndsDist[key]) {
          currentNDSDistArray.push(ndsDist[key]);
          return;
        }
        var intGraph = intGMap[key];
        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);
        currentNDSDistArray.push(ndsDist[key]);
      });
      currentNDSDistArray = currentNDSDistArray.sort(function(a3, b2) {
        return b2 - a3;
      });
      var prune3Invalid = false;
      for (var n2 = 0; n2 < patternLabel2Num; n2++) {
        if (currentNDSDistArray[n2] < currentPatternNDSDistArray[n2]) {
          prune3Invalid = true;
          break;
        }
      }
      if (prune3Invalid) {
        candidates.splice(m4, 1);
        return "continue";
      }
    };
    for (var m3 = candidatesNum - 1; m3 >= 0; m3--) {
      _loop_4(m3);
    }
  });
  var candidateGraphs = [];
  candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function(candidate) {
    var nodeIdx = nodeMap[candidate.id].idx;
    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);
    var neighborNodes = lengthNeighborUnit.neighbors;
    var neighborNum = neighborNodes.length;
    var unmatched = false;
    for (var i3 = neighborNum - 1; i3 >= 0; i3--) {
      if (neighborNodes.length + 1 < pattern.nodes.length) {
        unmatched = true;
        return;
      }
      var neighborNode = neighborNodes[i3];
      var neighborLabel = neighborNode[nodeLabelProp];
      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      var key = "".concat(candidate.id, "-").concat(neighborNode.id);
      var distToCandidate = spmMap[key];
      var idx = patternSpDist[neighborLabel].length - 1;
      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx];
      if (distToCandidate > maxDistWithLabelInPattern) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      if (directed) {
        var keyBack = "".concat(neighborNode.id, "-").concat(candidate.id);
        var distFromCandidate = spmMap[keyBack];
        idx = patternSpDistBack[neighborLabel].length - 1;
        var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];
        if (distFromCandidate > maxBackDistWithLabelInPattern) {
          neighborNodes.splice(i3, 1);
          continue;
        }
      }
      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);
      var patternKey = "".concat(beginPNode.id, "-").concat(neighborLabel);
      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1];
      if (ndsToCandidate < minNdsWithLabelInPattern) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      var _a3 = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _a3.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _a3.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _a3.minPatternNodeLabelOutDegree;
      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {
        neighborNodes.splice(i3, 1);
        continue;
      }
    }
    if (!unmatched) {
      candidateGraphs.push({
        nodes: [candidate].concat(neighborNodes)
      });
    }
  });
  var undirectedLengthsToBeginPNode = dijkstra_default(pattern, beginPNode.id, false).length;
  var undirectedLengthsToBeginPNodeLabelMap = {};
  if (directed) {
    Object.keys(undirectedLengthsToBeginPNode).forEach(function(nodeId) {
      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];
      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel])
        undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];
      else
        undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);
    });
    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function(pLabel) {
      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function(a3, b2) {
        return a3 - b2;
      });
    });
  } else {
    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;
  }
  var candidateGraphNum = candidateGraphs.length;
  var _loop_2 = function _loop_22(i3) {
    var candidateGraph = candidateGraphs[i3];
    var candidate = candidateGraph.nodes[0];
    var candidateNodeLabelCountMap = {};
    var candidateNodeMap = {};
    candidateGraph.nodes.forEach(function(node, q2) {
      candidateNodeMap[node.id] = {
        idx: q2,
        node,
        degree: 0,
        inDegree: 0,
        outDegree: 0
      };
      var cNodeLabel2 = node[nodeLabelProp];
      if (!candidateNodeLabelCountMap[cNodeLabel2])
        candidateNodeLabelCountMap[cNodeLabel2] = 1;
      else
        candidateNodeLabelCountMap[cNodeLabel2]++;
    });
    var candidateEdges = [];
    var edgeLabelCountMap = {};
    graphData.edges.forEach(function(edge) {
      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {
        candidateEdges.push(edge);
        if (!edgeLabelCountMap[edge[edgeLabelProp]])
          edgeLabelCountMap[edge[edgeLabelProp]] = 1;
        else
          edgeLabelCountMap[edge[edgeLabelProp]]++;
        candidateNodeMap[edge.source].degree++;
        candidateNodeMap[edge.target].degree++;
        candidateNodeMap[edge.source].outDegree++;
        candidateNodeMap[edge.target].inDegree++;
      }
    });
    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;
    var prunedByEdgeLabel = false;
    for (var e8 = 0; e8 < pattenrEdgeLabelNum; e8++) {
      var label_1 = Object.keys(patternEdgeLabelMap)[e8];
      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {
        prunedByEdgeLabel = true;
        break;
      }
    }
    if (prunedByEdgeLabel) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    var candidateEdgeNum = candidateEdges.length;
    if (candidateEdgeNum < pattern.edges.length) {
      candidateGraphs.splice(i3, 1);
      return "break";
    }
    var candidateGraphInvalid = false;
    var _loop_5 = function _loop_52(e9) {
      var edge = candidateEdges[e9];
      var edgeLabel2 = edge[edgeLabelProp];
      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel2];
      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {
        edgeLabelCountMap[edgeLabel2]--;
        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
          candidateGraphInvalid = true;
          return "break";
        }
        candidateEdges.splice(e9, 1);
        candidateNodeMap[edge.source].degree--;
        candidateNodeMap[edge.target].degree--;
        candidateNodeMap[edge.source].outDegree--;
        candidateNodeMap[edge.target].inDegree--;
        return "continue";
      }
      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];
      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];
      var edgeMatched = false;
      patternEdgesWithLabel.forEach(function(patternEdge) {
        var patternSource = patternNodeMap[patternEdge.source].node;
        var patternTarget = patternNodeMap[patternEdge.target].node;
        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel)
          edgeMatched = true;
        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel)
          edgeMatched = true;
      });
      if (!edgeMatched) {
        edgeLabelCountMap[edgeLabel2]--;
        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
          candidateGraphInvalid = true;
          return "break";
        }
        candidateEdges.splice(e9, 1);
        candidateNodeMap[edge.source].degree--;
        candidateNodeMap[edge.target].degree--;
        candidateNodeMap[edge.source].outDegree--;
        candidateNodeMap[edge.target].inDegree--;
        return "continue";
      }
    };
    for (var e8 = candidateEdgeNum - 1; e8 >= 0; e8--) {
      var state_2 = _loop_5(e8);
      if (state_2 === "break")
        break;
    }
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    candidateGraph.edges = candidateEdges;
    var lengthsToCandidate = dijkstra_default(candidateGraph, candidateGraph.nodes[0].id, false).length;
    Object.keys(lengthsToCandidate).reverse().forEach(function(targetId) {
      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid)
        return;
      if (lengthsToCandidate[targetId] === Infinity) {
        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
        candidateNodeLabelCountMap[targetNodeLabel]--;
        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
          candidateGraphInvalid = true;
          return;
        }
        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
        candidateGraph.nodes.splice(idx, 1);
        candidateNodeMap[targetId] = void 0;
        return;
      }
      var nLabel = nodeMap[targetId].node[nodeLabelProp];
      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {
        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
        candidateNodeLabelCountMap[targetNodeLabel]--;
        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
          candidateGraphInvalid = true;
          return;
        }
        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
        candidateGraph.nodes.splice(idx, 1);
        candidateNodeMap[targetId] = void 0;
      }
    });
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    var degreeChanged = true;
    var loopCount = 0;
    while (degreeChanged && !candidateGraphInvalid) {
      degreeChanged = false;
      var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;
      if (condition) {
        candidateGraphInvalid = true;
        break;
      }
      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {
        candidateGraphInvalid = true;
        break;
      }
      var currentCandidateNodeNum = candidateGraph.nodes.length;
      for (var o2 = currentCandidateNodeNum - 1; o2 >= 0; o2--) {
        var cgNode = candidateGraph.nodes[o2];
        var nodeDegree = candidateNodeMap[cgNode.id].degree;
        var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;
        var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;
        var cNodeLabel = cgNode[nodeLabelProp];
        var _e2 = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _e2.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _e2.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _e2.minPatternNodeLabelOutDegree;
        var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;
        if (deleteCondition) {
          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;
          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {
            candidateGraphInvalid = true;
            break;
          }
          candidateGraph.nodes.splice(o2, 1);
          candidateNodeMap[cgNode.id] = void 0;
          degreeChanged = true;
        }
      }
      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0)
        break;
      candidateEdgeNum = candidateEdges.length;
      for (var y4 = candidateEdgeNum - 1; y4 >= 0; y4--) {
        var cedge = candidateEdges[y4];
        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {
          candidateEdges.splice(y4, 1);
          var edgeLabel = cedge[edgeLabelProp];
          edgeLabelCountMap[edgeLabel]--;
          if (candidateNodeMap[cedge.source]) {
            candidateNodeMap[cedge.source].degree--;
            candidateNodeMap[cedge.source].outDegree--;
          }
          if (candidateNodeMap[cedge.target]) {
            candidateNodeMap[cedge.target].degree--;
            candidateNodeMap[cedge.target].inDegree--;
          }
          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {
            candidateGraphInvalid = true;
            break;
          }
          degreeChanged = true;
        }
      }
      loopCount++;
    }
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
  };
  for (var i2 = candidateGraphNum - 1; i2 >= 0; i2--) {
    var state_1 = _loop_2(i2);
    if (state_1 === "break")
      break;
  }
  var currentLength = candidateGraphs.length;
  var _loop_3 = function _loop_32(i3) {
    var cg1 = candidateGraphs[i3];
    var cg1EdgeMap = {};
    cg1.edges.forEach(function(edge) {
      var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
      if (!cg1EdgeMap[key])
        cg1EdgeMap[key] = 1;
      else
        cg1EdgeMap[key]++;
    });
    var _loop_6 = function _loop_62(j3) {
      var cg2 = candidateGraphs[j3];
      var cg2EdgeMap = {};
      cg2.edges.forEach(function(edge) {
        var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
        if (!cg2EdgeMap[key])
          cg2EdgeMap[key] = 1;
        else
          cg2EdgeMap[key]++;
      });
      var same = true;
      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {
        same = false;
      } else {
        Object.keys(cg1EdgeMap).forEach(function(key) {
          if (cg2EdgeMap[key] !== cg1EdgeMap[key])
            same = false;
        });
      }
      if (same) {
        candidateGraphs.splice(j3, 1);
      }
    };
    for (var j2 = currentLength - 1; j2 > i3; j2--) {
      _loop_6(j2);
    }
    currentLength = candidateGraphs.length;
  };
  for (var i2 = 0; i2 <= currentLength - 1; i2++) {
    _loop_3(i2);
  }
  return candidateGraphs;
};
var gaddi_default = GADDI;

// node_modules/@antv/algorithm/es/structs/stack.js
var Stack = (
  /** @class */
  function() {
    function Stack2(maxStep) {
      if (maxStep === void 0) {
        maxStep = 10;
      }
      this.linkedList = new linked_list_default();
      this.maxStep = maxStep;
    }
    Object.defineProperty(Stack2.prototype, "length", {
      get: function get3() {
        return this.linkedList.toArray().length;
      },
      enumerable: false,
      configurable: true
    });
    Stack2.prototype.isEmpty = function() {
      return !this.linkedList.head;
    };
    Stack2.prototype.isMaxStack = function() {
      return this.toArray().length >= this.maxStep;
    };
    Stack2.prototype.peek = function() {
      if (this.isEmpty()) {
        return null;
      }
      return this.linkedList.head.value;
    };
    Stack2.prototype.push = function(value) {
      this.linkedList.prepend(value);
      if (this.length > this.maxStep) {
        this.linkedList.deleteTail();
      }
    };
    Stack2.prototype.pop = function() {
      var removeHead = this.linkedList.deleteHead();
      return removeHead ? removeHead.value : null;
    };
    Stack2.prototype.toArray = function() {
      return this.linkedList.toArray().map(function(node) {
        return node.value;
      });
    };
    Stack2.prototype.clear = function() {
      while (!this.isEmpty()) {
        this.pop();
      }
    };
    return Stack2;
  }()
);
var stack_default = Stack;

// node_modules/@antv/algorithm/es/index.js
var detectDirectedCycle3 = detect_cycle_default;
var es_default = {
  getAdjMatrix: adjacent_matrix_default,
  breadthFirstSearch: bfs_default,
  connectedComponent: getConnectedComponents,
  getDegree: degree_default,
  getInDegree,
  getOutDegree,
  detectCycle: detect_cycle_default,
  detectDirectedCycle: detectDirectedCycle3,
  detectAllCycles,
  detectAllDirectedCycle,
  detectAllUndirectedCycle,
  depthFirstSearch,
  dijkstra: dijkstra_default,
  findAllPath,
  findShortestPath,
  floydWarshall: floydWarshall_default,
  labelPropagation: label_propagation_default,
  louvain: louvain_default,
  iLouvain: i_louvain_default,
  kCore: k_core_default,
  kMeans: k_means_default,
  cosineSimilarity: cosine_similarity_default,
  nodesCosineSimilarity: nodes_cosine_similarity_default,
  minimumSpanningTree: mts_default,
  pageRank: pageRank_default,
  getNeighbors,
  Stack: stack_default,
  GADDI: gaddi_default
};

// node_modules/@antv/g6-core/es/util/math.js
var math_exports = {};
__export(math_exports, {
  Line: () => Line,
  applyMatrix: () => applyMatrix,
  compare: () => compare,
  distance: () => distance,
  floydWarshall: () => floydWarshall3,
  fractionToLine: () => fractionToLine,
  getAdjMatrix: () => getAdjMatrix,
  getBBoxBoundLine: () => getBBoxBoundLine,
  getCircleCenterByPoints: () => getCircleCenterByPoints,
  getCircleIntersectByPoint: () => getCircleIntersectByPoint,
  getDegree: () => getDegree,
  getEllipseIntersectByPoint: () => getEllipseIntersectByPoint,
  getLineIntersect: () => getLineIntersect,
  getPointsCenter: () => getPointsCenter,
  getRectIntersectByPoint: () => getRectIntersectByPoint,
  intersectBBox: () => intersectBBox,
  invertMatrix: () => invertMatrix,
  isPointInPolygon: () => isPointInPolygon,
  isPointsOverlap: () => isPointsOverlap,
  isPolygonsIntersect: () => isPolygonsIntersect,
  itemIntersectByLine: () => itemIntersectByLine,
  lerp: () => lerp,
  lerpArray: () => lerpArray,
  move: () => move,
  pointLineDistance: () => pointLineDistance,
  pointLineSquareDist: () => pointLineSquareDist,
  pointRectSquareDist: () => pointRectSquareDist,
  rotate: () => rotate,
  scale: () => scale,
  scaleMatrix: () => scaleMatrix,
  squareDist: () => squareDist,
  translate: () => translate
});
init_esm();
var transform = ext_exports.transform;
var compare = function compare2(attributeName) {
  return function(m3, n2) {
    return m3[attributeName] - n2[attributeName];
  };
};
var isBetween = function isBetween2(value, min3, max4) {
  return value >= min3 && value <= max4;
};
var getLineIntersect = function getLineIntersect2(p0, p1, p2, p3) {
  var tolerance2 = 1e-4;
  var E2 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var invertKross = 1 / kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  if (sqrKross > tolerance2 * sqrLen0 * sqrLen1) {
    var s2 = (E2.x * D1.y - E2.y * D1.x) * invertKross;
    var t2 = (E2.x * D0.y - E2.y * D0.x) * invertKross;
    if (!isBetween(s2, 0, 1) || !isBetween(t2, 0, 1))
      return null;
    return {
      x: p0.x + s2 * D0.x,
      y: p0.y + s2 * D0.y
    };
  }
  return null;
};
var getRectIntersectByPoint = function getRectIntersectByPoint2(rect2, point) {
  var x4 = rect2.x, y4 = rect2.y, width = rect2.width, height = rect2.height;
  var cx = x4 + width / 2;
  var cy = y4 + height / 2;
  var points = [];
  var center = {
    x: cx,
    y: cy
  };
  points.push({
    x: x4,
    y: y4
  });
  points.push({
    x: x4 + width,
    y: y4
  });
  points.push({
    x: x4 + width,
    y: y4 + height
  });
  points.push({
    x: x4,
    y: y4 + height
  });
  points.push({
    x: x4,
    y: y4
  });
  var rst = null;
  for (var i2 = 1; i2 < points.length; i2++) {
    rst = getLineIntersect(points[i2 - 1], points[i2], center, point);
    if (rst) {
      break;
    }
  }
  return rst;
};
var getCircleIntersectByPoint = function getCircleIntersectByPoint2(circle2, point) {
  var cx = circle2.x, cy = circle2.y, r2 = circle2.r;
  var x4 = point.x, y4 = point.y;
  var dx = x4 - cx;
  var dy = y4 - cy;
  if (dx * dx + dy * dy < r2 * r2) {
    return null;
  }
  var angle = Math.atan(dy / dx);
  return {
    x: cx + Math.abs(r2 * Math.cos(angle)) * Math.sign(dx),
    y: cy + Math.abs(r2 * Math.sin(angle)) * Math.sign(dy)
  };
};
var getEllipseIntersectByPoint = function getEllipseIntersectByPoint2(ellipse, point) {
  var a3 = ellipse.rx;
  var b2 = ellipse.ry;
  var cx = ellipse.x;
  var cy = ellipse.y;
  var dx = point.x - cx;
  var dy = point.y - cy;
  var angle = Math.atan2(dy / b2, dx / a3);
  if (angle < 0) {
    angle += 2 * Math.PI;
  }
  return {
    x: cx + a3 * Math.cos(angle),
    y: cy + b2 * Math.sin(angle)
  };
};
var applyMatrix = function applyMatrix2(point, matrix, tag) {
  if (tag === void 0) {
    tag = 1;
  }
  var vector = [point.x, point.y, tag];
  if (!matrix || isNaN(matrix[0])) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  vec3_exports.transformMat3(vector, vector, matrix);
  return {
    x: vector[0],
    y: vector[1]
  };
};
var invertMatrix = function invertMatrix2(point, matrix, tag) {
  if (tag === void 0) {
    tag = 1;
  }
  if (!matrix || isNaN(matrix[0])) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var inversedMatrix = mat3_exports.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);
  if (!inversedMatrix) {
    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var vector = [point.x, point.y, tag];
  vec3_exports.transformMat3(vector, vector, inversedMatrix);
  return {
    x: vector[0],
    y: vector[1]
  };
};
var getCircleCenterByPoints = function getCircleCenterByPoints2(p1, p2, p3) {
  var a3 = p1.x - p2.x;
  var b2 = p1.y - p2.y;
  var c3 = p1.x - p3.x;
  var d2 = p1.y - p3.y;
  var e8 = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;
  var f2 = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;
  var denominator = b2 * c3 - a3 * d2;
  return {
    x: -(d2 * e8 - b2 * f2) / denominator,
    y: -(a3 * f2 - c3 * e8) / denominator
  };
};
var distance = function distance2(p1, p2) {
  var vx = p1.x - p2.x;
  var vy = p1.y - p2.y;
  return Math.sqrt(vx * vx + vy * vy);
};
var scaleMatrix = function scaleMatrix2(matrix, ratio) {
  var result = [];
  matrix.forEach(function(row) {
    var newRow = [];
    row.forEach(function(v2) {
      newRow.push(v2 * ratio);
    });
    result.push(newRow);
  });
  return result;
};
var floydWarshall3 = function floydWarshall4(adjMatrix3) {
  var dist = [];
  var size3 = adjMatrix3.length;
  for (var i2 = 0; i2 < size3; i2 += 1) {
    dist[i2] = [];
    for (var j2 = 0; j2 < size3; j2 += 1) {
      if (i2 === j2) {
        dist[i2][j2] = 0;
      } else if (adjMatrix3[i2][j2] === 0 || !adjMatrix3[i2][j2]) {
        dist[i2][j2] = Infinity;
      } else {
        dist[i2][j2] = adjMatrix3[i2][j2];
      }
    }
  }
  for (var k2 = 0; k2 < size3; k2 += 1) {
    for (var i2 = 0; i2 < size3; i2 += 1) {
      for (var j2 = 0; j2 < size3; j2 += 1) {
        if (dist[i2][j2] > dist[i2][k2] + dist[k2][j2]) {
          dist[i2][j2] = dist[i2][k2] + dist[k2][j2];
        }
      }
    }
  }
  return dist;
};
var getAdjMatrix = function getAdjMatrix2(data, directed) {
  var nodes = data.nodes, edges = data.edges;
  var matrix = [];
  var nodeMap = {};
  if (!nodes) {
    throw new Error("invalid nodes data!");
  }
  if (nodes) {
    nodes.forEach(function(node, i2) {
      nodeMap[node.id] = i2;
      var row = [];
      matrix.push(row);
    });
  }
  if (edges) {
    edges.forEach(function(e8) {
      var source = e8.source, target = e8.target;
      var sIndex = nodeMap[source];
      var tIndex = nodeMap[target];
      matrix[sIndex][tIndex] = 1;
      if (!directed) {
        matrix[tIndex][sIndex] = 1;
      }
    });
  }
  return matrix;
};
var translate = function translate2(group, vec) {
  group.translate(vec.x, vec.y);
};
var move = function move2(group, point, animate, animateCfg) {
  if (animateCfg === void 0) {
    animateCfg = {
      duration: 500
    };
  }
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var bbox = group.getCanvasBBox();
  var vx = point.x - bbox.minX;
  var vy = point.y - bbox.minY;
  if (animate) {
    var dx_1 = vx * matrix[0];
    var dy_1 = vy * matrix[4];
    var lastX_1 = 0;
    var lastY_1 = 0;
    var newX_1 = 0;
    var newY_1 = 0;
    group.animate(function(ratio) {
      newX_1 = dx_1 * ratio;
      newY_1 = dy_1 * ratio;
      matrix = transform(matrix, [["t", newX_1 - lastX_1, newY_1 - lastY_1]]);
      lastX_1 = newX_1;
      lastY_1 = newY_1;
      return {
        matrix
      };
    }, animateCfg);
  } else {
    var movedMatrix = transform(matrix, [["t", vx, vy]]);
    group.setMatrix(movedMatrix);
  }
};
var scale = function scale2(group, ratio) {
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var scaleXY = ratio;
  if (!is_array_default(ratio)) {
    scaleXY = [ratio, ratio];
  }
  if (is_array_default(ratio) && ratio.length === 1) {
    scaleXY = [ratio[0], ratio[0]];
  }
  matrix = transform(matrix, [["s", scaleXY[0], scaleXY[1]]]);
  group.setMatrix(matrix);
};
var rotate = function rotate2(group, angle) {
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  matrix = transform(matrix, [["r", angle]]);
  group.setMatrix(matrix);
};
var getDegree = function getDegree2(n2, nodeIdxMap, edges) {
  var degrees = [];
  for (var i2 = 0; i2 < n2; i2++) {
    degrees[i2] = 0;
  }
  edges.forEach(function(e8) {
    if (e8.source) {
      degrees[nodeIdxMap[e8.source]] += 1;
    }
    if (e8.target) {
      degrees[nodeIdxMap[e8.target]] += 1;
    }
  });
  return degrees;
};
function onSegment(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
var isPointInPolygon = function isPointInPolygon2(points, x4, y4) {
  var isHit = false;
  var n2 = points.length;
  var tolerance2 = 1e-6;
  function dcmp2(xValue) {
    if (Math.abs(xValue) < tolerance2) {
      return 0;
    }
    return xValue < 0 ? -1 : 1;
  }
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p2 = points[(i2 + 1) % n2];
    if (onSegment(p1, p2, [x4, y4])) {
      return true;
    }
    if (dcmp2(p1[1] - y4) > 0 !== dcmp2(p2[1] - y4) > 0 && dcmp2(x4 - (y4 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
};
var intersectBBox = function intersectBBox2(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
};
var lineIntersectPolygon = function lineIntersectPolygon2(lines, line) {
  var isIntersect = false;
  each_default(lines, function(l2) {
    if (getLineIntersect(l2.from, l2.to, line.from, line.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
};
var isPolygonsIntersect = function isPolygonsIntersect2(points1, points2) {
  var getBBox5 = function getBBox6(points) {
    var xArr = points.map(function(p2) {
      return p2[0];
    });
    var yArr = points.map(function(p2) {
      return p2[1];
    });
    return {
      minX: Math.min.apply(null, xArr),
      maxX: Math.max.apply(null, xArr),
      minY: Math.min.apply(null, yArr),
      maxY: Math.max.apply(null, yArr)
    };
  };
  var parseToLines2 = function parseToLines3(points) {
    var lines = [];
    var count = points.length;
    for (var i2 = 0; i2 < count - 1; i2++) {
      var point = points[i2];
      var next = points[i2 + 1];
      lines.push({
        from: {
          x: point[0],
          y: point[1]
        },
        to: {
          x: next[0],
          y: next[1]
        }
      });
    }
    if (lines.length > 1) {
      var first = points[0];
      var last2 = points[count - 1];
      lines.push({
        from: {
          x: last2[0],
          y: last2[1]
        },
        to: {
          x: first[0],
          y: first[1]
        }
      });
    }
    return lines;
  };
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox5(points1);
  var bbox2 = getBBox5(points2);
  if (!intersectBBox(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each_default(points2, function(point) {
    if (isPointInPolygon(points1, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each_default(points1, function(point) {
    if (isPointInPolygon(points2, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines2(points1);
  var lines2 = parseToLines2(points2);
  var isIntersect = false;
  each_default(lines2, function(line) {
    if (lineIntersectPolygon(lines1, line)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
};
var Line = (
  /** @class */
  function() {
    function Line2(x1, y1, x22, y22) {
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x22;
      this.y2 = y22;
    }
    Line2.prototype.getBBox = function() {
      var minX = Math.min(this.x1, this.x2);
      var minY = Math.min(this.y1, this.y2);
      var maxX = Math.max(this.x1, this.x2);
      var maxY = Math.max(this.y1, this.y2);
      var res = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return res;
    };
    return Line2;
  }()
);
var getBBoxBoundLine = function getBBoxBoundLine2(bbox, direction2) {
  var bounds = {
    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],
    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],
    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],
    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]
  };
  return bounds[direction2];
};
var fractionAlongLineA = function fractionAlongLineA2(la2, lb) {
  var uaT = (lb.x2 - lb.x1) * (la2.y1 - lb.y1) - (lb.y2 - lb.y1) * (la2.x1 - lb.x1);
  var ubT = (la2.x2 - la2.x1) * (la2.y1 - lb.y1) - (la2.y2 - la2.y1) * (la2.x1 - lb.x1);
  var uB = (lb.y2 - lb.y1) * (la2.x2 - la2.x1) - (lb.x2 - lb.x1) * (la2.y2 - la2.y1);
  if (uB) {
    var ua2 = uaT / uB;
    var ub = ubT / uB;
    if (ua2 >= 0 && ua2 <= 1 && ub >= 0 && ub <= 1) {
      return ua2;
    }
  }
  return Number.POSITIVE_INFINITY;
};
var itemIntersectByLine = function itemIntersectByLine2(item, line) {
  var directions = ["top", "left", "bottom", "right"];
  var bbox = item.getBBox();
  var countIntersections = 0;
  var intersections = [];
  for (var i2 = 0; i2 < 4; i2++) {
    var _a2 = getBBoxBoundLine(bbox, directions[i2]), x1 = _a2[0], y1 = _a2[1], x22 = _a2[2], y22 = _a2[3];
    intersections[i2] = getLineIntersect({
      x: line.x1,
      y: line.y1
    }, {
      x: line.x2,
      y: line.y2
    }, {
      x: x1,
      y: y1
    }, {
      x: x22,
      y: y22
    });
    if (intersections[i2]) {
      countIntersections += 1;
    }
  }
  return [intersections, countIntersections];
};
var fractionToLine = function fractionToLine2(item, line) {
  var directions = ["top", "left", "bottom", "right"];
  var bbox = item.getBBox();
  var minDistance = Number.POSITIVE_INFINITY;
  var countIntersections = 0;
  for (var i2 = 0; i2 < 4; i2++) {
    var _a2 = getBBoxBoundLine(bbox, directions[i2]), x1 = _a2[0], y1 = _a2[1], x22 = _a2[2], y22 = _a2[3];
    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x22, y22));
    testDistance = Math.abs(testDistance - 0.5);
    if (testDistance >= 0 && testDistance <= 1) {
      countIntersections += 1;
      minDistance = testDistance < minDistance ? testDistance : minDistance;
    }
  }
  if (countIntersections === 0)
    return -1;
  return minDistance;
};
var getPointsCenter = function getPointsCenter2(points) {
  var centerX = 0;
  var centerY = 0;
  if (points.length > 0) {
    for (var _i2 = 0, points_1 = points; _i2 < points_1.length; _i2++) {
      var point = points_1[_i2];
      centerX += point.x;
      centerY += point.y;
    }
    centerX /= points.length;
    centerY /= points.length;
  }
  return {
    x: centerX,
    y: centerY
  };
};
var squareDist = function squareDist2(a3, b2) {
  return Math.pow(a3.x - b2.x, 2) + Math.pow(a3.y - b2.y, 2);
};
var pointLineSquareDist = function pointLineSquareDist2(point, line) {
  var x1 = line.x1;
  var y1 = line.y1;
  var x22 = line.x2 - x1;
  var y22 = line.y2 - y1;
  var px = point.x - x1;
  var py = point.y - y1;
  var dotprod = px * x22 + py * y22;
  var projlenSq;
  if (dotprod <= 0) {
    projlenSq = 0;
  } else {
    px = x22 - px;
    py = y22 - py;
    dotprod = px * x22 + py * y22;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      projlenSq = dotprod * dotprod / (x22 * x22 + y22 * y22);
    }
  }
  var lenSq = px * px + py * py - projlenSq;
  if (lenSq < 0) {
    lenSq = 0;
  }
  return lenSq;
};
var isPointsOverlap = function isPointsOverlap2(p1, p2, e8) {
  if (e8 === void 0) {
    e8 = 1e-3;
  }
  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e8, 2);
};
var pointRectSquareDist = function pointRectSquareDist2(point, rect2) {
  var isLeft = point.x < rect2.x;
  var isRight = point.x > rect2.x + rect2.width;
  var isTop = point.y > rect2.y + rect2.height;
  var isBottom = point.y < rect2.y;
  var isPointOutside = isLeft || isRight || isTop || isBottom;
  if (!isPointOutside) {
    return 0;
  }
  if (isTop && !isLeft && !isRight) {
    return Math.pow(rect2.y + rect2.height - point.y, 2);
  }
  if (isBottom && !isLeft && !isRight) {
    return Math.pow(point.y - rect2.y, 2);
  }
  if (isLeft && !isTop && !isBottom) {
    return Math.pow(rect2.x - point.x, 2);
  }
  if (isRight && !isTop && !isBottom) {
    return Math.pow(rect2.x + rect2.width - point.x, 2);
  }
  var dx = Math.min(Math.abs(rect2.x - point.x), Math.abs(rect2.x + rect2.width - point.x));
  var dy = Math.min(Math.abs(rect2.y - point.y), Math.abs(rect2.y + rect2.height - point.y));
  return dx * dx + dy * dy;
};
var pointLineDistance = function pointLineDistance2(line, point) {
  var x1 = line[0], y1 = line[1], x22 = line[2], y22 = line[3];
  var x4 = point.x, y4 = point.y;
  var d2 = [x22 - x1, y22 - y1];
  if (vec2_exports.exactEquals(d2, [0, 0])) {
    return NaN;
  }
  var u2 = [-d2[1], d2[0]];
  vec2_exports.normalize(u2, u2);
  var a3 = [x4 - x1, y4 - y1];
  return Math.abs(vec2_exports.dot(a3, u2));
};
var lerp = function lerp2(start, end2, alpha) {
  return start + (end2 - start) * alpha;
};
var lerpArray = function lerpArray2(start, end2, alpha) {
  var len = Math.min(start.length, end2.length);
  var out = new Array(len);
  for (var i2 = 0; i2 < len; i2++) {
    out[i2] = lerp(start[i2], end2[i2], alpha);
  }
  return out;
};

// node_modules/@antv/g6-core/es/util/validation.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/util/graphic.js
var graphic_exports = {};
__export(graphic_exports, {
  cloneBesidesImg: () => cloneBesidesImg,
  getAnimateCfgWithCallback: () => getAnimateCfgWithCallback,
  getBBox: () => getBBox,
  getComboBBox: () => getComboBBox,
  getLabelPosition: () => getLabelPosition,
  getLetterWidth: () => getLetterWidth,
  getLoopCfgs: () => getLoopCfgs,
  getTextSize: () => getTextSize,
  plainCombosToTrees: () => plainCombosToTrees,
  reconstructTree: () => reconstructTree,
  shouldRefreshEdge: () => shouldRefreshEdge,
  traverseTree: () => traverseTree,
  traverseTreeUp: () => traverseTreeUp,
  truncateLabelByLength: () => truncateLabelByLength
});
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/global.js
var subjectColor = "rgb(95, 149, 255)";
var backColor = "rgb(255, 255, 255)";
var textColor = "rgb(0, 0, 0)";
var activeFill = "rgb(247, 250, 255)";
var nodeMainFill = "rgb(239, 244, 255)";
var comboFill = "rgb(253, 253, 253)";
var disabledFill = "rgb(250, 250, 250)";
var edgeMainStroke = "rgb(224, 224, 224)";
var edgeInactiveStroke = "rgb(234, 234, 234)";
var edgeDisablesStroke = "rgb(245, 245, 245)";
var inactiveStroke = "rgb(191, 213, 255)";
var highlightStroke = "#4572d9";
var highlightFill = "rgb(223, 234, 255)";
var colorSet = {
  // for nodes
  mainStroke: subjectColor,
  mainFill: nodeMainFill,
  activeStroke: subjectColor,
  activeFill,
  inactiveStroke,
  inactiveFill: activeFill,
  selectedStroke: subjectColor,
  selectedFill: backColor,
  highlightStroke,
  highlightFill,
  disableStroke: edgeMainStroke,
  disableFill: disabledFill,
  // for edges
  edgeMainStroke,
  edgeActiveStroke: subjectColor,
  edgeInactiveStroke,
  edgeSelectedStroke: subjectColor,
  edgeHighlightStroke: subjectColor,
  edgeDisableStroke: edgeDisablesStroke,
  // for combos
  comboMainStroke: edgeMainStroke,
  comboMainFill: comboFill,
  comboActiveStroke: subjectColor,
  comboActiveFill: activeFill,
  comboInactiveStroke: edgeMainStroke,
  comboInactiveFill: comboFill,
  comboSelectedStroke: subjectColor,
  comboSelectedFill: comboFill,
  comboHighlightStroke: highlightStroke,
  comboHighlightFill: comboFill,
  comboDisableStroke: edgeInactiveStroke,
  comboDisableFill: disabledFill
};
var global_default = {
  version: "0.8.7",
  rootContainerClassName: "root-container",
  nodeContainerClassName: "node-container",
  edgeContainerClassName: "edge-container",
  comboContainerClassName: "combo-container",
  delegateContainerClassName: "delegate-container",
  defaultLoopPosition: "top",
  nodeLabel: {
    style: {
      fill: "#000",
      fontSize: 12,
      textAlign: "center",
      textBaseline: "middle"
    },
    offset: 4
    // 节点的默认文本不居中时的偏移量
  },
  defaultNode: {
    type: "circle",
    style: {
      lineWidth: 1,
      stroke: colorSet.mainStroke,
      fill: nodeMainFill
    },
    size: 20,
    color: colorSet.mainStroke,
    linkPoints: {
      size: 8,
      lineWidth: 1,
      fill: colorSet.activeFill,
      stroke: colorSet.activeStroke
    }
  },
  // 节点应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  nodeStateStyles: {
    active: {
      fill: colorSet.activeFill,
      stroke: colorSet.activeStroke,
      lineWidth: 2,
      shadowColor: colorSet.mainStroke,
      shadowBlur: 10
    },
    selected: {
      fill: colorSet.selectedFill,
      stroke: colorSet.selectedStroke,
      lineWidth: 4,
      shadowColor: colorSet.selectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      fill: colorSet.highlightFill,
      stroke: colorSet.highlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      fill: colorSet.inactiveFill,
      stroke: colorSet.inactiveStroke,
      lineWidth: 1
    },
    disable: {
      fill: colorSet.disableFill,
      stroke: colorSet.disableStroke,
      lineWidth: 1
    }
  },
  edgeLabel: {
    style: {
      fill: textColor,
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 12
    }
  },
  defaultEdge: {
    type: "line",
    size: 1,
    style: {
      stroke: colorSet.edgeMainStroke,
      lineAppendWidth: 2
    },
    color: colorSet.edgeMainStroke
  },
  // 边应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  edgeStateStyles: {
    active: {
      stroke: colorSet.edgeActiveStroke,
      lineWidth: 1
    },
    selected: {
      stroke: colorSet.edgeSelectedStroke,
      lineWidth: 2,
      shadowColor: colorSet.edgeSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet.edgeHighlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet.edgeInactiveStroke,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet.edgeDisableStroke,
      lineWidth: 1
    }
  },
  comboLabel: {
    style: {
      fill: textColor,
      // textAlign: 'center',
      textBaseline: "middle",
      fontSize: 12
    },
    refY: 10,
    refX: 10
    // Combo 的默认文本不居中时的偏移量
  },
  defaultCombo: {
    type: "circle",
    style: {
      fill: colorSet.comboMainFill,
      lineWidth: 1,
      stroke: colorSet.comboMainStroke,
      r: 5,
      width: 20,
      height: 10
    },
    size: [20, 5],
    color: colorSet.comboMainStroke,
    padding: [25, 20, 15, 20]
  },
  // combo 应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  comboStateStyles: {
    active: {
      stroke: colorSet.comboActiveStroke,
      lineWidth: 1,
      fill: colorSet.comboActiveFill
    },
    selected: {
      stroke: colorSet.comboSelectedStroke,
      lineWidth: 2,
      fill: colorSet.comboSelectedFill,
      shadowColor: colorSet.comboSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet.comboHighlightStroke,
      lineWidth: 2,
      fill: colorSet.comboHighlightFill,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet.comboInactiveStroke,
      fill: colorSet.comboInactiveFill,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet.comboDisableStroke,
      fill: colorSet.comboDisableFill,
      lineWidth: 1
    }
  },
  delegateStyle: {
    fill: "#F3F9FF",
    fillOpacity: 0.5,
    stroke: "#1890FF",
    strokeOpacity: 0.9,
    lineDash: [5, 5]
  },
  windowFontFamily: typeof window !== "undefined" && window.getComputedStyle && document.body ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif"
};

// node_modules/@antv/g6-core/es/util/letterAspectRatio.js
var letterAspectRatio_default = {
  " ": 0.3329986572265625,
  a: 0.5589996337890625,
  A: 0.6569992065429687,
  b: 0.58599853515625,
  B: 0.6769989013671875,
  c: 0.5469985961914062,
  C: 0.7279998779296875,
  d: 0.58599853515625,
  D: 0.705999755859375,
  e: 0.554998779296875,
  E: 0.63699951171875,
  f: 0.37299957275390627,
  F: 0.5769989013671875,
  g: 0.5909988403320312,
  G: 0.7479995727539063,
  h: 0.555999755859375,
  H: 0.7199996948242188,
  i: 0.255999755859375,
  I: 0.23699951171875,
  j: 0.26699981689453123,
  J: 0.5169998168945312,
  k: 0.5289993286132812,
  K: 0.6899993896484375,
  l: 0.23499908447265624,
  L: 0.5879989624023437,
  m: 0.854998779296875,
  M: 0.8819992065429687,
  n: 0.5589996337890625,
  N: 0.7189987182617188,
  o: 0.58599853515625,
  O: 0.7669998168945312,
  p: 0.58599853515625,
  P: 0.6419998168945312,
  q: 0.58599853515625,
  Q: 0.7669998168945312,
  r: 0.3649993896484375,
  R: 0.6759994506835938,
  s: 0.504998779296875,
  S: 0.6319992065429687,
  t: 0.354998779296875,
  T: 0.6189987182617187,
  u: 0.5599990844726562,
  U: 0.7139999389648437,
  v: 0.48199920654296874,
  V: 0.6389999389648438,
  w: 0.754998779296875,
  W: 0.929998779296875,
  x: 0.5089996337890625,
  X: 0.63699951171875,
  y: 0.4959991455078125,
  Y: 0.66199951171875,
  z: 0.48699951171875,
  Z: 0.6239990234375,
  "0": 0.6,
  "1": 0.40099945068359377,
  "2": 0.6,
  "3": 0.6,
  "4": 0.6,
  "5": 0.6,
  "6": 0.6,
  "7": 0.5469985961914062,
  "8": 0.6,
  "9": 0.6,
  "[": 0.3329986572265625,
  "]": 0.3329986572265625,
  ",": 0.26399993896484375,
  ".": 0.26399993896484375,
  ";": 0.26399993896484375,
  ":": 0.26399993896484375,
  "{": 0.3329986572265625,
  "}": 0.3329986572265625,
  "\\": 0.5,
  "|": 0.19499969482421875,
  "=": 0.604998779296875,
  "+": 0.604998779296875,
  "-": 0.604998779296875,
  _: 0.5,
  "`": 0.3329986572265625,
  " ~": 0.8329986572265625,
  "!": 0.3329986572265625,
  "@": 0.8579986572265625,
  "#": 0.6,
  $: 0.6,
  "%": 0.9699996948242188,
  "^": 0.517999267578125,
  "&": 0.7259994506835937,
  "*": 0.505999755859375,
  "(": 0.3329986572265625,
  ")": 0.3329986572265625,
  "<": 0.604998779296875,
  ">": 0.604998779296875,
  "/": 0.5,
  "?": 0.53699951171875
};

// node_modules/@antv/g6-core/es/util/graphic.js
var PI = Math.PI;
var sin = Math.sin;
var cos = Math.cos;
var SELF_LINK_SIN = sin(PI / 8);
var SELF_LINK_COS = cos(PI / 8);
var getBBox = function getBBox2(element, group) {
  var bbox = element.getBBox();
  var leftTop = {
    x: bbox.minX,
    y: bbox.minY
  };
  var rightBottom = {
    x: bbox.maxX,
    y: bbox.maxY
  };
  if (group) {
    var matrix = group.getMatrix();
    if (!matrix) {
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    leftTop = applyMatrix(leftTop, matrix);
    rightBottom = applyMatrix(rightBottom, matrix);
  }
  var lx = leftTop.x, ly = leftTop.y;
  var rx = rightBottom.x, ry = rightBottom.y;
  return {
    x: lx,
    y: ly,
    minX: lx,
    minY: ly,
    maxX: rx,
    maxY: ry,
    width: rx - lx,
    height: ry - ly
  };
};
var getLoopCfgs = function getLoopCfgs2(cfg) {
  var item = cfg.sourceNode || cfg.targetNode;
  var container = item.get("group");
  var containerMatrix = container.getMatrix();
  if (!containerMatrix)
    containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  var keyShape = item.getKeyShape();
  var bbox = keyShape.getBBox();
  var loopCfg = cfg.loopCfg || {};
  var dist = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2;
  var position = loopCfg.position || global_default.defaultLoopPosition;
  var center = [(bbox.minX + bbox.maxX) / 2 + containerMatrix[6], (bbox.minY + bbox.maxY) / 2 + containerMatrix[7]];
  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];
  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];
  var halfOfHeight = bbox.height / 2;
  var halfOfWidth = bbox.width / 2;
  var rstart = halfOfHeight;
  var rend = halfOfHeight;
  var sinDeltaStart = rstart * SELF_LINK_SIN;
  var cosDeltaStart = rstart * SELF_LINK_COS;
  var sinDeltaEnd = rend * SELF_LINK_SIN;
  var cosDeltaEnd = rend * SELF_LINK_COS;
  var shapeType = keyShape.get("type");
  var defaultPointPadding = Math.min(halfOfHeight / 2, halfOfWidth / 2);
  var maxPointPadding = Math.min(halfOfHeight, halfOfWidth);
  var pointPadding = (loopCfg === null || loopCfg === void 0 ? void 0 : loopCfg.pointPadding) ? Math.min(maxPointPadding, loopCfg === null || loopCfg === void 0 ? void 0 : loopCfg.pointPadding) : defaultPointPadding;
  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {
    switch (position) {
      case "top":
        if (shapeType === "circle") {
          startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];
          endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];
        } else {
          startPoint = [center[0] - pointPadding, center[1] - halfOfHeight];
          endPoint = [center[0] + pointPadding, center[1] - halfOfHeight];
        }
        break;
      case "top-right":
        rstart = halfOfHeight;
        rend = halfOfWidth;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];
          endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];
        } else {
          startPoint = [center[0] + halfOfWidth - pointPadding, center[1] - halfOfHeight];
          endPoint = [center[0] + halfOfWidth, center[1] - halfOfHeight + pointPadding];
        }
        break;
      case "right":
        rstart = halfOfWidth;
        rend = halfOfWidth;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];
          endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];
        } else {
          startPoint = [center[0] + halfOfWidth, center[1] - pointPadding];
          endPoint = [center[0] + halfOfWidth, center[1] + pointPadding];
        }
        break;
      case "bottom-right":
        rstart = halfOfWidth;
        rend = halfOfHeight;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];
          endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];
        } else {
          startPoint = [center[0] + halfOfWidth, center[1] + halfOfHeight - pointPadding];
          endPoint = [center[0] + halfOfWidth - pointPadding, center[1] + halfOfHeight];
        }
        break;
      case "bottom":
        rstart = halfOfHeight;
        rend = halfOfHeight;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];
          endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];
        } else {
          startPoint = [center[0] - pointPadding, center[1] + halfOfHeight];
          endPoint = [center[0] + pointPadding, center[1] + halfOfHeight];
        }
        break;
      case "bottom-left":
        rstart = halfOfHeight;
        rend = halfOfWidth;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];
          endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];
        } else {
          startPoint = [center[0] - halfOfWidth, center[1] + halfOfHeight - pointPadding];
          endPoint = [center[0] - halfOfWidth + pointPadding, center[1] + halfOfHeight];
        }
        break;
      case "left":
        rstart = halfOfWidth;
        rend = halfOfWidth;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];
          endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];
        } else {
          startPoint = [center[0] - halfOfWidth, center[1] - pointPadding];
          endPoint = [center[0] - halfOfWidth, center[1] + pointPadding];
        }
        break;
      case "top-left":
        rstart = halfOfWidth;
        rend = halfOfHeight;
        if (shapeType === "circle") {
          sinDeltaStart = rstart * SELF_LINK_SIN;
          cosDeltaStart = rstart * SELF_LINK_COS;
          sinDeltaEnd = rend * SELF_LINK_SIN;
          cosDeltaEnd = rend * SELF_LINK_COS;
          startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];
          endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];
        } else {
          startPoint = [center[0] - halfOfWidth + pointPadding, center[1] - halfOfHeight];
          endPoint = [center[0] - halfOfWidth, center[1] - halfOfHeight + pointPadding];
        }
        break;
      default:
        rstart = halfOfWidth;
        rend = halfOfWidth;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];
        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];
    }
    if (loopCfg.clockwise === false) {
      var swap = [startPoint[0], startPoint[1]];
      startPoint = [endPoint[0], endPoint[1]];
      endPoint = [swap[0], swap[1]];
    }
  }
  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];
  var scaleRateStart = (rstart + dist) / rstart;
  var scaleRateEnd = (rend + dist) / rend;
  if (loopCfg.clockwise === false) {
    scaleRateStart = (rend + dist) / rend;
    scaleRateEnd = (rstart + dist) / rstart;
  }
  var startExtendVec = vec2_exports.scale([0, 0], startVec, scaleRateStart);
  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];
  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];
  var endExtendVec = vec2_exports.scale([0, 0], endVec, scaleRateEnd);
  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];
  cfg.startPoint = {
    x: startPoint[0],
    y: startPoint[1]
  };
  cfg.endPoint = {
    x: endPoint[0],
    y: endPoint[1]
  };
  cfg.controlPoints = [{
    x: controlPoint1[0],
    y: controlPoint1[1]
  }, {
    x: controlPoint2[0],
    y: controlPoint2[1]
  }];
  return cfg;
};
var getLabelPosition = function getLabelPosition2(pathShape, percent, refX, refY, rotate3) {
  var TAN_OFFSET = 1e-4;
  var vector = [];
  var point = pathShape === null || pathShape === void 0 ? void 0 : pathShape.getPoint(percent);
  if (!point) {
    return {
      x: 0,
      y: 0,
      angle: 0
    };
  }
  if (percent < TAN_OFFSET) {
    vector = pathShape.getStartTangent().reverse();
  } else if (percent > 1 - TAN_OFFSET) {
    vector = pathShape.getEndTangent();
  } else {
    var offsetPoint = pathShape === null || pathShape === void 0 ? void 0 : pathShape.getPoint(percent + TAN_OFFSET);
    vector.push([point.x, point.y]);
    vector.push([offsetPoint.x, offsetPoint.y]);
  }
  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);
  if (rad < 0) {
    rad += PI * 2;
  }
  if (refX) {
    point.x += cos(rad) * refX;
    point.y += sin(rad) * refX;
  }
  if (refY) {
    var normal = rad - PI / 2;
    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {
      normal -= PI;
    }
    point.x += cos(normal) * refY;
    point.y += sin(normal) * refY;
  }
  var result = {
    x: point.x,
    y: point.y,
    angle: rad
  };
  if (rotate3) {
    if (rad > 0.5 * PI && rad < 1.5 * PI) {
      rad -= PI;
    }
    return __assign({
      rotate: rad
    }, result);
  }
  return result;
};
var traverse = function traverse2(data, parent, index2, fn2) {
  if (fn2(data, parent, index2) === false) {
    return false;
  }
  if (data && data.children) {
    for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
      if (!traverse2(data.children[i2], data, i2, fn2))
        return false;
    }
  }
  return true;
};
var traverseUp = function traverseUp2(data, parent, index2, fn2) {
  if (data && data.children) {
    for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
      if (!traverseUp2(data.children[i2], data, i2, fn2))
        return;
    }
  }
  if (fn2(data, parent, index2) === false) {
    return false;
  }
  return true;
};
var traverseTree = function traverseTree2(data, fn2) {
  if (typeof fn2 !== "function") {
    return;
  }
  traverse(data, null, -1, fn2);
};
var traverseTreeUp = function traverseTreeUp2(data, fn2) {
  if (typeof fn2 !== "function") {
    return;
  }
  traverseUp(data, null, -1, fn2);
};
var getLetterWidth = function getLetterWidth2(letter, fontSize) {
  return fontSize * (letterAspectRatio_default[letter] || 1);
};
var getTextSize = function getTextSize2(text, fontSize) {
  var width = 0;
  var pattern = new RegExp("[一-龥]+");
  text.split("").forEach(function(letter) {
    if (pattern.test(letter)) {
      width += fontSize;
    } else {
      width += getLetterWidth(letter, fontSize);
    }
  });
  return [width, fontSize];
};
var truncateLabelByLength = function truncateLabelByLength2(text, length) {
  if (typeof length !== "number" || length <= 0 || length >= text.length) {
    return text;
  }
  return text.substring(0, length) + "...";
};
var plainCombosToTrees = function plainCombosToTrees2(array, nodes) {
  var result = [];
  var addedMap = {};
  var modelMap = {};
  array.forEach(function(d2) {
    modelMap[d2.id] = d2;
  });
  array.forEach(function(d2, i2) {
    var cd = clone_default(d2);
    cd.itemType = "combo";
    cd.children = void 0;
    if (cd.parentId === cd.id) {
      console.warn("The parentId for combo ".concat(cd.id, " can not be the same as the combo's id"));
      delete cd.parentId;
    } else if (cd.parentId && !modelMap[cd.parentId]) {
      console.warn("The parent combo for combo ".concat(cd.id, " does not exist!"));
      delete cd.parentId;
    }
    var mappedObj = addedMap[cd.id];
    if (mappedObj) {
      cd.children = mappedObj.children;
      addedMap[cd.id] = cd;
      mappedObj = cd;
      if (!mappedObj.parentId) {
        result.push(mappedObj);
        return;
      }
      var mappedParent = addedMap[mappedObj.parentId];
      if (mappedParent) {
        if (mappedParent.children)
          mappedParent.children.push(cd);
        else
          mappedParent.children = [cd];
      } else {
        var parent_1 = {
          id: mappedObj.parentId,
          children: [mappedObj]
        };
        addedMap[mappedObj.parentId] = parent_1;
        addedMap[cd.id] = cd;
      }
      return;
    }
    if (is_string_default(d2.parentId)) {
      var parent_2 = addedMap[d2.parentId];
      if (parent_2) {
        if (parent_2.children)
          parent_2.children.push(cd);
        else
          parent_2.children = [cd];
        addedMap[cd.id] = cd;
      } else {
        var pa2 = {
          id: d2.parentId,
          children: [cd]
        };
        addedMap[pa2.id] = pa2;
        addedMap[cd.id] = cd;
      }
    } else {
      result.push(cd);
      addedMap[cd.id] = cd;
    }
  });
  var nodeMap = {};
  (nodes || []).forEach(function(node) {
    nodeMap[node.id] = node;
    var combo = addedMap[node.comboId];
    if (combo) {
      var cnode = {
        id: node.id,
        comboId: node.comboId
      };
      if (combo.children)
        combo.children.push(cnode);
      else
        combo.children = [cnode];
      cnode.itemType = "node";
      addedMap[node.id] = cnode;
    }
  });
  var maxDepth = 0;
  result.forEach(function(tree) {
    tree.depth = maxDepth + 10;
    traverseTree(tree, function(child) {
      var parent;
      var itemType = addedMap[child.id].itemType;
      if (itemType === "node") {
        parent = addedMap[child.comboId];
      } else {
        parent = addedMap[child.parentId];
      }
      if (parent) {
        if (itemType === "node")
          child.depth = maxDepth + 1;
        else
          child.depth = maxDepth + 10;
      } else {
        child.depth = maxDepth + 10;
      }
      if (maxDepth < child.depth)
        maxDepth = child.depth;
      var oriNodeModel = nodeMap[child.id];
      if (oriNodeModel) {
        oriNodeModel.depth = child.depth;
      }
      return true;
    });
  });
  return result;
};
var reconstructTree = function reconstructTree2(trees, subtreeId, newParentId) {
  var _a2;
  var brothers = trees;
  var subtree;
  var comboChildsMap = {
    root: {
      children: trees
    }
  };
  var foundSubTree = false;
  var oldParentId = "root";
  (trees || []).forEach(function(tree) {
    if (foundSubTree)
      return;
    if (tree.id === subtreeId) {
      subtree = tree;
      if (tree.itemType === "combo") {
        subtree.parentId = newParentId;
      } else {
        subtree.comboId = newParentId;
      }
      foundSubTree = true;
      return;
    }
    traverseTree(tree, function(child) {
      var _a3;
      comboChildsMap[child.id] = {
        children: (child === null || child === void 0 ? void 0 : child.children) || []
      };
      brothers = (_a3 = comboChildsMap[child.parentId || child.comboId || "root"]) === null || _a3 === void 0 ? void 0 : _a3.children;
      if (child && (child.removed || subtreeId === child.id) && brothers) {
        oldParentId = child.parentId || child.comboId || "root";
        subtree = child;
        if (child.itemType === "combo") {
          subtree.parentId = newParentId;
        } else {
          subtree.comboId = newParentId;
        }
        foundSubTree = true;
        return false;
      }
      return true;
    });
  });
  brothers = (_a2 = comboChildsMap[oldParentId]) === null || _a2 === void 0 ? void 0 : _a2.children;
  var index2 = brothers ? brothers.indexOf(subtree) : -1;
  if (index2 > -1)
    brothers.splice(index2, 1);
  if (!foundSubTree) {
    subtree = {
      id: subtreeId,
      itemType: "node",
      comboId: newParentId
    };
    comboChildsMap[subtreeId] = {
      children: void 0
    };
  }
  if (subtreeId) {
    var found_1 = false;
    if (newParentId) {
      var newParentDepth_1 = 0;
      (trees || []).forEach(function(tree) {
        if (found_1)
          return;
        traverseTree(tree, function(child) {
          if (newParentId === child.id) {
            found_1 = true;
            if (child.children)
              child.children.push(subtree);
            else
              child.children = [subtree];
            newParentDepth_1 = child.depth;
            if (subtree.itemType === "node")
              subtree.depth = newParentDepth_1 + 2;
            else
              subtree.depth = newParentDepth_1 + 1;
            return false;
          }
          return true;
        });
      });
    } else if ((!newParentId || !found_1) && subtree.itemType !== "node") {
      trees.push(subtree);
    }
    var currentDepth_1 = subtree.depth;
    traverseTree(subtree, function(child) {
      if (child.itemType === "node")
        currentDepth_1 += 2;
      else
        currentDepth_1 += 1;
      child.depth = currentDepth_1;
      return true;
    });
  }
  return trees;
};
var getComboBBox = function getComboBBox2(children, graph, combo) {
  var comboBBox = {
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity,
    x: void 0,
    y: void 0,
    width: void 0,
    height: void 0,
    centerX: void 0,
    centerY: void 0
  };
  if (!children || children.length === 0) {
    var comboModel = combo === null || combo === void 0 ? void 0 : combo.getModel();
    var _a2 = comboModel || {}, x4 = _a2.x, y4 = _a2.y, fixSize = _a2.fixSize, collapsed = _a2.collapsed, fixCollapseSize = _a2.fixCollapseSize;
    var useFixSize = collapsed ? fixCollapseSize : fixSize;
    var _b = is_array_default(useFixSize) ? useFixSize : [useFixSize, useFixSize], width = _b[0], height = _b[1];
    var halfSize = [width / 2, height / 2];
    return {
      minX: x4 - halfSize[0],
      minY: y4 - halfSize[1],
      maxX: x4 + halfSize[0],
      maxY: y4 + halfSize[1],
      x: x4,
      y: y4,
      width,
      height
    };
  }
  children.forEach(function(child) {
    var childItem = graph.findById(child.id);
    if (!childItem || !childItem.isVisible())
      return;
    childItem.set("bboxCanvasCache", void 0);
    var childBBox = childItem.getCanvasBBox();
    if (childBBox.x && comboBBox.minX > childBBox.minX)
      comboBBox.minX = childBBox.minX;
    if (childBBox.y && comboBBox.minY > childBBox.minY)
      comboBBox.minY = childBBox.minY;
    if (childBBox.x && comboBBox.maxX < childBBox.maxX)
      comboBBox.maxX = childBBox.maxX;
    if (childBBox.y && comboBBox.maxY < childBBox.maxY)
      comboBBox.maxY = childBBox.maxY;
  });
  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;
  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;
  comboBBox.width = comboBBox.maxX - comboBBox.minX;
  comboBBox.height = comboBBox.maxY - comboBBox.minY;
  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;
  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;
  if ((combo === null || combo === void 0 ? void 0 : combo.getKeyShape().get("type")) === "circle") {
    comboBBox.width = Math.hypot(comboBBox.height, comboBBox.width);
    comboBBox.height = comboBBox.width;
  }
  Object.keys(comboBBox).forEach(function(key) {
    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {
      comboBBox[key] = void 0;
    }
  });
  return comboBBox;
};
var shouldRefreshEdge = function shouldRefreshEdge2(cfg) {
  var refreshEdge = is_number_default(cfg.x) || is_number_default(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size;
  if (cfg.style)
    refreshEdge = refreshEdge || is_number_default(cfg.style.r) || is_number_default(cfg.style.width) || is_number_default(cfg.style.height) || is_number_default(cfg.style.rx) || is_number_default(cfg.style.ry);
  return refreshEdge;
};
var cloneBesidesImg = function cloneBesidesImg2(obj) {
  var clonedObj = {};
  Object.keys(obj).forEach(function(key1) {
    var obj2 = obj[key1];
    if (is_object_default(obj2) && !is_array_default(obj2)) {
      var clonedObj2_1 = {};
      Object.keys(obj2).forEach(function(key2) {
        var v2 = obj2[key2];
        if (key2 === "img" && !is_string_default(v2))
          return;
        clonedObj2_1[key2] = clone_default(v2);
      });
      clonedObj[key1] = clonedObj2_1;
    } else {
      clonedObj[key1] = clone_default(obj2);
    }
  });
  return clonedObj;
};
var getAnimateCfgWithCallback = function getAnimateCfgWithCallback2(_a2) {
  var animateCfg = _a2.animateCfg, callback = _a2.callback;
  var animateConfig;
  if (!animateCfg) {
    animateConfig = {
      duration: 500,
      callback
    };
  } else {
    animateConfig = clone_default(animateCfg);
    if (animateCfg.callback) {
      var animateCfgCallback_1 = animateCfg.callback;
      animateConfig.callback = function() {
        callback();
        animateCfgCallback_1();
      };
    } else {
      animateConfig.callback = callback;
    }
  }
  return animateConfig;
};

// node_modules/@antv/g6-core/es/util/validation.js
var dataValidation = function dataValidation2(data) {
  if (!data) {
    console.error("G6 Error Tips: the data must be defined");
    return false;
  }
  var nodes = data.nodes, edges = data.edges, _a2 = data.combos, combos = _a2 === void 0 ? [] : _a2;
  if (!nodes && !edges) {
    var validated_1 = true;
    traverseTree(data, function(param) {
      if (!is_string_default(param.id)) {
        validated_1 = false;
        return false;
      }
      return true;
    });
    return validated_1;
  }
  var nonNode = (nodes || []).find(function(node) {
    return !is_string_default(node.id);
  });
  if (nonNode) {
    console.warn("G6 Warning Tips: missing 'id' property, or %c".concat(nonNode.id, "%c is not a string."), "font-size: 20px; color: red;", "");
    return false;
  }
  var nodeIds = (nodes || []).map(function(node) {
    return node.id;
  });
  var comboIds = combos === null || combos === void 0 ? void 0 : combos.map(function(combo) {
    return combo.id;
  });
  var ids = __spreadArray(__spreadArray([], nodeIds, true), comboIds, true);
  var nonEdges = (edges || []).find(function(edge) {
    return !ids.includes(edge.source) || !ids.includes(edge.target);
  });
  if (nonEdges) {
    console.warn("G6 Warning Tips: The source %c".concat(nonEdges.source, "%c or the target %c").concat(nonEdges.target, "%c of the edge do not exist in the nodes or combos."), "font-size: 20px; color: red;", "", "font-size: 20px; color: red;", "");
    return false;
  }
  return true;
};
var singleDataValidation = function singleDataValidation2(type, data) {
  if (type === "node" || type === "combo") {
    if (data.id && !is_string_default(data.id)) {
      console.warn("G6 Warning Tips: missing 'id' property, or the 'id' %c".concat(data.id, "%c is not a string."), "font-size: 20px; color: red;", "");
      return false;
    }
  } else if (type === "edge") {
    if (!data.source || !data.target) {
      console.warn("G6 Warning Tips: missing 'source' or 'target' for the edge.");
      return false;
    }
  }
  return true;
};

// node_modules/@antv/g6-core/es/graph/controller/mode.js
init_esm();
var ModeController = (
  /** @class */
  function() {
    function ModeController2(graph) {
      this.graph = graph;
      this.destroyed = false;
      this.modes = graph.get("modes") || {
        default: []
      };
      this.formatModes();
      this.mode = graph.get("defaultMode") || "default";
      this.currentBehaves = [];
      this.setMode(this.mode);
    }
    ModeController2.prototype.formatModes = function() {
      var modes = this.modes;
      each_default(modes, function(mode) {
        each_default(mode, function(behavior, i2) {
          if (is_string_default(behavior)) {
            mode[i2] = {
              type: behavior
            };
          }
        });
      });
    };
    ModeController2.prototype.setBehaviors = function(mode) {
      var graph = this.graph;
      var behaviors2 = this.modes[mode];
      var behaves = [];
      var behave;
      each_default(behaviors2 || [], function(behavior) {
        var BehaviorInstance = behavior_default.getBehavior(behavior.type || behavior);
        if (!BehaviorInstance) {
          return;
        }
        behave = new BehaviorInstance(behavior);
        if (behave) {
          behave.bind(graph);
          behaves.push(behave);
        }
      });
      this.currentBehaves = behaves;
    };
    ModeController2.mergeBehaviors = function(modeBehaviors, behaviors2) {
      each_default(behaviors2, function(behavior) {
        if (modeBehaviors.indexOf(behavior) < 0) {
          if (is_string_default(behavior)) {
            behavior = {
              type: behavior
            };
          }
          modeBehaviors.push(behavior);
        }
      });
      return modeBehaviors;
    };
    ModeController2.filterBehaviors = function(modeBehaviors, behaviors2) {
      var result = [];
      modeBehaviors.forEach(function(behavior) {
        var type = "";
        if (is_string_default(behavior)) {
          type = behavior;
        } else {
          type = behavior.type;
        }
        if (behaviors2.indexOf(type) < 0) {
          result.push(behavior);
        }
      });
      return result;
    };
    ModeController2.prototype.setMode = function(mode) {
      var _a2 = this, modes = _a2.modes, graph = _a2.graph;
      var current = mode;
      var behaviors2 = modes[current];
      if (!behaviors2) {
        return;
      }
      graph.emit("beforemodechange", {
        mode
      });
      each_default(this.currentBehaves, function(behave) {
        if (behave.delegate)
          behave.delegate.remove();
        behave.unbind(graph);
      });
      this.setBehaviors(current);
      graph.emit("aftermodechange", {
        mode
      });
      this.mode = mode;
    };
    ModeController2.prototype.getMode = function() {
      return this.mode;
    };
    ModeController2.prototype.manipulateBehaviors = function(behaviors2, modes, isAdd) {
      var _this = this;
      var behaves;
      if (!is_array_default(behaviors2)) {
        behaves = [behaviors2];
      } else {
        behaves = behaviors2;
      }
      if (is_array_default(modes)) {
        each_default(modes, function(mode) {
          if (!_this.modes[mode]) {
            if (isAdd) {
              _this.modes[mode] = behaves;
            }
          } else if (isAdd) {
            _this.modes[mode] = ModeController2.mergeBehaviors(_this.modes[mode] || [], behaves);
          } else {
            _this.modes[mode] = ModeController2.filterBehaviors(_this.modes[mode] || [], behaves);
          }
        });
        return this;
      }
      var currentMode = modes;
      if (!modes) {
        currentMode = this.mode;
      }
      if (!this.modes[currentMode]) {
        if (isAdd) {
          this.modes[currentMode] = behaves;
        }
      }
      if (isAdd) {
        this.modes[currentMode] = ModeController2.mergeBehaviors(this.modes[currentMode] || [], behaves);
      } else {
        this.modes[currentMode] = ModeController2.filterBehaviors(this.modes[currentMode] || [], behaves);
      }
      this.formatModes();
      this.setMode(this.mode);
      return this;
    };
    ModeController2.prototype.updateBehavior = function(behavior, newCfg, mode) {
      if (is_string_default(behavior)) {
        behavior = {
          type: behavior
        };
      }
      var behaviorSet = [];
      if (!mode || mode === this.mode || mode === "default") {
        behaviorSet = this.currentBehaves;
        if (!behaviorSet || !behaviorSet.length) {
          console.warn("Update behavior failed! There is no behaviors in this mode on the graph.");
          return this;
        }
        var length_1 = behaviorSet.length;
        for (var i2 = 0; i2 < length_1; i2++) {
          var behave = behaviorSet[i2];
          if (behave.type === behavior.type) {
            behave.updateCfg(newCfg);
            return this;
          }
          if (i2 === length_1 - 1)
            console.warn("Update behavior failed! There is no such behavior in the mode");
        }
      } else {
        behaviorSet = this.modes[mode];
        if (!behaviorSet || !behaviorSet.length) {
          console.warn("Update behavior failed! There is no behaviors in this mode on the graph.");
          return this;
        }
        var length_2 = behaviorSet.length;
        for (var i2 = 0; i2 < length_2; i2++) {
          var behave = behaviorSet[i2];
          if (behave.type === behavior.type || behave === behavior.type) {
            if (behave === behavior.type)
              behave = {
                type: behave
              };
            Object.assign(behave, newCfg);
            behaviorSet[i2] = behave;
            return this;
          }
          if (i2 === length_2 - 1)
            console.warn("Update behavior failed! There is no such behavior in the mode");
        }
      }
      return this;
    };
    ModeController2.prototype.destroy = function() {
      this.graph = null;
      this.modes = null;
      this.currentBehaves = null;
      this.destroyed = true;
    };
    return ModeController2;
  }()
);
var mode_default = ModeController;

// node_modules/@antv/g6-core/es/graph/controller/view.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/util/base.js
var base_exports = {};
__export(base_exports, {
  calculationItemsBBox: () => calculationItemsBBox,
  cloneEvent: () => cloneEvent,
  formatPadding: () => formatPadding,
  isNaN: () => isNaN2,
  isViewportChanged: () => isViewportChanged,
  processParallelEdges: () => processParallelEdges,
  uniqueId: () => uniqueId3
});
init_esm();

// node_modules/@antv/g6-core/es/interface/behavior.js
init_tslib_es6();
var G6GraphEvent = (
  /** @class */
  function(_super) {
    __extends(G6GraphEvent2, _super);
    function G6GraphEvent2(type, event) {
      var _this = _super.call(this, type, event) || this;
      _this.item = event.item;
      _this.canvasX = event.canvasX;
      _this.canvasY = event.canvasY;
      _this.wheelDelta = event.wheelDelta;
      _this.detail = event.detail;
      return _this;
    }
    return G6GraphEvent2;
  }(graph_event_default)
);

// node_modules/@antv/g6-core/es/util/base.js
var uniqueId3 = function uniqueId4(type) {
  return "".concat(type, "-").concat(Math.random()).concat(Date.now());
};
var formatPadding = function formatPadding2(padding) {
  if (is_array_default(padding)) {
    switch (padding.length) {
      case 4:
        return padding;
      case 3:
        padding.push(padding[1]);
        return padding;
      case 2:
        return padding.concat(padding);
      case 1:
        return [padding[0], padding[0], padding[0], padding[0]];
      default:
        return [0, 0, 0, 0];
    }
  }
  if (is_number_default(padding)) {
    return [padding, padding, padding, padding];
  } else if (is_string_default(padding)) {
    var intPadding = parseInt(padding, 10);
    return [intPadding, intPadding, intPadding, intPadding];
  }
  return [0, 0, 0, 0];
};
var cloneEvent = function cloneEvent2(e8) {
  var event = new G6GraphEvent(e8.type, e8);
  event.clientX = e8.clientX;
  event.clientY = e8.clientY;
  event.x = e8.x;
  event.y = e8.y;
  event.target = e8.target;
  event.currentTarget = e8.currentTarget;
  event.bubbles = true;
  event.item = e8.item;
  return event;
};
var isViewportChanged = function isViewportChanged2(matrix) {
  if (!matrix) {
    return false;
  }
  var MATRIX_LEN = 9;
  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0; i2 < MATRIX_LEN; i2++) {
    if (matrix[i2] !== ORIGIN_MATRIX[i2]) {
      return true;
    }
  }
  return false;
};
var isNaN2 = function isNaN3(input) {
  return Number.isNaN(Number(input));
};
var calculationItemsBBox = function calculationItemsBBox2(items) {
  var minx = Infinity;
  var maxx = -Infinity;
  var miny = Infinity;
  var maxy = -Infinity;
  for (var i2 = 0; i2 < items.length; i2++) {
    var element = items[i2];
    var bbox = element.getBBox();
    var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
    if (minX < minx) {
      minx = minX;
    }
    if (minY < miny) {
      miny = minY;
    }
    if (maxX > maxx) {
      maxx = maxX;
    }
    if (maxY > maxy) {
      maxy = maxY;
    }
  }
  var x4 = Math.floor(minx);
  var y4 = Math.floor(miny);
  var width = Math.ceil(maxx) - Math.floor(minx);
  var height = Math.ceil(maxy) - Math.floor(miny);
  return {
    x: x4,
    y: y4,
    width,
    height,
    minX: minx,
    minY: miny,
    maxX: maxx,
    maxY: maxy
  };
};
var processParallelEdges = function processParallelEdges2(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {
  if (offsetDiff === void 0) {
    offsetDiff = 15;
  }
  if (multiEdgeType === void 0) {
    multiEdgeType = "quadratic";
  }
  if (singleEdgeType === void 0) {
    singleEdgeType = void 0;
  }
  if (loopEdgeType === void 0) {
    loopEdgeType = void 0;
  }
  var len = edges.length;
  var cod = offsetDiff * 2;
  var loopPosition = ["top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left"];
  var edgeMap = {};
  var tags = [];
  var reverses = {};
  for (var i2 = 0; i2 < len; i2++) {
    var edge = edges[i2];
    var source = edge.source, target = edge.target;
    var sourceTarget = "".concat(source, "-").concat(target);
    if (tags[i2])
      continue;
    if (!edgeMap[sourceTarget]) {
      edgeMap[sourceTarget] = [];
    }
    tags[i2] = true;
    edgeMap[sourceTarget].push(edge);
    for (var j2 = 0; j2 < len; j2++) {
      if (i2 === j2)
        continue;
      var sedge = edges[j2];
      var src = sedge.source;
      var dst = sedge.target;
      if (!tags[j2]) {
        if (source === dst && target === src) {
          edgeMap[sourceTarget].push(sedge);
          tags[j2] = true;
          reverses["".concat(src, "|").concat(dst, "|").concat(edgeMap[sourceTarget].length - 1)] = true;
        } else if (source === src && target === dst) {
          edgeMap[sourceTarget].push(sedge);
          tags[j2] = true;
        }
      }
    }
  }
  for (var key in edgeMap) {
    var arcEdges = edgeMap[key];
    var length_1 = arcEdges.length;
    for (var k2 = 0; k2 < length_1; k2++) {
      var current = arcEdges[k2];
      if (current.source === current.target) {
        if (loopEdgeType)
          current.type = loopEdgeType;
        current.loopCfg = {
          position: loopPosition[k2 % 8],
          dist: Math.floor(k2 / 8) * 20 + 50
        };
        continue;
      }
      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {
        current.type = singleEdgeType;
        continue;
      }
      current.type = multiEdgeType;
      var sign = (k2 % 2 === 0 ? 1 : -1) * (reverses["".concat(current.source, "|").concat(current.target, "|").concat(k2)] ? -1 : 1);
      if (length_1 % 2 === 1) {
        current.curveOffset = sign * Math.ceil(k2 / 2) * cod;
      } else {
        current.curveOffset = sign * (Math.floor(k2 / 2) * cod + offsetDiff);
      }
    }
  }
  return edges;
};

// node_modules/@antv/g6-core/es/graph/controller/view.js
var import_ext = __toESM(require_ext());
var ViewController = (
  /** @class */
  function() {
    function ViewController2(graph) {
      this.destroyed = false;
      this.graph = graph;
      this.destroyed = false;
    }
    ViewController2.prototype.getViewCenter = function() {
      var padding = this.getFormatPadding();
      var graph = this.graph;
      var width = this.graph.get("width");
      var height = graph.get("height");
      return {
        x: (width - padding[1] - padding[3]) / 2 + padding[3],
        y: (height - padding[0] - padding[2]) / 2 + padding[0]
      };
    };
    ViewController2.prototype.fitCenter = function(animate, animateCfg) {
      var graph = this.graph;
      var group = graph.get("group");
      var bbox;
      var nodes = graph.getNodes();
      if (nodes.length > graph.get("optimizeThreshold")) {
        var minX_1 = Infinity;
        var minY_1 = Infinity;
        var maxX_1 = -Infinity;
        var maxY_1 = -Infinity;
        nodes.forEach(function(node) {
          var _a3 = node.getModel(), x4 = _a3.x, y4 = _a3.y;
          if (minX_1 > x4)
            minX_1 = x4;
          if (minY_1 > y4)
            minY_1 = y4;
          if (maxX_1 < x4)
            maxX_1 = x4;
          if (maxY_1 < y4)
            maxY_1 = y4;
        });
        var matrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        var _a2 = applyMatrix({
          x: minX_1,
          y: minY_1
        }, matrix), transMinX = _a2.x, transMinY = _a2.y;
        var _b = applyMatrix({
          x: maxX_1,
          y: maxY_1
        }, matrix), transMaxX = _b.x, transMaxY = _b.y;
        bbox = {
          minX: transMinX,
          maxX: transMaxX,
          minY: transMinY,
          maxY: transMaxY,
          width: transMaxX - transMinX,
          height: transMaxY - transMinY,
          x: transMinX,
          y: transMinY
        };
      } else {
        bbox = group.getCanvasBBox();
      }
      if (bbox.width === 0 || bbox.height === 0)
        return;
      var viewCenter = this.getViewCenter();
      var groupCenter = {
        x: bbox.x + bbox.width / 2,
        y: bbox.y + bbox.height / 2
      };
      graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y, animate, animateCfg);
    };
    ViewController2.prototype.animatedFitView = function(group, startMatrix, animateCfg, bbox, viewCenter, groupCenter, ratio, zoomToFit) {
      var graph = this.graph;
      animateCfg = animateCfg ? animateCfg : {
        duration: 500,
        easing: "easeCubic"
      };
      var matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var vx = bbox.x + viewCenter.x - groupCenter.x - bbox.minX;
      var vy = bbox.y + viewCenter.y - groupCenter.y - bbox.minY;
      if (isNaN2(vx) || isNaN2(vy))
        return;
      var translatedMatrix = (0, import_ext.transform)(matrix, [["t", vx, vy]]);
      if (!zoomToFit) {
        var animationConfig_1 = getAnimateCfgWithCallback({
          animateCfg,
          callback: function callback() {
            graph.emit("viewportchange", {
              action: "translate",
              matrix: translatedMatrix
            });
          }
        });
        group.animate(function(ratio2) {
          return {
            matrix: lerpArray(startMatrix, translatedMatrix, ratio2)
          };
        }, animationConfig_1);
        return;
      }
      var minZoom = graph.get("minZoom");
      var maxZoom = graph.get("maxZoom");
      var realRatio = ratio;
      if (minZoom && ratio < minZoom) {
        realRatio = minZoom;
        console.warn("fitview failed, ratio out of range, ratio: %f", ratio, "graph minzoom has been used instead");
      } else if (maxZoom && ratio > maxZoom) {
        realRatio = maxZoom;
        console.warn("fitview failed, ratio out of range, ratio: %f", ratio, "graph maxzoom has been used instead");
      }
      var zoomedMatrix = (0, import_ext.transform)(translatedMatrix, [["t", -viewCenter.x, -viewCenter.y], ["s", realRatio, realRatio], ["t", viewCenter.x, viewCenter.y]]);
      var animationConfig = getAnimateCfgWithCallback({
        animateCfg,
        callback: function callback() {
          group.setMatrix(zoomedMatrix);
          graph.emit("viewportchange", {
            action: "translate",
            matrix: translatedMatrix
          });
          graph.emit("viewportchange", {
            action: "zoom",
            matrix: zoomedMatrix
          });
        }
      });
      group.stopAnimate();
      group.setMatrix(startMatrix);
      group.animate(function(ratio2) {
        return {
          matrix: lerpArray(startMatrix, zoomedMatrix, ratio2)
        };
      }, animationConfig);
    };
    ViewController2.prototype.fitView = function(animate, animateCfg) {
      var graph = this.graph;
      var padding = this.getFormatPadding();
      var width = graph.get("width");
      var height = graph.get("height");
      var group = graph.get("group");
      var startMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      group.resetMatrix();
      var bbox;
      var nodes = graph.getNodes();
      if (nodes.length > graph.get("optimizeThreshold")) {
        var minX_2 = Infinity;
        var minY_2 = Infinity;
        var maxX_2 = -Infinity;
        var maxY_2 = -Infinity;
        nodes.forEach(function(node) {
          var _a2 = node.getModel(), x4 = _a2.x, y4 = _a2.y;
          if (minX_2 > x4)
            minX_2 = x4;
          if (minY_2 > y4)
            minY_2 = y4;
          if (maxX_2 < x4)
            maxX_2 = x4;
          if (maxY_2 < y4)
            maxY_2 = y4;
        });
        bbox = {
          minX: minX_2,
          maxX: maxX_2,
          minY: minY_2,
          maxY: maxY_2,
          width: maxX_2 - minX_2,
          height: maxY_2 - minY_2,
          x: minX_2,
          y: minY_2
        };
      } else {
        bbox = group.getCanvasBBox();
      }
      if (bbox.width === 0 || bbox.height === 0)
        return;
      var viewCenter = this.getViewCenter();
      var groupCenter = {
        x: bbox.x + bbox.width / 2,
        y: bbox.y + bbox.height / 2
      };
      var w2 = (width - padding[1] - padding[3]) / bbox.width;
      var h2 = (height - padding[0] - padding[2]) / bbox.height;
      var ratio = w2;
      if (w2 > h2) {
        ratio = h2;
      }
      if (animate) {
        this.animatedFitView(group, startMatrix, animateCfg, bbox, viewCenter, groupCenter, ratio, true);
      } else {
        var dx = viewCenter.x - groupCenter.x;
        var dy = viewCenter.y - groupCenter.y;
        if (isNaN2(dx) || isNaN2(dy))
          return;
        graph.translate(dx, dy);
        if (!graph.zoom(ratio, viewCenter)) {
          console.warn("zoom failed, ratio out of range, ratio: %f", ratio);
        }
      }
    };
    ViewController2.prototype.fitViewByRules = function(rules, animate, animateCfg) {
      var _a2 = rules.onlyOutOfViewPort, onlyOutOfViewPort = _a2 === void 0 ? false : _a2, _b = rules.direction, direction2 = _b === void 0 ? "both" : _b, _c = rules.ratioRule, ratioRule = _c === void 0 ? "min" : _c;
      var graph = this.graph;
      var padding = this.getFormatPadding();
      var width = graph.get("width");
      var height = graph.get("height");
      var group = graph.get("group");
      var startMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      group.resetMatrix();
      var bbox;
      var nodes = graph.getNodes();
      if (nodes.length > graph.get("optimizeThreshold")) {
        var minX_3 = Infinity;
        var minY_3 = Infinity;
        var maxX_3 = -Infinity;
        var maxY_3 = -Infinity;
        nodes.forEach(function(node) {
          var _a3 = node.getModel(), x4 = _a3.x, y4 = _a3.y;
          if (minX_3 > x4)
            minX_3 = x4;
          if (minY_3 > y4)
            minY_3 = y4;
          if (maxX_3 < x4)
            maxX_3 = x4;
          if (maxY_3 < y4)
            maxY_3 = y4;
        });
        bbox = {
          minX: minX_3,
          maxX: maxX_3,
          minY: minY_3,
          maxY: maxY_3,
          width: maxX_3 - minX_3,
          height: maxY_3 - minY_3,
          x: minX_3,
          y: minY_3
        };
      } else {
        bbox = group.getCanvasBBox();
      }
      if (bbox.width === 0 || bbox.height === 0)
        return;
      var viewCenter = this.getViewCenter();
      var groupCenter = {
        x: bbox.x + bbox.width / 2,
        y: bbox.y + bbox.height / 2
      };
      var wRatio = (width - padding[1] - padding[3]) / bbox.width;
      var hRatio = (height - padding[0] - padding[2]) / bbox.height;
      var ratio;
      if (direction2 === "x") {
        ratio = wRatio;
      } else if (direction2 === "y") {
        ratio = hRatio;
      } else {
        ratio = ratioRule === "max" ? Math.max(wRatio, hRatio) : Math.min(wRatio, hRatio);
      }
      if (onlyOutOfViewPort) {
        ratio = ratio < 1 ? ratio : 1;
      }
      if (animate) {
        this.animatedFitView(group, startMatrix, animateCfg, bbox, viewCenter, groupCenter, ratio, true);
      } else {
        var initZoomRatio = graph.getZoom();
        var endZoom = initZoomRatio * ratio;
        var minZoom = graph.get("minZoom");
        if (endZoom < minZoom) {
          endZoom = minZoom;
          console.warn("fitview failed, ratio out of range, ratio: %f", ratio, "graph minzoom has been used instead");
        }
        graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);
        graph.zoomTo(endZoom, viewCenter);
      }
    };
    ViewController2.prototype.getFormatPadding = function() {
      var padding = this.graph.get("fitViewPadding");
      return formatPadding(padding);
    };
    ViewController2.prototype.focusPoint = function(point, animate, animateCfg) {
      var _this = this;
      var viewCenter = this.getViewCenter();
      var modelCenter = this.getPointByCanvas(viewCenter.x, viewCenter.y);
      var viewportMatrix = this.graph.get("group").getMatrix();
      if (!viewportMatrix)
        viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (animate) {
        var dx_1 = (modelCenter.x - point.x) * viewportMatrix[0];
        var dy_1 = (modelCenter.y - point.y) * viewportMatrix[4];
        var lastX_1 = 0;
        var lastY_1 = 0;
        var newX_1 = 0;
        var newY_1 = 0;
        this.graph.get("canvas").animate(function(ratio) {
          newX_1 = dx_1 * ratio;
          newY_1 = dy_1 * ratio;
          _this.graph.translate(newX_1 - lastX_1, newY_1 - lastY_1);
          lastX_1 = newX_1;
          lastY_1 = newY_1;
        }, __assign({}, animateCfg));
      } else {
        this.graph.translate((modelCenter.x - point.x) * viewportMatrix[0], (modelCenter.y - point.y) * viewportMatrix[4]);
      }
    };
    ViewController2.prototype.getPointByCanvas = function(canvasX, canvasY) {
      var viewportMatrix = this.graph.get("group").getMatrix();
      if (!viewportMatrix) {
        viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      var point = invertMatrix({
        x: canvasX,
        y: canvasY
      }, viewportMatrix);
      return point;
    };
    ViewController2.prototype.getPointByClient = function(clientX, clientY) {
      var canvas = this.graph.get("canvas");
      var canvasPoint = canvas.getPointByClient(clientX, clientY);
      return this.getPointByCanvas(canvasPoint.x, canvasPoint.y);
    };
    ViewController2.prototype.getClientByPoint = function(x4, y4) {
      var canvas = this.graph.get("canvas");
      var canvasPoint = this.getCanvasByPoint(x4, y4);
      var point = canvas.getClientByPoint(canvasPoint.x, canvasPoint.y);
      return {
        x: point.x,
        y: point.y
      };
    };
    ViewController2.prototype.getCanvasByPoint = function(x4, y4) {
      var viewportMatrix = this.graph.get("group").getMatrix();
      if (!viewportMatrix) {
        viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      return applyMatrix({
        x: x4,
        y: y4
      }, viewportMatrix);
    };
    ViewController2.prototype.focus = function(item, animate, animateCfg) {
      if (is_string_default(item)) {
        item = this.graph.findById(item);
      }
      if (item) {
        var x4 = 0, y4 = 0;
        if (item.getType && item.getType() === "edge") {
          var sourceMatrix = item.getSource().get("group").getMatrix();
          var targetMatrix = item.getTarget().get("group").getMatrix();
          if (sourceMatrix && targetMatrix) {
            x4 = (sourceMatrix[6] + targetMatrix[6]) / 2;
            y4 = (sourceMatrix[7] + targetMatrix[7]) / 2;
          } else if (sourceMatrix || targetMatrix) {
            x4 = sourceMatrix ? sourceMatrix[6] : targetMatrix[6];
            y4 = sourceMatrix ? sourceMatrix[7] : targetMatrix[7];
          }
        } else {
          var group = item.get("group");
          var matrix = group.getMatrix();
          if (!matrix)
            matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          x4 = matrix[6];
          y4 = matrix[7];
        }
        this.focusPoint({
          x: x4,
          y: y4
        }, animate, animateCfg);
      }
    };
    ViewController2.prototype.focusItems = function(items, zoomToFit, animate, animateCfg) {
      if (!items.length) {
        return;
      }
      var graph = this.graph;
      var padding = this.getFormatPadding();
      var width = graph.get("width");
      var height = graph.get("height");
      var group = graph.get("group");
      var startMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      group.resetMatrix();
      var bbox = {
        x: 0,
        y: 0,
        minX: Number.MAX_SAFE_INTEGER,
        minY: Number.MAX_SAFE_INTEGER,
        maxX: Number.MIN_SAFE_INTEGER,
        maxY: Number.MIN_SAFE_INTEGER,
        width: 0,
        height: 0
      };
      for (var _i2 = 0, items_1 = items; _i2 < items_1.length; _i2++) {
        var item = items_1[_i2];
        var itemBBox = item.getBBox();
        if (itemBBox.minX < bbox.minX) {
          bbox.minX = itemBBox.minX;
        }
        if (itemBBox.minY < bbox.minY) {
          bbox.minY = itemBBox.minY;
        }
        if (itemBBox.maxX > bbox.maxX) {
          bbox.maxX = itemBBox.maxX;
        }
        if (itemBBox.maxY > bbox.maxY) {
          bbox.maxY = itemBBox.maxY;
        }
      }
      bbox.x = bbox.minX;
      bbox.y = bbox.minY;
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      if (bbox.width === 0 || bbox.height === 0)
        return;
      var viewCenter = this.getViewCenter();
      var groupCenter = {
        x: bbox.x + bbox.width / 2,
        y: bbox.y + bbox.height / 2
      };
      var w2 = (width - padding[1] - padding[3]) / bbox.width;
      var h2 = (height - padding[0] - padding[2]) / bbox.height;
      var ratio = w2;
      if (w2 > h2) {
        ratio = h2;
      }
      if (animate) {
        this.animatedFitView(group, startMatrix, animateCfg, bbox, viewCenter, groupCenter, ratio, zoomToFit);
      } else {
        graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);
        if (zoomToFit && !graph.zoom(ratio, viewCenter)) {
          console.warn("zoom failed, ratio out of range, ratio: %f", ratio);
        }
      }
    };
    ViewController2.prototype.changeSize = function(width, height) {
      var graph = this.graph;
      if (!is_number_default(width) || !is_number_default(height)) {
        throw Error("invalid canvas width & height, please make sure width & height type is number");
      }
      graph.set({
        width,
        height
      });
      var canvas = graph.get("canvas");
      canvas.changeSize(width, height);
      var plugins = graph.get("plugins");
      plugins.forEach(function(plugin) {
        if (plugin.get("gridContainer")) {
          plugin.positionInit();
        }
      });
    };
    ViewController2.prototype.destroy = function() {
      this.graph = null;
      this.destroyed = false;
    };
    return ViewController2;
  }()
);
var view_default = ViewController;

// node_modules/@antv/g6-core/es/graph/controller/item.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/item/edge.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/item/item.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/element/shape.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/element/xml.js
init_tslib_es6();
init_esm();
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function looseJSONParse(text) {
  if (typeof text !== "string") {
    return text;
  }
  var safeParse = function safeParse2(str2) {
    if (typeof str2 !== "string") {
      return str2;
    }
    try {
      return JSON.parse(str2.trim());
    } catch (e8) {
      return str2.trim();
    }
  };
  var firstAttempt = safeParse(text);
  if (typeof firstAttempt !== "string") {
    return firstAttempt;
  }
  var tail = function tail2(arr) {
    return arr[arr.length - 1];
  };
  var str = text.trim();
  var objectStack = [];
  var syntaxStack = [];
  var isLastPair = function isLastPair2() {
    var syntaxes = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      syntaxes[_i2] = arguments[_i2];
    }
    return syntaxes.some(function(syntax) {
      return tail(syntaxStack) === syntax;
    });
  };
  var getValueStore = function getValueStore2() {
    return tail(objectStack);
  };
  var rst = null;
  var i2 = 0;
  var temp = "";
  while (i2 < str.length) {
    var nowChar = str[i2];
    var isInString = isLastPair('"', "'");
    if (!isInString && !nowChar.trim()) {
      i2 += 1;
      continue;
    }
    var isLastTranslate = str[i2 - 1] === "\\";
    var isInObject = isLastPair("}");
    var isInArray = isLastPair("]");
    var isWaitingValue = isLastPair(",");
    var tempArr = getValueStore();
    if (isInString) {
      if (tail(syntaxStack) === nowChar && !isLastTranslate) {
        syntaxStack.pop();
        var value = safeParse(temp);
        tempArr.push(value);
        rst = value;
        temp = "";
      } else {
        temp += nowChar;
      }
    } else if (isInArray && nowChar === ",") {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
    } else if (isInObject && nowChar === ":") {
      syntaxStack.push(",");
      if (temp) {
        tempArr.push(temp);
        temp = "";
      }
    } else if (isWaitingValue && nowChar === ",") {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      syntaxStack.pop();
    } else if (nowChar === "}" && (isInObject || isWaitingValue)) {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      if (isWaitingValue) {
        syntaxStack.pop();
      }
      var obj = {};
      for (var c3 = 1; c3 < tempArr.length; c3 += 2) {
        obj[tempArr[c3 - 1]] = tempArr[c3];
      }
      objectStack.pop();
      if (objectStack.length) {
        tail(objectStack).push(obj);
      }
      syntaxStack.pop();
      rst = obj;
    } else if (nowChar === "]" && isInArray) {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      objectStack.pop();
      if (objectStack.length) {
        tail(objectStack).push(tempArr);
      }
      syntaxStack.pop();
      rst = tempArr;
    } else if (nowChar === "{") {
      objectStack.push([]);
      syntaxStack.push("}");
    } else if (nowChar === "[") {
      objectStack.push([]);
      syntaxStack.push("]");
    } else if (nowChar === '"') {
      syntaxStack.push('"');
    } else if (nowChar === "'") {
      syntaxStack.push("'");
    } else {
      temp += nowChar;
    }
    i2 += 1;
  }
  return rst || temp;
}
var keyConvert = function keyConvert2(str) {
  return str.split("-").reduce(function(a3, b2) {
    return a3 + b2.charAt(0).toUpperCase() + b2.slice(1);
  });
};
var xmlDataRenderer = function xmlDataRenderer2(xml) {
  return function(data) {
    var len = xml.length;
    var arr = [];
    var i2 = 0;
    var tmp = "";
    while (i2 < len) {
      if (xml[i2] === "{" && xml[i2 + 1] === "{") {
        arr.push(tmp);
        tmp = "";
        i2 += 2;
      } else if (xml[i2] === "}" && xml[i2 + 1] === "}") {
        if (arr.length) {
          var last2 = arr.pop();
          tmp = get_default(data, tmp, last2.endsWith("=") ? '"{'.concat(tmp, '}"') : tmp);
          arr.push(last2 + tmp);
        }
        i2 += 2;
        tmp = "";
      } else {
        tmp += xml[i2];
        i2 += 1;
      }
    }
    arr.push(tmp);
    return arr.map(function(e8, index2) {
      return arr[index2 - 1] && arr[index2 - 1].endsWith("=") ? '"{'.concat(e8, '}"') : e8;
    }).join("");
  };
};
function parseXML(xml, cfg) {
  var attrs = {};
  var keys2 = xml.getAttributeNames && xml.getAttributeNames() || [];
  var children = xml.children && Array.from(xml.children).map(function(e8) {
    return parseXML(e8, cfg);
  });
  var rst = {};
  var tagName = xml.tagName ? xml.tagName.toLowerCase() : "group";
  if (tagName === "text") {
    attrs.text = xml.innerText;
  }
  rst.type = tagName;
  if (tagName === "img") {
    rst.type = "image";
  }
  Array.from(keys2).forEach(function(k2) {
    var key = keyConvert(k2);
    var val = xml.getAttribute(k2);
    try {
      if (key === "style" || key === "attrs") {
        var style = looseJSONParse(val);
        attrs = __assign(__assign({}, attrs), style);
      } else {
        rst[key] = looseJSONParse(val);
      }
    } catch (e8) {
      if (key === "style") {
        throw e8;
      }
      rst[key] = val;
    }
  });
  rst.attrs = attrs;
  if (cfg && cfg.style && rst.name && _typeof(cfg.style[rst.name]) === "object") {
    rst.attrs = __assign(__assign({}, rst.attrs), cfg.style[rst.name]);
  }
  if (cfg && cfg.style && rst.keyshape) {
    rst.attrs = __assign(__assign({}, rst.attrs), cfg.style);
  }
  if (children.length) {
    rst.children = children;
  }
  return rst;
}
function getBBox3(node, offset, chilrenBBox) {
  var _a2 = node.attrs, attrs = _a2 === void 0 ? {} : _a2;
  var bbox = {
    x: offset.x || 0,
    y: offset.y || 0,
    width: chilrenBBox.width || 0,
    height: chilrenBBox.height || 0
  };
  var shapeHeight, shapeWidth;
  switch (node.type) {
    case "maker":
    case "circle":
      if (attrs.r) {
        shapeWidth = 2 * attrs.r;
        shapeHeight = 2 * attrs.r;
      }
      break;
    case "text":
      if (attrs.text) {
        shapeWidth = getTextSize(attrs.text, attrs.fontSize || 12)[0];
        shapeHeight = 16;
        bbox.y += shapeHeight;
        bbox.height = shapeHeight;
        bbox.width = shapeWidth;
        node.attrs = __assign({
          fontSize: 12,
          fill: "#000"
        }, attrs);
      }
      break;
    default:
      if (attrs.width) {
        shapeWidth = attrs.width;
      }
      if (attrs.height) {
        shapeHeight = attrs.height;
      }
  }
  if (shapeHeight >= 0) {
    bbox.height = shapeHeight;
  }
  if (shapeWidth >= 0) {
    bbox.width = shapeWidth;
  }
  if (attrs.marginTop) {
    bbox.y += attrs.marginTop;
  }
  if (attrs.marginLeft) {
    bbox.x += attrs.marginLeft;
  }
  return bbox;
}
function generateTarget(target, lastOffset) {
  var _a2;
  if (lastOffset === void 0) {
    lastOffset = {
      x: 0,
      y: 0
    };
  }
  var defaultBbox = __assign({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  }, lastOffset);
  if ((_a2 = target.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
    var _b = target.attrs, attrs = _b === void 0 ? {} : _b;
    var marginTop = attrs.marginTop;
    var offset = __assign({}, lastOffset);
    if (marginTop) {
      offset.y += marginTop;
    }
    for (var index2 = 0; index2 < target.children.length; index2++) {
      target.children[index2].attrs.key = "".concat(attrs.key || "root", " -").concat(index2, " ");
      var node = generateTarget(target.children[index2], offset);
      if (node.bbox) {
        var bbox = node.bbox;
        if (node.attrs.next === "inline") {
          offset.x += node.bbox.width;
        } else {
          offset.y += node.bbox.height;
        }
        if (bbox.width + bbox.x > defaultBbox.width) {
          defaultBbox.width = bbox.width + bbox.x;
        }
        if (bbox.height + bbox.y > defaultBbox.height) {
          defaultBbox.height = bbox.height + bbox.y;
        }
      }
    }
  }
  target.bbox = getBBox3(target, lastOffset, defaultBbox);
  target.attrs = __assign(__assign({}, target.attrs), target.bbox);
  return target;
}
function compareTwoTarget(nowTarget, formerTarget) {
  var _a2, _b, _c, _d;
  var type = (nowTarget || {}).type;
  var key = ((formerTarget === null || formerTarget === void 0 ? void 0 : formerTarget.attrs) || {}).key;
  if (key && nowTarget) {
    nowTarget.attrs.key = key;
  }
  if (!nowTarget && formerTarget) {
    return {
      action: "delete",
      val: formerTarget,
      type,
      key
    };
  }
  if (nowTarget && !formerTarget) {
    return {
      action: "add",
      val: nowTarget,
      type
    };
  }
  if (!nowTarget && !formerTarget) {
    return {
      action: "same",
      type
    };
  }
  var children = [];
  if (((_a2 = nowTarget.children) === null || _a2 === void 0 ? void 0 : _a2.length) > 0 || ((_b = formerTarget.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {
    var length_1 = Math.max((_c = nowTarget.children) === null || _c === void 0 ? void 0 : _c.length, (_d = formerTarget.children) === null || _d === void 0 ? void 0 : _d.length);
    var formerChilren = formerTarget.children || [];
    var nowChilren = nowTarget.children || [];
    for (var index2 = 0; index2 < length_1; index2 += 1) {
      children.push(compareTwoTarget(nowChilren[index2], formerChilren[index2]));
    }
  }
  var formerKeys = Object.keys(formerTarget.attrs);
  var nowKeys = Object.keys(nowTarget.attrs);
  if (formerTarget.type !== nowTarget.type) {
    return {
      action: "restructure",
      nowTarget,
      formerTarget,
      key,
      children
    };
  }
  if (formerKeys.filter(function(e8) {
    return e8 !== "children";
  }).some(function(e8) {
    return nowTarget.attrs[e8] !== formerTarget.attrs[e8] || !nowKeys.includes(e8);
  })) {
    return {
      action: "change",
      val: nowTarget,
      children,
      type,
      key
    };
  }
  return {
    action: "same",
    children,
    type,
    key
  };
}
function createNodeFromXML(gen) {
  var structures = {};
  var compileXML = function compileXML2(cfg) {
    var rawStr = typeof gen === "function" ? gen(cfg) : gen;
    var target = xmlDataRenderer(rawStr)(cfg);
    var xmlParser = document.createElement("div");
    xmlParser.innerHTML = target;
    var xml = xmlParser.children[0];
    var result = generateTarget(parseXML(xml, cfg));
    xmlParser.remove();
    return result;
  };
  return {
    draw: function draw4(cfg, group) {
      var resultTarget = compileXML(cfg);
      var keyshape = group;
      var renderTarget = function renderTarget2(target) {
        var _a2 = target.attrs, attrs = _a2 === void 0 ? {} : _a2, bbox = target.bbox, type = target.type, children = target.children, rest = __rest(target, ["attrs", "bbox", "type", "children"]);
        if (target.type !== "group") {
          var shape = group.addShape(target.type, __assign({
            attrs,
            origin: {
              bbox,
              type,
              children
            }
          }, rest));
          if (target.keyshape) {
            keyshape = shape;
          }
        }
        if (target.children) {
          target.children.forEach(function(n2) {
            return renderTarget2(n2);
          });
        }
      };
      renderTarget(resultTarget);
      structures[cfg.id] = [resultTarget];
      return keyshape;
    },
    update: function update14(cfg, node) {
      if (!structures[cfg.id]) {
        structures[cfg.id] = [];
      }
      var container = node.getContainer();
      var children = container.get("children");
      var newTarget = compileXML(cfg);
      var lastTarget = structures[cfg.id].pop();
      var diffResult = compareTwoTarget(newTarget, lastTarget);
      var addShape = function addShape2(shape) {
        var _a2;
        if (shape.type !== "group") {
          container.addShape(shape.type, {
            attrs: shape.attrs
          });
        }
        if ((_a2 = shape.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
          shape.children.map(function(e8) {
            return addShape2(e8);
          });
        }
      };
      var delShape = function delShape2(shape) {
        var _a2;
        var targetShape = children.find(function(e8) {
          return e8.attrs.key === shape.attrs.key;
        });
        if (targetShape) {
          container.removeChild(targetShape);
        }
        if ((_a2 = shape.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
          shape.children.map(function(e8) {
            return delShape2(e8);
          });
        }
      };
      var updateTarget = function updateTarget2(target) {
        var key = target.key;
        if (target.type !== "group") {
          var targetShape = children.find(function(e8) {
            return e8.attrs.key === key;
          });
          switch (target.action) {
            case "change":
              if (targetShape) {
                var originAttr = target.val.keyshape ? node.getOriginStyle() : {};
                targetShape.attr(__assign(__assign({}, originAttr), target.val.attrs));
              }
              break;
            case "add":
              addShape(target.val);
              break;
            case "delete":
              delShape(target.val);
              break;
            case "restructure":
              delShape(target.formerTarget);
              addShape(target.nowTarget);
              break;
            default:
              break;
          }
        }
        if (target.children) {
          target.children.forEach(function(n2) {
            return updateTarget2(n2);
          });
        }
      };
      updateTarget(diffResult);
      structures[cfg.id].push(newTarget);
    },
    getAnchorPoints: function getAnchorPoints4() {
      return [[0, 0.5], [1, 0.5], [0.5, 1], [0.5, 0]];
    }
  };
}

// node_modules/@antv/g6-core/es/element/shape.js
var cache = {};
function ucfirst(str) {
  if (!cache[str]) {
    cache[str] = upper_first_default(str);
  }
  return cache[str];
}
var ShapeFactoryBase = {
  /**
   * 默认的形状，当没有指定/匹配 shapeType 时，使用默认的
   * @type {String}
   */
  defaultShapeType: "defaultType",
  /**
   * 形状的 className，用于搜索
   * @type {String}
   */
  className: null,
  /**
   * 获取绘制 Shape 的工具类，无状态
   * @param  {String} type 类型
   * @return {Shape} 工具类
   */
  getShape: function getShape(type) {
    var self2 = this;
    var shape = self2[type] || self2[self2.defaultShapeType] || self2["simple-circle"];
    return shape;
  },
  /**
   * 绘制图形
   * @param  {String} type  类型
   * @param  {Object} cfg 配置项
   * @param  {G.Group} group 图形的分组
   * @return {IShape} 图形对象
   */
  draw: function draw(type, cfg, group) {
    var shape = this.getShape(type);
    group["shapeMap"] = {};
    var rst = shape.draw(cfg, group);
    if (shape.afterDraw) {
      shape.afterDraw(cfg, group, rst);
    }
    return rst;
  },
  /**
   * 更新
   * @param  {String} type  类型
   * @param  {Object} cfg 配置项
   * @param  {G6.Item} item 节点、边、分组等
   */
  baseUpdate: function baseUpdate(type, cfg, item, updateType) {
    var _a2, _b;
    var shape = this.getShape(type);
    if (shape.update) {
      shape.mergeStyle = (_a2 = shape.getOptions) === null || _a2 === void 0 ? void 0 : _a2.call(shape, cfg, updateType);
      (_b = shape.update) === null || _b === void 0 ? void 0 : _b.call(shape, cfg, item, updateType);
    }
    if (shape.afterUpdate) {
      shape.afterUpdate(cfg, item);
    }
  },
  /**
   * 设置状态
   * @param {String} type  类型
   * @param {String} name  状态名
   * @param {String | Boolean} value 状态值
   * @param {G6.Item} item  节点、边、分组等
   */
  setState: function setState(type, name, value, item) {
    var shape = this.getShape(type);
    shape.setState(name, value, item);
  },
  /**
   * 是否允许更新，不重新绘制图形
   * @param  {String} type 类型
   * @return {Boolean} 是否允许使用更新
   */
  shouldUpdate: function shouldUpdate2(type) {
    var shape = this.getShape(type);
    return !!shape.update;
  },
  getControlPoints: function getControlPoints(type, cfg) {
    var shape = this.getShape(type);
    return shape.getControlPoints(cfg);
  },
  /**
   * 获取控制点
   * @param {String} type 节点、边类型
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点
   */
  getAnchorPoints: function getAnchorPoints(type, cfg) {
    var shape = this.getShape(type);
    return shape.getAnchorPoints(cfg);
  }
};
var ShapeFramework = {
  // 默认样式及配置
  options: {},
  /**
   * 绘制
   */
  draw: function draw2(cfg, group) {
    return this.drawShape(cfg, group);
  },
  /**
   * 绘制
   */
  drawShape: function drawShape() {
  },
  /**
   * 绘制完成后的操作，便于用户继承现有的节点、边
   */
  afterDraw: function afterDraw() {
  },
  // update(cfg, item) // 默认不定义
  afterUpdate: function afterUpdate() {
  },
  /**
   * 设置节点、边状态
   */
  setState: function setState2() {
  },
  /**
   * 获取控制点
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点
   */
  getControlPoints: function getControlPoints2(cfg) {
    return cfg.controlPoints;
  },
  /**
   * 获取控制点
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点
   */
  getAnchorPoints: function getAnchorPoints2(cfg) {
    var defaultAnchorPoints = this.options.anchorPoints;
    var anchorPoints = cfg.anchorPoints || defaultAnchorPoints;
    return anchorPoints;
  }
  /* 如果没定义 update 方法，每次都调用 draw 方法
  update(cfg, item) {
     }
  */
};
var Shape = (
  /** @class */
  function() {
    function Shape2() {
    }
    Shape2.registerFactory = function(factoryType, cfg) {
      var className = ucfirst(factoryType);
      var factoryBase = ShapeFactoryBase;
      var shapeFactory = __assign(__assign({}, factoryBase), cfg);
      Shape2[className] = shapeFactory;
      shapeFactory.className = className;
      return shapeFactory;
    };
    Shape2.getFactory = function(factoryType) {
      var className = ucfirst(factoryType);
      return Shape2[className];
    };
    Shape2.registerNode = function(shapeType, nodeDefinition, extendShapeType) {
      var shapeFactory = Shape2.Node;
      var shapeObj;
      if (typeof nodeDefinition === "string" || typeof nodeDefinition === "function") {
        var autoNodeDefinition = createNodeFromXML(nodeDefinition);
        shapeObj = __assign(__assign({}, shapeFactory.getShape("single-node")), autoNodeDefinition);
      } else if (nodeDefinition.jsx) {
        var jsx = nodeDefinition.jsx;
        var autoNodeDefinition = createNodeFromXML(jsx);
        shapeObj = __assign(__assign(__assign({}, shapeFactory.getShape("single-node")), autoNodeDefinition), nodeDefinition);
      } else {
        shapeFactory.getShape(extendShapeType);
        var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
        shapeObj = __assign(__assign({}, extendShape), nodeDefinition);
      }
      shapeObj.type = shapeType;
      shapeObj.itemType = "node";
      shapeFactory[shapeType] = shapeObj;
      return shapeObj;
    };
    Shape2.registerEdge = function(shapeType, edgeDefinition, extendShapeType) {
      var shapeFactory = Shape2.Edge;
      var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
      var shapeObj = __assign(__assign({}, extendShape), edgeDefinition);
      shapeObj.type = shapeType;
      shapeObj.itemType = "edge";
      shapeFactory[shapeType] = shapeObj;
      return shapeObj;
    };
    Shape2.registerCombo = function(shapeType, comboDefinition, extendShapeType) {
      var shapeFactory = Shape2.Combo;
      var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
      var shapeObj = __assign(__assign({}, extendShape), comboDefinition);
      shapeObj.type = shapeType;
      shapeObj.itemType = "combo";
      shapeFactory[shapeType] = shapeObj;
      return shapeObj;
    };
    return Shape2;
  }()
);
var shape_default = Shape;
Shape.registerFactory("node", {
  defaultShapeType: "circle"
});
Shape.registerFactory("edge", {
  defaultShapeType: "line"
});
Shape.registerFactory("combo", {
  defaultShapeType: "circle"
});

// node_modules/@antv/g6-core/es/item/item.js
var CACHE_BBOX = "bboxCache";
var CACHE_CANVAS_BBOX = "bboxCanvasCache";
var ItemBase = (
  /** @class */
  function() {
    function ItemBase2(cfg) {
      this._cfg = {};
      this.destroyed = false;
      this.optimize = false;
      var defaultCfg2 = {
        /**
         * id
         * @type {string}
         */
        id: void 0,
        /**
         * 类型
         * @type {string}
         */
        type: "item",
        /**
         * data model
         * @type {object}
         */
        model: {},
        /**
         * g group
         * @type {G.Group}
         */
        group: void 0,
        /**
         * is open animate
         * @type {boolean}
         */
        animate: false,
        /**
         * visible - not group visible
         * @type {boolean}
         */
        visible: true,
        /**
         * locked - lock node
         * @type {boolean}
         */
        locked: false,
        /**
         * capture event
         * @type {boolean}
         */
        event: true,
        /**
         * key shape to calculate item's bbox
         * @type object
         */
        keyShape: void 0,
        /**
         * item's states, such as selected or active
         * @type Array
         */
        states: []
      };
      this._cfg = Object.assign(defaultCfg2, this.getDefaultCfg(), cfg);
      var model = this.get("model");
      var id = model.id;
      var itemType = this.get("type");
      if (typeof id === "undefined") {
        id = uniqueId3(itemType);
      } else if (typeof id !== "string") {
        id = String(id);
      }
      this.get("model").id = id;
      this.set("id", id);
      var group = cfg.group;
      if (group) {
        group.set("item", this);
        group.set("id", id);
      }
      this.init();
      this.draw();
      var shapeType = model.shape || model.type || (itemType === "edge" ? "line" : "circle");
      var shapeFactory = this.get("shapeFactory");
      if (shapeFactory && shapeFactory[shapeType]) {
        var options = shapeFactory[shapeType].options;
        if (options && options.stateStyles) {
          var styles = this.get("styles") || model.stateStyles;
          styles = deep_mix_default({}, options.stateStyles, styles);
          this.set("styles", styles);
        }
      }
    }
    ItemBase2.prototype.calculateBBox = function() {
      var keyShape = this.get("keyShape");
      var group = this.get("group");
      var bbox = getBBox(keyShape, group);
      bbox.x = bbox.minX;
      bbox.y = bbox.minY;
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      bbox.centerX = (bbox.minX + bbox.maxX) / 2;
      bbox.centerY = (bbox.minY + bbox.maxY) / 2;
      return bbox;
    };
    ItemBase2.prototype.calculateCanvasBBox = function() {
      var keyShape = this.get("keyShape");
      var group = this.get("group");
      var bbox = getBBox(keyShape, group);
      bbox.x = bbox.minX;
      bbox.y = bbox.minY;
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      bbox.centerX = (bbox.minX + bbox.maxX) / 2;
      bbox.centerY = (bbox.minY + bbox.maxY) / 2;
      return bbox;
    };
    ItemBase2.prototype.drawInner = function() {
      var self2 = this;
      var shapeFactory = self2.get("shapeFactory");
      var group = self2.get("group");
      var model = self2.get("model");
      group.clear();
      var visible = model.visible;
      if (visible !== void 0 && !visible)
        self2.changeVisibility(visible);
      if (!shapeFactory) {
        return;
      }
      self2.updatePosition(model);
      var cfg = self2.getShapeCfg(model);
      var shapeType = cfg.type;
      var keyShape = shapeFactory.draw(shapeType, cfg, group);
      if (keyShape) {
        self2.set("keyShape", keyShape);
        keyShape.set("isKeyShape", true);
        keyShape.set("draggable", true);
      }
      this.setOriginStyle();
      this.set("currentShape", shapeType);
      this.restoreStates(shapeFactory, shapeType);
    };
    ItemBase2.prototype.setOriginStyle = function() {
      var group = this.get("group");
      var children = group.get("children");
      var keyShape = this.getKeyShape();
      var self2 = this;
      var keyShapeName = keyShape.get("name");
      if (!this.get("originStyle")) {
        var originStyles = {};
        for (var i2 = 0; i2 < children.length; i2++) {
          var child = children[i2];
          var shapeType = child.get("type");
          var name_1 = child.get("name");
          if (name_1 && name_1 !== keyShapeName) {
            originStyles[name_1] = shapeType !== "image" ? clone_default(child.attr()) : self2.getShapeStyleByName(name_1);
            if (shapeType === "text" && originStyles[name_1]) {
              delete originStyles[name_1].x;
              delete originStyles[name_1].y;
              delete originStyles[name_1].matrix;
            }
          } else {
            var keyShapeStyle = self2.getShapeStyleByName();
            delete keyShapeStyle.path;
            delete keyShapeStyle.matrix;
            if (!keyShapeName) {
              Object.assign(originStyles, keyShapeStyle);
            } else {
              if (!name_1) {
                var shapeName = uniqueId3("shape");
                child.set("name", shapeName);
                group["shapeMap"][shapeName] = child;
                originStyles[shapeName] = shapeType !== "image" ? clone_default(child.attr()) : self2.getShapeStyleByName(name_1);
              } else {
                originStyles[keyShapeName] = keyShapeStyle;
              }
            }
          }
        }
        self2.set("originStyle", originStyles);
      } else {
        var styles_1 = this.get("originStyle");
        if (keyShapeName && !styles_1[keyShapeName])
          styles_1[keyShapeName] = {};
        var currentStatesStyle_1 = this.getCurrentStatesStyle();
        var _loop_1 = function _loop_12(i3) {
          var child2 = children[i3];
          var name_2 = child2.get("name");
          var shapeAttrs = child2.attr();
          if (name_2 && name_2 !== keyShapeName) {
            var shapeStateStyle_1 = currentStatesStyle_1[name_2];
            if (!styles_1[name_2])
              styles_1[name_2] = {};
            if (shapeStateStyle_1) {
              Object.keys(shapeAttrs).forEach(function(key) {
                var value = shapeAttrs[key];
                if (value !== shapeStateStyle_1[key])
                  styles_1[name_2][key] = value;
              });
            } else {
              styles_1[name_2] = child2.get("type") !== "image" ? clone_default(shapeAttrs) : self2.getShapeStyleByName(name_2);
            }
          } else {
            var shapeAttrs_1 = child2.attr();
            var keyShapeStateStyles_1 = {};
            Object.keys(currentStatesStyle_1).forEach(function(styleKey) {
              var subStyle = currentStatesStyle_1[styleKey];
              if (styleKey === keyShapeName || !is_plain_object_default(subStyle)) {
                keyShapeStateStyles_1[styleKey] = subStyle;
              }
            });
            Object.keys(shapeAttrs_1).forEach(function(key) {
              var value = shapeAttrs_1[key];
              if (keyShapeStateStyles_1[key] !== value) {
                if (keyShapeName)
                  styles_1[keyShapeName][key] = value;
                else
                  styles_1[key] = value;
              }
            });
          }
        };
        for (var i2 = 0; i2 < children.length; i2++) {
          _loop_1(i2);
        }
        delete styles_1.path;
        delete styles_1.matrix;
        delete styles_1.x;
        delete styles_1.y;
        if (styles_1[keyShapeName]) {
          delete styles_1[keyShapeName].x;
          delete styles_1[keyShapeName].y;
          delete styles_1[keyShapeName].matrix;
          delete styles_1[keyShapeName].path;
        }
        self2.set("originStyle", styles_1);
      }
    };
    ItemBase2.prototype.restoreStates = function(shapeFactory, shapeType) {
      var self2 = this;
      var states = self2.get("states");
      each_default(states, function(state) {
        shapeFactory.setState(shapeType, state, true, self2);
      });
    };
    ItemBase2.prototype.init = function() {
      var shapeFactory = shape_default.getFactory(this.get("type"));
      this.set("shapeFactory", shapeFactory);
    };
    ItemBase2.prototype.get = function(key) {
      return this._cfg[key];
    };
    ItemBase2.prototype.set = function(key, val) {
      if (is_plain_object_default(key)) {
        this._cfg = __assign(__assign({}, this._cfg), key);
      } else {
        this._cfg[key] = val;
      }
    };
    ItemBase2.prototype.getDefaultCfg = function() {
      return {};
    };
    ItemBase2.prototype.clearCache = function() {
      this.set(CACHE_BBOX, null);
      this.set(CACHE_CANVAS_BBOX, null);
    };
    ItemBase2.prototype.beforeDraw = function() {
    };
    ItemBase2.prototype.afterDraw = function() {
    };
    ItemBase2.prototype.afterUpdate = function() {
    };
    ItemBase2.prototype.draw = function() {
      this.beforeDraw();
      this.drawInner();
      this.afterDraw();
    };
    ItemBase2.prototype.getShapeStyleByName = function(name) {
      var group = this.get("group");
      var currentShape;
      if (name) {
        currentShape = group["shapeMap"][name];
      } else {
        currentShape = this.getKeyShape();
      }
      if (currentShape) {
        var styles_2 = {};
        each_default(currentShape.attr(), function(val, key) {
          if (key !== "img" || is_string_default(val)) {
            styles_2[key] = val;
          }
        });
        return styles_2;
      }
      return {};
    };
    ItemBase2.prototype.getShapeCfg = function(model, updateType) {
      var styles = this.get("styles");
      if (styles) {
        var newModel = model;
        newModel.style = __assign(__assign({}, styles), model.style);
        return newModel;
      }
      return model;
    };
    ItemBase2.prototype.getStateStyle = function(state) {
      var styles = this.get("styles");
      var stateStyle = styles && styles[state];
      return stateStyle;
    };
    ItemBase2.prototype.getOriginStyle = function() {
      return this.get("originStyle");
    };
    ItemBase2.prototype.getCurrentStatesStyle = function() {
      var self2 = this;
      var styles = {};
      var states = self2.getStates();
      if (!states || !states.length) {
        return this.get("originStyle");
      }
      each_default(self2.getStates(), function(state) {
        styles = Object.assign(styles, self2.getStateStyle(state));
      });
      return styles;
    };
    ItemBase2.prototype.setState = function(state, value) {
      var states = this.get("states");
      var shapeFactory = this.get("shapeFactory");
      var stateName = state;
      var filterStateName = state;
      if (is_string_default(value)) {
        stateName = "".concat(state, ":").concat(value);
        filterStateName = "".concat(state, ":");
      }
      var newStates = states;
      if (is_boolean_default(value)) {
        var index2 = states.indexOf(filterStateName);
        if (value) {
          if (index2 > -1) {
            return;
          }
          states.push(stateName);
        } else if (index2 > -1) {
          states.splice(index2, 1);
        }
      } else if (is_string_default(value)) {
        var filterStates = states.filter(function(name) {
          return name.includes(filterStateName);
        });
        if (filterStates.length > 0) {
          this.clearStates(filterStates);
        }
        newStates = newStates.filter(function(name) {
          return !name.includes(filterStateName);
        });
        newStates.push(stateName);
        this.set("states", newStates);
      }
      if (shapeFactory) {
        var model = this.get("model");
        var type = model.type;
        shapeFactory.setState(type, state, value, this);
      }
    };
    ItemBase2.prototype.clearStates = function(states) {
      var self2 = this;
      var originStates = self2.getStates();
      var shapeFactory = self2.get("shapeFactory");
      var model = self2.get("model");
      var shape = model.type;
      if (!states) {
        states = originStates;
      }
      if (is_string_default(states)) {
        states = [states];
      }
      var newStates = originStates.filter(function(state) {
        return states.indexOf(state) === -1;
      });
      self2.set("states", newStates);
      states.forEach(function(state) {
        shapeFactory.setState(shape, state, false, self2);
      });
    };
    ItemBase2.prototype.setOptimize = function(enableOptimize) {
      this.optimize = enableOptimize;
    };
    ItemBase2.prototype.getContainer = function() {
      return this.get("group");
    };
    ItemBase2.prototype.getKeyShape = function() {
      return this.get("keyShape");
    };
    ItemBase2.prototype.getModel = function() {
      return this.get("model");
    };
    ItemBase2.prototype.getType = function() {
      return this.get("type");
    };
    ItemBase2.prototype.getID = function() {
      return this.get("id");
    };
    ItemBase2.prototype.isItem = function() {
      return true;
    };
    ItemBase2.prototype.getStates = function() {
      return this.get("states");
    };
    ItemBase2.prototype.hasState = function(state) {
      var states = this.getStates();
      return states.indexOf(state) >= 0;
    };
    ItemBase2.prototype.refresh = function(updateType) {
      var model = this.get("model");
      this.updatePosition(model);
      this.updateShape(updateType);
      this.afterUpdate();
      this.clearCache();
    };
    ItemBase2.prototype.getUpdateType = function(cfg) {
      return void 0;
    };
    ItemBase2.prototype.update = function(cfg, updateType) {
      if (updateType === void 0) {
        updateType = void 0;
      }
      var model = this.get("model");
      if (updateType === "move") {
        this.updatePosition(cfg);
      } else {
        var oriVisible = model.visible;
        var cfgVisible = cfg.visible;
        if (oriVisible !== cfgVisible && cfgVisible !== void 0)
          this.changeVisibility(cfgVisible);
        var originPosition = {
          x: model.x,
          y: model.y
        };
        cfg.x = isNaN(+cfg.x) ? model.x : +cfg.x;
        cfg.y = isNaN(+cfg.y) ? model.y : +cfg.y;
        var styles = this.get("styles");
        if (cfg.stateStyles) {
          var stateStyles = cfg.stateStyles;
          mix(styles, stateStyles);
          delete cfg.stateStyles;
        }
        Object.assign(model, cfg);
        if (originPosition.x !== cfg.x || originPosition.y !== cfg.y) {
          this.updatePosition(cfg);
        }
        this.updateShape(updateType);
      }
      this.afterUpdate();
      this.clearCache();
    };
    ItemBase2.prototype.updateShape = function(updateType) {
      var shapeFactory = this.get("shapeFactory");
      var model = this.get("model");
      var shape = model.type;
      if (shapeFactory.shouldUpdate(shape) && shape === this.get("currentShape")) {
        var updateCfg2 = this.getShapeCfg(model, updateType);
        shapeFactory.baseUpdate(shape, updateCfg2, this, updateType);
        if (updateType !== "move")
          this.setOriginStyle();
      } else {
        this.draw();
      }
      this.restoreStates(shapeFactory, shape);
    };
    ItemBase2.prototype.updatePosition = function(cfg) {
      var model = this.get("model");
      var x4 = isNaN(+cfg.x) ? +model.x : +cfg.x;
      var y4 = isNaN(+cfg.y) ? +model.y : +cfg.y;
      var group = this.get("group");
      if (isNaN(x4) || isNaN(y4)) {
        return false;
      }
      model.x = x4;
      model.y = y4;
      var matrix = group.getMatrix();
      if (matrix && matrix[6] === x4 && matrix[7] === y4)
        return false;
      group.resetMatrix();
      translate(group, {
        x: x4,
        y: y4
      });
      this.clearCache();
      return true;
    };
    ItemBase2.prototype.getBBox = function() {
      var bbox = this.get(CACHE_BBOX);
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set(CACHE_BBOX, bbox);
      }
      return bbox;
    };
    ItemBase2.prototype.getCanvasBBox = function() {
      var bbox = this.get(CACHE_CANVAS_BBOX);
      if (!bbox) {
        bbox = this.calculateCanvasBBox();
        this.set(CACHE_CANVAS_BBOX, bbox);
      }
      return bbox;
    };
    ItemBase2.prototype.toFront = function() {
      var group = this.get("group");
      group.toFront();
    };
    ItemBase2.prototype.toBack = function() {
      var group = this.get("group");
      group.toBack();
    };
    ItemBase2.prototype.show = function() {
      this.changeVisibility(true);
    };
    ItemBase2.prototype.hide = function() {
      this.changeVisibility(false);
    };
    ItemBase2.prototype.changeVisibility = function(visible) {
      var group = this.get("group");
      if (visible) {
        group.show();
      } else {
        group.hide();
      }
      this.set("visible", visible);
    };
    ItemBase2.prototype.isVisible = function() {
      return this.get("visible");
    };
    ItemBase2.prototype.enableCapture = function(enable) {
      var group = this.get("group");
      if (group) {
        group.set("capture", enable);
      }
    };
    ItemBase2.prototype.destroy = function() {
      if (!this.destroyed) {
        var animate = this.get("animate");
        var group = this.get("group");
        if (animate) {
          group.stopAnimate();
        }
        group["shapeMap"] = {};
        this.clearCache();
        group.remove();
        this._cfg = null;
        this.destroyed = true;
      }
    };
    return ItemBase2;
  }()
);
var item_default = ItemBase;

// node_modules/@antv/g6-core/es/item/edge.js
var END_MAP = {
  source: "start",
  target: "end"
};
var ITEM_NAME_SUFFIX = "Node";
var POINT_NAME_SUFFIX = "Point";
var ANCHOR_NAME_SUFFIX = "Anchor";
var Edge2 = (
  /** @class */
  function(_super) {
    __extends(Edge3, _super);
    function Edge3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Edge3.prototype.getDefaultCfg = function() {
      return {
        type: "edge",
        sourceNode: null,
        targetNode: null,
        startPoint: null,
        endPoint: null,
        linkCenter: false
      };
    };
    Edge3.prototype.setEnd = function(name, value) {
      var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
      var itemName = name + ITEM_NAME_SUFFIX;
      var preItem = this.get(itemName);
      if (preItem && !preItem.destroyed) {
        preItem.removeEdge(this);
      }
      if (is_plain_object_default(value)) {
        this.set(pointName, value);
        this.set(itemName, null);
      } else if (value) {
        value.addEdge(this);
        this.set(itemName, value);
        this.set(pointName, null);
      }
    };
    Edge3.prototype.getLinkPoint = function(name, model, controlPoints) {
      var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
      var itemName = name + ITEM_NAME_SUFFIX;
      var point = this.get(pointName);
      if (!point) {
        var item = this.get(itemName);
        var anchorName = name + ANCHOR_NAME_SUFFIX;
        var prePoint = this.getPrePoint(name, controlPoints);
        var anchorIndex = model[anchorName];
        if (!is_nil_default(anchorIndex)) {
          point = item.getLinkPointByAnchor(anchorIndex);
        }
        point = point || item.getLinkPoint(prePoint);
        if (!is_nil_default(point.index)) {
          this.set("".concat(name, "AnchorIndex"), point.index);
        }
      }
      return point;
    };
    Edge3.prototype.getPrePoint = function(name, controlPoints) {
      if (controlPoints && controlPoints.length) {
        var index2 = name === "source" ? 0 : controlPoints.length - 1;
        return controlPoints[index2];
      }
      var oppositeName = name === "source" ? "target" : "source";
      return this.getEndPoint(oppositeName);
    };
    Edge3.prototype.getEndPoint = function(name) {
      var itemName = name + ITEM_NAME_SUFFIX;
      var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
      var item = this.get(itemName);
      if (item && !item.destroyed) {
        return item.get("model");
      }
      return this.get(pointName);
    };
    Edge3.prototype.getControlPointsByCenter = function(model) {
      var sourcePoint = this.getEndPoint("source");
      var targetPoint = this.getEndPoint("target");
      var shapeFactory = this.get("shapeFactory");
      var type = model.type;
      return shapeFactory.getControlPoints(type, {
        startPoint: sourcePoint,
        endPoint: targetPoint
      });
    };
    Edge3.prototype.getEndCenter = function(name) {
      var itemName = name + ITEM_NAME_SUFFIX;
      var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
      var item = this.get(itemName);
      if (item) {
        var bbox = item.getBBox();
        return {
          x: bbox.centerX,
          y: bbox.centerY
        };
      }
      return this.get(pointName);
    };
    Edge3.prototype.init = function() {
      _super.prototype.init.call(this);
      this.setSource(this.get("source"));
      this.setTarget(this.get("target"));
    };
    Edge3.prototype.getShapeCfg = function(model, updateType) {
      var self2 = this;
      var linkCenter = self2.get("linkCenter");
      var cfg = (updateType === null || updateType === void 0 ? void 0 : updateType.includes("move")) ? model : _super.prototype.getShapeCfg.call(this, model);
      if (linkCenter) {
        cfg.startPoint = self2.getEndCenter("source");
        cfg.endPoint = self2.getEndCenter("target");
      } else {
        var controlPoints = cfg.controlPoints || self2.getControlPointsByCenter(cfg);
        cfg.startPoint = self2.getLinkPoint("source", model, controlPoints);
        cfg.endPoint = self2.getLinkPoint("target", model, controlPoints);
      }
      cfg.sourceNode = self2.get("sourceNode");
      cfg.targetNode = self2.get("targetNode");
      return cfg;
    };
    Edge3.prototype.getModel = function() {
      var out = this.get("model");
      var sourceItem = this.get("source".concat(ITEM_NAME_SUFFIX));
      var targetItem = this.get("target".concat(ITEM_NAME_SUFFIX));
      if (sourceItem) {
        delete out["source".concat(ITEM_NAME_SUFFIX)];
      } else {
        out.source = this.get("start".concat(POINT_NAME_SUFFIX));
      }
      if (targetItem) {
        delete out["target".concat(ITEM_NAME_SUFFIX)];
      } else {
        out.target = this.get("end".concat(POINT_NAME_SUFFIX));
      }
      if (!is_string_default(out.source) && !is_plain_object_default(out.source)) {
        out.source = out.source.getID();
      }
      if (!is_string_default(out.target) && !is_plain_object_default(out.target)) {
        out.target = out.target.getID();
      }
      return out;
    };
    Edge3.prototype.setSource = function(source) {
      this.setEnd("source", source);
      this.set("source", source);
    };
    Edge3.prototype.setTarget = function(target) {
      this.setEnd("target", target);
      this.set("target", target);
    };
    Edge3.prototype.getSource = function() {
      return this.get("source");
    };
    Edge3.prototype.getTarget = function() {
      return this.get("target");
    };
    Edge3.prototype.updatePosition = function() {
      return false;
    };
    Edge3.prototype.update = function(cfg, updateType) {
      if (updateType === void 0) {
        updateType = void 0;
      }
      var model = this.get("model");
      var oriVisible = model.visible;
      var cfgVisible = cfg.visible;
      if (oriVisible !== cfgVisible && cfgVisible !== void 0)
        this.changeVisibility(cfgVisible);
      var sourceItem = this.get("source");
      var targetItem = this.get("target");
      if (!sourceItem || sourceItem.destroyed || !targetItem || targetItem.destroyed)
        return;
      var styles = this.get("styles");
      if (cfg.stateStyles) {
        var stateStyles = cfg.stateStyles;
        mix(styles, stateStyles);
        delete cfg.stateStyles;
      }
      Object.assign(model, cfg);
      this.updateShape(updateType);
      this.afterUpdate();
      this.clearCache();
    };
    Edge3.prototype.destroy = function() {
      var sourceItem = this.get("source".concat(ITEM_NAME_SUFFIX));
      var targetItem = this.get("target".concat(ITEM_NAME_SUFFIX));
      if (sourceItem && !sourceItem.destroyed) {
        sourceItem.removeEdge(this);
      }
      if (targetItem && !targetItem.destroyed) {
        targetItem.removeEdge(this);
      }
      _super.prototype.destroy.call(this);
    };
    return Edge3;
  }(item_default)
);
var edge_default = Edge2;

// node_modules/@antv/g6-core/es/item/node.js
init_tslib_es6();
init_esm();
var CACHE_ANCHOR_POINTS = "anchorPointsCache";
var CACHE_BBOX2 = "bboxCache";
var Node2 = (
  /** @class */
  function(_super) {
    __extends(Node3, _super);
    function Node3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Node3.prototype.getNearestPoint = function(points, curPoint) {
      var index2 = 0;
      var nearestPoint = points[0];
      var minDistance = distance(points[0], curPoint);
      for (var i2 = 0; i2 < points.length; i2++) {
        var point = points[i2];
        var dis = distance(point, curPoint);
        if (dis < minDistance) {
          nearestPoint = point;
          minDistance = dis;
          index2 = i2;
        }
      }
      nearestPoint.anchorIndex = index2;
      return nearestPoint;
    };
    Node3.prototype.getDefaultCfg = function() {
      return {
        type: "node",
        edges: []
      };
    };
    Node3.prototype.getEdges = function() {
      return this.get("edges");
    };
    Node3.prototype.getInEdges = function() {
      var self2 = this;
      return this.get("edges").filter(function(edge) {
        return edge.get("target") === self2;
      });
    };
    Node3.prototype.getOutEdges = function() {
      var self2 = this;
      return this.get("edges").filter(function(edge) {
        return edge.get("source") === self2;
      });
    };
    Node3.prototype.getNeighbors = function(type) {
      var _this = this;
      var edges = this.get("edges");
      if (type === "target") {
        var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
          return edge.getSource() === _this;
        };
        return edges.filter(neighhborsConverter_1).map(function(edge) {
          return edge.getTarget();
        });
      }
      if (type === "source") {
        var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
          return edge.getTarget() === _this;
        };
        return edges.filter(neighhborsConverter_2).map(function(edge) {
          return edge.getSource();
        });
      }
      var neighhborsConverter = function neighhborsConverter2(edge) {
        return edge.getSource() === _this ? edge.getTarget() : edge.getSource();
      };
      return edges.map(neighhborsConverter);
    };
    Node3.prototype.getLinkPointByAnchor = function(index2) {
      var anchorPoints = this.getAnchorPoints();
      return anchorPoints[index2];
    };
    Node3.prototype.getLinkPoint = function(point) {
      var keyShape = this.get("keyShape");
      var type = keyShape.get("type");
      var itemType = this.get("type");
      var centerX;
      var centerY;
      var bbox = this.getBBox();
      if (itemType === "combo") {
        centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;
        centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;
      } else {
        centerX = bbox.centerX;
        centerY = bbox.centerY;
      }
      var anchorPoints = this.getAnchorPoints();
      var intersectPoint;
      switch (type) {
        case "circle":
          intersectPoint = getCircleIntersectByPoint({
            x: centerX,
            y: centerY,
            r: bbox.width / 2
          }, point);
          break;
        case "ellipse":
          intersectPoint = getEllipseIntersectByPoint({
            x: centerX,
            y: centerY,
            rx: bbox.width / 2,
            ry: bbox.height / 2
          }, point);
          break;
        default:
          intersectPoint = getRectIntersectByPoint(bbox, point);
      }
      var linkPoint = intersectPoint;
      if (anchorPoints.length) {
        if (!linkPoint) {
          linkPoint = point;
        }
        linkPoint = this.getNearestPoint(anchorPoints, linkPoint);
      }
      if (!linkPoint) {
        linkPoint = {
          x: centerX,
          y: centerY
        };
      }
      return linkPoint;
    };
    Node3.prototype.getAnchorPoints = function() {
      var anchorPoints = this.get(CACHE_ANCHOR_POINTS);
      if (!anchorPoints) {
        anchorPoints = [];
        var shapeFactory = this.get("shapeFactory");
        var bbox_1 = this.getBBox();
        var model = this.get("model");
        var shapeCfg = this.getShapeCfg(model);
        var type = model.type;
        var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];
        each_default(points, function(pointArr, index2) {
          var point = {
            x: bbox_1.minX + pointArr[0] * bbox_1.width,
            y: bbox_1.minY + pointArr[1] * bbox_1.height,
            anchorIndex: index2
          };
          anchorPoints.push(point);
        });
        this.set(CACHE_ANCHOR_POINTS, anchorPoints);
      }
      return anchorPoints;
    };
    Node3.prototype.addEdge = function(edge) {
      this.get("edges").push(edge);
    };
    Node3.prototype.lock = function() {
      this.set("locked", true);
    };
    Node3.prototype.unlock = function() {
      this.set("locked", false);
    };
    Node3.prototype.hasLocked = function() {
      return this.get("locked");
    };
    Node3.prototype.removeEdge = function(edge) {
      var edges = this.getEdges();
      var index2 = edges.indexOf(edge);
      if (index2 > -1)
        edges.splice(index2, 1);
    };
    Node3.prototype.clearCache = function() {
      this.set(CACHE_BBOX2, null);
      this.set(CACHE_ANCHOR_POINTS, null);
    };
    Node3.prototype.getUpdateType = function(cfg) {
      var _a2, _b, _c, _d, _e2;
      if (!cfg)
        return void 0;
      var existX = !is_nil_default(cfg.x);
      var existY = !is_nil_default(cfg.y);
      var keys2 = Object.keys(cfg);
      if (keys2.length === 1 && (existX || existY) || keys2.length === 2 && existX && existY)
        return "move";
      if (is_number_default(cfg.x) || is_number_default(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size || (cfg === null || cfg === void 0 ? void 0 : cfg.style) && (((_a2 = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _a2 === void 0 ? void 0 : _a2.r) || ((_b = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _b === void 0 ? void 0 : _b.width) || ((_c = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _d === void 0 ? void 0 : _d.rx) || ((_e2 = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _e2 === void 0 ? void 0 : _e2.ry)))
        return "bbox|label";
      var updateLabel2 = keys2.includes("label") || keys2.includes("labelCfg");
      return updateLabel2 ? "style|label" : "style";
    };
    Node3.prototype.setState = function(state, value) {
      var _this = this;
      if (this.optimize) {
        _super.prototype.setState.call(this, state, value);
        return;
      }
      this.runWithBBoxAffected(function() {
        return _super.prototype.setState.call(_this, state, value);
      });
    };
    Node3.prototype.clearStates = function(states) {
      var _this = this;
      if (this.optimize) {
        _super.prototype.clearStates.call(this, states);
        return;
      }
      this.runWithBBoxAffected(function() {
        return _super.prototype.clearStates.call(_this, states);
      });
    };
    Node3.prototype.runWithBBoxAffected = function(fn2) {
      var bboxAffectedStyleKeys = ["r", "width", "height", "rx", "ry", "lineWidth"];
      var beforeAttrs = this.getKeyShape().attr();
      var bboxAffectedStyleBefore = {};
      Object.keys(this.getKeyShape().attr()).forEach(function(key2) {
        if (bboxAffectedStyleKeys.includes(key2))
          bboxAffectedStyleBefore[key2] = beforeAttrs[key2];
      });
      fn2();
      var afterAttrs = this.getKeyShape().attr();
      for (var i2 = 0; i2 < bboxAffectedStyleKeys.length; i2++) {
        var key = bboxAffectedStyleKeys[i2];
        if (afterAttrs[key] !== bboxAffectedStyleBefore[key]) {
          this.clearCache();
          this.getEdges().forEach(function(edge) {
            return edge.refresh();
          });
          break;
        }
      }
    };
    return Node3;
  }(item_default)
);
var node_default = Node2;

// node_modules/@antv/g6-core/es/item/combo.js
init_tslib_es6();
init_esm();
var CACHE_BBOX3 = "bboxCache";
var CACHE_CANVAS_BBOX2 = "bboxCanvasCache";
var CACHE_SIZE = "sizeCache";
var CACHE_ANCHOR_POINTS2 = "anchorPointsCache";
var Combo = (
  /** @class */
  function(_super) {
    __extends(Combo2, _super);
    function Combo2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Combo2.prototype.getDefaultCfg = function() {
      return {
        type: "combo",
        nodes: [],
        edges: [],
        combos: []
      };
    };
    Combo2.prototype.getShapeCfg = function(model) {
      var styles = this.get("styles");
      var bbox = this.get("bbox");
      if (styles && bbox) {
        var newModel = model;
        var modelSize = is_number_default(model.size) ? [model.size, model.size] : model.size;
        var modelFixSize = is_number_default(model.fixSize) ? [model.fixSize, model.fixSize] : model.fixSize;
        var useModelSize = modelSize || modelFixSize || global_default.defaultCombo.size;
        var size3 = {
          r: (Math.max(bbox.width, bbox.height) || Math.max(useModelSize[0], useModelSize[1])) / 2,
          width: bbox.width || useModelSize[0],
          height: bbox.height || useModelSize[1]
        };
        newModel.style = __assign(__assign(__assign({}, styles), model.style), size3);
        var padding = model.padding || global_default.defaultCombo.padding;
        if (is_number_default(padding)) {
          size3.r += padding;
          size3.width += padding * 2;
          size3.height += padding * 2;
        } else {
          size3.r = size3.r + Math.max.apply(Math, padding);
          size3.width += padding[1] + padding[3] || padding[1] * 2;
          size3.height += padding[0] + padding[2] || padding[0] * 2;
        }
        this.set(CACHE_SIZE, size3);
        return newModel;
      }
      return model;
    };
    Combo2.prototype.calculateCanvasBBox = function() {
      if (this.destroyed)
        return;
      var keyShape = this.get("keyShape");
      var group = this.get("group");
      var bbox = getBBox(keyShape, group);
      bbox.centerX = (bbox.minX + bbox.maxX) / 2;
      bbox.centerY = (bbox.minY + bbox.maxY) / 2;
      var cacheBBox = this.get(CACHE_BBOX3) || {};
      var oriX = cacheBBox.x;
      var oriY = cacheBBox.x;
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      bbox.centerX = (bbox.minX + bbox.maxX) / 2;
      bbox.centerY = (bbox.minY + bbox.maxY) / 2;
      bbox.x = bbox.minX;
      bbox.y = bbox.minY;
      if (bbox.x !== oriX || bbox.y !== oriY)
        this.set(CACHE_ANCHOR_POINTS2, null);
      return bbox;
    };
    Combo2.prototype.getChildren = function() {
      var self2 = this;
      return {
        nodes: self2.getNodes(),
        combos: self2.getCombos()
      };
    };
    Combo2.prototype.getNodes = function() {
      var self2 = this;
      return self2.get("nodes");
    };
    Combo2.prototype.getCombos = function() {
      var self2 = this;
      return self2.get("combos");
    };
    Combo2.prototype.addChild = function(item) {
      var self2 = this;
      var itemType = item.getType();
      switch (itemType) {
        case "node":
          self2.addNode(item);
          break;
        case "combo":
          self2.addCombo(item);
          break;
        default:
          console.warn("Only node or combo items are allowed to be added into a combo");
          return false;
      }
      return true;
    };
    Combo2.prototype.addCombo = function(combo) {
      var self2 = this;
      self2.get("combos").push(combo);
      return true;
    };
    Combo2.prototype.addNode = function(node) {
      var self2 = this;
      self2.get("nodes").push(node);
      return true;
    };
    Combo2.prototype.removeChild = function(item) {
      var self2 = this;
      var itemType = item.getType();
      switch (itemType) {
        case "node":
          self2.removeNode(item);
          break;
        case "combo":
          self2.removeCombo(item);
          break;
        default:
          console.warn("Only node or combo items are allowed to be added into a combo");
          return false;
      }
      return true;
    };
    Combo2.prototype.removeCombo = function(combo) {
      if (!combo)
        return;
      var combos = this.getCombos();
      var index2 = combos.indexOf(combo);
      if (index2 > -1) {
        combos.splice(index2, 1);
        return true;
      }
      return false;
    };
    Combo2.prototype.removeNode = function(node) {
      if (!node)
        return;
      var nodes = this.getNodes();
      var index2 = nodes.indexOf(node);
      if (index2 > -1) {
        nodes.splice(index2, 1);
        return true;
      }
      return false;
    };
    Combo2.prototype.getUpdateType = function(cfg) {
      return void 0;
    };
    Combo2.prototype.getBBox = function() {
      this.set(CACHE_CANVAS_BBOX2, null);
      var bbox = this.calculateCanvasBBox();
      return bbox;
    };
    Combo2.prototype.clearCache = function() {
      this.set(CACHE_BBOX3, null);
      this.set(CACHE_CANVAS_BBOX2, null);
      this.set(CACHE_ANCHOR_POINTS2, null);
    };
    Combo2.prototype.destroy = function() {
      if (!this.destroyed) {
        var animate = this.get("animate");
        var group = this.get("group");
        if (animate) {
          group.stopAnimate();
        }
        group["shapeMap"] = {};
        this.clearCache();
        this.set(CACHE_SIZE, null);
        this.set("bbox", null);
        group.remove();
        this._cfg = null;
        this.destroyed = true;
      }
    };
    return Combo2;
  }(node_default)
);
var combo_default = Combo;

// node_modules/@antv/g6-core/es/graph/controller/item.js
var NODE = "node";
var EDGE = "edge";
var VEDGE = "vedge";
var COMBO = "combo";
var CFG_PREFIX = "default";
var MAPPER_SUFFIX = "Mapper";
var STATE_SUFFIX = "stateStyles";
var ItemController = (
  /** @class */
  function() {
    function ItemController2(graph) {
      var _this = this;
      this.edgeToBeUpdateMap = {};
      this.throttleRefresh = throttle_default(function(_2) {
        var graph2 = _this.graph;
        if (!graph2 || graph2.get("destroyed"))
          return;
        var edgeToBeUpdateMap = _this.edgeToBeUpdateMap;
        if (!edgeToBeUpdateMap)
          return;
        var edgeValues = Object.values(edgeToBeUpdateMap);
        if (!edgeValues.length)
          return;
        edgeValues.forEach(function(obj) {
          var edge = obj.edge;
          if (!edge || edge.destroyed)
            return;
          var source = edge.getSource();
          var target = edge.getTarget();
          if (!source || source.destroyed || !target || target.destroyed)
            return;
          edge.refresh(obj.updateType);
        });
        _this.edgeToBeUpdateMap = {};
      }, 16, {
        trailing: true,
        leading: true
      });
      this.graph = graph;
      this.destroyed = false;
    }
    ItemController2.prototype.addItem = function(type, model) {
      var graph = this.graph;
      var vType = type === VEDGE ? EDGE : type;
      var parent = graph.get("".concat(vType, "Group")) || graph.get("group");
      var upperType = upper_first_default(vType);
      var item = null;
      var styles = graph.get(vType + upper_first_default(STATE_SUFFIX)) || {};
      var defaultModel = graph.get(CFG_PREFIX + upperType);
      if (model[STATE_SUFFIX]) {
        styles = model[STATE_SUFFIX];
      }
      if (defaultModel) {
        each_default(defaultModel, function(val, cfg) {
          if (is_object_default(val) && !is_array_default(val)) {
            model[cfg] = deep_mix_default({}, val, model[cfg]);
          } else if (is_array_default(val)) {
            model[cfg] = model[cfg] || clone_default(defaultModel[cfg]);
          } else {
            model[cfg] = model[cfg] || defaultModel[cfg];
          }
        });
      }
      var mapper = graph.get(vType + MAPPER_SUFFIX);
      if (mapper) {
        var mappedModel_1 = mapper(model);
        if (mappedModel_1[STATE_SUFFIX]) {
          styles = mappedModel_1[STATE_SUFFIX];
          delete mappedModel_1[STATE_SUFFIX];
        }
        each_default(mappedModel_1, function(val, cfg) {
          if (is_object_default(val) && !is_array_default(val)) {
            model[cfg] = deep_mix_default({}, model[cfg], val);
          } else {
            model[cfg] = mappedModel_1[cfg] || model[cfg];
          }
        });
      }
      graph.emit("beforeadditem", {
        type,
        model
      });
      if (type === EDGE || type === VEDGE) {
        var source = void 0;
        var target = void 0;
        source = model.source;
        target = model.target;
        if (source && is_string_default(source)) {
          source = graph.findById(source);
        }
        if (target && is_string_default(target)) {
          target = graph.findById(target);
        }
        if (!source || !target) {
          console.warn("The source or target node of edge ".concat(model.id, " does not exist!"));
          return;
        }
        if (source.getType && source.getType() === "combo") {
          model.isComboEdge = true;
        }
        if (target.getType && target.getType() === "combo") {
          model.isComboEdge = true;
        }
        item = new edge_default({
          model,
          source,
          target,
          styles,
          linkCenter: graph.get("linkCenter"),
          group: parent.addGroup()
        });
      } else if (type === NODE) {
        item = new node_default({
          model,
          styles,
          group: parent.addGroup()
        });
      } else if (type === COMBO) {
        var children = model.children;
        var comboBBox = getComboBBox(children, graph);
        var bboxX = void 0, bboxY = void 0;
        if (!isNaN(comboBBox.x))
          bboxX = comboBBox.x;
        else if (isNaN(model.x))
          bboxX = Math.random() * 100;
        if (!isNaN(comboBBox.y))
          bboxY = comboBBox.y;
        else if (isNaN(model.y))
          bboxY = Math.random() * 100;
        if (isNaN(model.x) || isNaN(model.y)) {
          model.x = bboxX;
          model.y = bboxY;
        } else {
          var dx = model.x - bboxX;
          var dy = model.y - bboxY;
          this.updateComboSucceeds(model.id, dx, dy, children);
        }
        var comboGroup = parent.addGroup();
        comboGroup.setZIndex(model.depth);
        item = new combo_default({
          model,
          styles,
          animate: graph.get("animate"),
          bbox: model.collapsed ? getComboBBox([], graph) : comboBBox,
          group: comboGroup
        });
        if (!model.collapsed && item.getKeyShape().get("type") === "circle") {
          comboBBox.width = Math.hypot(comboBBox.height, comboBBox.width);
          comboBBox.height = comboBBox.width;
          item.set("bbox", comboBBox);
          item.refresh();
        }
        var comboModel_1 = item.getModel();
        (children || []).forEach(function(child) {
          var childItem = graph.findById(child.id);
          item.addChild(childItem);
          child.depth = comboModel_1.depth + 2;
        });
      }
      if (item) {
        item.setOptimize(graph.getNodes().length > graph.get("optimizeThreshold"));
        graph.get("".concat(type, "s")).push(item);
        graph.get("itemMap")[item.get("id")] = item;
        graph.emit("afteradditem", {
          item,
          model
        });
        return item;
      }
    };
    ItemController2.prototype.updateItem = function(item, cfg) {
      var _this = this;
      var _a2, _b;
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      if (!item || item.destroyed) {
        return;
      }
      var type = "";
      if (item.getType)
        type = item.getType();
      var mapper = graph.get(type + MAPPER_SUFFIX);
      var model = item.getModel();
      var oriX = model.x, oriY = model.y;
      var updateType = item.getUpdateType(cfg);
      if (mapper) {
        var result = deep_mix_default({}, model, cfg);
        var mappedModel = mapper(result);
        var newModel = deep_mix_default({}, model, mappedModel, cfg);
        if (mappedModel[STATE_SUFFIX]) {
          item.set("styles", newModel[STATE_SUFFIX]);
          delete newModel[STATE_SUFFIX];
        }
        each_default(newModel, function(val, key) {
          cfg[key] = val;
        });
      } else {
        each_default(cfg, function(val, key) {
          if (model[key]) {
            if (is_object_default(val) && !is_array_default(val)) {
              cfg[key] = __assign(__assign({}, model[key]), cfg[key]);
            }
          }
        });
      }
      graph.emit("beforeupdateitem", {
        item,
        cfg
      });
      if (type === EDGE) {
        if (cfg.source) {
          var source = cfg.source;
          if (is_string_default(source)) {
            source = graph.findById(source);
          }
          item.setSource(source);
        }
        if (cfg.target) {
          var target = cfg.target;
          if (is_string_default(target)) {
            target = graph.findById(target);
          }
          item.setTarget(target);
        }
        item.update(cfg);
      } else if (type === NODE) {
        item.update(cfg, updateType);
        var edges = item.getEdges();
        if (updateType === "move") {
          each_default(edges, function(edge) {
            _this.edgeToBeUpdateMap[edge.getID()] = {
              edge,
              updateType
            };
            _this.throttleRefresh();
          });
        } else if (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox")) {
          each_default(edges, function(edge) {
            edge.refresh(updateType);
          });
        }
      } else if (type === COMBO) {
        item.update(cfg, updateType);
        if (!isNaN(cfg.x) || !isNaN(cfg.y)) {
          var dx = cfg.x - oriX || 0;
          var dy = cfg.y - oriY || 0;
          this.updateComboSucceeds(model.id, dx, dy);
        }
        var edges_1 = item.getEdges();
        var refreshEdge = (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox")) || updateType === "move";
        if (refreshEdge && type === COMBO) {
          var shapeFactory = item.get("shapeFactory");
          var shapeType = model.type || "circle";
          var comboAnimate = model.animate === void 0 || cfg.animate === void 0 ? (_b = (_a2 = shapeFactory[shapeType]) === null || _a2 === void 0 ? void 0 : _a2.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate || cfg.animate;
          if (comboAnimate) {
            setTimeout(function() {
              if (!item || item.destroyed)
                return;
              var keyShape = item.getKeyShape();
              if (!keyShape || keyShape.destroyed)
                return;
              each_default(edges_1, function(edge) {
                if (edge && !edge.destroyed)
                  edge.refresh();
              });
            }, 201);
          } else {
            each_default(edges_1, function(edge) {
              edge.refresh();
            });
          }
        }
      }
      item.setOptimize(graph.getNodes().length > graph.get("optimizeThreshold"));
      graph.emit("afterupdateitem", {
        item,
        cfg
      });
    };
    ItemController2.prototype.updateCombo = function(combo, children, followCombo) {
      var _this = this;
      var _a2, _b;
      var graph = this.graph;
      if (is_string_default(combo)) {
        combo = graph.findById(combo);
      }
      if (!combo || combo.destroyed) {
        return;
      }
      var model = combo.getModel();
      var comboBBox = getComboBBox(children, graph, combo);
      var comboX = comboBBox.x, comboY = comboBBox.y;
      combo.set("bbox", comboBBox);
      var x4 = comboX, y4 = comboY;
      if (followCombo) {
        x4 = isNaN(model.x) ? comboX : model.x;
        y4 = isNaN(model.y) ? comboY : model.y;
      } else {
        x4 = isNaN(comboX) ? model.x : comboX;
        y4 = isNaN(comboY) ? model.y : comboY;
      }
      combo.update({
        x: x4,
        y: y4
      });
      var shapeFactory = combo.get("shapeFactory");
      var shapeType = model.type || "circle";
      var comboAnimate = model.animate === void 0 ? (_b = (_a2 = shapeFactory[shapeType]) === null || _a2 === void 0 ? void 0 : _a2.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate;
      if (comboAnimate) {
        setTimeout(function() {
          if (!combo || combo.destroyed)
            return;
          var keyShape = combo.getKeyShape();
          if (!keyShape || keyShape.destroyed)
            return;
          combo.getShapeCfg(model);
          _this.updateComboEdges(combo);
        }, 201);
      } else {
        this.updateComboEdges(combo);
      }
    };
    ItemController2.prototype.updateComboEdges = function(combo) {
      var _a2, _b;
      var combEdges = combo.getEdges() || [];
      for (var i2 = 0; i2 < combEdges.length; i2++) {
        var edge = combEdges[i2];
        if (!(edge === null || edge === void 0 ? void 0 : edge.destroyed) && !((_a2 = edge === null || edge === void 0 ? void 0 : edge.getSource()) === null || _a2 === void 0 ? void 0 : _a2.destroyed) && !((_b = edge === null || edge === void 0 ? void 0 : edge.getTarget()) === null || _b === void 0 ? void 0 : _b.destroyed)) {
          edge.refresh();
        }
      }
    };
    ItemController2.prototype.collapseCombo = function(combo, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var graph = this.graph;
      if (is_string_default(combo)) {
        combo = graph.findById(combo);
      }
      var children = combo.getChildren();
      children.nodes.forEach(function(node) {
        graph.hideItem(node, stack);
      });
      children.combos.forEach(function(c3) {
        graph.hideItem(c3, stack);
      });
    };
    ItemController2.prototype.updateComboSucceeds = function(comboId, dx, dy, children) {
      var _this = this;
      if (children === void 0) {
        children = [];
      }
      var graph = this.graph;
      if (!dx && !dy)
        return;
      var kids = children;
      if (!(kids === null || kids === void 0 ? void 0 : kids.length)) {
        var comboTrees = graph.get("comboTrees");
        comboTrees === null || comboTrees === void 0 ? void 0 : comboTrees.forEach(function(child) {
          traverseTree(child, function(subTree) {
            if (subTree.id === comboId) {
              kids = subTree.children;
              return false;
            }
            return true;
          });
        });
      }
      kids === null || kids === void 0 ? void 0 : kids.forEach(function(child) {
        var childItem = graph.findById(child.id);
        if (childItem) {
          var childModel = childItem.getModel();
          _this.updateItem(child.id, {
            x: (childModel.x || 0) + dx,
            y: (childModel.y || 0) + dy
          });
        }
      });
    };
    ItemController2.prototype.expandCombo = function(combo, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var graph = this.graph;
      if (is_string_default(combo)) {
        combo = graph.findById(combo);
      }
      var children = combo.getChildren();
      var edgeSet = /* @__PURE__ */ new Set();
      children.nodes.forEach(function(node) {
        graph.showItem(node, stack);
        node.getEdges().forEach(function(edge) {
          return edgeSet.add(edge);
        });
      });
      children.combos.forEach(function(c3) {
        if (c3.getModel().collapsed) {
          c3.show();
        } else {
          graph.showItem(c3, stack);
        }
        c3.getEdges().forEach(function(edge) {
          return edgeSet.add(edge);
        });
      });
      edgeSet.forEach(function(edge) {
        return edge.refresh();
      });
    };
    ItemController2.prototype.removeItem = function(item) {
      var _this = this;
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      if (!item || item.destroyed) {
        return;
      }
      var itemModel = clone_default(item.getModel());
      var type = "";
      if (item.getType)
        type = item.getType();
      graph.emit("beforeremoveitem", {
        item: itemModel,
        type
      });
      var items = graph.get("".concat(type, "s"));
      var index2 = items.indexOf(item);
      if (index2 > -1)
        items.splice(index2, 1);
      if (type === EDGE) {
        var vitems = graph.get("v".concat(type, "s"));
        var vindex = vitems.indexOf(item);
        if (vindex > -1)
          vitems.splice(vindex, 1);
      }
      var itemId = item.get("id");
      var itemMap = graph.get("itemMap");
      delete itemMap[itemId];
      var comboTrees = graph.get("comboTrees");
      var id = item.get("id");
      if (type === NODE) {
        var comboId = item.getModel().comboId;
        if (comboTrees && comboId) {
          var brothers_1 = comboTrees;
          var found_1 = false;
          comboTrees.forEach(function(ctree) {
            if (found_1)
              return;
            traverseTree(ctree, function(combo) {
              if (combo.id === id && brothers_1) {
                var bidx = brothers_1.indexOf(combo);
                brothers_1.splice(bidx, 1);
                found_1 = true;
                return false;
              }
              brothers_1 = combo.children;
              return true;
            });
          });
        }
        var edges = item.getEdges();
        for (var i2 = edges.length - 1; i2 >= 0; i2--) {
          graph.removeItem(edges[i2], false);
        }
        if (comboId)
          graph.updateCombo(comboId);
      } else if (type === COMBO) {
        var parentId = item.getModel().parentId;
        var comboInTree_1;
        var found_2 = false;
        (comboTrees || []).forEach(function(ctree) {
          if (found_2)
            return;
          traverseTree(ctree, function(combo) {
            if (combo.id === id) {
              comboInTree_1 = combo;
              found_2 = true;
              return false;
            }
            return true;
          });
        });
        comboInTree_1.removed = true;
        if (comboInTree_1 && comboInTree_1.children) {
          comboInTree_1.children.forEach(function(child) {
            _this.removeItem(child.id);
          });
        }
        var edges = item.getEdges();
        for (var i2 = edges.length; i2 >= 0; i2--) {
          graph.removeItem(edges[i2], false);
        }
        if (parentId)
          graph.updateCombo(parentId);
      }
      item.destroy();
      graph.emit("afterremoveitem", {
        item: itemModel,
        type
      });
    };
    ItemController2.prototype.setItemState = function(item, state, value) {
      var graph = this.graph;
      var stateName = state;
      if (is_string_default(value)) {
        stateName = "".concat(state, ":").concat(value);
      }
      if (item.hasState(stateName) === value && value || // 当该状态已经存在且现在需要设置为 true 时，不需要继续。当该状态不存在，且设置为 false 时，需要继续
      is_string_default(value) && item.hasState(stateName)) {
        return;
      }
      graph.emit("beforeitemstatechange", {
        item,
        state: stateName,
        enabled: value
      });
      item.setState(state, value);
      graph.autoPaint();
      graph.emit("afteritemstatechange", {
        item,
        state: stateName,
        enabled: value
      });
    };
    ItemController2.prototype.priorityState = function(item, state) {
      var graph = this.graph;
      var currentItem = item;
      if (is_string_default(item)) {
        currentItem = graph.findById(item);
      }
      this.setItemState(currentItem, state, false);
      this.setItemState(currentItem, state, true);
    };
    ItemController2.prototype.clearItemStates = function(item, states) {
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      graph.emit("beforeitemstatesclear", {
        item,
        states
      });
      item.clearStates(states);
      graph.emit("afteritemstatesclear", {
        item,
        states
      });
    };
    ItemController2.prototype.refreshItem = function(item) {
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      graph.emit("beforeitemrefresh", {
        item
      });
      item.refresh();
      graph.emit("afteritemrefresh", {
        item
      });
    };
    ItemController2.prototype.addCombos = function(comboTrees, comboModels) {
      var _this = this;
      var graph = this.graph;
      (comboTrees || []).forEach(function(ctree) {
        traverseTreeUp(ctree, function(child) {
          var comboModel;
          comboModels.forEach(function(model) {
            if (model.id === child.id) {
              model.children = child.children;
              model.depth = child.depth;
              comboModel = model;
            }
          });
          if (comboModel) {
            _this.addItem("combo", comboModel);
          }
          return true;
        });
      });
      var comboGroup = graph.get("comboGroup");
      if (comboGroup)
        comboGroup.sort();
    };
    ItemController2.prototype.changeItemVisibility = function(item, visible) {
      var _this = this;
      var graph = this.graph;
      if (is_string_default(item)) {
        item = graph.findById(item);
      }
      if (!item) {
        console.warn("The item to be shown or hidden does not exist!");
        return;
      }
      graph.emit("beforeitemvisibilitychange", {
        item,
        visible
      });
      item.changeVisibility(visible);
      if (item.getType && item.getType() === NODE) {
        var edges = item.getEdges();
        each_default(edges, function(edge) {
          if (visible && !(edge.get("source").isVisible() && edge.get("target").isVisible())) {
            return;
          }
          _this.changeItemVisibility(edge, visible);
        });
      } else if (item.getType && item.getType() === COMBO) {
        var comboTrees = graph.get("comboTrees");
        var id_1 = item.get("id");
        var children_1 = [];
        var found_3 = false;
        (comboTrees || []).forEach(function(ctree) {
          if (found_3)
            return;
          if (!ctree.children || ctree.children.length === 0)
            return;
          traverseTree(ctree, function(combo) {
            if (combo.id === id_1) {
              children_1 = combo.children;
              found_3 = true;
              return false;
            }
            return true;
          });
        });
        if (children_1 && (!visible || visible && !item.getModel().collapsed)) {
          children_1.forEach(function(child) {
            var childItem = graph.findById(child.id);
            _this.changeItemVisibility(childItem, visible);
          });
        }
        var edges = item.getEdges();
        each_default(edges, function(edge) {
          if (visible && !(edge.get("source").isVisible() && edge.get("target").isVisible())) {
            return;
          }
          _this.changeItemVisibility(edge, visible);
        });
      }
      graph.emit("afteritemvisibilitychange", {
        item,
        visible
      });
      return item;
    };
    ItemController2.prototype.destroy = function() {
      this.graph = null;
      this.destroyed = true;
    };
    return ItemController2;
  }()
);
var item_default2 = ItemController;

// node_modules/@antv/g6-core/es/graph/controller/state.js
init_esm();
var StateController = (
  /** @class */
  function() {
    function StateController2(graph) {
      this.graph = graph;
      this.destroyed = false;
    }
    StateController2.prototype.updateState = function(item, state, enabled) {
      var graphStates = this.graph.get("states");
      var key = state;
      if (is_string_default(enabled))
        key = "".concat(state, ":").concat(enabled);
      if (!graphStates[key])
        graphStates[key] = [];
      if (enabled)
        graphStates[key].push(item);
      else
        graphStates[key] = graphStates[key].filter(function(itemInState) {
          return itemInState !== item;
        });
      this.graph.set("states", graphStates);
      this.graph.emit("graphstatechange", {
        states: graphStates
      });
    };
    StateController2.prototype.updateStates = function(item, states, enabled) {
      var graphStates = this.graph.get("states");
      var stateNames = is_string_default(states) ? [states] : states;
      stateNames.forEach(function(stateName) {
        var key = stateName;
        if (!graphStates[key])
          graphStates[key] = [];
        if (is_string_default(enabled))
          key = "".concat(stateName, ":").concat(enabled);
        if (enabled)
          graphStates[key].push(item);
        else
          graphStates[key] = graphStates[key].filter(function(itemInState) {
            return itemInState !== item;
          });
      });
      this.graph.set("states", graphStates);
      this.graph.emit("graphstatechange", {
        states
      });
    };
    StateController2.prototype.destroy = function() {
      this.graph = null;
      this.destroyed = true;
    };
    return StateController2;
  }()
);
var state_default = StateController;

// node_modules/@antv/g6-core/es/item/hull.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/util/path.js
var path_exports = {};
__export(path_exports, {
  getClosedSpline: () => getClosedSpline,
  getControlPoint: () => getControlPoint,
  getSpline: () => getSpline,
  getStarPath: () => getStarPath,
  paddedHull: () => paddedHull,
  pathToPoints: () => pathToPoints,
  pointsToPolygon: () => pointsToPolygon,
  roundedHull: () => roundedHull
});
var substitute = function substitute2(str, o2) {
  if (!str || !o2) {
    return str;
  }
  return str.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    var res = o2[name];
    if (res === 0)
      res = "0";
    return res || "";
  });
};
var getSpline = function getSpline2(points) {
  var data = [];
  if (points.length < 2) {
    throw new Error("point length must largn than 2, now it's ".concat(points.length));
  }
  for (var _i2 = 0, points_1 = points; _i2 < points_1.length; _i2++) {
    var point = points_1[_i2];
    var x4 = point.x, y4 = point.y;
    data.push(x4);
    data.push(y4);
  }
  var spliePath = catmull_rom_2_bezier_default(data);
  spliePath.unshift(["M", points[0].x, points[0].y]);
  return spliePath;
};
var getControlPoint = function getControlPoint2(startPoint, endPoint, percent, offset) {
  if (percent === void 0) {
    percent = 0;
  }
  if (offset === void 0) {
    offset = 0;
  }
  var point = {
    x: (1 - percent) * startPoint.x + percent * endPoint.x,
    y: (1 - percent) * startPoint.y + percent * endPoint.y
  };
  var tangent = [0, 0];
  vec2_exports.normalize(tangent, [endPoint.x - startPoint.x, endPoint.y - startPoint.y]);
  if (!tangent || !tangent[0] && !tangent[1]) {
    tangent = [0, 0];
  }
  var perpendicular = [-tangent[1] * offset, tangent[0] * offset];
  point.x += perpendicular[0];
  point.y += perpendicular[1];
  return point;
};
var pointsToPolygon = function pointsToPolygon2(points, z2) {
  var length = points.length;
  if (!length) {
    return "";
  }
  var path = "";
  var str = "";
  for (var i2 = 0; i2 < length; i2++) {
    var item = points[i2];
    if (i2 === 0) {
      str = "M{x} {y}";
    } else {
      str = "L{x} {y}";
    }
    path += substitute(str, item);
  }
  if (z2) {
    path += "Z";
  }
  return path;
};
var pathToPoints = function pathToPoints2(path) {
  var points = [];
  path.forEach(function(seg) {
    var command = seg[0];
    if (command !== "A") {
      for (var i2 = 1; i2 < seg.length; i2 = i2 + 2) {
        points.push([seg[i2], seg[i2 + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points;
};
var getClosedSpline = function getClosedSpline2(points) {
  if (points.length < 2) {
    throw new Error("point length must largn than 2, now it's ".concat(points.length));
  }
  var first = points[0];
  var second = points[1];
  var last2 = points[points.length - 1];
  var lastSecond = points[points.length - 2];
  points.unshift(last2);
  points.unshift(lastSecond);
  points.push(first);
  points.push(second);
  var closedPath = [];
  for (var i2 = 1; i2 < points.length - 2; i2 += 1) {
    var x0 = points[i2 - 1].x;
    var y0 = points[i2 - 1].y;
    var x1 = points[i2].x;
    var y1 = points[i2].y;
    var x22 = points[i2 + 1].x;
    var y22 = points[i2 + 1].y;
    var x32 = i2 !== points.length - 2 ? points[i2 + 2].x : x22;
    var y32 = i2 !== points.length - 2 ? points[i2 + 2].y : y22;
    var cp1x = x1 + (x22 - x0) / 6;
    var cp1y = y1 + (y22 - y0) / 6;
    var cp2x = x22 - (x32 - x1) / 6;
    var cp2y = y22 - (y32 - y1) / 6;
    closedPath.push(["C", cp1x, cp1y, cp2x, cp2y, x22, y22]);
  }
  closedPath.unshift(["M", last2.x, last2.y]);
  return closedPath;
};
var vecScaleTo = function vecScaleTo2(v2, length) {
  return vec2_exports.scale([0, 0], vec2_exports.normalize([0, 0], v2), length);
};
var unitNormal = function unitNormal2(p0, p1) {
  var n2 = [p0[1] - p1[1], p1[0] - p0[0]];
  var nLength = Math.sqrt(n2[0] * n2[0] + n2[1] * n2[1]);
  if (nLength === 0) {
    throw new Error("p0 should not be equal to p1");
  }
  return [n2[0] / nLength, n2[1] / nLength];
};
var vecFrom = function vecFrom2(p0, p1) {
  return [p1[0] - p0[0], p1[1] - p0[1]];
};
function roundedHull(polyPoints, padding) {
  var roundedHull1 = function roundedHull12(points) {
    var p12 = [points[0][0], points[0][1] - padding];
    var p2 = [points[0][0], points[0][1] + padding];
    return "M ".concat(p12, " A ").concat(padding, ",").concat(padding, ",0,0,0,").concat(p2, " A ").concat(padding, ",").concat(padding, ",0,0,0,").concat(p12);
  };
  var roundedHull2 = function roundedHull22(points) {
    var offsetVector = vec2_exports.scale([0, 0], unitNormal(points[0], points[1]), padding);
    var invOffsetVector = vec2_exports.scale([0, 0], offsetVector, -1);
    var p02 = vec2_exports.add([0, 0], points[0], offsetVector);
    var p12 = vec2_exports.add([0, 0], points[1], offsetVector);
    var p2 = vec2_exports.add([0, 0], points[1], invOffsetVector);
    var p3 = vec2_exports.add([0, 0], points[0], invOffsetVector);
    return "M ".concat(p02, " L ").concat(p12, " A ").concat([padding, padding, "0,0,0", p2].join(","), " L ").concat(p3, " A ").concat([padding, padding, "0,0,0", p02].join(","));
  };
  if (!polyPoints || polyPoints.length < 1)
    return "";
  if (polyPoints.length === 1)
    return roundedHull1(polyPoints);
  if (polyPoints.length === 2)
    return roundedHull2(polyPoints);
  var segments = new Array(polyPoints.length);
  for (var segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {
    var p0 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];
    var p1 = polyPoints[segmentIndex];
    var offset = vec2_exports.scale([0, 0], unitNormal(p0, p1), padding);
    segments[segmentIndex] = [vec2_exports.add([0, 0], p0, offset), vec2_exports.add([0, 0], p1, offset)];
  }
  var arcData = "A ".concat([padding, padding, "0,0,0,"].join(","));
  segments = segments.map(function(segment, index2) {
    var pathFragment = "";
    if (index2 === 0) {
      pathFragment = "M ".concat(segments[segments.length - 1][1], " ");
    }
    pathFragment += "".concat(arcData + segment[0], " L ").concat(segment[1]);
    return pathFragment;
  });
  return segments.join(" ");
}
function paddedHull(polyPoints, padding) {
  var pointCount = polyPoints.length;
  var smoothHull1 = function smoothHull12(points) {
    var p1 = [points[0][0], points[0][1] - padding];
    var p2 = [points[0][0], points[0][1] + padding];
    return "M ".concat(p1, " A ").concat([padding, padding, "0,0,0", p2].join(","), " A ").concat([padding, padding, "0,0,0", p1].join(","));
  };
  var smoothHull2 = function smoothHull22(points) {
    var v2 = vecFrom(points[0], points[1]);
    var extensionVec2 = vecScaleTo(v2, padding);
    var extension0 = vec2_exports.add([0, 0], points[0], vec2_exports.scale([0, 0], extensionVec2, -1));
    var extension1 = vec2_exports.add([0, 0], points[1], extensionVec2);
    var tangentHalfLength = 1.2 * padding;
    var controlDelta = vecScaleTo(vec2_exports.normalize([0, 0], v2), tangentHalfLength);
    var invControlDelta = vec2_exports.scale([0, 0], controlDelta, -1);
    var control0 = vec2_exports.add([0, 0], extension0, invControlDelta);
    var control1 = vec2_exports.add([0, 0], extension1, invControlDelta);
    var control3 = vec2_exports.add([0, 0], extension0, controlDelta);
    return "M ".concat(extension0, " C ").concat([control0, control1, extension1].join(","), " S ").concat([control3, extension0].join(","), " Z");
  };
  if (!polyPoints || pointCount < 1)
    return "";
  if (pointCount === 1)
    return smoothHull1(polyPoints);
  if (pointCount === 2)
    return smoothHull2(polyPoints);
  var hullPoints = polyPoints.map(function(point, index2) {
    var pNext = polyPoints[(index2 + 1) % pointCount];
    return {
      p: point,
      v: vec2_exports.normalize([0, 0], vecFrom(point, pNext))
    };
  });
  for (var i2 = 0; i2 < hullPoints.length; ++i2) {
    var priorIndex = i2 > 0 ? i2 - 1 : pointCount - 1;
    var extensionVec = vec2_exports.normalize([0, 0], vec2_exports.add([0, 0], hullPoints[priorIndex].v, vec2_exports.scale([0, 0], hullPoints[i2].v, -1)));
    hullPoints[i2].p = vec2_exports.add([0, 0], hullPoints[i2].p, vec2_exports.scale([0, 0], extensionVec, padding));
  }
  return hullPoints.map(function(obj) {
    var point = obj.p;
    return {
      x: point[0],
      y: point[1]
    };
  });
}
var getStarPath = function getStarPath2(outerR, innerR) {
  var path = [];
  for (var i2 = 0; i2 < 5; i2++) {
    var x1 = Math.cos((18 + 72 * i2) / 180 * Math.PI) * outerR;
    var y1 = Math.sin((18 + 72 * i2) / 180 * Math.PI) * outerR;
    var x22 = Math.cos((54 + 72 * i2) / 180 * Math.PI) * innerR;
    var y22 = Math.sin((54 + 72 * i2) / 180 * Math.PI) * innerR;
    if (i2 === 0) {
      path.push(["M", x1, -y1]);
    } else {
      path.push(["L", x1, -y1]);
    }
    path.push(["L", x22, -y22]);
  }
  path.push(["Z"]);
  return path;
};

// node_modules/@antv/g6-core/es/element/hull/convexHull.js
var cross = function cross2(a3, b2, o2) {
  return (a3.y - o2.y) * (b2.x - o2.x) - (a3.x - o2.x) * (b2.y - o2.y);
};
var genConvexHull = function genConvexHull2(items) {
  var points = items.map(function(item) {
    return {
      x: item.getModel().x,
      y: item.getModel().y
    };
  });
  points.sort(function(a3, b2) {
    return a3.x === b2.x ? a3.y - b2.y : a3.x - b2.x;
  });
  var pointMap = {};
  for (var i2 = points.length - 1; i2 >= 0; i2--) {
    var _a2 = points[i2], x4 = _a2.x, y4 = _a2.y;
    if (pointMap["".concat(x4, "-").concat(y4)])
      points.splice(i2, 1);
    pointMap["".concat(x4, "-").concat(y4)] = true;
  }
  if (points.length === 1) {
    return points;
  }
  var lower = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i2]) <= 0) {
      lower.pop();
    }
    lower.push(points[i2]);
  }
  var upper = [];
  for (var i2 = points.length - 1; i2 >= 0; i2--) {
    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i2]) <= 0) {
      upper.pop();
    }
    upper.push(points[i2]);
  }
  upper.pop();
  lower.pop();
  var strictHull = lower.concat(upper);
  return strictHull;
};

// node_modules/@antv/g6-core/es/element/hull/bubbleset.js
var defaultOps = {
  maxRoutingIterations: 100,
  maxMarchingIterations: 100,
  pixelGroupSize: 2,
  edgeR0: 10,
  edgeR1: 10,
  nodeR0: 5,
  nodeR1: 10,
  morphBuffer: 5,
  threshold: 1e-3,
  skip: 16,
  nodeInfluenceFactor: 1,
  edgeInfluenceFactor: 1,
  negativeNodeInfluenceFactor: -0.5
};
function MarchingSquares(contour, potentialArea, threshold) {
  var marched = false;
  var getVal = function getVal2(x4, y4) {
    return potentialArea.cells[x4 + y4 * potentialArea.width];
  };
  var getState = function getState2(x4, y4) {
    var squareVal = 0;
    if (getVal(x4 - 1, y4 - 1) >= threshold) {
      squareVal += 1;
    }
    if (getVal(x4, y4 - 1) > threshold) {
      squareVal += 2;
    }
    if (getVal(x4 - 1, y4) > threshold) {
      squareVal += 4;
    }
    if (getVal(x4, y4) > threshold) {
      squareVal += 8;
    }
    return squareVal;
  };
  var doMarch = function doMarch2(xPos, yPos) {
    var x4 = xPos;
    var y4 = yPos;
    var prevX;
    var prevY;
    for (var i2 = 0; i2 < potentialArea.width * potentialArea.height; i2++) {
      prevX = x4;
      prevY = y4;
      if (contour.findIndex(function(item) {
        return item.x === x4 && item.y === y4;
      }) > -1) {
        if (contour[0].x !== x4 || contour[0].y !== y4) {
        } else {
          return true;
        }
      } else {
        contour.push({
          x: x4,
          y: y4
        });
      }
      var state = getState(x4, y4);
      switch (state) {
        case -1:
          console.warn("Marched out of bounds");
          return true;
        case 0:
        case 3:
        case 2:
        case 7:
          x4++;
          break;
        case 12:
        case 14:
        case 4:
          x4--;
          break;
        case 6:
          if (prevX === 0) {
            if (prevY === -1) {
              x4 -= 1;
            } else {
              x4 += 1;
            }
          }
          break;
        case 1:
        case 13:
        case 5:
          y4--;
          break;
        case 9:
          if (prevX === 1) {
            if (prevY === 0) {
              y4 -= 1;
            } else {
              y4 += 1;
            }
          }
          break;
        case 10:
        case 8:
        case 11:
          y4++;
          break;
        default:
          console.warn("Marching squares invalid state: ".concat(state));
          return true;
      }
    }
  };
  this.march = function() {
    for (var x4 = 0; x4 < potentialArea.width && !marched; x4 += 1) {
      for (var y4 = 0; y4 < potentialArea.height && !marched; y4 += 1) {
        if (getVal(x4, y4) > threshold && getState(x4, y4) !== 15) {
          marched = doMarch(x4, y4);
        }
      }
    }
    return marched;
  };
}
var initGridCells = function initGridCells2(width, height, pixelGroupSize) {
  var scaleWidth = Math.ceil(width / pixelGroupSize);
  var scaleHeight = Math.ceil(height / pixelGroupSize);
  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);
  return {
    cells: gridCells,
    width: scaleWidth,
    height: scaleHeight
  };
};
var pickBestNeighbor = function pickBestNeighbor2(item, visited, nonMembers) {
  var closestNeighbour = null;
  var minCost = Number.POSITIVE_INFINITY;
  visited.forEach(function(neighbourItem) {
    var itemP = {
      x: item.getModel().x,
      y: item.getModel().y
    };
    var neighbourItemP = {
      x: neighbourItem.getModel().x,
      y: neighbourItem.getModel().y
    };
    var dist = squareDist(itemP, neighbourItemP);
    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);
    var numberObstacles = nonMembers.reduce(function(count, _item) {
      if (fractionToLine(_item, directLine) > 0) {
        return count + 1;
      }
      return count;
    }, 0);
    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {
      closestNeighbour = neighbourItem;
      minCost = dist * Math.pow(numberObstacles + 1, 2);
    }
  });
  return closestNeighbour;
};
var getIntersectItem = function getIntersectItem2(items, line) {
  var minDistance = Number.POSITIVE_INFINITY;
  var closestItem = null;
  items.forEach(function(item) {
    var distance6 = fractionToLine(item, line);
    if (distance6 >= 0 && distance6 < minDistance) {
      closestItem = item;
      minDistance = distance6;
    }
  });
  return closestItem;
};
var computeRoute = function computeRoute2(directLine, nonMembers, maxRoutingIterations, morphBuffer) {
  var checkedLines = [];
  var linesToCheck = [];
  linesToCheck.push(directLine);
  var hasIntersection = true;
  var iterations = 0;
  var pointExists = function pointExists2(point, lines) {
    var flag = false;
    lines.forEach(function(line) {
      if (flag)
        return;
      if (isPointsOverlap(point, {
        x: line.x1,
        y: line.y1
      }) || isPointsOverlap(point, {
        x: line.x2,
        y: line.y2
      })) {
        flag = true;
      }
    });
    return flag;
  };
  var isPointInNonMembers = function isPointInNonMembers2(point, _nonMembers) {
    for (var _i2 = 0, _nonMembers_1 = _nonMembers; _i2 < _nonMembers_1.length; _i2++) {
      var item = _nonMembers_1[_i2];
      var bbox = item.getBBox();
      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];
      if (isPointInPolygon(itemContour, point.x, point.y)) {
        return true;
      }
    }
    return false;
  };
  while (hasIntersection && iterations < maxRoutingIterations) {
    hasIntersection = false;
    var _loop_1 = function _loop_12() {
      var line = linesToCheck.pop();
      var closestItem = getIntersectItem(nonMembers, line);
      if (closestItem) {
        var _a2 = itemIntersectByLine(closestItem, line), intersections_1 = _a2[0], countIntersections = _a2[1];
        if (countIntersections === 2) {
          var testReroute = function testReroute2(isFirst) {
            var tempMorphBuffer = morphBuffer;
            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);
            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);
            var pointInside = isPointInNonMembers(virtualNode, nonMembers);
            while (!exist && pointInside && tempMorphBuffer >= 1) {
              tempMorphBuffer /= 1.5;
              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);
              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);
              pointInside = isPointInNonMembers(virtualNode, nonMembers);
            }
            if (virtualNode && !exist && (!isFirst || !pointInside)) {
              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));
              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));
              hasIntersection = true;
            }
          };
          testReroute(true);
          if (!hasIntersection) {
            testReroute(false);
          }
        }
      }
      if (!hasIntersection) {
        checkedLines.push(line);
      }
      iterations += 1;
    };
    while (!hasIntersection && linesToCheck.length) {
      _loop_1();
    }
  }
  while (linesToCheck.length) {
    checkedLines.push(linesToCheck.pop());
  }
  return checkedLines;
};
function getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {
  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);
  if (optimalNeighbor === null) {
    return [];
  }
  var mergeLines = function mergeLines2(checkedLines2) {
    var finalRoute2 = [];
    while (checkedLines2.length > 0) {
      var line1 = checkedLines2.pop();
      if (checkedLines2.length === 0) {
        finalRoute2.push(line1);
        break;
      }
      var line2 = checkedLines2.pop();
      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);
      var closestItem = getIntersectItem(nonMembers, mergeLine);
      if (!closestItem) {
        checkedLines2.push(mergeLine);
      } else {
        finalRoute2.push(line1);
        checkedLines2.push(line2);
      }
    }
    return finalRoute2;
  };
  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);
  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);
  var finalRoute = mergeLines(checkedLines);
  return finalRoute;
}
var genBubbleSet = function genBubbleSet2(members, nonMembers, ops) {
  var options = Object.assign(defaultOps, ops);
  var centroid = getPointsCenter(members.map(function(item) {
    return {
      x: item.getModel().x,
      y: item.getModel().y
    };
  }));
  members = members.sort(function(a3, b2) {
    return squareDist({
      x: a3.getModel().x,
      y: a3.getModel().y
    }, centroid) - squareDist({
      x: b2.getModel().x,
      y: b2.getModel().y
    }, centroid);
  });
  var visited = [];
  var virtualEdges = [];
  members.forEach(function(item) {
    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);
    lines.forEach(function(l2) {
      virtualEdges.push(l2);
    });
    visited.push(item);
  });
  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);
  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize);
  var contour = [];
  var hull = [];
  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {
    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);
    contour = [];
    hull = [];
    if (!new MarchingSquares(contour, potentialArea, options.threshold).march())
      continue;
    var marchedPath = contour.map(function(point) {
      return {
        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),
        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)
      };
    });
    if (marchedPath) {
      var size3 = marchedPath.length;
      if (options.skip > 1) {
        size3 = Math.floor(marchedPath.length / options.skip);
        while (size3 < 3 && options.skip > 1) {
          options.skip -= 1;
          size3 = Math.floor(marchedPath.length / options.skip);
        }
      }
      for (var i2 = 0, j2 = 0; j2 < size3; j2 += 1, i2 += options.skip) {
        hull.push({
          x: marchedPath[i2].x,
          y: marchedPath[i2].y
        });
      }
    }
    var isContourValid = function isContourValid2() {
      for (var _i2 = 0, members_1 = members; _i2 < members_1.length; _i2++) {
        var item = members_1[_i2];
        var hullPoints = hull.map(function(point) {
          return [point.x, point.y];
        });
        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY))
          return false;
      }
      return true;
    };
    if (hull && isContourValid()) {
      return hull;
    }
    options.threshold *= 0.9;
    if (iterations <= options.maxMarchingIterations * 0.5) {
      options.memberInfluenceFactor *= 1.2;
      options.edgeInfluenceFactor *= 1.2;
    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {
      options.nonMemberInfluenceFactor *= 0.8;
    } else {
      break;
    }
  }
  return hull;
};
function getActiveRregion(members, edges, offset) {
  var activeRegion = {
    minX: Number.POSITIVE_INFINITY,
    minY: Number.POSITIVE_INFINITY,
    maxX: Number.NEGATIVE_INFINITY,
    maxY: Number.NEGATIVE_INFINITY,
    width: 0,
    height: 0,
    x: 0,
    y: 0
  };
  var bboxes = [];
  members.forEach(function(item) {
    bboxes.push(item.getBBox());
  });
  edges.forEach(function(l2) {
    bboxes.push(l2.getBBox());
  });
  for (var _i2 = 0, bboxes_1 = bboxes; _i2 < bboxes_1.length; _i2++) {
    var bbox = bboxes_1[_i2];
    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;
    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;
    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;
    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;
  }
  activeRegion.width = activeRegion.maxX - activeRegion.minX;
  activeRegion.height = activeRegion.maxY - activeRegion.minY;
  activeRegion.x = activeRegion.minX;
  activeRegion.y = activeRegion.minY;
  return activeRegion;
}
function fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {
  function pos2GridIx3(x4, offset) {
    var gridIx = Math.floor((x4 - offset) / options.pixelGroupSize);
    return gridIx < 0 ? 0 : gridIx;
  }
  function gridIx2Pos(x4, offset) {
    return x4 * options.pixelGroupSize + offset;
  }
  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);
  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);
  var getAffectedRegion = function getAffectedRegion2(bbox, thresholdR) {
    var startX = Math.min(pos2GridIx3(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);
    var startY = Math.min(pos2GridIx3(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);
    var endX = Math.min(pos2GridIx3(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);
    var endY = Math.min(pos2GridIx3(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);
    return [startX, startY, endX, endY];
  };
  var addItemInfluence = function addItemInfluence2(item, influenceFactor) {
    var bbox = item.getBBox();
    var _a2 = getAffectedRegion(bbox, options.nodeR1), startX = _a2[0], startY = _a2[1], endX = _a2[2], endY = _a2[3];
    for (var y4 = startY; y4 < endY; y4 += 1) {
      for (var x4 = startX; x4 < endX; x4 += 1) {
        if (influenceFactor < 0 && potentialArea[x4 + y4 * potentialArea.width] <= 0) {
          continue;
        }
        var tempX = gridIx2Pos(x4, activeRegion.minX);
        var tempY = gridIx2Pos(y4, activeRegion.minY);
        var distanceSq = pointRectSquareDist({
          x: tempX,
          y: tempY
        }, {
          x: bbox.minX,
          y: bbox.minY,
          width: bbox.width,
          height: bbox.height
        });
        if (distanceSq < Math.pow(options.nodeR1, 2)) {
          var dr2 = Math.sqrt(distanceSq) - options.nodeR1;
          potentialArea.cells[x4 + y4 * potentialArea.width] += influenceFactor * dr2 * dr2;
        }
      }
    }
  };
  var addEdgeInfluence = function addEdgeInfluence2(line, influenceFactor) {
    var bbox = line.getBBox();
    var _a2 = getAffectedRegion(bbox, options.edgeR1), startX = _a2[0], startY = _a2[1], endX = _a2[2], endY = _a2[3];
    for (var y4 = startY; y4 < endY; y4 += 1) {
      for (var x4 = startX; x4 < endX; x4 += 1) {
        if (influenceFactor < 0 && potentialArea.cells[x4 + y4 * potentialArea.width] <= 0) {
          continue;
        }
        var tempX = gridIx2Pos(x4, activeRegion.minX);
        var tempY = gridIx2Pos(y4, activeRegion.minY);
        var minDistanceSq = pointLineSquareDist({
          x: tempX,
          y: tempY
        }, line);
        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {
          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;
          potentialArea.cells[x4 + y4 * potentialArea.width] += influenceFactor * mdr * mdr;
        }
      }
    }
  };
  if (options.nodeInfluenceFactor) {
    members.forEach(function(item) {
      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);
    });
  }
  if (options.edgeInfluenceFactor) {
    edges.forEach(function(edge) {
      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);
    });
  }
  if (options.negativeNodeInfluenceFactor) {
    nonMembers.forEach(function(item) {
      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);
    });
  }
}
function rerouteLine(item, buffer, intersections, wrapNormal) {
  var bbox = item.getBBox();
  var topIntersect = intersections[0], leftIntersect = intersections[1], bottomIntersect = intersections[2], rightIntersect = intersections[3];
  var cornerPos = {
    topLeft: {
      x: bbox.minX - buffer,
      y: bbox.minY - buffer
    },
    topRight: {
      x: bbox.maxX + buffer,
      y: bbox.minY - buffer
    },
    bottomLeft: {
      x: bbox.minX - buffer,
      y: bbox.maxY + buffer
    },
    bottomRight: {
      x: bbox.maxX + buffer,
      y: bbox.maxY + buffer
    }
  };
  var totalArea = bbox.height * bbox.width;
  function calcHalfArea(intersect1, intersect2) {
    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);
  }
  if (leftIntersect) {
    if (topIntersect)
      return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
    if (bottomIntersect)
      return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
    var topArea = calcHalfArea(leftIntersect, rightIntersect);
    if (topArea < totalArea * 0.5) {
      if (leftIntersect.y > rightIntersect.y)
        return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
    }
    if (leftIntersect.y < rightIntersect.y)
      return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
  }
  if (rightIntersect) {
    if (topIntersect)
      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
    if (bottomIntersect)
      return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
  }
  var leftArea = calcHalfArea(topIntersect, bottomIntersect);
  if (leftArea < totalArea * 0.5) {
    if (topIntersect.x > bottomIntersect.x)
      return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
  }
  if (topIntersect.x < bottomIntersect.x)
    return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
}

// node_modules/@antv/g6-core/es/item/hull.js
var Hull = (
  /** @class */
  function() {
    function Hull2(graph, cfg) {
      this.cfg = deep_mix_default(this.getDefaultCfg(), cfg);
      this.graph = graph;
      this.id = this.cfg.id;
      this.group = this.cfg.group;
      this.members = this.cfg.members.map(function(item) {
        return is_string_default(item) ? graph.findById(item) : item;
      });
      this.nonMembers = this.cfg.nonMembers.map(function(item) {
        return is_string_default(item) ? graph.findById(item) : item;
      });
      this.setPadding();
      this.setType();
      this.path = this.calcPath(this.members, this.nonMembers);
      this.render();
    }
    Hull2.prototype.getDefaultCfg = function() {
      return {
        id: "g6-hull",
        type: "round-convex",
        members: [],
        nonMembers: [],
        style: {
          fill: "lightblue",
          stroke: "blue",
          opacity: 0.2
        },
        padding: 10
      };
    };
    Hull2.prototype.setPadding = function() {
      var nodeSize = this.members.length && this.members[0].getKeyShape().getCanvasBBox().width / 2;
      this.padding = this.cfg.padding > 0 ? this.cfg.padding + nodeSize : 10 + nodeSize;
      this.cfg.bubbleCfg = {
        nodeR0: this.padding - nodeSize,
        nodeR1: this.padding - nodeSize,
        morphBuffer: this.padding - nodeSize
      };
    };
    Hull2.prototype.setType = function() {
      this.type = this.cfg.type;
      if (this.members.length < 3) {
        this.type = "round-convex";
      }
      if (this.type !== "round-convex" && this.type !== "smooth-convex" && this.type !== "bubble") {
        console.warn("The hull type should be either round-convex, smooth-convex or bubble, round-convex is used by default.");
        this.type = "round-convex";
      }
    };
    Hull2.prototype.calcPath = function(members, nonMembers) {
      var contour, path, hull;
      switch (this.type) {
        case "round-convex":
          contour = genConvexHull(members);
          hull = roundedHull(contour.map(function(p2) {
            return [p2.x, p2.y];
          }), this.padding);
          path = parsePathString(hull);
          break;
        case "smooth-convex":
          contour = genConvexHull(members);
          if (contour.length === 2) {
            hull = roundedHull(contour.map(function(p2) {
              return [p2.x, p2.y];
            }), this.padding);
            path = parsePathString(hull);
          } else if (contour.length > 2) {
            hull = paddedHull(contour.map(function(p2) {
              return [p2.x, p2.y];
            }), this.padding);
            path = getClosedSpline(hull);
          }
          break;
        case "bubble":
          contour = genBubbleSet(members, nonMembers, this.cfg.bubbleCfg);
          path = contour.length >= 2 && getClosedSpline(contour);
          break;
        default:
      }
      return path;
    };
    Hull2.prototype.render = function() {
      this.group.addShape("path", {
        attrs: __assign({
          path: this.path
        }, this.cfg.style),
        id: this.id,
        name: this.cfg.id,
        capture: false
      });
      this.group.toBack();
    };
    Hull2.prototype.addMember = function(item) {
      if (!item)
        return;
      if (is_string_default(item))
        item = this.graph.findById(item);
      this.members.push(item);
      var index2 = this.nonMembers.indexOf(item);
      if (index2 > -1) {
        this.nonMembers.splice(index2, 1);
      }
      this.updateData(this.members, this.nonMembers);
      return true;
    };
    Hull2.prototype.addNonMember = function(item) {
      if (!item)
        return;
      if (is_string_default(item))
        item = this.graph.findById(item);
      this.nonMembers.push(item);
      var index2 = this.members.indexOf(item);
      if (index2 > -1) {
        this.members.splice(index2, 1);
      }
      this.updateData(this.members, this.nonMembers);
      return true;
    };
    Hull2.prototype.removeMember = function(item) {
      if (!item)
        return;
      if (is_string_default(item))
        item = this.graph.findById(item);
      var index2 = this.members.indexOf(item);
      if (index2 > -1) {
        this.members.splice(index2, 1);
        this.updateData(this.members, this.nonMembers);
        return true;
      }
      return false;
    };
    Hull2.prototype.removeNonMember = function(item) {
      if (!item)
        return;
      if (is_string_default(item))
        item = this.graph.findById(item);
      var index2 = this.nonMembers.indexOf(item);
      if (index2 > -1) {
        this.nonMembers.splice(index2, 1);
        this.updateData(this.members, this.nonMembers);
        return true;
      }
      return false;
    };
    Hull2.prototype.updateData = function(members, nonMembers) {
      var _this = this;
      this.group.findById(this.id).remove();
      if (members)
        this.members = members.map(function(item) {
          return is_string_default(item) ? _this.graph.findById(item) : item;
        });
      if (nonMembers)
        this.nonMembers = nonMembers.map(function(item) {
          return is_string_default(item) ? _this.graph.findById(item) : item;
        });
      this.path = this.calcPath(this.members, this.nonMembers);
      this.render();
    };
    Hull2.prototype.updateStyle = function(cfg) {
      var path = this.group.findById(this.id);
      path.attr(__assign({}, cfg));
    };
    Hull2.prototype.updateCfg = function(cfg) {
      var _this = this;
      this.cfg = deep_mix_default(this.cfg, cfg);
      this.id = this.cfg.id;
      this.group = this.cfg.group;
      if (cfg.members) {
        this.members = this.cfg.members.map(function(item) {
          return is_string_default(item) ? _this.graph.findById(item) : item;
        });
      }
      if (cfg.nonMembers) {
        this.nonMembers = this.cfg.nonMembers.map(function(item) {
          return is_string_default(item) ? _this.graph.findById(item) : item;
        });
      }
      this.setPadding();
      this.setType();
      this.path = this.calcPath(this.members, this.nonMembers);
      this.render();
    };
    Hull2.prototype.contain = function(item) {
      var _this = this;
      var nodeItem;
      if (is_string_default(item)) {
        nodeItem = this.graph.findById(item);
      } else {
        nodeItem = item;
      }
      var shapePoints;
      var shape = nodeItem.getKeyShape();
      if (nodeItem.get("type") === "path") {
        shapePoints = pathToPoints(shape.attr("path"));
      } else {
        var shapeBBox = shape.getCanvasBBox();
        shapePoints = [[shapeBBox.minX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.maxY], [shapeBBox.minX, shapeBBox.maxY]];
      }
      shapePoints = shapePoints.map(function(canvasPoint) {
        var point = _this.graph.getPointByCanvas(canvasPoint[0], canvasPoint[1]);
        return [point.x, point.y];
      });
      return isPolygonsIntersect(shapePoints, pathToPoints(this.path));
    };
    Hull2.prototype.destroy = function() {
      this.group.remove();
      this.cfg = null;
    };
    return Hull2;
  }()
);
var hull_default = Hull;

// node_modules/@antv/g6-core/es/graph/graph.js
var transform3 = ext_exports.transform;
var NODE2 = "node";
var AbstractGraph = (
  /** @class */
  function(_super) {
    __extends(AbstractGraph2, _super);
    function AbstractGraph2(cfg) {
      var _this = _super.call(this) || this;
      _this.sortCombos = debounce_default(function() {
        var comboSorted = _this.get("comboSorted");
        if (!_this || _this.destroyed || comboSorted)
          return;
        _this.set("comboSorted", true);
        var depthMap = [];
        var dataDepthMap = {};
        var comboTrees = _this.get("comboTrees");
        (comboTrees || []).forEach(function(cTree) {
          traverseTree(cTree, function(child) {
            if (depthMap[child.depth])
              depthMap[child.depth].push(child.id);
            else
              depthMap[child.depth] = [child.id];
            dataDepthMap[child.id] = child.depth;
            return true;
          });
        });
        var edges = _this.getEdges().concat(_this.get("vedges"));
        (edges || []).forEach(function(edgeItem) {
          var edge = edgeItem.getModel();
          var sourceDepth = dataDepthMap[edge.source] || 0;
          var targetDepth = dataDepthMap[edge.target] || 0;
          var depth = Math.max(sourceDepth, targetDepth);
          if (depthMap[depth])
            depthMap[depth].push(edge.id);
          else
            depthMap[depth] = [edge.id];
        });
        depthMap.forEach(function(array) {
          if (!array || !array.length)
            return;
          for (var i2 = array.length - 1; i2 >= 0; i2--) {
            var item = _this.findById(array[i2]);
            if (item)
              item.toFront();
          }
        });
      }, 500, false);
      _this.cfg = deep_mix_default(_this.getDefaultCfg(), cfg);
      _this.init();
      _this.animating = false;
      _this.destroyed = false;
      if (_this.cfg.enabledStack) {
        _this.undoStack = new stack_default(_this.cfg.maxStep);
        _this.redoStack = new stack_default(_this.cfg.maxStep);
      }
      return _this;
    }
    AbstractGraph2.prototype.init = function() {
      this.initCanvas();
      var viewController = new view_default(this);
      var modeController = new mode_default(this);
      var itemController = new item_default2(this);
      var stateController = new state_default(this);
      this.set({
        viewController,
        modeController,
        itemController,
        stateController
      });
      this.initLayoutController();
      this.initEventController();
      this.initGroups();
      this.initPlugins();
    };
    AbstractGraph2.prototype.initGroups = function() {
      var canvas = this.get("canvas");
      if (!canvas)
        return;
      var el = canvas.get("el");
      var _a2 = (el || {}).id, id = _a2 === void 0 ? "g6" : _a2;
      var group = canvas.addGroup({
        id: "".concat(id, "-root"),
        className: global_default.rootContainerClassName
      });
      if (this.get("groupByTypes")) {
        var edgeGroup = group.addGroup({
          id: "".concat(id, "-edge"),
          className: global_default.edgeContainerClassName
        });
        var nodeGroup = group.addGroup({
          id: "".concat(id, "-node"),
          className: global_default.nodeContainerClassName
        });
        var comboGroup = group.addGroup({
          id: "".concat(id, "-combo"),
          className: global_default.comboContainerClassName
        });
        comboGroup.toBack();
        this.set({
          nodeGroup,
          edgeGroup,
          comboGroup
        });
      }
      var delegateGroup = group.addGroup({
        id: "".concat(id, "-delegate"),
        className: global_default.delegateContainerClassName
      });
      this.set({
        delegateGroup
      });
      this.set("group", group);
    };
    AbstractGraph2.prototype.getDefaultCfg = function() {
      return {
        /**
         * Container could be dom object or dom id
         */
        container: void 0,
        /**
         * Canvas width
         * unit pixel if undefined force fit width
         */
        width: void 0,
        /**
         * Canvas height
         * unit pixel if undefined force fit height
         */
        height: void 0,
        /**
         * renderer canvas or svg
         * @type {string}
         */
        renderer: "canvas",
        /**
         * control graph behaviors
         */
        modes: {},
        /**
         * 注册插件
         */
        plugins: [],
        /**
         * source data
         */
        data: {},
        /**
         * Fit view padding (client scale)
         */
        fitViewPadding: 10,
        /**
         * Minimum scale size
         */
        minZoom: 0.02,
        /**
         * Maxmum scale size
         */
        maxZoom: 10,
        /**
         *  capture events
         */
        event: true,
        /**
         * group node & edges into different graphic groups
         */
        groupByTypes: true,
        /**
         * determine if it's a directed graph
         */
        directed: false,
        /**
         * when data or shape changed, should canvas draw automatically
         */
        autoPaint: true,
        /**
         * store all the node instances
         */
        nodes: [],
        /**
         * store all the edge instances
         */
        edges: [],
        /**
         * store all the combo instances
         */
        combos: [],
        /**
         * store all the edge instances which are virtual edges related to collapsed combo
         */
        vedges: [],
        /**
         * all the instances indexed by id
         */
        itemMap: {},
        /**
         * 边直接连接到节点的中心，不再考虑锚点
         */
        linkCenter: false,
        /**
         * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：
         * defaultNode: {
         *  type: 'rect',
         *  size: [60, 40],
         *  style: {
         *    //... 样式配置项
         *  }
         * }
         * 若数据项为 { id: 'node', x: 100, y: 100 }
         * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }
         * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }
         * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }
         */
        defaultNode: {},
        /**
         * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode
         */
        defaultEdge: {},
        /**
         * 节点默认样式，也可以添加状态样式
         * 例如：
         * const graph = new G6.Graph({
         *  nodeStateStyles: {
         *    selected: { fill: '#ccc', stroke: '#666' },
         *    active: { lineWidth: 2 }
         *  },
         *  ...
         * });
         *
         */
        nodeStateStyles: {},
        /**
         * 边默认样式，用法同nodeStateStyle
         */
        edgeStateStyles: {},
        /**
         * graph 状态
         */
        states: {},
        /**
         * 是否启用全局动画
         */
        animate: false,
        /**
         * 动画设置,仅在 animate 为 true 时有效
         */
        animateCfg: {
          /**
           * 帧回调函数，用于自定义节点运动路径，为空时线性运动
           */
          onFrame: void 0,
          /**
           * 动画时长(ms)
           */
          duration: 500,
          /**
           * 指定动画动效
           */
          easing: "easeLinear"
        },
        callback: void 0,
        // 默认不启用 undo & redo 功能
        enabledStack: false,
        // 只有当 enabledStack 为 true 时才起作用
        maxStep: 10,
        // 存储图上的 tooltip dom，方便销毁
        tooltips: [],
        // 达到这一节点数量(默认值 1000)，将开启性能优化模式。目前包括：节点状态样式变更是否影响相关边的更新
        optimizeThreshold: 1e3
      };
    };
    AbstractGraph2.prototype.set = function(key, val) {
      if (is_plain_object_default(key)) {
        this.cfg = __assign(__assign({}, this.cfg), key);
      } else {
        this.cfg[key] = val;
      }
      if (key === "enabledStack" && val && !this.undoStack && !this.redoStack) {
        this.undoStack = new stack_default(this.cfg.maxStep);
        this.redoStack = new stack_default(this.cfg.maxStep);
      }
      return this;
    };
    AbstractGraph2.prototype.get = function(key) {
      var _a2;
      return (_a2 = this.cfg) === null || _a2 === void 0 ? void 0 : _a2[key];
    };
    AbstractGraph2.prototype.getGroup = function() {
      return this.get("group");
    };
    AbstractGraph2.prototype.getContainer = function() {
      return this.get("container");
    };
    AbstractGraph2.prototype.getMinZoom = function() {
      return this.get("minZoom");
    };
    AbstractGraph2.prototype.setMinZoom = function(ratio) {
      return this.set("minZoom", ratio);
    };
    AbstractGraph2.prototype.getMaxZoom = function() {
      return this.get("maxZoom");
    };
    AbstractGraph2.prototype.setMaxZoom = function(ratio) {
      return this.set("maxZoom", ratio);
    };
    AbstractGraph2.prototype.getWidth = function() {
      return this.get("width");
    };
    AbstractGraph2.prototype.getHeight = function() {
      return this.get("height");
    };
    AbstractGraph2.prototype.clearItemStates = function(item, states) {
      if (is_string_default(item)) {
        item = this.findById(item);
      }
      var itemController = this.get("itemController");
      if (!states) {
        states = item.get("states");
      }
      itemController.clearItemStates(item, states);
      var stateController = this.get("stateController");
      stateController.updateStates(item, states, false);
    };
    AbstractGraph2.prototype.node = function(nodeFn) {
      if (typeof nodeFn === "function") {
        this.set("nodeMapper", nodeFn);
      }
    };
    AbstractGraph2.prototype.edge = function(edgeFn) {
      if (typeof edgeFn === "function") {
        this.set("edgeMapper", edgeFn);
      }
    };
    AbstractGraph2.prototype.combo = function(comboFn) {
      if (typeof comboFn === "function") {
        this.set("comboMapper", comboFn);
      }
    };
    AbstractGraph2.prototype.findById = function(id) {
      return this.get("itemMap")[id];
    };
    AbstractGraph2.prototype.find = function(type, fn2) {
      var result;
      var items = this.get("".concat(type, "s"));
      each_default(items, function(item, i2) {
        if (fn2(item, i2)) {
          result = item;
          return result;
        }
      });
      return result;
    };
    AbstractGraph2.prototype.findAll = function(type, fn2) {
      var result = [];
      each_default(this.get("".concat(type, "s")), function(item, i2) {
        if (fn2(item, i2)) {
          result.push(item);
        }
      });
      return result;
    };
    AbstractGraph2.prototype.findAllByState = function(type, state, additionalFilter) {
      if (additionalFilter) {
        return this.findAll(type, function(item) {
          return item.hasState(state) && additionalFilter(item);
        });
      } else {
        return this.findAll(type, function(item) {
          return item.hasState(state);
        });
      }
    };
    AbstractGraph2.prototype.translate = function(dx, dy, animate, animateCfg) {
      var _this = this;
      var group = this.get("group");
      var matrix = clone_default(group.getMatrix());
      if (!matrix) {
        matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      if (animate) {
        var animateConfig = getAnimateCfgWithCallback({
          animateCfg,
          callback: function callback() {
            return _this.emit("viewportchange", {
              action: "translate",
              matrix: group.getMatrix()
            });
          }
        });
        move(group, {
          x: group.getCanvasBBox().x + dx,
          y: group.getCanvasBBox().y + dy
        }, animate, animateConfig || {
          duration: 500,
          easing: "easeCubic"
        });
      } else {
        matrix = transform3(matrix, [["t", dx, dy]]);
        group.setMatrix(matrix);
        this.emit("viewportchange", {
          action: "translate",
          matrix
        });
        this.autoPaint();
      }
    };
    AbstractGraph2.prototype.moveTo = function(x4, y4, animate, animateCfg) {
      var group = this.get("group");
      move(group, {
        x: x4,
        y: y4
      }, animate, animateCfg || {
        duration: 500,
        easing: "easeCubic"
      });
      this.emit("viewportchange", {
        action: "move",
        matrix: group.getMatrix()
      });
    };
    AbstractGraph2.prototype.fitView = function(padding, rules, animate, animateCfg) {
      if (padding) {
        this.set("fitViewPadding", padding);
      }
      var viewController = this.get("viewController");
      if (rules) {
        viewController.fitViewByRules(rules, animate, animateCfg);
      } else {
        viewController.fitView(animate, animateCfg);
      }
      this.autoPaint();
    };
    AbstractGraph2.prototype.fitCenter = function(animate, animateCfg) {
      var viewController = this.get("viewController");
      viewController.fitCenter(animate, animateCfg);
      this.autoPaint();
    };
    AbstractGraph2.prototype.addBehaviors = function(behaviors2, modes) {
      var modeController = this.get("modeController");
      modeController.manipulateBehaviors(behaviors2, modes, true);
      return this;
    };
    AbstractGraph2.prototype.removeBehaviors = function(behaviors2, modes) {
      var modeController = this.get("modeController");
      modeController.manipulateBehaviors(behaviors2, modes, false);
      return this;
    };
    AbstractGraph2.prototype.updateBehavior = function(behavior, newCfg, mode) {
      var modeController = this.get("modeController");
      modeController.updateBehavior(behavior, newCfg, mode);
      return this;
    };
    AbstractGraph2.prototype.zoom = function(ratio, center, animate, animateCfg) {
      var _this = this;
      var group = this.get("group");
      var matrix = clone_default(group.getMatrix()) || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var minZoom = this.get("minZoom");
      var maxZoom = this.get("maxZoom");
      var currentZoom = this.getZoom() || 1;
      var targetZoom = currentZoom * ratio;
      var finalRatio = ratio;
      var failed = false;
      if (minZoom && targetZoom < minZoom) {
        finalRatio = minZoom / currentZoom;
        failed = true;
      } else if (maxZoom && targetZoom > maxZoom) {
        finalRatio = maxZoom / currentZoom;
        failed = true;
      }
      if (center) {
        matrix = transform3(matrix, [["t", -center.x, -center.y], ["s", finalRatio, finalRatio], ["t", center.x, center.y]]);
      } else {
        matrix = transform3(matrix, [["s", finalRatio, finalRatio]]);
      }
      if (animate) {
        var aniMatrix_1 = clone_default(group.getMatrix());
        if (!aniMatrix_1) {
          aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        }
        var initialRatio_1 = aniMatrix_1[0];
        var targetRatio_1 = initialRatio_1 * finalRatio;
        var animateConfig = getAnimateCfgWithCallback({
          animateCfg,
          callback: function callback() {
            return _this.emit("viewportchange", {
              action: "zoom",
              matrix: group.getMatrix()
            });
          }
        });
        group.animate(function(ratio2) {
          if (ratio2 === 1) {
            aniMatrix_1 = matrix;
          } else {
            var scale3 = lerp(initialRatio_1, targetRatio_1, ratio2) / aniMatrix_1[0];
            if (center) {
              aniMatrix_1 = transform3(aniMatrix_1, [["t", -center.x, -center.y], ["s", scale3, scale3], ["t", center.x, center.y]]);
            } else {
              aniMatrix_1 = transform3(aniMatrix_1, [["s", scale3, scale3]]);
            }
          }
          return {
            matrix: aniMatrix_1
          };
        }, animateConfig);
      } else {
        group.setMatrix(matrix);
        this.emit("viewportchange", {
          action: "zoom",
          matrix
        });
        this.autoPaint();
      }
      return !failed;
    };
    AbstractGraph2.prototype.zoomTo = function(toRatio, center, animate, animateCfg) {
      var ratio = toRatio / this.getZoom();
      return this.zoom(ratio, center, animate, animateCfg);
    };
    AbstractGraph2.prototype.focusItem = function(item, animate, animateCfg) {
      var viewController = this.get("viewController");
      var isAnimate = false;
      if (animate)
        isAnimate = true;
      else if (animate === void 0)
        isAnimate = this.get("animate");
      var curAniamteCfg = {};
      if (animateCfg)
        curAniamteCfg = animateCfg;
      else if (animateCfg === void 0)
        curAniamteCfg = this.get("animateCfg");
      viewController.focus(item, isAnimate, curAniamteCfg);
      this.autoPaint();
    };
    AbstractGraph2.prototype.focusItems = function(items, zoomToFit, animate, animateCfg) {
      var viewController = this.get("viewController");
      viewController.focusItems(items, zoomToFit, animate, animateCfg);
    };
    AbstractGraph2.prototype.autoPaint = function() {
      if (this.get("autoPaint")) {
        this.paint();
      }
    };
    AbstractGraph2.prototype.paint = function() {
      this.emit("beforepaint");
      this.get("canvas").draw();
      this.emit("afterpaint");
    };
    AbstractGraph2.prototype.getPointByClient = function(clientX, clientY) {
      var viewController = this.get("viewController");
      return viewController.getPointByClient(clientX, clientY);
    };
    AbstractGraph2.prototype.getClientByPoint = function(x4, y4) {
      var viewController = this.get("viewController");
      return viewController.getClientByPoint(x4, y4);
    };
    AbstractGraph2.prototype.getPointByCanvas = function(canvasX, canvasY) {
      var viewController = this.get("viewController");
      return viewController.getPointByCanvas(canvasX, canvasY);
    };
    AbstractGraph2.prototype.getCanvasByPoint = function(x4, y4) {
      var viewController = this.get("viewController");
      return viewController.getCanvasByPoint(x4, y4);
    };
    AbstractGraph2.prototype.getGraphCenterPoint = function() {
      var bbox = this.get("group").getCanvasBBox();
      return {
        x: (bbox.minX + bbox.maxX) / 2,
        y: (bbox.minY + bbox.maxY) / 2
      };
    };
    AbstractGraph2.prototype.getViewPortCenterPoint = function() {
      return this.getPointByCanvas(this.get("width") / 2, this.get("height") / 2);
    };
    AbstractGraph2.prototype.showItem = function(item, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var itemController = this.get("itemController");
      var object = itemController.changeItemVisibility(item, true);
      if (stack && this.get("enabledStack")) {
        var id = object.getID();
        var type = object.getType();
        var before = {};
        var after = {};
        switch (type) {
          case "node":
            before.nodes = [{
              id,
              visible: false
            }];
            after.nodes = [{
              id,
              visible: true
            }];
            break;
          case "edge":
            before.nodes = [{
              id,
              visible: false
            }];
            after.edges = [{
              id,
              visible: true
            }];
            break;
          case "combo":
            before.nodes = [{
              id,
              visible: false
            }];
            after.combos = [{
              id,
              visible: true
            }];
            break;
          default:
            break;
        }
        this.pushStack("visible", {
          before,
          after
        });
      }
    };
    AbstractGraph2.prototype.hideItem = function(item, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var itemController = this.get("itemController");
      var object = itemController.changeItemVisibility(item, false);
      if (stack && this.get("enabledStack")) {
        var id = object.getID();
        var type = object.getType();
        var before = {};
        var after = {};
        switch (type) {
          case "node":
            before.nodes = [{
              id,
              visible: true
            }];
            after.nodes = [{
              id,
              visible: false
            }];
            break;
          case "edge":
            before.nodes = [{
              id,
              visible: true
            }];
            after.edges = [{
              id,
              visible: false
            }];
            break;
          case "combo":
            before.nodes = [{
              id,
              visible: true
            }];
            after.combos = [{
              id,
              visible: false
            }];
            break;
          default:
            break;
        }
        this.pushStack("visible", {
          before,
          after
        });
      }
    };
    AbstractGraph2.prototype.refreshItem = function(item) {
      var itemController = this.get("itemController");
      itemController.refreshItem(item);
    };
    AbstractGraph2.prototype.setAutoPaint = function(auto) {
      var self2 = this;
      self2.set("autoPaint", auto);
      var canvas = self2.get("canvas");
      canvas.set("autoDraw", auto);
    };
    AbstractGraph2.prototype.remove = function(item, stack) {
      if (stack === void 0) {
        stack = true;
      }
      this.removeItem(item, stack);
    };
    AbstractGraph2.prototype.removeItem = function(item, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var nodeItem = item;
      if (is_string_default(item))
        nodeItem = this.findById(item);
      if (!nodeItem && is_string_default(item)) {
        console.warn("The item ".concat(item, " to be removed does not exist!"));
      } else if (nodeItem) {
        var type = "";
        if (nodeItem.getType)
          type = nodeItem.getType();
        if (stack && this.get("enabledStack")) {
          var deletedModel = __assign(__assign({}, nodeItem.getModel()), {
            itemType: type
          });
          var before = {};
          switch (type) {
            case "node": {
              before.nodes = [deletedModel];
              before.edges = [];
              var edges = nodeItem.getEdges();
              for (var i2 = edges.length - 1; i2 >= 0; i2--) {
                before.edges.push(__assign(__assign({}, edges[i2].getModel()), {
                  itemType: "edge"
                }));
              }
              break;
            }
            case "edge":
              before.edges = [deletedModel];
              break;
            case "combo":
              before.combos = [deletedModel];
              break;
            default:
              break;
          }
          this.pushStack("delete", {
            before,
            after: {}
          });
        }
        if (type === "node") {
          var model = nodeItem.getModel();
          if (model.comboId) {
            this.updateComboTree(nodeItem, void 0, false);
          }
        }
        var itemController = this.get("itemController");
        itemController.removeItem(nodeItem);
        if (type === "combo") {
          var newComboTrees = reconstructTree(this.get("comboTrees"));
          this.set("comboTrees", newComboTrees);
        }
      }
    };
    AbstractGraph2.prototype.innerAddItem = function(type, model, itemController) {
      if (!singleDataValidation(type, model)) {
        return false;
      }
      if (model.id && this.findById(model.id)) {
        console.warn("This item exists already. Be sure the id %c".concat(model.id, "%c is unique."), "font-size: 20px; color: red;", "");
        return;
      }
      var item;
      var comboTrees = this.get("comboTrees") || [];
      if (type === "combo") {
        var itemMap_1 = this.get("itemMap");
        var foundParent_1 = false;
        comboTrees.forEach(function(ctree) {
          if (foundParent_1)
            return;
          traverseTreeUp(ctree, function(child) {
            if (model.parentId === child.id) {
              foundParent_1 = true;
              var newCombo2 = __assign({
                id: model.id,
                depth: child.depth + 2
              }, model);
              if (child.children)
                child.children.push(newCombo2);
              else
                child.children = [newCombo2];
              model.depth = newCombo2.depth;
              item = itemController.addItem(type, model);
            }
            var childItem = itemMap_1[child.id];
            if (foundParent_1 && childItem && childItem.getType && childItem.getType() === "combo") {
              itemController.updateCombo(childItem, child.children);
            }
            return true;
          });
        });
        if (!foundParent_1) {
          var newCombo = __assign({
            id: model.id,
            depth: 0
          }, model);
          model.depth = newCombo.depth;
          comboTrees.push(newCombo);
          item = itemController.addItem(type, model);
        }
        this.set("comboTrees", comboTrees);
        if (model.collapsed) {
          this.collapseCombo(item, false);
          this.updateCombo(item);
        }
      } else if (type === "node" && is_string_default(model.comboId) && comboTrees) {
        var parentCombo = this.findById(model.comboId);
        if (parentCombo && parentCombo.getType && parentCombo.getType() !== "combo") {
          console.warn("'".concat(model.comboId, "' is not a id of a combo in the graph, the node will be added without combo."));
        }
        item = itemController.addItem(type, model);
        var itemMap_2 = this.get("itemMap");
        var foundParent_2 = false, foundNode_1 = false;
        comboTrees.forEach(function(ctree) {
          if (foundNode_1 || foundParent_2)
            return;
          traverseTreeUp(ctree, function(child) {
            if (child.id === model.id) {
              foundNode_1 = true;
              return false;
            }
            if (model.comboId === child.id && !foundNode_1) {
              foundParent_2 = true;
              var cloneNode = clone_default(model);
              cloneNode.itemType = "node";
              if (child.children)
                child.children.push(cloneNode);
              else
                child.children = [cloneNode];
              cloneNode.depth = child.depth + 1;
            }
            if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === "combo") {
              itemController.updateCombo(itemMap_2[child.id], child.children);
            }
            return true;
          });
        });
      } else {
        item = itemController.addItem(type, model);
      }
      if (type === "node" && model.comboId || type === "combo" && model.parentId) {
        var parentCombo = this.findById(model.comboId || model.parentId);
        if (parentCombo && parentCombo.getType && parentCombo.getType() === "combo")
          parentCombo.addChild(item);
      }
      return item;
    };
    AbstractGraph2.prototype.addItem = function(type, model, stack, sortCombo) {
      if (stack === void 0) {
        stack = true;
      }
      if (sortCombo === void 0) {
        sortCombo = true;
      }
      var currentComboSorted = this.get("comboSorted");
      this.set("comboSorted", currentComboSorted && !sortCombo);
      var itemController = this.get("itemController");
      var item = this.innerAddItem(type, model, itemController);
      if (item === false || item === true) {
        return item;
      }
      var combos = this.get("combos");
      if (combos && combos.length > 0) {
        this.sortCombos();
      }
      this.autoPaint();
      if (stack && this.get("enabledStack")) {
        var addedModel = __assign(__assign({}, item.getModel()), {
          itemType: type
        });
        var after = {};
        switch (type) {
          case "node":
            after.nodes = [addedModel];
            break;
          case "edge":
            after.edges = [addedModel];
            break;
          case "combo":
            after.combos = [addedModel];
            break;
          default:
            break;
        }
        this.pushStack("add", {
          before: {},
          after
        });
      }
      return item;
    };
    AbstractGraph2.prototype.addItems = function(items, stack, sortCombo) {
      if (items === void 0) {
        items = [];
      }
      if (stack === void 0) {
        stack = true;
      }
      if (sortCombo === void 0) {
        sortCombo = true;
      }
      var currentComboSorted = this.get("comboSorted");
      this.set("comboSorted", currentComboSorted && !sortCombo);
      var itemController = this.get("itemController");
      var returnItems = [];
      for (var i2 = 0; i2 < items.length; i2++) {
        var item = items[i2];
        if (item.type !== "edge" && item.type !== "vedge") {
          returnItems.push(this.innerAddItem(item.type, item.model, itemController));
        } else {
          returnItems.push(void 0);
        }
      }
      for (var i2 = 0; i2 < items.length; i2++) {
        var item = items[i2];
        if (item.type === "edge" || item.type === "vedge") {
          returnItems[i2] = this.innerAddItem(item.type, item.model, itemController);
        }
      }
      if (sortCombo) {
        var combos = this.get("combos");
        if (combos && combos.length > 0) {
          this.sortCombos();
        }
      }
      this.autoPaint();
      if (stack && this.get("enabledStack")) {
        var after = {
          nodes: [],
          edges: [],
          combos: []
        };
        for (var i2 = 0; i2 < items.length; i2++) {
          var type = items[i2].type;
          var returnItem = returnItems[i2];
          if (!!returnItem && returnItem !== true) {
            var addedModel = __assign(__assign({}, returnItem.getModel()), {
              itemType: type
            });
            switch (type) {
              case "node":
                after.nodes.push(addedModel);
                break;
              case "edge":
                after.edges.push(addedModel);
                break;
              case "combo":
                after.combos.push(addedModel);
                break;
              default:
                break;
            }
          }
        }
        this.pushStack("addItems", {
          before: {},
          after
        });
      }
      return returnItems;
    };
    AbstractGraph2.prototype.add = function(type, model, stack, sortCombo) {
      if (stack === void 0) {
        stack = true;
      }
      if (sortCombo === void 0) {
        sortCombo = true;
      }
      return this.addItem(type, model, stack, sortCombo);
    };
    AbstractGraph2.prototype.updateItem = function(item, cfg, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = true;
      }
      var itemController = this.get("itemController");
      var currentItem;
      if (is_string_default(item)) {
        currentItem = this.findById(item);
      } else {
        currentItem = item;
      }
      var stackEnabled = stack && this.get("enabledStack");
      var unupdatedModel;
      if (stackEnabled) {
        unupdatedModel = clone_default(currentItem.getModel());
      }
      var type = "";
      if (currentItem.getType)
        type = currentItem.getType();
      var states = __spreadArray([], currentItem.getStates(), true);
      if (type === "combo") {
        each_default(states, function(state) {
          return _this.setItemState(currentItem, state, false);
        });
      }
      itemController.updateItem(currentItem, cfg);
      if (type === "combo") {
        each_default(states, function(state) {
          return _this.setItemState(currentItem, state, true);
        });
      }
      if (stackEnabled) {
        var before = {
          nodes: [],
          edges: [],
          combos: []
        };
        var after = {
          nodes: [],
          edges: [],
          combos: []
        };
        var afterModel = __assign({
          id: unupdatedModel.id
        }, cfg);
        switch (type) {
          case "node":
            before.nodes.push(unupdatedModel);
            after.nodes.push(afterModel);
            break;
          case "edge":
            before.edges.push(unupdatedModel);
            after.edges.push(afterModel);
            break;
          case "combo":
            before.combos.push(unupdatedModel);
            after.combos.push(afterModel);
            break;
          default:
            break;
        }
        this.pushStack("update", {
          before,
          after
        });
      }
    };
    AbstractGraph2.prototype.update = function(item, cfg, stack) {
      if (stack === void 0) {
        stack = true;
      }
      this.updateItem(item, cfg, stack);
    };
    AbstractGraph2.prototype.setItemState = function(item, state, value) {
      if (is_string_default(item)) {
        item = this.findById(item);
      }
      var itemController = this.get("itemController");
      itemController.setItemState(item, state, value);
      var stateController = this.get("stateController");
      stateController.updateState(item, state, value);
    };
    AbstractGraph2.prototype.priorityState = function(item, state) {
      var itemController = this.get("itemController");
      itemController.priorityState(item, state);
    };
    AbstractGraph2.prototype.data = function(data) {
      dataValidation(data);
      this.set("data", data);
    };
    AbstractGraph2.prototype.render = function() {
      var self2 = this;
      this.set("comboSorted", false);
      var data = this.get("data");
      if (this.get("enabledStack")) {
        this.clearStack();
      }
      if (!data) {
        throw new Error("data must be defined first");
      }
      var _a2 = data.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = data.edges, edges = _b === void 0 ? [] : _b, _c = data.combos, combos = _c === void 0 ? [] : _c;
      this.clear(true);
      this.emit("beforerender");
      self2.addItems(nodes.map(function(node) {
        return {
          type: "node",
          model: node
        };
      }), false, false);
      if ((combos === null || combos === void 0 ? void 0 : combos.length) !== 0) {
        var comboTrees = plainCombosToTrees(combos, nodes);
        this.set("comboTrees", comboTrees);
        self2.addCombos(combos);
      }
      self2.addItems(edges.map(function(edge) {
        return {
          type: "edge",
          model: edge
        };
      }), false, false);
      var animate = self2.get("animate");
      if (self2.get("fitView") || self2.get("fitCenter")) {
        self2.set("animate", false);
      }
      var layoutController = self2.get("layoutController");
      if (layoutController) {
        layoutController.layout(success);
        if (this.destroyed)
          return;
      } else {
        success();
      }
      function success() {
        (self2.get("comboTrees") || []).forEach(function(ctree) {
          traverseTreeUp(ctree, function(child) {
            var item = self2.findById(child.id);
            if (item.getType() === "combo" && child.collapsed) {
              self2.collapseCombo(child.id, false);
              self2.updateCombo(item);
            }
            return true;
          });
        });
        if (self2.get("fitView")) {
          self2.fitView();
        } else if (self2.get("fitCenter")) {
          self2.fitCenter();
        }
        self2.autoPaint();
        self2.emit("afterrender");
        if (self2.get("fitView") || self2.get("fitCenter")) {
          self2.set("animate", animate);
        }
        setTimeout(function() {
          var _a3;
          (_a3 = self2.getCombos()) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(combo) {
            combo.set("animate", true);
          });
        }, 0);
      }
      if (!this.get("groupByTypes")) {
        if (combos && combos.length !== 0) {
          this.sortCombos();
        } else {
          if (data.nodes && data.edges && data.nodes.length < data.edges.length) {
            var nodesArr = this.getNodes();
            nodesArr.forEach(function(node) {
              node.toFront();
            });
          } else {
            var edgesArr = this.getEdges();
            edgesArr.forEach(function(edge) {
              edge.toBack();
            });
          }
        }
      }
    };
    AbstractGraph2.prototype.read = function(data) {
      this.data(data);
      this.render();
    };
    AbstractGraph2.prototype.diffItems = function(type, items, models) {
      var self2 = this;
      var item;
      var itemMap = this.get("itemMap");
      each_default(models, function(model) {
        item = itemMap[model.id];
        if (item) {
          if (self2.get("animate") && type === NODE2) {
            var containerMatrix = item.getContainer().getMatrix();
            if (!containerMatrix)
              containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            item.set("originAttrs", {
              x: containerMatrix[6],
              y: containerMatrix[7]
            });
          }
          self2.updateItem(item, model, false);
        } else {
          item = self2.addItem(type, model, false);
        }
        if (item)
          items["".concat(type, "s")].push(item);
      });
    };
    AbstractGraph2.prototype.changeData = function(propsData, stack) {
      var _this = this;
      var _a2;
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      var data = propsData || self2.get("data");
      if (!dataValidation(data)) {
        return this;
      }
      this.emit("beforechangedata");
      if (stack && this.get("enabledStack")) {
        this.pushStack("changedata", {
          before: self2.save(),
          after: data
        });
      }
      this.set("comboSorted", false);
      this.removeHulls();
      this.getNodes().map(function(node) {
        return self2.clearItemStates(node);
      });
      this.getEdges().map(function(edge) {
        return self2.clearItemStates(edge);
      });
      var canvas = this.get("canvas");
      var localRefresh = canvas.get("localRefresh");
      canvas.set("localRefresh", false);
      if (!self2.get("data")) {
        self2.data(data);
        self2.render();
      }
      var itemMap = this.get("itemMap");
      var items = {
        nodes: [],
        edges: []
      };
      var combosData = data.combos;
      if (combosData) {
        var comboTrees = plainCombosToTrees(combosData, data.nodes);
        this.set("comboTrees", comboTrees);
      } else {
        this.set("comboTrees", []);
      }
      this.diffItems("node", items, data.nodes);
      each_default(itemMap, function(item, id) {
        itemMap[id].getModel().depth = 0;
        if (item.getType && item.getType() === "edge")
          return;
        if (item.getType && item.getType() === "combo") {
          delete itemMap[id];
          item.destroy();
        } else if (items.nodes.indexOf(item) < 0) {
          delete itemMap[id];
          self2.remove(item, false);
        }
      });
      var comboItems = this.getCombos();
      var combosLength = comboItems.length;
      for (var i2 = combosLength - 1; i2 >= 0; i2--) {
        if (comboItems[i2].destroyed) {
          comboItems.splice(i2, 1);
        }
      }
      if (combosData) {
        self2.addCombos(combosData);
        if (!this.get("groupByTypes")) {
          this.sortCombos();
        }
      }
      this.diffItems("edge", items, data.edges);
      each_default(itemMap, function(item, id) {
        if (item.getType && (item.getType() === "node" || item.getType() === "combo"))
          return;
        if (items.edges.indexOf(item) < 0) {
          delete itemMap[id];
          self2.remove(item, false);
        }
      });
      (this.get("comboTrees") || []).forEach(function(ctree) {
        traverseTreeUp(ctree, function(child) {
          var item = _this.findById(child.id);
          if (item.getType() === "combo" && child.collapsed) {
            _this.collapseCombo(child.id, false);
          }
          return true;
        });
      });
      this.set({
        nodes: items.nodes,
        edges: items.edges
      });
      var layoutController = this.get("layoutController");
      if (layoutController) {
        layoutController.changeData(function() {
          setTimeout(function() {
            var _a3;
            (_a3 = self2.getCombos()) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(combo) {
              combo.set("animate", true);
            });
          }, 0);
        });
        if (self2.get("animate") && !layoutController.getLayoutType()) {
          self2.positionsAnimate();
          (_a2 = self2.getCombos()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(combo) {
            return combo.set("animate", true);
          });
        } else {
          self2.autoPaint();
        }
      }
      setTimeout(function() {
        canvas.set("localRefresh", localRefresh);
      }, 16);
      this.set("data", data);
      this.emit("afterchangedata");
      return this;
    };
    AbstractGraph2.prototype.addCombos = function(combos) {
      var self2 = this;
      var comboTrees = self2.get("comboTrees");
      var itemController = this.get("itemController");
      itemController.addCombos(comboTrees, combos);
    };
    AbstractGraph2.prototype.createCombo = function(combo, childrenIds, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = true;
      }
      var itemController = this.get("itemController");
      this.set("comboSorted", false);
      var comboId = "";
      var comboConfig;
      if (!combo)
        return;
      if (is_string_default(combo)) {
        comboId = combo;
        comboConfig = {
          id: combo
        };
      } else {
        comboId = combo.id;
        if (!comboId) {
          console.warn("Create combo failed. Please assign a unique string id for the adding combo.");
          return;
        }
        comboConfig = combo;
      }
      var shouldStack = stack && this.get("enabledStack");
      var childrenParentCache = {
        nodes: [],
        combos: []
      };
      if (shouldStack) {
        childrenIds.forEach(function(childId) {
          var childItem = _this.findById(childId);
          var childType = childItem.getType();
          if (childType !== "node" && childType !== "combo")
            return;
          var childModel = childItem.getModel();
          childrenParentCache["".concat(childType, "s")].push({
            id: childId,
            parentId: childType === "node" ? childModel.comboId : childModel.parentId
          });
        });
      }
      var comboTrees = this.get("comboTrees");
      var childrenIdsSet = new Set(childrenIds);
      var pulledComboTreesById = /* @__PURE__ */ new Map();
      if (comboTrees) {
        comboTrees.forEach(function(ctree) {
          traverseTreeUp(ctree, function(treeNode, parentTreeNode, index2) {
            if (childrenIdsSet.has(treeNode.id)) {
              if (parentTreeNode) {
                var parentItem = _this.findById(parentTreeNode.id);
                var item = _this.findById(treeNode.id);
                parentTreeNode.children.splice(index2, 1);
                parentItem.removeChild(item);
                itemController.updateCombo(parentItem, parentTreeNode.children);
              }
              if (treeNode.itemType === "combo") {
                pulledComboTreesById.set(treeNode.id, treeNode);
              }
            }
            return true;
          });
        });
        comboTrees = comboTrees.filter(function(ctree) {
          return !childrenIdsSet.has(ctree.id);
        });
        this.set("comboTrees", comboTrees);
      }
      var newChildrenParent = {
        nodes: [],
        combos: []
      };
      var trees = childrenIds.map(function(elementId) {
        var item = _this.findById(elementId);
        var model = item.getModel();
        var type = "";
        if (item.getType)
          type = item.getType();
        var cItem = pulledComboTreesById.get(elementId) || {
          id: item.getID(),
          itemType: type
        };
        if (type === "combo") {
          cItem.parentId = comboId;
          model.parentId = comboId;
        } else if (type === "node") {
          cItem.comboId = comboId;
          model.comboId = comboId;
        }
        if (shouldStack) {
          newChildrenParent["".concat(type, "s")].push({
            id: model.id,
            parentId: comboId
          });
        }
        return cItem;
      });
      comboConfig.children = trees;
      this.addItem("combo", comboConfig, false);
      this.set("comboSorted", false);
      if (comboTrees) {
        comboTrees.forEach(function(ctree) {
          traverseTree(ctree, function(treeNode) {
            if (treeNode.id === comboId) {
              treeNode.itemType = "combo";
              treeNode.children = trees;
              return false;
            }
            return true;
          });
        });
        this.sortCombos();
      }
      if (shouldStack) {
        newChildrenParent.combos.push(comboConfig);
        this.pushStack("createCombo", {
          before: childrenParentCache,
          after: newChildrenParent
        });
      }
    };
    AbstractGraph2.prototype.uncombo = function(combo, stack) {
      var _this = this;
      var _a2, _b;
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      var comboItem = combo;
      if (is_string_default(combo)) {
        comboItem = this.findById(combo);
      }
      if (!comboItem || comboItem.getType && comboItem.getType() !== "combo") {
        console.warn("The item is not a combo!");
        return;
      }
      var comboModel = comboItem.getModel();
      var parentId = comboItem.getModel().parentId;
      var comboTrees = self2.get("comboTrees");
      if (!comboTrees)
        comboTrees = [];
      var itemMap = this.get("itemMap");
      var comboId = comboItem.get("id");
      var treeToBeUncombo;
      var brothers = [];
      var comboItems = this.get("combos");
      var parentItem = this.findById(parentId);
      var shouldStack = stack && this.get("enabledStack");
      var comboConfig = {};
      if (shouldStack) {
        comboConfig = clone_default(comboModel);
        comboConfig.children = [];
      }
      comboTrees.forEach(function(ctree) {
        if (treeToBeUncombo)
          return;
        traverseTreeUp(ctree, function(subtree) {
          var _a3;
          if (subtree.id === comboId) {
            treeToBeUncombo = subtree;
            var edgeIds = comboItem.getEdges().map(function(edge) {
              return edge.getID();
            });
            edgeIds.forEach(function(edgeId) {
              _this.removeItem(edgeId, false);
            });
            var index3 = comboItems.indexOf(comboItem);
            comboItems.splice(index3, 1);
            delete itemMap[comboId];
            var itemModel = clone_default(comboItem.getModel());
            comboItem.destroy();
            _this.emit("afterremoveitem", {
              item: itemModel,
              type: "combo"
            });
          }
          if (parentId && treeToBeUncombo && subtree.id === parentId) {
            parentItem.removeCombo(comboItem);
            brothers = subtree.children;
            var index3 = brothers.indexOf(treeToBeUncombo);
            if (index3 !== -1) {
              brothers.splice(index3, 1);
            }
            (_a3 = treeToBeUncombo.children) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(child) {
              var item = _this.findById(child.id);
              var childModel = item.getModel();
              if (item.getType && item.getType() === "combo") {
                child.parentId = parentId;
                delete child.comboId;
                childModel.parentId = parentId;
                delete childModel.comboId;
              } else if (item.getType && item.getType() === "node") {
                child.comboId = parentId;
                childModel.comboId = parentId;
              }
              parentItem.addChild(item);
              brothers.push(child);
            });
            _this.updateCombo(parentItem);
            return false;
          }
          return true;
        });
      });
      if (!parentId && treeToBeUncombo) {
        var index2 = comboTrees.indexOf(treeToBeUncombo);
        comboTrees.splice(index2, 1);
        (_a2 = treeToBeUncombo.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          child.parentId = void 0;
          var childModel = _this.findById(child.id).getModel();
          delete childModel.parentId;
          delete childModel.comboId;
          if (child.itemType !== "node")
            comboTrees.push(child);
        });
      }
      if (shouldStack) {
        var childrenParentCache_1 = {
          nodes: [],
          combos: []
        };
        var childNewParent_1 = {
          nodes: [],
          combos: []
        };
        (_b = treeToBeUncombo.children) === null || _b === void 0 ? void 0 : _b.forEach(function(child) {
          var childItem = _this.findById(child.id);
          var childType = childItem.getType();
          if (childType !== "node" && childType !== "combo")
            return;
          childrenParentCache_1["".concat(childType, "s")].push({
            id: child.id,
            parentId: comboId
          });
          childNewParent_1["".concat(childType, "s")].push({
            id: child.id,
            parentId
          });
        });
        childrenParentCache_1.combos.push(comboConfig);
        this.pushStack("uncombo", {
          before: childrenParentCache_1,
          after: childNewParent_1
        });
      }
    };
    AbstractGraph2.prototype.updateCombos = function(followCombo) {
      var _this = this;
      if (followCombo === void 0) {
        followCombo = false;
      }
      var self2 = this;
      var comboTrees = this.get("comboTrees");
      var itemController = self2.get("itemController");
      var itemMap = self2.get("itemMap");
      (comboTrees || []).forEach(function(ctree) {
        traverseTreeUp(ctree, function(child) {
          var _a2;
          if (!child) {
            return true;
          }
          var childItem = itemMap[child.id];
          if (((_a2 = childItem === null || childItem === void 0 ? void 0 : childItem.getType) === null || _a2 === void 0 ? void 0 : _a2.call(childItem)) === "combo") {
            var states = __spreadArray([], childItem.getStates(), true);
            each_default(states, function(state) {
              return _this.setItemState(childItem, state, false);
            });
            itemController.updateCombo(childItem, child.children, followCombo);
            each_default(states, function(state) {
              return _this.setItemState(childItem, state, true);
            });
          }
          return true;
        });
      });
      self2.sortCombos();
    };
    AbstractGraph2.prototype.updateCombo = function(combo) {
      var _this = this;
      var self2 = this;
      var comboItem = combo;
      var comboId;
      if (is_string_default(combo)) {
        comboItem = this.findById(combo);
      }
      if (!comboItem || comboItem.getType && comboItem.getType() !== "combo") {
        console.warn("The item to be updated is not a combo!");
        return;
      }
      comboId = comboItem.get("id");
      var comboTrees = this.get("comboTrees");
      var itemController = self2.get("itemController");
      var itemMap = self2.get("itemMap");
      (comboTrees || []).forEach(function(ctree) {
        traverseTreeUp(ctree, function(child) {
          if (!child) {
            return true;
          }
          var childItem = itemMap[child.id];
          if (comboId === child.id && childItem && childItem.getType && childItem.getType() === "combo") {
            var states = __spreadArray([], childItem.getStates(), true);
            each_default(states, function(state) {
              if (childItem.getStateStyle(state)) {
                _this.setItemState(childItem, state, false);
              }
            });
            itemController.updateCombo(childItem, child.children);
            each_default(states, function(state) {
              if (childItem.getStateStyle(state)) {
                _this.setItemState(childItem, state, true);
              }
            });
            if (comboId)
              comboId = child.parentId;
          }
          return true;
        });
      });
    };
    AbstractGraph2.prototype.updateComboTree = function(item, parentId, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      this.set("comboSorted", false);
      var uItem;
      if (is_string_default(item)) {
        uItem = self2.findById(item);
      } else {
        uItem = item;
      }
      var model = uItem.getModel();
      var oldParentId = model.comboId || model.parentId;
      var type = "";
      if (uItem.getType)
        type = uItem.getType();
      if (parentId && type === "combo") {
        var comboTrees = this.get("comboTrees");
        var valid_1 = true;
        var itemSubTree_1;
        (comboTrees || []).forEach(function(ctree) {
          if (itemSubTree_1)
            return;
          traverseTree(ctree, function(subTree) {
            if (itemSubTree_1)
              return;
            if (subTree.id === uItem.getID()) {
              itemSubTree_1 = subTree;
            }
            return true;
          });
        });
        traverseTree(itemSubTree_1, function(subTree) {
          if (subTree.id === parentId) {
            valid_1 = false;
            return false;
          }
          return true;
        });
        if (!valid_1) {
          console.warn("Failed to update the combo tree! The parentId points to a descendant of the combo!");
          return;
        }
      }
      if (stack && this.get("enabledStack")) {
        var beforeData = {}, afterData = {};
        if (type === "combo") {
          beforeData.combos = [{
            id: model.id,
            parentId: model.parentId
          }];
          afterData.combos = [{
            id: model.id,
            parentId
          }];
        } else if (type === "node") {
          beforeData.nodes = [{
            id: model.id,
            parentId: model.comboId
          }];
          afterData.nodes = [{
            id: model.id,
            parentId
          }];
        }
        this.pushStack("updateComboTree", {
          before: beforeData,
          after: afterData
        });
      }
      if (model.parentId || model.comboId) {
        var combo = this.findById(model.parentId || model.comboId);
        if (combo) {
          combo.removeChild(uItem);
        }
      }
      if (type === "combo") {
        model.parentId = parentId;
      } else if (type === "node") {
        model.comboId = parentId;
      }
      if (parentId) {
        var parentCombo = this.findById(parentId);
        if (parentCombo) {
          parentCombo.addChild(uItem);
        }
      }
      if (oldParentId) {
        var parentCombo = this.findById(oldParentId);
        if (parentCombo) {
          parentCombo.removeChild(uItem);
        }
      }
      var newComboTrees = reconstructTree(this.get("comboTrees"), model.id, parentId);
      this.set("comboTrees", newComboTrees);
      this.updateCombos();
    };
    AbstractGraph2.prototype.save = function() {
      var nodes = [];
      var edges = [];
      var combos = [];
      each_default(this.get("nodes"), function(node) {
        nodes.push(node.getModel());
      });
      each_default(this.get("edges"), function(edge) {
        edges.push(edge.getModel());
      });
      each_default(this.get("combos"), function(combo) {
        combos.push(combo.getModel());
      });
      return {
        nodes,
        edges,
        combos
      };
    };
    AbstractGraph2.prototype.changeSize = function(width, height) {
      var viewController = this.get("viewController");
      viewController.changeSize(width, height);
      return this;
    };
    AbstractGraph2.prototype.refresh = function() {
      var self2 = this;
      self2.emit("beforegraphrefresh");
      if (self2.get("animate")) {
        self2.positionsAnimate();
      } else {
        var nodes = self2.get("nodes");
        var edges = self2.get("edges");
        var vedges = self2.get("edges");
        each_default(nodes, function(node) {
          node.refresh();
        });
        each_default(edges, function(edge) {
          edge.refresh();
        });
        each_default(vedges, function(vedge) {
          vedge.refresh();
        });
      }
      self2.emit("aftergraphrefresh");
      self2.autoPaint();
    };
    AbstractGraph2.prototype.getNodes = function() {
      return this.get("nodes");
    };
    AbstractGraph2.prototype.getEdges = function() {
      return this.get("edges");
    };
    AbstractGraph2.prototype.getCombos = function() {
      return this.get("combos");
    };
    AbstractGraph2.prototype.getComboChildren = function(combo) {
      if (is_string_default(combo)) {
        combo = this.findById(combo);
      }
      if (!combo || combo.getType && combo.getType() !== "combo") {
        console.warn("The combo does not exist!");
        return;
      }
      return combo.getChildren();
    };
    AbstractGraph2.prototype.positionsAnimate = function(referComboModel) {
      var self2 = this;
      self2.emit("beforeanimate");
      var animateCfg = self2.get("animateCfg");
      var onFrame = animateCfg.onFrame;
      var nodes = referComboModel ? self2.getNodes().concat(self2.getCombos()) : self2.getNodes();
      var toNodes = nodes.map(function(node) {
        var model = node.getModel();
        return {
          id: model.id,
          x: model.x,
          y: model.y
        };
      });
      self2.stopAnimate();
      var canvas = self2.get("canvas");
      self2.animating = true;
      canvas.animate(function(ratio) {
        each_default(toNodes, function(data) {
          var node = self2.findById(data.id);
          if (!node || node.destroyed) {
            return;
          }
          var originAttrs = node.get("originAttrs");
          var model = node.get("model");
          var containerMatrix = node.getContainer().getMatrix();
          if (originAttrs === void 0 || originAttrs === null) {
            if (containerMatrix) {
              originAttrs = {
                x: containerMatrix[6],
                y: containerMatrix[7]
              };
            }
            node.set("originAttrs", originAttrs || 0);
          }
          if (onFrame) {
            var attrs = onFrame(node, ratio, data, originAttrs || {
              x: 0,
              y: 0
            });
            node.set("model", Object.assign(model, attrs));
          } else if (originAttrs) {
            model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;
            model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;
          } else {
            model.x = data.x;
            model.y = data.y;
          }
        });
        self2.refreshPositions(referComboModel);
      }, {
        duration: animateCfg.duration,
        easing: animateCfg.easing,
        callback: function callback() {
          each_default(nodes, function(node) {
            node.set("originAttrs", null);
          });
          if (animateCfg.callback) {
            animateCfg.callback();
          }
          self2.emit("afteranimate");
          self2.animating = false;
        }
      });
    };
    AbstractGraph2.prototype.refreshPositions = function(referComboModel) {
      var self2 = this;
      self2.emit("beforegraphrefreshposition");
      var nodes = self2.get("nodes");
      var edges = self2.get("edges");
      var vedges = self2.get("vedges");
      var combos = self2.get("combos");
      var model;
      var updatedNodes = {};
      var updateItems = function updateItems2(items) {
        each_default(items, function(item) {
          model = item.getModel();
          var originAttrs = item.get("originAttrs");
          if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {
            return;
          }
          var changed = item.updatePosition({
            x: model.x,
            y: model.y
          });
          updatedNodes[model.id] = changed;
          if (model.comboId)
            updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;
          if (model.parentId)
            updatedNodes[model.parentId] = updatedNodes[model.parentId] || changed;
        });
      };
      updateItems(combos);
      updateItems(nodes);
      if (combos && combos.length !== 0) {
        if (referComboModel) {
          updateItems(combos);
          self2.updateCombos();
        } else {
          self2.updateCombos();
        }
      }
      each_default(edges, function(edge) {
        var sourceModel = edge.getSource().getModel();
        var target = edge.getTarget();
        if (!is_plain_object_default(target)) {
          var targetModel = target.getModel();
          if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {
            edge.refresh();
          }
        }
      });
      each_default(vedges, function(vedge) {
        vedge.refresh();
      });
      self2.emit("aftergraphrefreshposition");
      self2.autoPaint();
    };
    AbstractGraph2.prototype.stopAnimate = function() {
      if (this.isAnimating()) {
        this.get("canvas").stopAnimate();
      }
    };
    AbstractGraph2.prototype.isAnimating = function() {
      return this.animating;
    };
    AbstractGraph2.prototype.getZoom = function() {
      var matrix = this.get("group").getMatrix();
      return matrix ? matrix[0] : 1;
    };
    AbstractGraph2.prototype.getCurrentMode = function() {
      var modeController = this.get("modeController");
      return modeController.getMode();
    };
    AbstractGraph2.prototype.setMode = function(mode) {
      var modeController = this.get("modeController");
      modeController.setMode(mode);
      return this;
    };
    AbstractGraph2.prototype.clear = function(avoidEmit) {
      var _a2;
      if (avoidEmit === void 0) {
        avoidEmit = false;
      }
      (_a2 = this.get("canvas")) === null || _a2 === void 0 ? void 0 : _a2.clear();
      this.initGroups();
      this.set({
        itemMap: {},
        nodes: [],
        edges: [],
        vedges: [],
        groups: [],
        combos: [],
        comboTrees: []
      });
      if (!avoidEmit)
        this.emit("afterrender");
      return this;
    };
    AbstractGraph2.prototype.updateLayout = function(cfg, align, alignPoint, stack) {
      var _this = this;
      if (cfg === void 0) {
        cfg = {};
      }
      if (stack === void 0) {
        stack = true;
      }
      var layoutController = this.get("layoutController");
      if (is_string_default(cfg)) {
        cfg = {
          type: cfg
        };
      }
      if (align) {
        var toPoint_1 = alignPoint;
        if (!toPoint_1) {
          if (align === "begin")
            toPoint_1 = {
              x: 0,
              y: 0
            };
          else
            toPoint_1 = {
              x: this.getWidth() / 2,
              y: this.getHeight() / 2
            };
        }
        toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);
        var forceTypes = ["force", "gForce", "fruchterman", "force2"];
        if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {
          cfg.center = [toPoint_1.x, toPoint_1.y];
        } else {
          this.once("afterlayout", function(e8) {
            var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
            toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];
            toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];
            var _a2 = _this.getGroup().getCanvasBBox(), minX = _a2.minX, maxX = _a2.maxX, minY = _a2.minY, maxY = _a2.maxY;
            var bboxPoint = {
              x: (minX + maxX) / 2,
              y: (minY + maxY) / 2
            };
            if (align === "begin") {
              bboxPoint.x = minX;
              bboxPoint.y = minY;
            }
            _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);
          });
        }
      }
      var oriLayoutCfg = __assign({}, this.get("layout"));
      var layoutCfg = {};
      Object.assign(layoutCfg, oriLayoutCfg, cfg);
      if (cfg.pipes && !cfg.type)
        delete layoutCfg.type;
      else if (!cfg.pipes && layoutCfg.type)
        delete layoutCfg.pipes;
      this.set("layout", layoutCfg);
      if (!layoutController)
        return;
      if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {
        layoutController.updateLayoutCfg(layoutCfg);
      } else {
        layoutController.changeLayout(layoutCfg);
      }
      if (stack && this.get("enabledStack")) {
        this.pushStack("layout", {
          before: oriLayoutCfg,
          after: layoutCfg
        });
      }
    };
    AbstractGraph2.prototype.destroyLayout = function() {
      var layoutController = this.get("layoutController");
      layoutController === null || layoutController === void 0 ? void 0 : layoutController.destroyLayout();
    };
    AbstractGraph2.prototype.layout = function() {
      var _a2;
      var layoutController = this.get("layoutController");
      var layoutCfg = this.get("layout");
      if (!layoutCfg || !layoutController)
        return;
      if (layoutCfg.workerEnabled) {
        layoutController.layout();
        return;
      }
      if ((_a2 = layoutController.layoutMethods) === null || _a2 === void 0 ? void 0 : _a2.length) {
        layoutController.relayout(true);
      } else {
        layoutController.layout();
      }
    };
    AbstractGraph2.prototype.collapseCombo = function(combo, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = true;
      }
      if (this.destroyed)
        return;
      if (is_string_default(combo)) {
        combo = this.findById(combo);
      }
      if (!combo) {
        console.warn("The combo to be collapsed does not exist!");
        return;
      }
      this.emit("beforecollapseexpandcombo", {
        action: "expand",
        item: combo
      });
      var comboModel = combo.getModel();
      var itemController = this.get("itemController");
      itemController.collapseCombo(combo, stack);
      comboModel.collapsed = true;
      var edges = this.getEdges().concat(this.get("vedges"));
      var cNodesCombos = [];
      var comboTrees = this.get("comboTrees");
      var found = false;
      (comboTrees || []).forEach(function(ctree) {
        if (found)
          return;
        traverseTree(ctree, function(subTree) {
          if (found && subTree.depth <= comboModel.depth)
            return false;
          if (comboModel.id === subTree.id)
            found = true;
          if (found) {
            var item = _this.findById(subTree.id);
            if (item && item.getType && item.getType() === "combo") {
              cNodesCombos = cNodesCombos.concat(item.getNodes());
              cNodesCombos = cNodesCombos.concat(item.getCombos());
            }
          }
          return true;
        });
      });
      var addedVEdgeMap = {};
      edges.forEach(function(edge) {
        var _a2 = edge.getModel(), isVEdge = _a2.isVEdge, _b = _a2.size, size3 = _b === void 0 ? 1 : _b;
        if (edge.isVisible() && !isVEdge)
          return;
        var source = edge.getSource();
        var target = edge.getTarget();
        var otherEnd = null;
        var otherEndIsSource;
        if (source.getModel().id === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {
          otherEnd = target;
          otherEndIsSource = false;
        } else if (target.getModel().id === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {
          otherEnd = source;
          otherEndIsSource = true;
        }
        if (otherEnd) {
          if (isVEdge) {
            _this.removeItem(edge, false);
            return;
          }
          var otherEndModel = otherEnd.getModel();
          while (!otherEnd.isVisible()) {
            var otherEndPId = otherEndModel.parentId, otherEndCId = otherEndModel.comboId;
            var otherEndParentId = otherEndPId || otherEndCId;
            otherEnd = _this.findById(otherEndParentId);
            if (!otherEnd || !otherEndParentId)
              return;
            otherEndModel = otherEnd.getModel();
          }
          var otherEndId = otherEndModel.id;
          var vEdgeInfo = otherEndIsSource ? {
            source: otherEndId,
            target: comboModel.id,
            size: size3,
            isVEdge: true
          } : {
            source: comboModel.id,
            target: otherEndId,
            size: size3,
            isVEdge: true
          };
          var key = "".concat(vEdgeInfo.source, "-").concat(vEdgeInfo.target);
          if (addedVEdgeMap[key]) {
            addedVEdgeMap[key].size += size3;
            return;
          }
          addedVEdgeMap[key] = vEdgeInfo;
        }
      });
      this.addItems(Object.values(addedVEdgeMap).map(function(edgeInfo) {
        return {
          type: "vedge",
          model: edgeInfo
        };
      }), false);
      this.emit("aftercollapseexpandcombo", {
        action: "collapse",
        item: combo
      });
    };
    AbstractGraph2.prototype.expandCombo = function(combo, stack) {
      var _this = this;
      if (stack === void 0) {
        stack = true;
      }
      if (is_string_default(combo)) {
        combo = this.findById(combo);
      }
      if (!combo || combo.getType && combo.getType() !== "combo") {
        console.warn("The combo to be collapsed does not exist!");
        return;
      }
      this.emit("beforecollapseexpandcombo", {
        action: "expand",
        item: combo
      });
      var comboModel = combo.getModel();
      var itemController = this.get("itemController");
      itemController.expandCombo(combo, stack);
      comboModel.collapsed = false;
      var edges = this.getEdges().concat(this.get("vedges"));
      var cNodesCombos = [];
      var comboTrees = this.get("comboTrees");
      var found = false;
      (comboTrees || []).forEach(function(ctree) {
        if (found)
          return;
        traverseTree(ctree, function(subTree) {
          if (found && subTree.depth <= comboModel.depth)
            return false;
          if (comboModel.id === subTree.id)
            found = true;
          if (found) {
            var item = _this.findById(subTree.id);
            if (item && item.getType && item.getType() === "combo") {
              cNodesCombos = cNodesCombos.concat(item.getNodes());
              cNodesCombos = cNodesCombos.concat(item.getCombos());
            }
          }
          return true;
        });
      });
      var addedVEdgeMap = {};
      edges.forEach(function(edge) {
        if (edge.isVisible() && !edge.getModel().isVEdge)
          return;
        var source = edge.getSource();
        var target = edge.getTarget();
        var sourceId = source.get("id");
        var targetId = target.get("id");
        var otherEnd = null;
        var otherEndIsSource;
        if (sourceId === comboModel.id || cNodesCombos.includes(source) && !cNodesCombos.includes(target)) {
          otherEnd = target;
          otherEndIsSource = false;
        } else if (targetId === comboModel.id || !cNodesCombos.includes(source) && cNodesCombos.includes(target)) {
          otherEnd = source;
          otherEndIsSource = true;
        } else if (cNodesCombos.includes(source) && cNodesCombos.includes(target)) {
          if (source.isVisible() && target.isVisible()) {
            edge.show();
          }
        }
        if (otherEnd) {
          var _a2 = edge.getModel(), isVEdge = _a2.isVEdge, _b = _a2.size, size3 = _b === void 0 ? 1 : _b;
          if (isVEdge) {
            _this.removeItem(edge, false);
            return;
          }
          var otherEndModel = otherEnd.getModel();
          while (!otherEnd.isVisible()) {
            var otherEndPId = otherEndModel.parentId, otherEndCId = otherEndModel.comboId;
            var otherEndParentId = otherEndPId || otherEndCId;
            otherEnd = _this.findById(otherEndParentId);
            if (!otherEnd || !otherEndParentId) {
              return;
            }
            otherEndModel = otherEnd.getModel();
          }
          var otherEndId = otherEndModel.id;
          var selfEnd = otherEndIsSource ? target : source;
          var selfEndModel = selfEnd.getModel();
          while (!selfEnd.isVisible()) {
            var selfEndPId = selfEndModel.parentId, selfEndCId = selfEndModel.comboId;
            var selfEndParentId = selfEndPId || selfEndCId;
            selfEnd = _this.findById(selfEndParentId);
            if (!selfEnd || !selfEndParentId) {
              return;
            }
            if (selfEndModel.comboId === comboModel.id || selfEndModel.parentId === comboModel.id) {
              break;
            }
            selfEndModel = selfEnd.getModel();
          }
          var selfEndId = selfEndModel.id;
          if (otherEndId) {
            var vEdgeInfo = otherEndIsSource ? {
              source: otherEndId,
              target: selfEndId,
              isVEdge: true,
              size: size3
            } : {
              source: selfEndId,
              target: otherEndId,
              isVEdge: true,
              size: size3
            };
            var vedgeId = "".concat(vEdgeInfo.source, "-").concat(vEdgeInfo.target);
            if (addedVEdgeMap[vedgeId]) {
              addedVEdgeMap[vedgeId].size += size3;
              return;
            }
            addedVEdgeMap[vedgeId] = vEdgeInfo;
          }
        }
      });
      this.addItems(Object.values(addedVEdgeMap).map(function(edgeInfo) {
        return {
          type: "vedge",
          model: edgeInfo
        };
      }), false);
      this.emit("aftercollapseexpandcombo", {
        action: "expand",
        item: combo
      });
    };
    AbstractGraph2.prototype.collapseExpandCombo = function(combo, stack) {
      if (stack === void 0) {
        stack = true;
      }
      if (is_string_default(combo)) {
        combo = this.findById(combo);
      }
      if (!combo || combo.getType && combo.getType() !== "combo")
        return;
      var comboModel = combo.getModel();
      var parentItem = this.findById(comboModel.parentId);
      while (parentItem) {
        var parentModel = parentItem.getModel();
        if (parentModel.collapsed) {
          console.warn("Fail to expand the combo since it's ancestor combo is collapsed.");
          parentItem = void 0;
          return;
        }
        parentItem = this.findById(parentModel.parentId);
      }
      var collapsed = comboModel.collapsed;
      if (collapsed) {
        this.expandCombo(combo, stack);
      } else {
        this.collapseCombo(combo, stack);
      }
      this.updateCombo(combo);
    };
    AbstractGraph2.prototype.getNeighbors = function(node, type) {
      var item = node;
      if (is_string_default(node)) {
        item = this.findById(node);
      }
      return item.getNeighbors(type);
    };
    AbstractGraph2.prototype.getNodeDegree = function(node, type, refresh) {
      if (type === void 0) {
        type = void 0;
      }
      if (refresh === void 0) {
        refresh = false;
      }
      var item = node;
      if (is_string_default(node)) {
        item = this.findById(node);
      }
      var degrees = this.get("degrees");
      if (!degrees || refresh) {
        degrees = degree_default(this.save());
        this.set("degrees", degrees);
      }
      var nodeDegrees = degrees[item.getID()];
      var res = 0;
      if (!nodeDegrees) {
        return 0;
      }
      switch (type) {
        case "in":
          res = nodeDegrees.inDegree;
          break;
        case "out":
          res = nodeDegrees.outDegree;
          break;
        case "all":
          res = nodeDegrees;
          break;
        default:
          res = nodeDegrees.degree;
          break;
      }
      return res;
    };
    AbstractGraph2.prototype.getUndoStack = function() {
      return this.undoStack;
    };
    AbstractGraph2.prototype.getRedoStack = function() {
      return this.redoStack;
    };
    AbstractGraph2.prototype.getStackData = function() {
      if (!this.get("enabledStack")) {
        return null;
      }
      return {
        undoStack: this.undoStack.toArray(),
        redoStack: this.redoStack.toArray()
      };
    };
    AbstractGraph2.prototype.clearStack = function() {
      if (this.get("enabledStack")) {
        this.undoStack.clear();
        this.redoStack.clear();
        this.emit("stackchange", {
          undoStack: this.undoStack,
          redoStack: this.redoStack
        });
      }
    };
    AbstractGraph2.prototype.pushStack = function(action, data, stackType) {
      if (action === void 0) {
        action = "update";
      }
      if (stackType === void 0) {
        stackType = "undo";
      }
      if (!this.get("enabledStack")) {
        console.warn("请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !");
        return;
      }
      var stackData = data ? clone_default(data) : {
        before: {},
        after: clone_default(this.save())
      };
      if (stackType === "redo") {
        this.redoStack.push({
          action,
          data: stackData
        });
      } else {
        this.undoStack.push({
          action,
          data: stackData
        });
      }
      this.emit("stackchange", {
        action,
        stackType,
        undoStack: this.undoStack,
        redoStack: this.redoStack
      });
    };
    AbstractGraph2.prototype.getAdjMatrix = function(cache2, directed) {
      if (cache2 === void 0) {
        cache2 = true;
      }
      if (directed === void 0)
        directed = this.get("directed");
      var currentAdjMatrix = this.get("adjMatrix");
      if (!currentAdjMatrix || !cache2) {
        currentAdjMatrix = adjacent_matrix_default(this.save(), directed);
        this.set("adjMatrix", currentAdjMatrix);
      }
      return currentAdjMatrix;
    };
    AbstractGraph2.prototype.getShortestPathMatrix = function(cache2, directed) {
      if (cache2 === void 0) {
        cache2 = true;
      }
      if (directed === void 0)
        directed = this.get("directed");
      var currentAdjMatrix = this.get("adjMatrix");
      var currentShourtestPathMatrix = this.get("shortestPathMatrix");
      if (!currentAdjMatrix || !cache2) {
        currentAdjMatrix = adjacent_matrix_default(this.save(), directed);
        this.set("adjMatrix", currentAdjMatrix);
      }
      if (!currentShourtestPathMatrix || !cache2) {
        currentShourtestPathMatrix = floydWarshall_default(this.save(), directed);
        this.set("shortestPathMatrix", currentShourtestPathMatrix);
      }
      return currentShourtestPathMatrix;
    };
    AbstractGraph2.prototype.on = function(eventName, callback, once) {
      return _super.prototype.on.call(this, eventName, callback, once);
    };
    AbstractGraph2.prototype.destroy = function() {
      var _a2, _b, _c, _d, _e2;
      this.clear();
      this.clearStack();
      (_a2 = this.get("itemController")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.get("modeController")) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.get("viewController")) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.get("stateController")) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e2 = this.get("canvas")) === null || _e2 === void 0 ? void 0 : _e2.destroy();
      this.cfg = null;
      this.destroyed = true;
      this.redoStack = null;
      this.undoStack = null;
    };
    AbstractGraph2.prototype.createHull = function(cfg) {
      if (!cfg.members || cfg.members.length < 1) {
        console.warn("Create hull failed! The members is empty.");
        return;
      }
      var parent = this.get("hullGroup");
      var hullMap = this.get("hullMap");
      if (!hullMap) {
        hullMap = {};
        this.set("hullMap", hullMap);
      }
      if (!parent || parent.get("destroyed")) {
        parent = this.get("group").addGroup({
          id: "hullGroup"
        });
        parent.toBack();
        this.set("hullGroup", parent);
      }
      if (hullMap[cfg.id]) {
        console.warn("Existed hull id.");
        return hullMap[cfg.id];
      }
      var group = parent.addGroup({
        id: "".concat(cfg.id, "-container")
      });
      var hull = new hull_default(this, __assign(__assign({}, cfg), {
        group
      }));
      var hullId = hull.id;
      hullMap[hullId] = hull;
      return hull;
    };
    AbstractGraph2.prototype.getHulls = function() {
      return this.get("hullMap");
    };
    AbstractGraph2.prototype.getHullById = function(hullId) {
      return this.get("hullMap")[hullId];
    };
    AbstractGraph2.prototype.removeHull = function(hull) {
      var _a2;
      var hullInstance;
      if (is_string_default(hull)) {
        hullInstance = this.getHullById(hull);
      } else {
        hullInstance = hull;
      }
      (_a2 = this.get("hullMap")) === null || _a2 === void 0 ? true : delete _a2[hullInstance.id];
      hullInstance.destroy();
    };
    AbstractGraph2.prototype.removeHulls = function() {
      var hulls = this.getHulls();
      if (!hulls || !Object.keys(hulls).length)
        return;
      Object.keys(hulls).forEach(function(key) {
        var hull = hulls[key];
        hull.destroy();
      });
      this.set("hullMap", {});
    };
    return AbstractGraph2;
  }(esm_default)
);
var graph_default = AbstractGraph;

// node_modules/@antv/g6-core/es/element/node.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-core/es/element/shapeBase.js
init_tslib_es6();
init_esm();
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
var transform4 = ext_exports.transform;
var CLS_SHAPE_SUFFIX = "-shape";
var CLS_LABEL_SUFFIX = "-label";
var ARROWS = ["startArrow", "endArrow"];
var SHAPE_DEFAULT_ATTRS = {
  lineWidth: 1,
  stroke: void 0,
  fill: void 0,
  lineAppendWidth: 1,
  opacity: void 0,
  strokeOpacity: void 0,
  fillOpacity: void 0,
  x: 0,
  y: 0,
  r: 10,
  width: 20,
  height: 20,
  shadowColor: void 0,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var PATH_SHAPE_DEFAULT_ATTRS = {
  lineWidth: 1,
  stroke: "#000",
  lineDash: void 0,
  startArrow: false,
  endArrow: false,
  opacity: void 0,
  strokeOpacity: void 0,
  fillOpacity: void 0,
  shadowColor: void 0,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var SHAPES_DEFAULT_ATTRS = {
  edge: PATH_SHAPE_DEFAULT_ATTRS,
  node: SHAPE_DEFAULT_ATTRS,
  combo: SHAPE_DEFAULT_ATTRS
};
var CLS_LABEL_BG_SUFFIX = "-label-bg";
var shapeBase = {
  // 默认样式及配置
  options: {
    labelCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    },
    descriptionCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    }
  },
  itemType: "",
  /**
   * 形状的类型，例如 circle，ellipse，polyline...
   */
  type: "",
  getCustomConfig: function getCustomConfig(cfg) {
    return {};
  },
  getOptions: function getOptions(cfg, updateType) {
    if (updateType === "move" || (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox")))
      return cfg;
    return deep_mix_default({}, this.options, this.getCustomConfig(cfg) || {}, cfg);
  },
  /**
   * 绘制节点/边，包含文本
   * @override
   * @param  {Object} cfg 节点的配置项
   * @param  {G.Group} group 节点的容器
   * @return {IShape} 绘制的图形
   */
  draw: function draw3(cfg, group) {
    group["shapeMap"] = {};
    this.mergeStyle = this.getOptions(cfg);
    var shape = this.drawShape(cfg, group);
    shape.set("className", this.itemType + CLS_SHAPE_SUFFIX);
    group["shapeMap"][this.itemType + CLS_SHAPE_SUFFIX] = shape;
    if (cfg.label) {
      var label = this.drawLabel(cfg, group);
      label.set("className", this.itemType + CLS_LABEL_SUFFIX);
      group["shapeMap"][this.itemType + CLS_LABEL_SUFFIX] = label;
    }
    return shape;
  },
  /**
   * 绘制完成后的操作，便于用户继承现有的节点、边
   * @param cfg
   * @param group
   * @param keyShape
   */
  afterDraw: function afterDraw2(cfg, group, keyShape) {
  },
  drawShape: function drawShape2(cfg, group) {
    return null;
  },
  drawLabel: function drawLabel(cfg, group) {
    var defaultLabelCfg = (this.mergeStyle || this.getOptions(cfg) || {}).labelCfg;
    var labelCfg = defaultLabelCfg || {};
    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);
    var rotate3 = labelStyle.rotate;
    delete labelStyle.rotate;
    var label = group.addShape("text", {
      attrs: labelStyle,
      draggable: true,
      className: "text-shape",
      name: "text-shape",
      labelRelated: true
    });
    group["shapeMap"]["text-shape"] = label;
    if (!isNaN(rotate3) && rotate3 !== "") {
      var labelBBox = label.getBBox();
      var labelMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (labelStyle.rotateCenter) {
        switch (labelStyle.rotateCenter) {
          case "center":
            labelMatrix = transform4(labelMatrix, [["t", -labelBBox.width / 2, -labelBBox.height / 2], ["r", rotate3], ["t", labelBBox.width / 2, labelBBox.height / 2]]);
            break;
          case "lefttop":
            labelMatrix = transform4(labelMatrix, [["t", -labelStyle.x, -labelStyle.y], ["r", rotate3], ["t", labelStyle.x, labelStyle.y]]);
            break;
          case "leftcenter":
            labelMatrix = transform4(labelMatrix, [["t", -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ["r", rotate3], ["t", labelStyle.x, labelStyle.y + labelBBox.height / 2]]);
            break;
          default:
            labelMatrix = transform4(labelMatrix, [["t", -labelBBox.width / 2, -labelBBox.height / 2], ["r", rotate3], ["t", labelBBox.width / 2, labelBBox.height / 2]]);
            break;
        }
      } else {
        labelMatrix = transform4(labelMatrix, [["t", -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ["r", rotate3], ["t", labelStyle.x, labelStyle.y + labelBBox.height / 2]]);
      }
      label.setMatrix(labelMatrix);
    }
    if (labelStyle.background) {
      var rect2 = this.drawLabelBg(cfg, group, label);
      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;
      rect2.set("classname", labelBgClassname);
      group["shapeMap"][labelBgClassname] = rect2;
      label.toFront();
    }
    return label;
  },
  drawLabelBg: function drawLabelBg(cfg, group, label) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = mix({}, defaultLabelCfg, cfg.labelCfg);
    var style = this.getLabelBgStyleByPosition(label, labelCfg);
    var rect2 = group.addShape("rect", {
      name: "text-bg-shape",
      attrs: style,
      labelRelated: true
    });
    group["shapeMap"]["text-bg-shape"] = rect2;
    return rect2;
  },
  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {
    return {
      text: cfg.label
    };
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, labelCfg) {
    return {};
  },
  /**
   * 获取文本的配置项
   * @param cfg 节点的配置项
   * @param labelCfg 文本的配置项
   * @param group 父容器，label 的定位可能与图形相关
   */
  getLabelStyle: function getLabelStyle(cfg, labelCfg, group) {
    var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group);
    var attrName = "".concat(this.itemType, "Label");
    var defaultStyle = global_default[attrName] ? global_default[attrName].style : null;
    return __assign(__assign(__assign({}, defaultStyle), calculateStyle), labelCfg.style);
  },
  /**
   * 获取图形的配置项
   * @param cfg
   */
  getShapeStyle: function getShapeStyle(cfg) {
    return cfg.style;
  },
  /**
   * 更新节点，包含文本
   * @override
   * @param  {Object} cfg 节点/边的配置项
   * @param  {G6.Item} item 节点/边
   */
  update: function update(cfg, item, updateType) {
    this.updateShapeStyle(cfg, item, updateType);
    this.updateLabel(cfg, item, updateType);
  },
  updateShapeStyle: function updateShapeStyle(cfg, item, updateType) {
    var _a2;
    var group = item.getContainer();
    var shape = item.getKeyShape();
    var shapeStyle = mix({}, shape.attr(), cfg.style);
    var _loop_1 = function _loop_12(key2) {
      var _b;
      var style = shapeStyle[key2];
      if (is_plain_object_default(style)) {
        var subShape = ((_a2 = group["shapeMap"]) === null || _a2 === void 0 ? void 0 : _a2[key2]) || group.find(function(element) {
          return element.get("name") === key2;
        });
        subShape === null || subShape === void 0 ? void 0 : subShape.attr(style);
      } else {
        shape.attr((_b = {}, _b[key2] = style, _b));
      }
    };
    for (var key in shapeStyle) {
      _loop_1(key);
    }
  },
  updateLabel: function updateLabel(cfg, item, updateType) {
    var _a2, _b;
    if (cfg.label || cfg.label === "") {
      var group = item.getContainer();
      var _c = (this.mergeStyle || this.getOptions({}, updateType) || {}).labelCfg, labelCfg = _c === void 0 ? {} : _c;
      var labelClassName_1 = this.itemType + CLS_LABEL_SUFFIX;
      var label = group["shapeMap"][labelClassName_1] || group.find(function(ele) {
        return ele.get("className") === labelClassName_1;
      });
      var labelBgClassname_1 = this.itemType + CLS_LABEL_BG_SUFFIX;
      var labelBg = group["shapeMap"][labelBgClassname_1] || group.find(function(ele) {
        return ele.get("className") === labelBgClassname_1;
      });
      if (!label) {
        var newLabel = this.drawLabel(cfg, group);
        newLabel.set("className", labelClassName_1);
        group["shapeMap"][labelClassName_1] = newLabel;
      } else {
        if (!updateType || updateType === "bbox|label" || this.itemType === "edge" && updateType !== "style") {
          labelCfg = deep_mix_default(labelCfg, cfg.labelCfg);
        }
        var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group);
        var cfgStyle = (_a2 = cfg.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style;
        var labelStyle = __assign(__assign({}, calculateStyle), cfgStyle);
        var rotate3 = labelStyle.rotate;
        delete labelStyle.rotate;
        if (!isNaN(rotate3) && rotate3 !== "") {
          var rotateMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          rotateMatrix = transform4(rotateMatrix, [["t", -labelStyle.x, -labelStyle.y], ["r", rotate3], ["t", labelStyle.x, labelStyle.y]]);
          labelStyle.matrix = rotateMatrix;
          label.attr(labelStyle);
        } else {
          if (((_b = label.getMatrix()) === null || _b === void 0 ? void 0 : _b[4]) !== 1) {
            label.resetMatrix();
          }
          label.attr(labelStyle);
        }
        if (!labelBg) {
          if (labelStyle.background) {
            labelBg = this.drawLabelBg(cfg, group, label);
            labelBg.set("classname", labelBgClassname_1);
            group["shapeMap"][labelBgClassname_1] = labelBg;
            label.toFront();
          }
        } else if (labelStyle.background) {
          var calculateBgStyle = this.getLabelBgStyleByPosition(label, labelCfg);
          labelBg.attr(calculateBgStyle);
        } else {
          group.removeChild(labelBg);
        }
      }
    }
  },
  // update(cfg, item) // 默认不定义
  afterUpdate: function afterUpdate2(cfg, item) {
  },
  /**
   * 设置节点的状态，主要是交互状态，业务状态请在 draw 方法中实现
   * 单图形的节点仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法
   * @override
   * @param  {String} name 状态名称
   * @param  {String | Boolean} value 状态值
   * @param  {G6.Item} item 节点
   */
  setState: function setState3(name, value, item) {
    var _a2, _b;
    var _c;
    var shape = item.get("keyShape");
    if (!shape || shape.destroyed)
      return;
    var type = item.getType();
    var stateName = is_boolean_default(value) ? name : "".concat(name, ":").concat(value);
    var shapeStateStyle = this.getStateStyle(stateName, item);
    var itemStateStyle = item.getStateStyle(stateName);
    if (!itemStateStyle && !shapeStateStyle) {
      return;
    }
    var styles = mix({}, itemStateStyle || shapeStateStyle);
    var group = item.getContainer();
    var keptAttrs = {
      x: 1,
      y: 1,
      cx: 1,
      cy: 1,
      matrix: 1
    };
    if (type === "combo") {
      keptAttrs.r = 1;
      keptAttrs.width = 1;
      keptAttrs.height = 1;
    }
    if (value) {
      var _loop_2 = function _loop_22(key2) {
        var _d;
        var style = styles[key2];
        if (is_plain_object_default(style) && !ARROWS.includes(key2)) {
          var subShape = ((_c = group["shapeMap"]) === null || _c === void 0 ? void 0 : _c[key2]) || group.find(function(element) {
            return element.get("name") === key2;
          });
          subShape === null || subShape === void 0 ? void 0 : subShape.attr(style);
        } else {
          shape.attr((_d = {}, _d[key2] = style, _d));
        }
      };
      for (var key in styles) {
        _loop_2(key);
      }
    } else {
      var enableStatesStyle = cloneBesidesImg(item.getCurrentStatesStyle());
      var model = item.getModel();
      var originStyle_1 = mix({}, model.style, cloneBesidesImg(item.getOriginStyle()));
      var keyShapeName_1 = shape.get("name");
      var shapeAttrs_1 = shape.attr();
      var keyShapeStyles_1 = {};
      Object.keys(shapeAttrs_1).forEach(function(key2) {
        if (key2 === "img")
          return;
        var attr = shapeAttrs_1[key2];
        if (attr && _typeof2(attr) === "object") {
          keyShapeStyles_1[key2] = clone_default(attr);
        } else {
          keyShapeStyles_1[key2] = attr;
        }
      });
      var filtetDisableStatesStyle = {};
      var _loop_3 = function _loop_32(p3) {
        var style = styles[p3];
        if (is_plain_object_default(style) && !ARROWS.includes(p3)) {
          var subShape_1 = group["shapeMap"][p3] || group.find(function(ele) {
            return ele.get("name") === p3;
          });
          if (subShape_1) {
            var subShapeStyles_1 = cloneBesidesImg(subShape_1.attr());
            each_default(style, function(v2, key2) {
              if (p3 === keyShapeName_1 && keyShapeStyles_1[key2] && !keptAttrs[key2]) {
                delete keyShapeStyles_1[key2];
                var value_1 = originStyle_1[p3][key2] || SHAPES_DEFAULT_ATTRS[type][key2];
                shape.attr(key2, value_1);
              } else if (subShapeStyles_1[key2] || subShapeStyles_1[key2] === 0) {
                delete subShapeStyles_1[key2];
                var value_2 = originStyle_1[p3][key2] || SHAPES_DEFAULT_ATTRS[type][key2];
                subShape_1.attr(key2, value_2);
              }
            });
            filtetDisableStatesStyle[p3] = subShapeStyles_1;
          }
        } else {
          if (keyShapeStyles_1[p3] && !keptAttrs[p3]) {
            delete keyShapeStyles_1[p3];
            var value_3 = originStyle_1[p3] || (originStyle_1[keyShapeName_1] ? originStyle_1[keyShapeName_1][p3] : void 0) || SHAPES_DEFAULT_ATTRS[type][p3];
            shape.attr(p3, value_3);
          }
        }
      };
      for (var p2 in styles) {
        _loop_3(p2);
      }
      if (!keyShapeName_1) {
        mix(filtetDisableStatesStyle, keyShapeStyles_1);
      } else {
        filtetDisableStatesStyle[keyShapeName_1] = keyShapeStyles_1;
      }
      for (var key in enableStatesStyle) {
        if (keptAttrs[key])
          continue;
        var enableStyle = enableStatesStyle[key];
        if (!is_plain_object_default(enableStyle) || ARROWS.includes(key)) {
          if (!keyShapeName_1) {
            mix(originStyle_1, (_a2 = {}, _a2[key] = enableStyle, _a2));
          } else {
            mix(originStyle_1[keyShapeName_1], (_b = {}, _b[key] = enableStyle, _b));
            delete originStyle_1[key];
          }
          delete enableStatesStyle[key];
        }
      }
      var originstyles = {};
      deep_mix_default(originstyles, originStyle_1, filtetDisableStatesStyle, enableStatesStyle);
      var keyShapeSetted = false;
      var _loop_4 = function _loop_42(originKey2) {
        var _e2, _f;
        var style = originstyles[originKey2];
        if (is_plain_object_default(style) && !ARROWS.includes(originKey2)) {
          var subShape = group["shapeMap"][originKey2] || group.find(function(ele) {
            return ele.get("name") === originKey2;
          });
          if (subShape) {
            if (subShape.get("type") === "text" || subShape.get("labelRelated")) {
              delete style.x;
              delete style.y;
              delete style.matrix;
            }
            if (originKey2 === keyShapeName_1) {
              if (type === "combo") {
                delete style.r;
                delete style.width;
                delete style.height;
              }
              keyShapeSetted = true;
            }
            subShape.attr(style);
          }
        } else if (!keyShapeSetted) {
          var value_4 = style || SHAPES_DEFAULT_ATTRS[type][originKey2];
          if (type === "combo") {
            if (!keyShapeName_1) {
              shape.attr((_e2 = {}, _e2[originKey2] = value_4, _e2));
            }
          } else {
            shape.attr((_f = {}, _f[originKey2] = value_4, _f));
          }
        }
      };
      for (var originKey in originstyles) {
        _loop_4(originKey);
      }
    }
  },
  /**
   * 获取不同状态下的样式
   *
   * @param {string} name 状态名称
   * @param {Item} item Node或Edge的实例
   * @return {object} 样式
   */
  getStateStyle: function getStateStyle(name, item) {
    var model = item.getModel();
    var type = item.getType();
    var _a2 = this.getOptions(model), stateStyles = _a2.stateStyles, _b = _a2.style, style = _b === void 0 ? {} : _b;
    var modelStateStyle = model.stateStyles ? model.stateStyles[name] : stateStyles && stateStyles[name];
    if (type === "combo") {
      return clone_default(modelStateStyle);
    }
    return mix({}, style, modelStateStyle);
  },
  /**
   * 获取控制点
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点
   */
  getControlPoints: function getControlPoints3(cfg) {
    return cfg.controlPoints;
  },
  /**
   * 获取控制点
   * @param  {Object} cfg 节点、边的配置项
   * @return {Array|null} 锚点的数组,如果为 null，则没有锚点
   */
  getAnchorPoints: function getAnchorPoints3(cfg) {
    var _a2, _b;
    var anchorPoints = (cfg === null || cfg === void 0 ? void 0 : cfg.anchorPoints) || ((_a2 = this.getCustomConfig(cfg)) === null || _a2 === void 0 ? void 0 : _a2.anchorPoints) || ((_b = this.options) === null || _b === void 0 ? void 0 : _b.anchorPoints);
    return anchorPoints;
  }
};

// node_modules/@antv/g6-core/es/element/node.js
var singleNode = {
  itemType: "node",
  // 单个图形的类型
  shapeType: "single-node",
  /**
   * 文本相对图形的位置，默认以中心点
   * 位置包括： top, bottom, left, right, center
   * @type {String}
   */
  labelPosition: "center",
  /**
   * 文本相对偏移，当 labelPosition 不为 center 时有效
   * @type {Number}
   */
  offset: global_default.nodeLabel.offset,
  /**
   * 获取节点宽高
   * @internal 返回节点的大小，以 [width, height] 的方式维护
   * @param  {Object} cfg 节点的配置项
   * @return {Array} 宽高
   */
  getSize: function getSize(cfg) {
    var _a2;
    var size3 = ((_a2 = this.mergeStyle) === null || _a2 === void 0 ? void 0 : _a2.size) || cfg.size || this.getOptions({}).size || global_default.defaultNode.size;
    if (is_array_default(size3) && size3.length === 1) {
      size3 = [size3[0], size3[0]];
    }
    if (!is_array_default(size3)) {
      size3 = [size3, size3];
    }
    return size3;
  },
  // 私有方法，不希望扩展的节点复写这个方法
  getLabelStyleByPosition: function getLabelStyleByPosition2(cfg, labelCfg) {
    var labelMaxLength = labelCfg.maxLength;
    var text = cfg.label;
    if (labelMaxLength) {
      text = truncateLabelByLength(text, labelMaxLength);
    }
    var labelPosition = labelCfg.position || this.labelPosition;
    if (labelPosition === "center") {
      return {
        x: 0,
        y: 0,
        text,
        textBaseline: "middle",
        textAlign: "center"
      };
    }
    var offset = labelCfg.offset;
    if (is_nil_default(offset)) {
      offset = this.offset;
    }
    var size3 = this.getSize(cfg);
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: 0,
          y: -size3[1] / 2 - offset,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: size3[1] / 2 + offset,
          textBaseline: "top",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: -size3[0] / 2 - offset,
          y: 0,
          textBaseline: "middle",
          textAlign: "right"
        };
        break;
      default:
        style = {
          x: size3[0] / 2 + offset,
          y: 0,
          textBaseline: "middle",
          textAlign: "left"
        };
        break;
    }
    style.text = text;
    return style;
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition2(label, labelCfg) {
    var _a2;
    if (!label)
      return {};
    var backgroundStyle = (_a2 = labelCfg.style) === null || _a2 === void 0 ? void 0 : _a2.background;
    if (!backgroundStyle)
      return {};
    var bbox = label.getBBox();
    var padding = formatPadding(backgroundStyle.padding);
    var backgroundWidth = bbox.width + padding[1] + padding[3];
    var backgroundHeight = bbox.height + padding[0] + padding[2];
    return __assign(__assign({
      x: bbox.minX - padding[3],
      y: bbox.minY - padding[0]
    }, backgroundStyle), {
      width: backgroundWidth,
      height: backgroundHeight
    });
  },
  drawShape: function drawShape3(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    var shape = group.addShape(shapeType, {
      attrs: style,
      draggable: true,
      name: "node-shape"
    });
    group["shapeMap"]["node-shape"] = shape;
    return shape;
  },
  /**
   * 更新linkPoints
   * @param {Object} cfg 节点数据配置项
   * @param {Group} group Item所在的group
   */
  updateLinkPoints: function updateLinkPoints(cfg, group) {
    var defaultLinkPoints = (this.mergeStyle || this.getOptions(cfg)).linkPoints;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markBottom = group["shapeMap"]["link-point-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-bottom";
    });
    var currentLinkPoints;
    if (markLeft) {
      currentLinkPoints = markLeft.attr();
    }
    if (markRight && !currentLinkPoints) {
      currentLinkPoints = markRight.attr();
    }
    if (markTop && !currentLinkPoints) {
      currentLinkPoints = markTop.attr();
    }
    if (markBottom && !currentLinkPoints) {
      currentLinkPoints = markBottom.attr();
    }
    if (!currentLinkPoints)
      currentLinkPoints = defaultLinkPoints;
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize)
      markSize = linkPoints.r;
    var _a2 = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0
    }, left = _a2.left, right = _a2.right, top = _a2.top, bottom = _a2.bottom;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    if (markLeft) {
      if (!left && left !== void 0) {
        markLeft.remove();
        delete group["shapeMap"]["link-point-left"];
      } else {
        markLeft.attr(__assign(__assign({}, styles), {
          x: -width / 2,
          y: 0
        }));
      }
    } else if (left) {
      var name_1 = "link-point-left";
      group["shapeMap"][name_1] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: -width / 2,
          y: 0
        }),
        className: name_1,
        name: name_1,
        isAnchorPoint: true
      });
    }
    if (markRight) {
      if (!right && right !== void 0) {
        markRight.remove();
        delete group["shapeMap"]["link-point-right"];
      }
      markRight.attr(__assign(__assign({}, styles), {
        x: width / 2,
        y: 0
      }));
    } else if (right) {
      var name_2 = "link-point-right";
      group["shapeMap"][name_2] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: width / 2,
          y: 0
        }),
        className: name_2,
        name: name_2,
        isAnchorPoint: true
      });
    }
    if (markTop) {
      if (!top && top !== void 0) {
        markTop.remove();
        delete group["shapeMap"]["link-point-top"];
      }
      markTop.attr(__assign(__assign({}, styles), {
        x: 0,
        y: -height / 2
      }));
    } else if (top) {
      var name_3 = "link-point-top";
      group["shapeMap"][name_3] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: 0,
          y: -height / 2
        }),
        className: name_3,
        name: name_3,
        isAnchorPoint: true
      });
    }
    if (markBottom) {
      if (!bottom && bottom !== void 0) {
        markBottom.remove();
        delete group["shapeMap"]["link-point-bottom"];
      } else {
        markBottom.attr(__assign(__assign({}, styles), {
          x: 0,
          y: height / 2
        }));
      }
    } else if (bottom) {
      var name_4 = "link-point-bottom";
      group["shapeMap"][name_4] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: 0,
          y: height / 2
        }),
        className: name_4,
        name: name_4,
        isAnchorPoint: true
      });
    }
  },
  updateShape: function updateShape(cfg, item, keyShapeStyle, hasIcon, updateType) {
    var keyShape = item.get("keyShape");
    keyShape.attr(__assign({}, keyShapeStyle));
    if (true) {
      this.updateLabel(cfg, item, updateType);
    }
    if (hasIcon) {
      this.updateIcon(cfg, item);
    }
  },
  updateIcon: function updateIcon(cfg, item) {
    var _this = this;
    var group = item.getContainer();
    var icon = (this.mergeStyle || this.getOptions(cfg)).icon;
    var _a2 = cfg.icon ? cfg.icon : {
      show: void 0,
      text: void 0
    }, show = _a2.show, text = _a2.text;
    var iconShape = group["shapeMap"]["".concat(this.type, "-icon")] || group.find(function(ele) {
      return ele.get("name") === "".concat(_this.type, "-icon");
    });
    if (iconShape) {
      if (show || show === void 0) {
        var iconConfig = mix({}, iconShape.attr(), icon);
        var _b = iconConfig.width, w2 = _b === void 0 ? 20 : _b, _c = iconConfig.height, h2 = _c === void 0 ? 20 : _c;
        if (iconConfig.fontFamily === "iconfont" || iconConfig.hasOwnProperty("text")) {
          w2 = 0;
          h2 = 0;
        }
        iconShape.attr(__assign(__assign({}, iconConfig), {
          x: -w2 / 2,
          y: -h2 / 2
        }));
      } else {
        iconShape.remove();
        delete group["shapeMap"]["".concat(this.type, "-icon")];
      }
    } else if (show) {
      var name_5 = "".concat(this.type, "-icon");
      if (text) {
        group["shapeMap"][name_5] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: name_5,
          name: name_5
        });
      } else {
        var w2 = icon.width, h2 = icon.height;
        group["shapeMap"][name_5] = group.addShape("image", {
          attrs: __assign(__assign({}, icon), {
            x: -w2 / 2,
            y: -h2 / 2
          }),
          className: name_5,
          name: name_5
        });
      }
      var labelShape = group["shapeMap"]["node-label"] || group.find(function(ele) {
        return ele.get("name") === "node-label";
      });
      if (labelShape) {
        labelShape.toFront();
      }
    }
  }
};
var singleNodeDef = __assign(__assign({}, shapeBase), singleNode);
shape_default.registerNode("single-node", singleNodeDef);

// node_modules/@antv/g6-core/es/element/edge.js
init_tslib_es6();
init_esm();
var CLS_SHAPE = "edge-shape";
function revertAlign(labelPosition) {
  var textAlign = labelPosition;
  if (labelPosition === "start") {
    textAlign = "end";
  } else if (labelPosition === "end") {
    textAlign = "start";
  }
  return textAlign;
}
var singleEdge = {
  itemType: "edge",
  /**
   * 文本的位置
   * @type {String}
   */
  labelPosition: "center",
  /**
   * 文本的 x 偏移
   * @type {Number}
   */
  refX: 0,
  /**
   * 文本的 y 偏移
   * @type {Number}
   */
  refY: 0,
  /**
   * 文本是否跟着线自动旋转，默认 false
   * @type {Boolean}
   */
  labelAutoRotate: false,
  // 自定义边时的配置
  options: {
    size: global_default.defaultEdge.size,
    style: {
      x: 0,
      y: 0,
      stroke: global_default.defaultEdge.style.stroke,
      lineAppendWidth: global_default.defaultEdge.style.lineAppendWidth
    },
    labelCfg: {
      style: {
        fill: global_default.edgeLabel.style.fill,
        fontSize: global_default.edgeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign({}, global_default.edgeStateStyles)
  },
  /**
   * 获取边的 path
   * @internal 供扩展的边覆盖
   * @param  {Array} points 构成边的点的集合
   * @return {Array} 构成 path 的数组
   */
  getPath: function getPath(points) {
    var path = [];
    each_default(points, function(point, index2) {
      if (index2 === 0) {
        path.push(["M", point.x, point.y]);
      } else {
        path.push(["L", point.x, point.y]);
      }
    });
    return path;
  },
  getShapeStyle: function getShapeStyle2(cfg) {
    var defaultStyle = this.options.style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var size3 = cfg.size || global_default.defaultEdge.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var path = this.getPath(points);
    var styles = mix({}, global_default.defaultEdge.style, {
      stroke: global_default.defaultEdge.color,
      lineWidth: size3,
      path
    }, style);
    return styles;
  },
  updateShapeStyle: function updateShapeStyle2(cfg, item, updateType) {
    var _a2;
    var group = item.getContainer();
    var shape = ((_a2 = item.getKeyShape) === null || _a2 === void 0 ? void 0 : _a2.call(item)) || group["shapeMap"]["edge-shape"];
    var size3 = cfg.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var currentAttr = shape.attr();
    var previousStyle = cfg.style || {};
    if (previousStyle.stroke === void 0) {
      previousStyle.stroke = cfg.color;
    }
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var routeCfg = {
      radius: previousStyle.radius
    };
    if (!controlPoints) {
      routeCfg = {
        source,
        target,
        offset: previousStyle.offset,
        radius: previousStyle.radius
      };
    }
    var path = this.getPath(points, routeCfg);
    var style = {};
    if (updateType === "move") {
      style = {
        path
      };
    } else {
      if (currentAttr.endArrow && previousStyle.endArrow === false) {
        cfg.style.endArrow = {
          path: ""
        };
      }
      if (currentAttr.startArrow && previousStyle.startArrow === false) {
        cfg.style.startArrow = {
          path: ""
        };
      }
      style = __assign({}, cfg.style);
      if (style.lineWidth === void 0)
        style.lineWdith = (is_number_default(size3) ? size3 : size3 === null || size3 === void 0 ? void 0 : size3[0]) || currentAttr.lineWidth;
      if (style.path === void 0)
        style.path = path;
      if (style.stroke === void 0)
        style.stroke = currentAttr.stroke || cfg.color;
    }
    if (shape) {
      shape.attr(style);
    }
  },
  getLabelStyleByPosition: function getLabelStyleByPosition3(cfg, labelCfg, group) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var style = {};
    var pathShape = group === null || group === void 0 ? void 0 : group["shapeMap"][CLS_SHAPE];
    var pointPercent;
    if (labelPosition === "start") {
      pointPercent = 0;
    } else if (labelPosition === "end") {
      pointPercent = 1;
    } else {
      pointPercent = 0.5;
    }
    var offsetX = labelCfg.refX || this.refX;
    var offsetY = labelCfg.refY || this.refY;
    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {
      style.x = cfg.startPoint.x + offsetX;
      style.y = cfg.startPoint.y + offsetY;
      style.text = cfg.label;
      return style;
    }
    var autoRotate;
    if (is_nil_default(labelCfg.autoRotate))
      autoRotate = this.labelAutoRotate;
    else
      autoRotate = labelCfg.autoRotate;
    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);
    style.x = offsetStyle.x;
    style.y = offsetStyle.y;
    style.rotate = offsetStyle.rotate;
    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);
    style.text = cfg.label;
    return style;
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition3(label, labelCfg) {
    if (!label) {
      return {};
    }
    var bbox = label.getBBox();
    var backgroundStyle = labelCfg.style && labelCfg.style.background;
    if (!backgroundStyle) {
      return {};
    }
    var padding = backgroundStyle.padding;
    var backgroundWidth = bbox.width + padding[1] + padding[3];
    var backgroundHeight = bbox.height + padding[0] + padding[2];
    var style = __assign(__assign({}, backgroundStyle), {
      width: backgroundWidth,
      height: backgroundHeight,
      x: bbox.minX - padding[3],
      y: bbox.minY - padding[0],
      matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    });
    var autoRotate;
    if (is_nil_default(labelCfg.autoRotate))
      autoRotate = this.labelAutoRotate;
    else
      autoRotate = labelCfg.autoRotate;
    if (autoRotate) {
      style.matrix = label.attr("matrix") || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    return style;
  },
  // 获取文本对齐方式
  _getTextAlign: function _getTextAlign(labelPosition, angle) {
    var textAlign = "center";
    if (!angle) {
      return labelPosition;
    }
    angle = angle % (Math.PI * 2);
    if (labelPosition !== "center") {
      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {
        textAlign = labelPosition;
      } else {
        textAlign = revertAlign(labelPosition);
      }
    }
    return textAlign;
  },
  /**
   * @internal 获取边的控制点
   * @param  {Object} cfg 边的配置项
   * @return {Array} 控制点的数组
   */
  getControlPoints: function getControlPoints4(cfg) {
    return cfg.controlPoints;
  },
  /**
   * @internal 处理需要重计算点和边的情况
   * @param {Object} cfg 边的配置项
   * @return {Object} 边的配置项
   */
  getPathPoints: function getPathPoints(cfg) {
    return cfg;
  },
  /**
   * 绘制边
   * @override
   * @param  {Object} cfg   边的配置项
   * @param  {G.Group} group 边的容器
   * @return {IShape} 图形
   */
  drawShape: function drawShape4(cfg, group) {
    var shapeStyle = this.getShapeStyle(cfg);
    var shape = group.addShape("path", {
      className: CLS_SHAPE,
      name: CLS_SHAPE,
      attrs: shapeStyle
    });
    group["shapeMap"][CLS_SHAPE] = shape;
    return shape;
  },
  drawLabel: function drawLabel2(cfg, group) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = deep_mix_default({}, defaultLabelCfg, cfg.labelCfg);
    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);
    var rotate3 = labelStyle.rotate;
    delete labelStyle.rotate;
    var label = group.addShape("text", {
      attrs: labelStyle,
      name: "text-shape",
      labelRelated: true
    });
    group["shapeMap"]["text-shape"] = label;
    if (!isNaN(rotate3) && rotate3 !== "") {
      label.rotateAtStart(rotate3);
    }
    if (labelStyle.background) {
      var rect2 = this.drawLabelBg(cfg, group, label, labelStyle, rotate3);
      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;
      rect2.set("classname", labelBgClassname);
      group["shapeMap"][labelBgClassname] = rect2;
      label.toFront();
    }
    return label;
  },
  drawLabelBg: function drawLabelBg2(cfg, group, label, labelStyle, rotate3) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = deep_mix_default({}, defaultLabelCfg, cfg.labelCfg);
    var style = this.getLabelBgStyleByPosition(label, labelCfg);
    var rect2 = group.addShape("rect", {
      name: "text-bg-shape",
      attrs: style,
      labelRelated: true
    });
    group["shapeMap"]["text-bg-shape"] = rect2;
    return rect2;
  }
};
var singleEdgeDef = __assign(__assign({}, shapeBase), singleEdge);
shape_default.registerEdge("single-edge", singleEdgeDef);
shape_default.registerEdge("line", {
  // 控制点不生效
  getControlPoints: function getControlPoints5() {
    return void 0;
  }
}, "single-edge");
shape_default.registerEdge("spline", {
  getPath: function getPath2(points) {
    var path = getSpline(points);
    return path;
  }
}, "single-edge");
shape_default.registerEdge("arc", {
  curveOffset: 20,
  clockwise: 1,
  getControlPoints: function getControlPoints6(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var midPoint2 = {
      x: (startPoint.x + endPoint.x) / 2,
      y: (startPoint.y + endPoint.y) / 2
    };
    var center;
    var arcPoint;
    if (cfg.controlPoints !== void 0) {
      arcPoint = cfg.controlPoints[0];
      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);
      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {
        this.clockwise = center.x > arcPoint.x ? 0 : 1;
      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {
        this.clockwise = center.x > arcPoint.x ? 1 : 0;
      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {
        this.clockwise = center.y < arcPoint.y ? 0 : 1;
      } else {
        this.clockwise = center.y < arcPoint.y ? 1 : 0;
      }
      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {
        return [];
      }
    } else {
      if (cfg.curveOffset === void 0) {
        cfg.curveOffset = this.curveOffset;
      }
      if (is_array_default(cfg.curveOffset)) {
        cfg.curveOffset = cfg.curveOffset[0];
      }
      if (cfg.curveOffset < 0) {
        this.clockwise = 0;
      } else {
        this.clockwise = 1;
      }
      var vec = {
        x: endPoint.x - startPoint.x,
        y: endPoint.y - startPoint.y
      };
      var edgeAngle = Math.atan2(vec.y, vec.x);
      arcPoint = {
        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint2.x,
        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint2.y
      };
      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);
    }
    var radius = distance(startPoint, center);
    var controlPoints = [{
      x: radius,
      y: radius
    }];
    return controlPoints;
  },
  getPath: function getPath3(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    if (points.length === 2) {
      path.push(["L", points[1].x, points[1].y]);
    } else {
      path.push(["A", points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);
    }
    return path;
  }
}, "single-edge");
shape_default.registerEdge("quadratic", {
  curvePosition: 0.5,
  curveOffset: -20,
  getControlPoints: function getControlPoints7(cfg) {
    var controlPoints = cfg.controlPoints;
    if (!controlPoints || !controlPoints.length) {
      var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
      if (cfg.curveOffset === void 0)
        cfg.curveOffset = this.curveOffset;
      if (cfg.curvePosition === void 0)
        cfg.curvePosition = this.curvePosition;
      if (is_array_default(this.curveOffset))
        cfg.curveOffset = cfg.curveOffset[0];
      if (is_array_default(this.curvePosition))
        cfg.curvePosition = cfg.curveOffset[0];
      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);
      controlPoints = [innerPoint];
    }
    return controlPoints;
  },
  getPath: function getPath4(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    path.push(["Q", points[1].x, points[1].y, points[2].x, points[2].y]);
    return path;
  }
}, "single-edge");
shape_default.registerEdge("cubic", {
  curvePosition: [1 / 2, 1 / 2],
  curveOffset: [-20, 20],
  getControlPoints: function getControlPoints8(cfg) {
    var controlPoints = cfg.controlPoints;
    if (cfg.curveOffset === void 0)
      cfg.curveOffset = this.curveOffset;
    if (cfg.curvePosition === void 0)
      cfg.curvePosition = this.curvePosition;
    if (is_number_default(cfg.curveOffset))
      cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.curvePosition))
      cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {
      var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);
      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);
      controlPoints = [innerPoint1, innerPoint2];
    }
    return controlPoints;
  },
  getPath: function getPath5(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    path.push(["C", points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    return path;
  }
}, "single-edge");
shape_default.registerEdge("cubic-vertical", {
  curvePosition: [1 / 2, 1 / 2],
  minCurveOffset: [0, 0],
  curveOffset: void 0,
  getControlPoints: function getControlPoints9(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    if (cfg.curvePosition === void 0)
      cfg.curvePosition = this.curvePosition;
    if (cfg.curveOffset === void 0)
      cfg.curveOffset = this.curveOffset;
    if (cfg.minCurveOffset === void 0)
      cfg.minCurveOffset = this.minCurveOffset;
    if (is_number_default(cfg.curveOffset))
      cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.minCurveOffset))
      cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];
    if (is_number_default(cfg.curvePosition))
      cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    var yDist = endPoint.y - startPoint.y;
    var curveOffset = [0, 0];
    if (cfg.curveOffset) {
      curveOffset = cfg.curveOffset;
    } else if (Math.abs(yDist) < Math.abs(cfg.minCurveOffset[0])) {
      curveOffset = cfg.minCurveOffset;
    }
    var innerPoint1 = {
      x: startPoint.x,
      y: startPoint.y + yDist * this.curvePosition[0] + curveOffset[0]
    };
    var innerPoint2 = {
      x: endPoint.x,
      y: endPoint.y - yDist * this.curvePosition[1] + curveOffset[1]
    };
    return [innerPoint1, innerPoint2];
  }
}, "cubic");
shape_default.registerEdge("cubic-horizontal", {
  curvePosition: [1 / 2, 1 / 2],
  minCurveOffset: [0, 0],
  curveOffset: void 0,
  getControlPoints: function getControlPoints10(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    if (cfg.curvePosition === void 0)
      cfg.curvePosition = this.curvePosition;
    if (cfg.curveOffset === void 0)
      cfg.curveOffset = this.curveOffset;
    if (cfg.minCurveOffset === void 0)
      cfg.minCurveOffset = this.minCurveOffset;
    if (is_number_default(cfg.curveOffset))
      cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.minCurveOffset))
      cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];
    if (is_number_default(cfg.curvePosition))
      cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    var xDist = endPoint.x - startPoint.x;
    var curveOffset = [0, 0];
    if (cfg.curveOffset) {
      curveOffset = cfg.curveOffset;
    } else if (Math.abs(xDist) < Math.abs(cfg.minCurveOffset[0])) {
      curveOffset = cfg.minCurveOffset;
    }
    var innerPoint1 = {
      x: startPoint.x + xDist * this.curvePosition[0] + curveOffset[0],
      y: startPoint.y
    };
    var innerPoint2 = {
      x: endPoint.x - xDist * this.curvePosition[1] + curveOffset[1],
      y: endPoint.y
    };
    var controlPoints = [innerPoint1, innerPoint2];
    return controlPoints;
  }
}, "cubic");
shape_default.registerEdge("loop", {
  getPathPoints: function getPathPoints2(cfg) {
    return getLoopCfgs(cfg);
  },
  getControlPoints: function getControlPoints11(cfg) {
    return cfg.controlPoints;
  },
  afterDraw: function afterDraw3(cfg) {
    cfg.controlPoints = void 0;
  },
  afterUpdate: function afterUpdate3(cfg) {
    cfg.controlPoints = void 0;
  }
}, "cubic");

// node_modules/@antv/g6-core/es/element/combo.js
init_tslib_es6();
init_esm();
var singleCombo = {
  itemType: "combo",
  // 单个图形的类型
  shapeType: "single-combo",
  /**
   * Combo 标题文本相对图形的位置，默认为 top
   * 位置包括： top, bottom, left, right, center
   * @type {String}
   */
  labelPosition: "top",
  /**
   * 标题文本相对偏移，当 labelPosition 不为 center 时有效
   * @type {Number}
   */
  refX: global_default.comboLabel.refX,
  refY: global_default.comboLabel.refY,
  options: {
    style: {
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign({}, global_default.comboStateStyles),
    collapsedSubstituteIcon: {
      show: false,
      img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*RsnHRqLfJn4AAAAAAAAAAAAAARQnAQ"
    }
  },
  /**
   * 获取 Combo 宽高
   * @internal 返回 Combo 的大小，以 [width, height] 的方式维护
   * @param  {Object} cfg Combo 的配置项
   * @return {Array} 宽高
   */
  getSize: function getSize2(cfg) {
    var size3 = clone_default(cfg.size || this.options.size || global_default.defaultCombo.size);
    if (is_array_default(size3) && size3.length === 1) {
      size3 = [size3[0], size3[0]];
    }
    if (!is_array_default(size3)) {
      size3 = [size3, size3];
    }
    return size3;
  },
  // 私有方法，不希望扩展的 Combo 复写这个方法
  getLabelStyleByPosition: function getLabelStyleByPosition4(cfg, labelCfg) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var cfgStyle = cfg.style;
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding))
      padding = Math.max.apply(Math, padding);
    var refX = labelCfg.refX, refY = labelCfg.refY;
    if (is_nil_default(refX)) {
      refX = this.refX;
    }
    if (is_nil_default(refY)) {
      refY = this.refY;
    }
    var size3 = this.getSize(cfg);
    var r2 = Math.max(cfgStyle.r, size3[0] / 2) || size3[0] / 2;
    var dis = r2 + padding;
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: 0,
          y: -dis - refY,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: dis + refY,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: -dis + refX,
          y: 0,
          textAlign: "left"
        };
        break;
      case "center":
        style = {
          x: 0,
          y: 0,
          text: cfg.label,
          textAlign: "center"
        };
        break;
      default:
        style = {
          x: dis + refX,
          y: 0,
          textAlign: "right"
        };
        break;
    }
    style.text = cfg.label;
    return style;
  },
  drawShape: function drawShape5(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    var shape = group.addShape(shapeType, {
      attrs: style,
      draggable: true,
      name: "combo-shape"
    });
    return shape;
  },
  updateCollapsedIcon: function updateCollapsedIcon(cfg, item, keyShapeStyle) {
    var collapsed = cfg.collapsed, _a2 = cfg.collapsedSubstituteIcon, collapsedSubstituteIcon = _a2 === void 0 ? {} : _a2;
    var subsitututeIconConfig = Object.assign({}, this.options.collapsedSubstituteIcon, collapsedSubstituteIcon);
    var show = subsitututeIconConfig.show, img = subsitututeIconConfig.img, width = subsitututeIconConfig.width, height = subsitututeIconConfig.height;
    var group = item.getContainer();
    var collapsedIconShape = group.find(function(ele) {
      return ele.get("name") === "combo-collapsed-substitute-icon";
    });
    var iconShapeExist = collapsedIconShape && !collapsedIconShape.destroyed;
    var keyShape = item.get("keyShape");
    if (collapsed && show) {
      if (iconShapeExist) {
        collapsedIconShape.show();
      } else {
        var sizeAttr = {
          width: width || keyShapeStyle.r * 2 || keyShapeStyle.width,
          height: height || keyShapeStyle.r * 2 || keyShapeStyle.height
        };
        collapsedIconShape = group.addShape("image", {
          attrs: __assign({
            img,
            x: -sizeAttr.width / 2,
            y: -sizeAttr.height / 2
          }, sizeAttr),
          name: "combo-collapsed-substitute-icon",
          draggable: true
        });
      }
      keyShape.hide();
    } else if (iconShapeExist) {
      collapsedIconShape.hide();
      keyShape.show();
    }
  },
  updateShape: function updateShape2(cfg, item, keyShapeStyle) {
    var _this = this;
    var keyShape = item.get("keyShape");
    var itemAnimate = item.get("animate");
    var animate = itemAnimate && (cfg.animate === void 0 ? this.options.animate : cfg.animate);
    if (animate && keyShape.animate) {
      if (!cfg.collapsed) {
        this.updateCollapsedIcon(cfg, item, keyShapeStyle);
      }
      keyShape.animate(keyShapeStyle, {
        duration: 200,
        easing: "easeLinear",
        callback: function callback() {
          if (cfg.collapsed) {
            _this.updateCollapsedIcon(cfg, item, keyShapeStyle);
          }
        }
      });
    } else {
      keyShape.attr(__assign({}, keyShapeStyle));
      this.updateCollapsedIcon(cfg, item, keyShapeStyle);
    }
    this.updateLabel(cfg, item);
  }
};
var singleComboDef = __assign(__assign({}, shapeBase), singleCombo);
shape_default.registerCombo("single-combo", singleComboDef);

// node_modules/@antv/g6-core/es/element/combos/circle.js
init_tslib_es6();
init_esm();
shape_default.registerCombo("circle", {
  // 自定义节点时的配置
  options: {
    size: [global_default.defaultCombo.size[0], global_default.defaultCombo.size[0]],
    padding: Math.max.apply(Math, global_default.defaultCombo.padding),
    animate: true,
    style: {
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize
      },
      refX: 0,
      refY: 0
    },
    stateStyles: __assign({}, global_default.comboStateStyles),
    collapsedSubstituteIcon: {
      show: false,
      img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*RsnHRqLfJn4AAAAAAAAAAAAAARQnAQ"
    }
  },
  shapeType: "circle",
  // 文本位置
  labelPosition: "top",
  drawShape: function drawShape6(cfg, group) {
    var style = this.getShapeStyle(cfg);
    delete style.height;
    delete style.width;
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "circle-combo",
      name: "circle-combo",
      draggable: true
    });
    return keyShape;
  },
  /**
   * 获取 Combo 的样式，供基于该 Combo 自定义时使用
   * @param {Object} cfg Combo 数据模型
   * @return {Object} Combo 的样式
   */
  getShapeStyle: function getShapeStyle3(cfg) {
    var defaultStyle = this.options.style;
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding))
      padding = Math.max.apply(Math, padding);
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    var r2;
    if (fixSize) {
      r2 = is_number_default(fixSize) ? fixSize / 2 : fixSize[0] / 2;
    } else {
      var size3 = this.getSize(cfg);
      if (!is_number_default(style.r) || isNaN(style.r))
        r2 = size3[0] / 2 || global_default.defaultCombo.style.r;
      else
        r2 = Math.max(style.r, size3[0] / 2) || size3[0] / 2;
    }
    style.r = r2 + padding;
    var styles = __assign({
      x: 0,
      y: 0
    }, style);
    if (cfg.style)
      cfg.style.r = r2;
    else {
      cfg.style = {
        r: r2
      };
    }
    return styles;
  },
  update: function update2(cfg, item) {
    var size3 = this.getSize(cfg);
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding))
      padding = Math.max.apply(Math, padding);
    var cfgStyle = clone_default(cfg.style);
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    var r2;
    if (fixSize) {
      r2 = is_number_default(fixSize) ? fixSize / 2 : fixSize[0] / 2;
    } else {
      r2 = Math.max(cfgStyle.r, size3[0] / 2) || size3[0] / 2;
    }
    cfgStyle.r = r2 + padding;
    var itemCacheSize = item.get("sizeCache");
    if (itemCacheSize) {
      itemCacheSize.r = cfgStyle.r;
    }
    var strokeStyle = {
      stroke: cfg.color
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, keyShape.attr(), strokeStyle, cfgStyle);
    if (cfg.style)
      cfg.style.r = r2;
    else {
      cfg.style = {
        r: r2
      };
    }
    this.updateShape(cfg, item, style, true);
  }
}, "single-combo");

// node_modules/@antv/g6-core/es/element/combos/rect.js
init_tslib_es6();
init_esm();
shape_default.registerCombo("rect", {
  // 自定义 Combo 时的配置
  options: {
    size: [40, 5],
    padding: [25, 20, 15, 20],
    animate: true,
    style: {
      radius: 0,
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    // 连接点，默认为左右
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign({}, global_default.comboStateStyles),
    collapsedSubstituteIcon: {
      show: false,
      img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*RsnHRqLfJn4AAAAAAAAAAAAAARQnAQ"
    }
  },
  shapeType: "rect",
  labelPosition: "top",
  drawShape: function drawShape7(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "rect-combo",
      name: "rect-combo",
      draggable: true
    });
    return keyShape;
  },
  // 私有方法，不希望扩展的 Combo 复写这个方法
  getLabelStyleByPosition: function getLabelStyleByPosition5(cfg, labelCfg) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var cfgStyle = cfg.style;
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding))
      padding = [padding, padding, padding, padding];
    var refX = labelCfg.refX, refY = labelCfg.refY;
    if (is_nil_default(refX)) {
      refX = this.refX;
    }
    if (is_nil_default(refY)) {
      refY = this.refY;
    }
    var left = -cfgStyle.width / 2 - padding[3];
    var right = cfgStyle.width / 2 + padding[1];
    var top = -cfgStyle.height / 2 - padding[0];
    var bottom = cfgStyle.height / 2 + padding[2];
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: left + refX,
          y: top + refY,
          textBaseline: "top",
          textAlign: "left"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: bottom + refY,
          textBaseline: "top",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: left + refY,
          y: 0,
          textAlign: "left"
        };
        break;
      case "center":
        style = {
          x: 0,
          y: 0,
          text: cfg.label,
          textAlign: "center"
        };
        break;
      case "top-center":
        style = {
          x: 0,
          y: top + refY,
          textBaseline: "top",
          textAlign: "center"
        };
        break;
      default:
        style = {
          x: right + refX,
          y: 0,
          textAlign: "right"
        };
        break;
    }
    style.text = cfg.label;
    return style;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle4(cfg) {
    var defaultStyle = this.options.style;
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding))
      padding = [padding, padding, padding, padding];
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var size3 = this.getSize(cfg);
    var width;
    var height;
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    if (fixSize) {
      if (is_number_default(fixSize)) {
        width = fixSize;
        height = fixSize;
      } else {
        width = fixSize[0];
        height = fixSize[1];
      }
    } else {
      if (!is_number_default(style.width) || isNaN(style.width))
        width = size3[0] || global_default.defaultCombo.style.width;
      else
        width = Math.max(style.width, size3[0]) || size3[0];
      if (!is_number_default(style.height) || isNaN(style.height))
        height = size3[1] || global_default.defaultCombo.style.height;
      else
        height = Math.max(style.height, size3[1]) || size3[1];
    }
    var x4 = -width / 2 - padding[3];
    var y4 = -height / 2 - padding[0];
    style.width = width + padding[1] + padding[3];
    style.height = height + padding[0] + padding[2];
    var styles = __assign({
      x: x4,
      y: y4
    }, style);
    if (!cfg.style) {
      cfg.style = {
        width,
        height
      };
    } else {
      cfg.style.width = width;
      cfg.style.height = height;
    }
    return styles;
  },
  update: function update3(cfg, item) {
    var size3 = this.getSize(cfg);
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding))
      padding = [padding, padding, padding, padding];
    var cfgStyle = clone_default(cfg.style);
    var width, height;
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    if (fixSize) {
      if (is_number_default(fixSize)) {
        width = fixSize;
        height = fixSize;
      } else {
        width = fixSize[0];
        height = fixSize[1];
      }
    } else {
      width = Math.max(cfgStyle.width, size3[0]) || size3[0];
      height = Math.max(cfgStyle.height, size3[1]) || size3[1];
    }
    cfgStyle.width = width + padding[1] + padding[3];
    cfgStyle.height = height + padding[0] + padding[2];
    var itemCacheSize = item.get("sizeCache");
    if (itemCacheSize) {
      itemCacheSize.width = cfgStyle.width;
      itemCacheSize.height = cfgStyle.height;
    }
    cfgStyle.x = -width / 2 - padding[3];
    cfgStyle.y = -height / 2 - padding[0];
    var strokeStyle = {
      stroke: cfg.color
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, keyShape.attr(), strokeStyle, cfgStyle);
    if (cfg.style) {
      cfg.style.width = width;
      cfg.style.height = height;
    } else {
      cfg.style = {
        width,
        height
      };
    }
    this.updateShape(cfg, item, style, false);
  }
}, "single-combo");

// node_modules/@antv/g6-core/es/element/nodes/simple-circle.js
init_tslib_es6();
init_esm();
shape_default.registerNode("simple-circle", {
  // 自定义节点时的配置
  options: {
    size: global_default.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: global_default.defaultNode.style.stroke,
      fill: global_default.defaultNode.style.fill,
      lineWidth: global_default.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.nodeLabel.style.fill,
        fontSize: global_default.nodeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign({}, global_default.nodeStateStyles)
  },
  shapeType: "simple-circle",
  // 文本位置
  labelPosition: "center",
  shapeMap: {},
  drawShape: function drawShape8(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var name = "".concat(this.type, "-keyShape");
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name,
      draggable: true
    });
    group["shapeMap"][name] = keyShape;
    return keyShape;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle5(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = deep_mix_default({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var r2 = size3[0] / 2;
    var styles = __assign({
      x: 0,
      y: 0,
      r: r2
    }, style);
    return styles;
  },
  update: function update4(cfg, item, updateType) {
    var size3 = this.getSize(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      r: size3[0] / 2
    };
    var keyShape = item.get("keyShape");
    var style = deep_mix_default({}, keyShape.attr(), strokeStyle, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/nodes/simple-rect.js
init_tslib_es6();
init_esm();
shape_default.registerNode("simple-rect", {
  // 自定义节点时的配置
  options: {
    size: [100, 30],
    style: {
      radius: 0,
      stroke: global_default.defaultNode.style.stroke,
      fill: global_default.defaultNode.style.fill,
      lineWidth: global_default.defaultNode.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: global_default.nodeLabel.style.fill,
        fontSize: global_default.nodeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    // 连接点，默认为左右
    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign({}, global_default.nodeStateStyles)
  },
  shapeType: "simple-rect",
  labelPosition: "center",
  drawShape: function drawShape9(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    return keyShape;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle6(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var width = style.width || size3[0];
    var height = style.height || size3[1];
    var styles = __assign({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update5(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var size3 = this.getSize(cfg);
    var keyShape = item.get("keyShape");
    if (!cfg.size) {
      size3[0] = keyShape.attr("width") || defaultStyle.width;
      size3[1] = keyShape.attr("height") || defaultStyle.height;
    }
    var strokeStyle = {
      stroke: cfg.color,
      x: -size3[0] / 2,
      y: -size3[1] / 2,
      width: size3[0],
      height: size3[1]
    };
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, false, updateType);
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/nodes/image.js
init_tslib_es6();
shape_default.registerNode("image", {
  options: {
    img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ",
    size: 200,
    labelCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    },
    clipCfg: {
      show: false,
      type: "circle",
      // circle
      r: 50,
      // ellipse
      rx: 50,
      ry: 35,
      // rect
      width: 50,
      height: 35,
      // polygon
      points: [[30, 12], [12, 30], [30, 48], [48, 30]],
      // path
      path: [["M", 25, 25], ["L", 50, 25], ["A", 12.5, 12.5, 0, 1, 1, 50, 50], ["A", 12.5, 12.5, 0, 1, 0, 50, 50], ["L", 25, 75], ["Z"]],
      // 坐标
      x: 0,
      y: 0
      // clip 的属性样式
      // style: {
      //   lineWidth: 1
      // },
    }
  },
  shapeType: "image",
  labelPosition: "bottom",
  drawShape: function drawShape10(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    delete style.fill;
    var shape = group.addShape(shapeType, {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    this.drawClip(cfg, shape);
    return shape;
  },
  drawClip: function drawClip(cfg, shape) {
    var clip = (this.mergeStyle || this.getOptions(cfg)).clipCfg;
    if (!clip.show) {
      return;
    }
    var type = clip.type, x4 = clip.x, y4 = clip.y, style = clip.style;
    if (type === "circle") {
      var r2 = clip.r;
      shape.setClip({
        type: "circle",
        attrs: __assign({
          r: r2,
          x: x4,
          y: y4
        }, style)
      });
    } else if (type === "rect") {
      var width = clip.width, height = clip.height;
      var rectX = x4 - width / 2;
      var rectY = y4 - height / 2;
      shape.setClip({
        type: "rect",
        attrs: __assign({
          x: rectX,
          y: rectY,
          width,
          height
        }, style)
      });
    } else if (type === "ellipse") {
      var rx = clip.rx, ry = clip.ry;
      shape.setClip({
        type: "ellipse",
        attrs: __assign({
          x: x4,
          y: y4,
          rx,
          ry
        }, style)
      });
    } else if (type === "polygon") {
      var points = clip.points;
      shape.setClip({
        type: "polygon",
        attrs: __assign({
          points
        }, style)
      });
    } else if (type === "path") {
      var path = clip.path;
      shape.setClip({
        type: "path",
        attrs: __assign({
          path
        }, style)
      });
    }
  },
  getShapeStyle: function getShapeStyle7(cfg) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), defaultStyle = _a2.style, img = _a2.img;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    if (defaultStyle) {
      width = defaultStyle.width || size3[0];
      height = defaultStyle.height || size3[1];
    }
    var style = __assign({
      x: -width / 2,
      y: -height / 2,
      width,
      height,
      img
    }, defaultStyle);
    return style;
  },
  updateShapeStyle: function updateShapeStyle3(cfg, item) {
    var group = item.getContainer();
    var shapeClassName = "".concat(this.itemType, "-shape");
    var shape = group["shapeMap"][shapeClassName] || group.find(function(element) {
      return element.get("className") === shapeClassName;
    }) || item.getKeyShape();
    var shapeStyle = this.getShapeStyle(cfg);
    if (shape && !shape.destroyed) {
      shape.attr(shapeStyle);
    }
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/arrow.js
var arrow_default = {
  triangle: function triangle(width, length, d2) {
    if (width === void 0) {
      width = 10;
    }
    if (length === void 0) {
      length = 15;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 L ").concat(begin + length, ",-").concat(width / 2, " L ").concat(begin + length, ",").concat(width / 2, " Z");
    return path;
  },
  vee: function vee(width, length, d2) {
    if (width === void 0) {
      width = 15;
    }
    if (length === void 0) {
      length = 20;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 L ").concat(begin + length, ",-").concat(width / 2, "\n        L ").concat(begin + 2 * length / 3, ",0 L ").concat(begin + length, ",").concat(width / 2, " Z");
    return path;
  },
  circle: function circle(r2, d2) {
    if (r2 === void 0) {
      r2 = 5;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ", 0\n            a ").concat(r2, ",").concat(r2, " 0 1,0 ").concat(r2 * 2, ",0\n            a ").concat(r2, ",").concat(r2, " 0 1,0 ").concat(-r2 * 2, ",0");
    return path;
  },
  rect: function rect(width, length, d2) {
    if (width === void 0) {
      width = 10;
    }
    if (length === void 0) {
      length = 10;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",").concat(-width / 2, " \n        L ").concat(begin + length, ",").concat(-width / 2, " \n        L ").concat(begin + length, ",").concat(width / 2, " \n        L ").concat(begin, ",").concat(width / 2, " Z");
    return path;
  },
  diamond: function diamond(width, length, d2) {
    if (width === void 0) {
      width = 15;
    }
    if (length === void 0) {
      length = 15;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 \n        L ").concat(begin + length / 2, ",").concat(-width / 2, " \n        L ").concat(begin + length, ",0 \n        L ").concat(begin + length / 2, ",").concat(width / 2, " Z");
    return path;
  },
  triangleRect: function triangleRect(tWidth, tLength, rWidth, rLength, gap, d2) {
    if (tWidth === void 0) {
      tWidth = 15;
    }
    if (tLength === void 0) {
      tLength = 15;
    }
    if (rWidth === void 0) {
      rWidth = 15;
    }
    if (rLength === void 0) {
      rLength = 3;
    }
    if (gap === void 0) {
      gap = 5;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var rectBegin = begin + tLength + gap;
    var path = "M ".concat(begin, ",0 L ").concat(begin + tLength, ",-").concat(tWidth / 2, " L ").concat(begin + tLength, ",").concat(tWidth / 2, " Z\n            M ").concat(rectBegin, ", -").concat(rWidth / 2, "\n            L ").concat(rectBegin + rLength, " -").concat(rWidth / 2, "\n            L ").concat(rectBegin + rLength, " ").concat(rWidth / 2, "\n            L ").concat(rectBegin, " ").concat(rWidth / 2, "\n            Z");
    return path;
  }
};

// node_modules/@antv/g6-core/es/element/marker.js
var marker_default = {
  collapse: function collapse(x4, y4, r2) {
    return [["M", x4 - r2, y4], ["a", r2, r2, 0, 1, 0, r2 * 2, 0], ["a", r2, r2, 0, 1, 0, -r2 * 2, 0], ["M", x4 - r2 + 4, y4], ["L", x4 + r2 - 4, y4]];
  },
  expand: function expand(x4, y4, r2) {
    return [["M", x4 - r2, y4], ["a", r2, r2, 0, 1, 0, r2 * 2, 0], ["a", r2, r2, 0, 1, 0, -r2 * 2, 0], ["M", x4 - r2 + 4, y4], ["L", x4 - r2 + 2 * r2 - 4, y4], ["M", x4 - r2 + r2, y4 - r2 + 4], ["L", x4, y4 + r2 - 4]];
  },
  upTriangle: function upTriangle(x4, y4, r2) {
    var l1 = r2 * Math.cos(Math.PI / 6);
    var l2 = r2 * Math.sin(Math.PI / 6);
    return [["M", x4 - l1, y4 + l2], ["L", x4 + l1, y4 + l2], ["L", x4, y4 - r2], ["Z"]];
  },
  downTriangle: function downTriangle(x4, y4, r2) {
    var l1 = r2 * Math.cos(Math.PI / 6);
    var l2 = r2 * Math.sin(Math.PI / 6);
    return [["M", x4 - l1, y4 - l2], ["L", x4 + l1, y4 - l2], ["L", x4, y4 + r2], ["Z"]];
  }
};

// node_modules/@antv/g6-core/es/element/index.js
var element_default = shape_default;

// node_modules/@antv/g6-core/es/util/index.js
init_tslib_es6();

// node_modules/@antv/g6-core/es/util/color.js
var color_exports = {};
__export(color_exports, {
  defaultSubjectColors: () => defaultSubjectColors
});
var defaultSubjectColors = ["#5F95FF", "#61DDAA", "#65789B", "#F6BD16", "#7262FD", "#78D3F8", "#9661BC", "#F6903D", "#008685", "#F08BB4"];

// node_modules/@antv/g6-core/es/util/layout.js
var layout_exports = {};
__export(layout_exports, {
  isForce: () => isForce
});
var isForce = function isForce2(layoutType) {
  return layoutType === "force" || layoutType === "g6force" || layoutType === "gForce" || layoutType === "force2";
};

// node_modules/@antv/g6-core/es/util/index.js
var transform5 = ext_exports.transform;
var Util = __assign(__assign(__assign(__assign(__assign(__assign(__assign({}, base_exports), graphic_exports), path_exports), math_exports), color_exports), layout_exports), {
  transform: transform5,
  mat3: mat3_exports
});
var util_default = Util;

// node_modules/@antv/g6-core/es/graph/controller/layout.js
init_tslib_es6();
init_esm();
var LayoutController = (
  /** @class */
  function() {
    function LayoutController3(graph) {
      this.graph = graph;
      this.layoutCfg = graph.get("layout") || {};
      this.layoutType = this.getLayoutType();
      this.layoutMethods = [];
      this.initLayout();
    }
    LayoutController3.prototype.initLayout = function() {
    };
    LayoutController3.prototype.getLayoutType = function() {
      return this.getLayoutCfgType(this.layoutCfg);
    };
    LayoutController3.prototype.getLayoutCfgType = function(layoutCfg) {
      var type = layoutCfg.type;
      if (type) {
        return type;
      }
      var pipes = layoutCfg.pipes;
      if (Array.isArray(pipes)) {
        return pipes.map(function(pipe) {
          return (pipe === null || pipe === void 0 ? void 0 : pipe.type) || "";
        });
      }
      return null;
    };
    LayoutController3.prototype.isLayoutTypeSame = function(cfg) {
      var current = this.getLayoutCfgType(cfg);
      var preHasPipies = Array.isArray(this.layoutType);
      var currentHasPipes = Array.isArray(current);
      if (preHasPipies && currentHasPipes) {
        return this.layoutType.every(function(type, index2) {
          return type === current[index2];
        });
      }
      if (Array.isArray(current) || Array.isArray(this.layoutType)) {
        return false;
      }
      return (cfg === null || cfg === void 0 ? void 0 : cfg.type) === this.layoutType;
    };
    LayoutController3.prototype.refreshLayout = function() {
      var _a2 = this, graph = _a2.graph, layoutType = _a2.layoutType, _b = _a2.layoutCfg, layoutCfg = _b === void 0 ? {} : _b;
      if (!graph)
        return;
      var animate = layoutCfg.animate;
      var isDefaultAnimateLayout = animate === void 0 && (layoutType === "force" || layoutType === "force2");
      var forceAnimate = isForce(layoutType) && (animate || isDefaultAnimateLayout);
      if (graph.get("animate") && !forceAnimate) {
        graph.positionsAnimate(layoutType === "comboCombined");
      } else {
        graph.refreshPositions(layoutType === "comboCombined");
      }
    };
    LayoutController3.prototype.changeLayout = function(cfg) {
      var disableTriggerLayout = cfg.disableTriggerLayout, otherCfgs = __rest(cfg, ["disableTriggerLayout"]);
      this.layoutCfg = otherCfgs;
      this.layoutType = otherCfgs.type || this.layoutType;
      if (disableTriggerLayout)
        return;
      this.layout();
    };
    LayoutController3.prototype.changeData = function(success) {
      this.layout(success);
    };
    LayoutController3.prototype.destoryLayoutMethods = function() {
      var layoutMethods = this.layoutMethods;
      var destroyedLayoutTypes = [];
      layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function(layoutMethod) {
        var _a2;
        var layoutType = (_a2 = layoutMethod.getType) === null || _a2 === void 0 ? void 0 : _a2.call(layoutMethod);
        if (layoutType)
          destroyedLayoutTypes.push(layoutType);
        layoutMethod.destroy();
      });
      this.layoutMethods = [];
      return destroyedLayoutTypes;
    };
    LayoutController3.prototype.destroyLayout = function() {
      this.destoryLayoutMethods();
      var graph = this.graph;
      if (graph && !graph.get("destroyed")) {
        graph.set("layout", void 0);
      }
      this.layoutCfg = void 0;
      this.layoutType = void 0;
      this.layoutMethods = void 0;
    };
    LayoutController3.prototype.setDataFromGraph = function() {
      var _a2;
      var nodes = [];
      var hiddenNodes = [];
      var edges = [];
      var hiddenEdges = [];
      var comboEdges = [];
      var combos = [];
      var hiddenCombos = [];
      var nodeItems = this.graph.getNodes();
      var edgeItems = this.graph.getEdges();
      var comboItems = this.graph.getCombos();
      var nodeLength = nodeItems.length;
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var nodeItem = nodeItems[i2];
        if (!nodeItem || nodeItem.destroyed)
          continue;
        var model = nodeItem.getModel();
        if (!nodeItem.isVisible()) {
          hiddenNodes.push(model);
          continue;
        }
        nodes.push(model);
      }
      var edgeLength = edgeItems.length;
      for (var i2 = 0; i2 < edgeLength; i2++) {
        var edgeItem = edgeItems[i2];
        if (!edgeItem || edgeItem.destroyed)
          continue;
        var model = edgeItem.getModel();
        if (!edgeItem.isVisible()) {
          hiddenEdges.push(model);
          continue;
        }
        if (!model.isComboEdge)
          edges.push(model);
        else
          comboEdges.push(model);
      }
      var comboLength = comboItems.length;
      for (var i2 = 0; i2 < comboLength; i2++) {
        var comboItem = comboItems[i2];
        if (comboItem.destroyed)
          continue;
        var model = comboItem.getModel();
        if (!comboItem.isVisible()) {
          hiddenCombos.push(model);
          continue;
        }
        combos.push(model);
      }
      return {
        nodes,
        hiddenNodes,
        edges,
        hiddenEdges,
        combos,
        hiddenCombos,
        comboEdges,
        vedges: (_a2 = this.graph.get("vedges")) === null || _a2 === void 0 ? void 0 : _a2.map(function(edge) {
          return edge.getModel();
        })
      };
    };
    LayoutController3.prototype.relayout = function(reloadData) {
      var _this = this;
      var _a2 = this, graph = _a2.graph, layoutMethods = _a2.layoutMethods, layoutCfg = _a2.layoutCfg;
      if (!graph || graph.get("destroyed"))
        return;
      if (reloadData) {
        this.data = this.setDataFromGraph();
        var nodes = this.data.nodes;
        if (!nodes) {
          return false;
        }
        this.initPositions(layoutCfg.center, nodes);
      }
      graph.emit("beforelayout");
      var start = Promise.resolve();
      layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function(layoutMethod, index2) {
        var currentCfg = layoutCfg[index2] || layoutCfg;
        start = start.then(function() {
          var _a3;
          var relayoutPromise = _this.execLayoutMethod(currentCfg, index2);
          if (index2 === layoutMethods.length - 1) {
            (_a3 = layoutCfg.onAllLayoutEnd) === null || _a3 === void 0 ? void 0 : _a3.call(layoutCfg);
          }
          return relayoutPromise;
        });
      });
    };
    LayoutController3.prototype.filterLayoutData = function(data, cfg) {
      var nodes = data.nodes, edges = data.edges, rest = __rest(data, ["nodes", "edges"]);
      if (!nodes) {
        return data;
      }
      var nodesFilter;
      var edegsFilter;
      if (is_function_default(cfg === null || cfg === void 0 ? void 0 : cfg.nodesFilter)) {
        nodesFilter = cfg.nodesFilter;
      } else {
        nodesFilter = function nodesFilter2() {
          return true;
        };
      }
      var fNodes = nodes.filter(nodesFilter);
      if (is_function_default(cfg === null || cfg === void 0 ? void 0 : cfg.edgesFilter)) {
        edegsFilter = cfg.edgesFilter;
      } else {
        var nodesMap_1 = fNodes.reduce(function(acc, cur) {
          acc[cur.id] = true;
          return acc;
        }, {});
        edegsFilter = function edegsFilter2(edge) {
          return nodesMap_1[edge.source] && nodesMap_1[edge.target];
        };
      }
      return __assign({
        nodes: fNodes,
        edges: edges.filter(edegsFilter)
      }, rest);
    };
    LayoutController3.prototype.getLayoutBBox = function(nodes) {
      var graph = this.graph;
      var graphGroupNodes = group_by_default(graph.getNodes(), function(n2) {
        return n2.getModel().layoutOrder;
      });
      var layoutNodes = Object.values(graphGroupNodes).map(function(value) {
        var bbox = calculationItemsBBox(value);
        bbox.size = [bbox.width, bbox.height];
        return bbox;
      });
      var groupNodes = Object.values(group_by_default(nodes, "layoutOrder"));
      return {
        groupNodes,
        layoutNodes
      };
    };
    LayoutController3.prototype.layoutAnimate = function() {
    };
    LayoutController3.prototype.moveToZero = function() {
      var graph = this.graph;
      var data = graph.get("data");
      var nodes = data.nodes;
      if (nodes[0].x === void 0 || nodes[0].x === null || isNaN2(nodes[0].x)) {
        return;
      }
      var meanCenter = [0, 0];
      var nodeLength = nodes.length;
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var node = nodes[i2];
        meanCenter[0] += node.x;
        meanCenter[1] += node.y;
      }
      meanCenter[0] /= nodes.length;
      meanCenter[1] /= nodes.length;
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var node = nodes[i2];
        node.x -= meanCenter[0];
        node.y -= meanCenter[1];
      }
    };
    LayoutController3.prototype.initPositions = function(center, nodes) {
      var _a2;
      var graph = this.graph;
      if (!nodes) {
        return false;
      }
      var nodesToInit = nodes.filter(function(node2) {
        return isNaN2(node2.x) || isNaN2(node2.y);
      });
      var nodeLength = nodesToInit ? nodesToInit.length : 0;
      if (!nodeLength)
        return;
      var hasPreset = (_a2 = this.initWithPreset) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      if (hasPreset)
        return false;
      var width = graph.get("width") * 0.85;
      var height = graph.get("height") * 0.85;
      var horiNum = Math.ceil(Math.sqrt(nodeLength) * (width / height));
      var vertiNum = Math.ceil(nodeLength / horiNum);
      var horiGap = width / (horiNum - 1);
      var vertiGap = height / (vertiNum - 1);
      if (!isFinite(horiGap) || !horiGap)
        horiGap = 0;
      if (!isFinite(vertiGap) || !horiGap)
        vertiGap = 0;
      var beginX = center[0] - width / 2;
      var beginY = center[1] - height / 2;
      var allHavePos = true;
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var node = nodesToInit[i2];
        if (isNaN2(+node.x)) {
          allHavePos = false;
          node.x = i2 % horiNum * horiGap + beginX;
        }
        if (isNaN2(+node.y)) {
          allHavePos = false;
          node.y = Math.floor(i2 / horiNum) * vertiGap + beginY;
        }
      }
      return allHavePos;
    };
    LayoutController3.prototype.destroy = function() {
      this.graph = null;
      this.destoryLayoutMethods();
      this.destroyed = true;
    };
    return LayoutController3;
  }()
);
var layout_default = LayoutController;

// node_modules/@antv/g6-core/es/graph/controller/event.js
var EventController = (
  /** @class */
  function() {
    function EventController3(graph) {
      this.graph = graph;
      this.destroyed = false;
      this.initEvents();
    }
    return EventController3;
  }()
);
var event_default = EventController;

// node_modules/@antv/g6-core/es/index.js
var registerNode = element_default.registerNode;
var registerEdge = element_default.registerEdge;
var registerCombo = element_default.registerCombo;
var registerBehavior = behavior_default2.registerBehavior;
var BaseGlobal = global_default;
var es_default2 = {
  version: global_default.version,
  AbstractGraph: graph_default,
  BaseGlobal,
  Util: util_default,
  Shape: element_default,
  Node: node_default,
  Edge: edge_default,
  Combo: combo_default,
  Hull: hull_default,
  registerNode: element_default.registerNode,
  registerEdge: element_default.registerEdge,
  registerCombo: element_default.registerCombo,
  registerBehavior: behavior_default2.registerBehavior,
  Arrow: arrow_default,
  Marker: marker_default,
  AbstractLayout: layout_default,
  AbstractEvent: event_default
};

// node_modules/@antv/g6-pc/es/index.js
var AlgorithmAsync = __toESM(require_asyncIndex());

// node_modules/@antv/g6-pc/es/graph/graph.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-pc/es/util/color.js
var color_exports2 = {};
__export(color_exports2, {
  getColorSetsBySubjectColors: () => getColorSetsBySubjectColors,
  getColorsWithSubjectColor: () => getColorsWithSubjectColor,
  mixColor: () => mixColor
});
var import_color = __toESM(require_color());

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color2, opts) {
  color2 = color2 ? color2 : "";
  opts = opts || {};
  if (color2 instanceof tinycolor) {
    return color2;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color2, opts);
  }
  var rgb = inputToRGB(color2);
  this._originalInput = color2, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R2, G2, B2;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R2 = RsRGB / 12.92;
    else
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G2 = GsRGB / 12.92;
    else
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B2 = BsRGB / 12.92;
    else
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h2 = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h2 = Math.round(hsl.h * 360), s2 = Math.round(hsl.s * 100), l2 = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s2 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn2, args) {
    var color2 = fn2.apply(null, [this].concat([].slice.call(args)));
    this._r = color2._r;
    this._g = color2._g;
    this._b = color2._b;
    this.setAlpha(color2._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn2, args) {
    return fn2.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color2, opts) {
  if (_typeof3(color2) == "object") {
    var newColor = {};
    for (var i2 in color2) {
      if (color2.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color2[i2];
        } else {
          newColor[i2] = convertToPercentage(color2[i2]);
        }
      }
    }
    color2 = newColor;
  }
  return tinycolor(color2, opts);
};
function inputToRGB(color2) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a3 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format = false;
  if (typeof color2 == "string") {
    color2 = stringInputToObject(color2);
  }
  if (_typeof3(color2) == "object") {
    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
      rgb = rgbToRgb(color2.r, color2.g, color2.b);
      ok = true;
      format = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
      s2 = convertToPercentage(color2.s);
      v2 = convertToPercentage(color2.v);
      rgb = hsvToRgb(color2.h, s2, v2);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
      s2 = convertToPercentage(color2.s);
      l2 = convertToPercentage(color2.l);
      rgb = hslToRgb(color2.h, s2, l2);
      ok = true;
      format = "hsl";
    }
    if (color2.hasOwnProperty("a")) {
      a3 = color2.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color2.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a3
  };
}
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max4 = Math.max(r2, g2, b2), min3 = Math.min(r2, g2, b2);
  var h2, s2, l2 = (max4 + min3) / 2;
  if (max4 == min3) {
    h2 = s2 = 0;
  } else {
    var d2 = max4 - min3;
    s2 = l2 > 0.5 ? d2 / (2 - max4 - min3) : d2 / (max4 + min3);
    switch (max4) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    l: l2
  };
}
function hslToRgb(h2, s2, l2) {
  var r2, g2, b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  function hue2rgb(p3, q3, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p3 + (q3 - p3) * 6 * t2;
    if (t2 < 1 / 2)
      return q3;
    if (t2 < 2 / 3)
      return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
    return p3;
  }
  if (s2 === 0) {
    r2 = g2 = b2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g2 * 255,
    b: b2 * 255
  };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max4 = Math.max(r2, g2, b2), min3 = Math.min(r2, g2, b2);
  var h2, s2, v2 = max4;
  var d2 = max4 - min3;
  s2 = max4 === 0 ? 0 : d2 / max4;
  if (max4 == min3) {
    h2 = 0;
  } else {
    switch (max4) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return {
    h: h2,
    s: s2,
    v: v2
  };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod2 = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod2], g2 = [t2, v2, v2, q2, p2, p2][mod2], b2 = [p2, p2, t2, v2, v2, q2][mod2];
  return {
    r: r2 * 255,
    g: g2 * 255,
    b: b2 * 255
  };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r2, g2, b2, a3, allow4Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a3))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r2, g2, b2, a3) {
  var hex = [pad2(convertDecimalToHex(a3)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color2).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color2).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color2) {
  return tinycolor(color2).desaturate(100);
}
function _lighten(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color2).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color2).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color2, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color2).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color2, amount) {
  var hsl = tinycolor(color2).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color2) {
  var hsl = tinycolor(color2).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color2, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color2).toHsl();
  var result = [tinycolor(color2)];
  var step = 360 / number;
  for (var i2 = 1; i2 < number; i2++) {
    result.push(tinycolor({
      h: (hsl.h + i2 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color2) {
  var hsl = tinycolor(color2).toHsl();
  var h2 = hsl.h;
  return [tinycolor(color2), tinycolor({
    h: (h2 + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h2 + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color2, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color2).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color2)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color2, results) {
  results = results || 6;
  var hsv = tinycolor(color2).toHsv();
  var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h2,
      s: s2,
      v: v2
    }));
    v2 = (v2 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p2 = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p2 + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size3;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size3 = args.size;
  for (var i2 = 0; i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size: size3
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o2) {
  var flipped = {};
  for (var i2 in o2) {
    if (o2.hasOwnProperty(i2)) {
      flipped[o2[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function bound01(n2, max4) {
  if (isOnePointZero(n2))
    n2 = "100%";
  var processPercent = isPercentage(n2);
  n2 = Math.min(max4, Math.max(0, parseFloat(n2)));
  if (processPercent) {
    n2 = parseInt(n2 * max4, 10) / 100;
  }
  if (Math.abs(n2 - max4) < 1e-6) {
    return 1;
  }
  return n2 % max4 / parseFloat(max4);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n2) {
  return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") != -1;
}
function pad2(c3) {
  return c3.length == 1 ? "0" + c3 : "" + c3;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    n2 = n2 * 100 + "%";
  }
  return n2;
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color2) {
  return !!matchers.CSS_UNIT.exec(color2);
}
function stringInputToObject(color2) {
  color2 = color2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color2]) {
    color2 = names[color2];
    named = true;
  } else if (color2 == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color2)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color2)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color2)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color2)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color2)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color2)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color2)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color2)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color2)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color2)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size3;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size3 = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size3 !== "small" && size3 !== "large") {
    size3 = "small";
  }
  return {
    level,
    size: size3
  };
}

// node_modules/@ant-design/colors/dist/index.esm.js
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function getHue(hsv, i2, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i2;
  } else {
    value = hsv.v - brightnessStep2 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate(color2) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = tinycolor(color2);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = pColor.toHsv();
    var colorString = tinycolor({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue(hsv, i2, true)
    }).toHexString();
    patterns.push(colorString);
  }
  patterns.push(pColor.toHexString());
  for (var _i2 = 1; _i2 <= darkColorCount; _i2 += 1) {
    var _hsv = pColor.toHsv();
    var _colorString = tinycolor({
      h: getHue(_hsv, _i2),
      s: getSaturation(_hsv, _i2),
      v: getValue(_hsv, _i2)
    }).toHexString();
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref) {
      var index2 = _ref.index, opacity = _ref.opacity;
      var darkColorString = tinycolor.mix(opts.backgroundColor || "#141414", patterns[index2], opacity * 100).toHexString();
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key) {
  presetPalettes[key] = generate(presetPrimaryColors[key]);
  presetPalettes[key].primary = presetPalettes[key][5];
  presetDarkPalettes[key] = generate(presetPrimaryColors[key], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
});
var red = presetPalettes.red;
var volcano = presetPalettes.volcano;
var gold = presetPalettes.gold;
var orange = presetPalettes.orange;
var yellow = presetPalettes.yellow;
var lime = presetPalettes.lime;
var green = presetPalettes.green;
var cyan = presetPalettes.cyan;
var blue = presetPalettes.blue;
var geekblue = presetPalettes.geekblue;
var purple = presetPalettes.purple;
var magenta = presetPalettes.magenta;
var grey = presetPalettes.grey;

// node_modules/@antv/g6-pc/es/util/color.js
var mixColor = function mixColor2(backColor3, frontColor, frontAlpha) {
  var bc = (0, import_color.default)(backColor3);
  var fc = (0, import_color.default)(frontColor);
  return (0, import_color.default)([(1 - frontAlpha) * bc.red() + frontAlpha * fc.red(), (1 - frontAlpha) * bc.green() + frontAlpha * fc.green(), (1 - frontAlpha) * bc.blue() + frontAlpha * fc.blue()]).rgb();
};
var getColorsWithDefaultTheme = function getColorsWithDefaultTheme2(subjectColor3, backColor3, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  var subjectColor005 = mixColor(backColor3, subjectColor3, 0.05).rgb().toString();
  var subjectColor01 = mixColor(backColor3, subjectColor3, 0.1).rgb().toString();
  var subjectColor02 = mixColor(backColor3, subjectColor3, 0.2).rgb().toString();
  var subjectColor04 = mixColor(backColor3, subjectColor3, 0.4).rgb().toString();
  var disableColor002 = mixColor(backColor3, disableColor, 0.02).rgb().toString();
  var disableColor005 = mixColor(backColor3, disableColor, 0.05).rgb().toString();
  var disableColor01 = mixColor(backColor3, disableColor, 0.1).rgb().toString();
  var disableColor02 = mixColor(backColor3, disableColor, 0.2).rgb().toString();
  var disableColor03 = mixColor(backColor3, disableColor, 0.3).rgb().toString();
  var paletteFromSubject = generate(subjectColor3, {
    theme: "default",
    backgroundColor: backColor3
  });
  var subjectHex = (0, import_color.default)(subjectColor3).hex().toLowerCase();
  var subjectIdx = paletteFromSubject.indexOf(subjectHex);
  var deeperSubject = subjectColor3;
  if (subjectIdx !== -1) {
    deeperSubject = paletteFromSubject[subjectIdx + 1];
  }
  return {
    // for nodes
    mainStroke: subjectColor3,
    mainFill: subjectColor01,
    activeStroke: subjectColor3,
    activeFill: subjectColor005,
    inactiveStroke: subjectColor04,
    inactiveFill: subjectColor005,
    selectedStroke: subjectColor3,
    selectedFill: backColor3,
    highlightStroke: deeperSubject,
    highlightFill: subjectColor02,
    disableStroke: disableColor03,
    disableFill: disableColor005,
    // for edges
    edgeMainStroke: disableColor03,
    edgeActiveStroke: subjectColor3,
    edgeInactiveStroke: disableColor02,
    edgeSelectedStroke: subjectColor3,
    edgeHighlightStroke: subjectColor3,
    edgeDisableStroke: disableColor01,
    // for combos
    comboMainStroke: disableColor03,
    comboMainFill: disableColor002,
    comboActiveStroke: subjectColor3,
    comboActiveFill: subjectColor005,
    comboInactiveStroke: disableColor03,
    comboInactiveFill: disableColor002,
    comboSelectedStroke: subjectColor3,
    comboSelectedFill: disableColor002,
    comboHighlightStroke: deeperSubject,
    comboHighlightFill: disableColor002,
    comboDisableStroke: disableColor02,
    comboDisableFill: disableColor005
  };
};
var getColorsWithDarkTheme = function getColorsWithDarkTheme2(subjectColor3, backColor3, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (disableColor === void 0) {
    disableColor = "#777";
  }
  var subjectColor02 = mixColor(backColor3, subjectColor3, 0.2).rgb().toString();
  var subjectColor03 = mixColor(backColor3, subjectColor3, 0.3).rgb().toString();
  var subjectColor06 = mixColor(backColor3, subjectColor3, 0.6).rgb().toString();
  var subjectColor08 = mixColor(backColor3, subjectColor3, 0.8).rgb().toString();
  var disableColor02 = mixColor(backColor3, disableColor, 0.2).rgb().toString();
  var disableColor025 = mixColor(backColor3, disableColor, 0.25).rgb().toString();
  var disableColor03 = mixColor(backColor3, disableColor, 0.3).rgb().toString();
  var disableColor04 = mixColor(backColor3, disableColor, 0.4).rgb().toString();
  var disableColor05 = mixColor(backColor3, disableColor, 0.5).rgb().toString();
  var paletteFromSubject = generate(subjectColor3, {
    theme: "dark",
    backgroundColor: backColor3
  });
  var subjectHex = (0, import_color.default)(subjectColor3).hex().toLowerCase();
  var subjectIdx = paletteFromSubject.indexOf(subjectHex);
  var deeperSubject = subjectColor3;
  if (subjectIdx !== -1) {
    deeperSubject = paletteFromSubject[subjectIdx + 1];
  }
  return {
    // for nodes
    mainStroke: subjectColor08,
    mainFill: subjectColor02,
    activeStroke: subjectColor3,
    activeFill: subjectColor03,
    inactiveStroke: subjectColor08,
    inactiveFill: subjectColor02,
    selectedStroke: subjectColor3,
    selectedFill: subjectColor02,
    highlightStroke: subjectColor3,
    highlightFill: subjectColor06,
    disableStroke: disableColor05,
    disableFill: disableColor025,
    // for edges
    edgeMainStroke: disableColor,
    edgeActiveStroke: subjectColor3,
    edgeInactiveStroke: disableColor,
    edgeSelectedStroke: subjectColor3,
    edgeHighlightStroke: subjectColor3,
    edgeDisableStroke: disableColor03,
    // for combos
    comboMainStroke: disableColor04,
    comboMainFill: disableColor025,
    comboActiveStroke: subjectColor3,
    comboActiveFill: disableColor02,
    comboInactiveStroke: disableColor04,
    comboInactiveFill: disableColor025,
    comboSelectedStroke: subjectColor3,
    comboSelectedFill: disableColor02,
    comboHighlightStroke: deeperSubject,
    comboHighlightFill: disableColor025,
    comboDisableStroke: disableColor04,
    comboDisableFill: disableColor02
  };
};
var getColorsWithSubjectColor = function getColorsWithSubjectColor2(subjectColor3, backColor3, theme, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (theme === void 0) {
    theme = "default";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  if (theme === "default")
    return getColorsWithDefaultTheme(subjectColor3, backColor3, "rgb(150, 150, 150)");
  return getColorsWithDarkTheme(subjectColor3, backColor3, "#777");
};
var getColorSetsBySubjectColors = function getColorSetsBySubjectColors2(subjectColors, backColor3, theme, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (theme === void 0) {
    theme = "default";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  var sets = [];
  subjectColors.forEach(function(sColor) {
    sets.push(getColorsWithSubjectColor(sColor, backColor3, theme, disableColor));
  });
  return sets;
};

// node_modules/@antv/g6-pc/es/global.js
var subjectColor2 = "rgb(95, 149, 255)";
var backColor2 = "rgb(255, 255, 255)";
var textColor2 = "rgb(0, 0, 0)";
var colorSet2 = getColorsWithSubjectColor(subjectColor2, backColor2);
var global_default2 = {
  version: "0.8.7",
  rootContainerClassName: "root-container",
  nodeContainerClassName: "node-container",
  edgeContainerClassName: "edge-container",
  comboContainerClassName: "combo-container",
  delegateContainerClassName: "delegate-container",
  defaultLoopPosition: "top",
  nodeLabel: {
    style: {
      fill: "#000",
      fontSize: 12,
      textAlign: "center",
      textBaseline: "middle"
    },
    offset: 4
    // 节点的默认文本不居中时的偏移量
  },
  defaultNode: {
    type: "circle",
    style: {
      lineWidth: 1,
      stroke: colorSet2.mainStroke,
      fill: colorSet2.mainFill
    },
    size: 20,
    color: colorSet2.mainStroke,
    linkPoints: {
      size: 8,
      lineWidth: 1,
      fill: colorSet2.activeFill,
      stroke: colorSet2.activeStroke
    }
  },
  // 节点应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  nodeStateStyles: {
    active: {
      fill: colorSet2.activeFill,
      stroke: colorSet2.activeStroke,
      lineWidth: 2,
      shadowColor: colorSet2.mainStroke,
      shadowBlur: 10
    },
    selected: {
      fill: colorSet2.selectedFill,
      stroke: colorSet2.selectedStroke,
      lineWidth: 4,
      shadowColor: colorSet2.selectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      fill: colorSet2.highlightFill,
      stroke: colorSet2.highlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      fill: colorSet2.inactiveFill,
      stroke: colorSet2.inactiveStroke,
      lineWidth: 1
    },
    disable: {
      fill: colorSet2.disableFill,
      stroke: colorSet2.disableStroke,
      lineWidth: 1
    }
  },
  edgeLabel: {
    style: {
      fill: textColor2,
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 12
    }
  },
  defaultEdge: {
    type: "line",
    size: 1,
    style: {
      stroke: colorSet2.edgeMainStroke,
      lineAppendWidth: 2
    },
    color: colorSet2.edgeMainStroke
  },
  // 边应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  edgeStateStyles: {
    active: {
      stroke: colorSet2.edgeActiveStroke,
      lineWidth: 1
    },
    selected: {
      stroke: colorSet2.edgeSelectedStroke,
      lineWidth: 2,
      shadowColor: colorSet2.edgeSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet2.edgeHighlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet2.edgeInactiveStroke,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet2.edgeDisableStroke,
      lineWidth: 1
    }
  },
  comboLabel: {
    style: {
      fill: textColor2,
      // textAlign: 'center',
      textBaseline: "middle",
      fontSize: 12
    },
    refY: 10,
    refX: 10
    // Combo 的默认文本不居中时的偏移量
  },
  defaultCombo: {
    type: "circle",
    style: {
      fill: colorSet2.comboMainFill,
      lineWidth: 1,
      stroke: colorSet2.comboMainStroke,
      r: 5,
      width: 20,
      height: 10
    },
    size: [20, 5],
    color: colorSet2.comboMainStroke,
    padding: [25, 20, 15, 20]
  },
  // combo 应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展
  comboStateStyles: {
    active: {
      stroke: colorSet2.comboActiveStroke,
      lineWidth: 1,
      fill: colorSet2.comboActiveFill
    },
    selected: {
      stroke: colorSet2.comboSelectedStroke,
      lineWidth: 2,
      fill: colorSet2.comboSelectedFill,
      shadowColor: colorSet2.comboSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet2.comboHighlightStroke,
      lineWidth: 2,
      fill: colorSet2.comboHighlightFill,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet2.comboInactiveStroke,
      fill: colorSet2.comboInactiveFill,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet2.comboDisableStroke,
      fill: colorSet2.comboDisableFill,
      lineWidth: 1
    }
  },
  delegateStyle: {
    fill: "#F3F9FF",
    fillOpacity: 0.5,
    stroke: "#1890FF",
    strokeOpacity: 0.9,
    lineDash: [5, 5]
  },
  // 文本水印默认配置
  textWaterMarkerConfig: {
    width: 150,
    height: 100,
    compatible: false,
    text: {
      x: 0,
      y: 60,
      lineHeight: 20,
      rotate: 20,
      fontSize: 14,
      fontFamily: "Microsoft YaHei",
      fill: "rgba(0, 0, 0, 0.1)",
      baseline: "Middle"
    }
  },
  imageWaterMarkerConfig: {
    width: 150,
    height: 130,
    compatible: false,
    image: {
      x: 0,
      y: 0,
      width: 30,
      height: 20,
      rotate: 0
    }
  },
  waterMarkerImage: "https://gw.alipayobjects.com/os/s/prod/antv/assets/image/logo-with-text-73b8a.svg"
};

// node_modules/@antv/g6-pc/es/graph/controller/event.js
init_tslib_es6();
init_esm();
var cloneEvent3 = util_default.cloneEvent;
var isViewportChanged3 = util_default.isViewportChanged;
var EventController2 = (
  /** @class */
  function(_super) {
    __extends(EventController3, _super);
    function EventController3(graph) {
      var _this = _super.call(this, graph) || this;
      _this.extendEvents = [];
      _this.dragging = false;
      _this.mousedown = false;
      _this.preItem = null;
      _this.destroy();
      _this.graph = graph;
      _this.destroyed = false;
      _this.initEvents();
      return _this;
    }
    EventController3.prototype.initEvents = function() {
      var _a2 = this, graph = _a2.graph, _b = _a2.extendEvents, extendEvents = _b === void 0 ? [] : _b;
      var canvas = graph.get("canvas");
      var el = canvas.get("el");
      var canvasHandler = wrap_behavior_default(this, "onCanvasEvents");
      var originHandler = wrap_behavior_default(this, "onExtendEvents");
      var wheelHandler = wrap_behavior_default(this, "onWheelEvent");
      canvas.off("*").on("*", canvasHandler);
      this.canvasHandler = canvasHandler;
      extendEvents.push(addEventListener(el, "wheel", wheelHandler));
      if (typeof window !== "undefined") {
        extendEvents.push(addEventListener(window, "keydown", originHandler));
        extendEvents.push(addEventListener(window, "keyup", originHandler));
        extendEvents.push(addEventListener(window, "focus", originHandler));
      }
      if (this.resetHandler)
        graph.off("afterchangedata", this.resetHandler);
      this.resetHandler = wrap_behavior_default(this, "resetStatus");
      graph.on("afterchangedata", this.resetHandler);
    };
    EventController3.getItemRoot = function(shape) {
      while (shape && !shape.get("item")) {
        shape = shape.get("parent");
      }
      return shape;
    };
    EventController3.prototype.onCanvasEvents = function(evt) {
      var _this = this;
      var graph = this.graph;
      var canvas = graph.get("canvas");
      var target = evt.target;
      var eventType = evt.type;
      switch (eventType) {
        case "drag":
          this.onCanvasEvents(Object.assign({}, evt, {
            type: "mousemove"
          }));
          break;
        case "dragend":
          this.onCanvasEvents(Object.assign({}, evt, {
            type: "mouseup"
          }));
          break;
        case "mousedown":
          this.mousedown = true;
          break;
        case "dragend":
        case "mouseup":
          setTimeout(function() {
            return _this.mousedown = false;
          });
          break;
        case "click":
          if (!this.mousedown)
            return;
          break;
        default:
          break;
      }
      evt.canvasX = evt.x;
      evt.canvasY = evt.y;
      var point = {
        x: evt.canvasX,
        y: evt.canvasY
      };
      var group = graph.get("group");
      var matrix = group.getMatrix();
      if (!matrix) {
        matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      if (isViewportChanged3(matrix)) {
        point = graph.getPointByClient(evt.clientX, evt.clientY);
      }
      evt.x = point.x;
      evt.y = point.y;
      evt.currentTarget = graph;
      if (target === canvas) {
        if (eventType === "mousemove" || eventType === "mouseleave") {
          this.handleMouseMove(evt, "canvas");
        }
        evt.target = canvas;
        evt.item = null;
        graph.emit(eventType, evt);
        graph.emit("canvas:".concat(eventType), evt);
        return;
      }
      var itemShape = EventController3.getItemRoot(target);
      if (!itemShape) {
        graph.emit(eventType, evt);
        return;
      }
      var item = itemShape.get("item");
      if (item.destroyed) {
        return;
      }
      var type = item.getType();
      evt.target = target;
      evt.item = item;
      if (evt.canvasX === evt.x && evt.canvasY === evt.y) {
        var canvasPoint = graph.getCanvasByPoint(evt.x, evt.y);
        evt.canvasX = canvasPoint.x;
        evt.canvasY = canvasPoint.y;
      }
      if (evt.name && !evt.name.includes(":")) {
        graph.emit("".concat(type, ":").concat(eventType), evt);
        graph.emit(eventType, evt);
      } else if (evt.name) {
        graph.emit(evt.name, evt);
      }
      if (eventType === "dragstart") {
        this.dragging = true;
      }
      if (eventType === "dragend") {
        this.dragging = false;
      }
      if (eventType === "mousemove") {
        this.handleMouseMove(evt, type);
      }
    };
    EventController3.prototype.onExtendEvents = function(evt) {
      this.graph.emit(evt.type, evt);
    };
    EventController3.prototype.onWheelEvent = function(evt) {
      if (is_nil_default(evt.wheelDelta)) {
        evt.wheelDelta = -evt.detail;
      }
      this.graph.emit("wheel", evt);
    };
    EventController3.prototype.handleMouseMove = function(evt, type) {
      var _a2 = this, graph = _a2.graph, preItem = _a2.preItem;
      var canvas = graph.get("canvas");
      var item = evt.target === canvas ? null : evt.item;
      evt = cloneEvent3(evt);
      if (preItem && preItem !== item && !preItem.destroyed) {
        evt.item = preItem;
        this.emitCustomEvent(preItem.getType(), "mouseleave", evt);
        if (this.dragging) {
          this.emitCustomEvent(preItem.getType(), "dragleave", evt);
        }
      }
      if (item && preItem !== item) {
        evt.item = item;
        this.emitCustomEvent(type, "mouseenter", evt);
        if (this.dragging) {
          this.emitCustomEvent(type, "dragenter", evt);
        }
      }
      this.preItem = item;
    };
    EventController3.prototype.emitCustomEvent = function(itemType, eventType, evt) {
      evt.type = eventType;
      this.graph.emit("".concat(itemType, ":").concat(eventType), evt);
    };
    EventController3.prototype.resetStatus = function() {
      this.mousedown = false;
      this.dragging = false;
      this.preItem = null;
    };
    EventController3.prototype.destroy = function() {
      var _a2 = this, graph = _a2.graph, canvasHandler = _a2.canvasHandler, extendEvents = _a2.extendEvents;
      var canvas = graph.get("canvas");
      canvas.off("*", canvasHandler);
      each_default(extendEvents, function(event) {
        event.remove();
      });
      this.resetStatus();
      this.extendEvents.length = 0;
      this.canvasHandler = null;
      this.resetHandler = null;
      this.destroyed = true;
    };
    return EventController3;
  }(event_default)
);
var event_default2 = EventController2;

// node_modules/@antv/g6-pc/es/graph/controller/layout.js
init_tslib_es6();

// node_modules/@antv/g6-pc/es/layout/index.js
var import_lib = __toESM(require_lib());

// node_modules/@antv/g6-pc/es/layout/tree-layout.js
var import_hierarchy = __toESM(require_hierarchy());

// node_modules/@antv/g6-pc/es/util/index.js
init_tslib_es6();

// node_modules/@antv/g6-pc/es/util/layout.js
var layout_exports2 = {};
__export(layout_exports2, {
  arrayToTextureData: () => arrayToTextureData,
  attributesToTextureData: () => attributesToTextureData,
  buildTextureData: () => buildTextureData,
  buildTextureDataWithOneEdgeAttr: () => buildTextureDataWithOneEdgeAttr,
  buildTextureDataWithTwoEdgeAttr: () => buildTextureDataWithTwoEdgeAttr,
  proccessToFunc: () => proccessToFunc,
  radialLayout: () => radialLayout
});
init_esm();
var traverseTree3 = util_default.traverseTree;
var proccessToFunc = function proccessToFunc2(value, defaultV) {
  var func;
  if (!value) {
    func = function func2(d2) {
      return defaultV || 1;
    };
  } else if (is_number_default(value)) {
    func = function func2(d2) {
      return value;
    };
  } else {
    func = value;
  }
  return func;
};
var buildTextureData = function buildTextureData2(nodes, edges) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len = dests.length;
    dataArray[i2 * 4 + 2] = offset;
    dataArray[i2 * 4 + 3] = dests.length;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);
    for (var j2 = 0; j2 < len; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr2(nodes, edges, attrs) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.source]].push(attrs(e8));
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
    nodeDict[mapIdPos[e8.target]].push(attrs(e8));
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len = dests.length;
    dataArray[i2 * 4 + 2] = offset;
    dataArray[i2 * 4 + 3] = len / 2;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);
    for (var j2 = 0; j2 < len; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr2(nodes, edges, attrs1, attrs2) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.source]].push(attrs1(e8));
    nodeDict[mapIdPos[e8.source]].push(attrs2(e8));
    nodeDict[mapIdPos[e8.source]].push(0);
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
    nodeDict[mapIdPos[e8.target]].push(attrs1(e8));
    nodeDict[mapIdPos[e8.target]].push(attrs2(e8));
    nodeDict[mapIdPos[e8.target]].push(0);
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len = dests.length;
    dataArray[i2 * 4 + 2] = offset + 1048576 * len / 4;
    dataArray[i2 * 4 + 3] = 0;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);
    for (var j2 = 0; j2 < len; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var attributesToTextureData = function attributesToTextureData2(attributeNames, items) {
  var dataArray = [];
  var attributeNum = attributeNames.length;
  var attributteStringMap = {};
  items.forEach(function(item) {
    attributeNames.forEach(function(name, i2) {
      if (attributteStringMap[item[name]] === void 0) {
        attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;
      }
      dataArray.push(attributteStringMap[item[name]]);
      if (i2 === attributeNum - 1) {
        while (dataArray.length % 4 !== 0) {
          dataArray.push(0);
        }
      }
    });
  });
  return {
    array: new Float32Array(dataArray),
    count: Object.keys(attributteStringMap).length
  };
};
var arrayToTextureData = function arrayToTextureData2(valueArrays) {
  var dataArray = [];
  var attributeNum = valueArrays.length;
  var itemNum = valueArrays[0].length;
  var _loop_1 = function _loop_12(j3) {
    valueArrays.forEach(function(valueArray, i2) {
      dataArray.push(valueArray[j3]);
      if (i2 === attributeNum - 1) {
        while (dataArray.length % 4 !== 0) {
          dataArray.push(0);
        }
      }
    });
  };
  for (var j2 = 0; j2 < itemNum; j2++) {
    _loop_1(j2);
  }
  return new Float32Array(dataArray);
};
var radialLayout = function radialLayout2(data, layout2) {
  var VERTICAL_LAYOUTS = ["V", "TB", "BT"];
  var min3 = {
    x: Infinity,
    y: Infinity
  };
  var max4 = {
    x: -Infinity,
    y: -Infinity
  };
  var rScale = "x";
  var radScale = "y";
  if (layout2 && VERTICAL_LAYOUTS.indexOf(layout2) >= 0) {
    radScale = "x";
    rScale = "y";
  }
  var count = 0;
  traverseTree3(data, function(node) {
    count++;
    if (node.x > max4.x) {
      max4.x = node.x;
    }
    if (node.x < min3.x) {
      min3.x = node.x;
    }
    if (node.y > max4.y) {
      max4.y = node.y;
    }
    if (node.y < min3.y) {
      min3.y = node.y;
    }
    return true;
  });
  var avgRad = Math.PI * 2 / count;
  var radDiff = max4[radScale] - min3[radScale];
  if (radDiff === 0) {
    return data;
  }
  traverseTree3(data, function(node) {
    var radial = (node[radScale] - min3[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;
    var r2 = Math.abs(rScale === "x" ? node.x - data.x : node.y - data.y);
    node.x = r2 * Math.cos(radial);
    node.y = r2 * Math.sin(radial);
    return true;
  });
  return data;
};

// node_modules/@antv/g6-pc/es/util/gpu.js
var gpu_exports = {};
__export(gpu_exports, {
  gpuDetector: () => gpuDetector
});
var gpuDetector = function gpuDetector2() {
  if (typeof window === "undefined" || typeof document === "undefined")
    return {};
  return {
    canvas: !!window.CanvasRenderingContext2D,
    webgl: function() {
      try {
        var canvas = document.createElement("canvas");
        return !!(window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
      } catch (e8) {
        return false;
      }
    }(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
    getWebGLErrorMessage: function getWebGLErrorMessage() {
      var element = document.createElement("div");
      element.id = "webgl-error-message";
      element.style.fontFamily = "monospace";
      element.style.fontSize = "13px";
      element.style.fontWeight = "normal";
      element.style.textAlign = "center";
      element.style.background = "#fff";
      element.style.color = "#000";
      element.style.padding = "1.5em";
      element.style.width = "400px";
      element.style.margin = "5em auto 0";
      if (!this.webgl) {
        element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" rel="external nofollow" rel="external nofollow" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" rel="external nofollow" rel="external nofollow" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" rel="external nofollow" rel="external nofollow" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" rel="external nofollow" rel="external nofollow" style="color:#000">here</a>.'].join("\n");
      }
      return element;
    },
    addGetWebGLMessage: function addGetWebGLMessage(parameters) {
      parameters = parameters || {};
      var parent = parameters.parent !== void 0 ? parameters.parent : document.body;
      var id = parameters.id !== void 0 ? parameters.id : "oldie";
      var element = gpuDetector2().getWebGLErrorMessage();
      element.id = id;
      parent.appendChild(element);
    }
  };
};

// node_modules/@antv/g6-pc/es/util/index.js
var G6Util = __assign(__assign(__assign(__assign({}, util_default), color_exports2), layout_exports2), gpu_exports);
var util_default2 = G6Util;

// node_modules/@antv/g6-pc/es/layout/tree-layout.js
var radialLayout3 = util_default2.radialLayout;
var TreeLayout = (
  /** @class */
  function() {
    function TreeLayout2(cfg) {
      this.type = cfg.type;
      this.radial = cfg.radial;
      this.config = cfg;
    }
    TreeLayout2.prototype.init = function(data) {
      var _this = this;
      this.data = data;
      if (this.radial) {
        this.layoutMethod = function(data2) {
          var layoutData = import_hierarchy.default[_this.type](data2, _this.config);
          radialLayout3(layoutData);
          return layoutData;
        };
        return;
      }
      this.layoutMethod = function(data2) {
        return import_hierarchy.default[_this.type](data2, _this.config);
      };
    };
    TreeLayout2.prototype.execute = function() {
      return this.layoutMethod(this.data, this.config);
    };
    TreeLayout2.prototype.layout = function(data) {
      this.init(data);
      return this.execute();
    };
    return TreeLayout2;
  }()
);
var tree_layout_default = TreeLayout;

// node_modules/@antv/g6-pc/es/layout/index.js
(0, import_lib.registerLayout)("grid", import_lib.GridLayout);
(0, import_lib.registerLayout)("random", import_lib.RandomLayout);
(0, import_lib.registerLayout)("force", import_lib.ForceLayout);
(0, import_lib.registerLayout)("circular", import_lib.CircularLayout);
(0, import_lib.registerLayout)("dagre", import_lib.DagreLayout);
(0, import_lib.registerLayout)("dagreCompound", import_lib.DagreCompoundLayout);
(0, import_lib.registerLayout)("radial", import_lib.RadialLayout);
(0, import_lib.registerLayout)("concentric", import_lib.ConcentricLayout);
(0, import_lib.registerLayout)("mds", import_lib.MDSLayout);
(0, import_lib.registerLayout)("fruchterman", import_lib.FruchtermanLayout);
(0, import_lib.registerLayout)("fruchterman-gpu", import_lib.FruchtermanGPULayout);
(0, import_lib.registerLayout)("gForce", import_lib.GForceLayout);
(0, import_lib.registerLayout)("force2", import_lib.Force2Layout);
(0, import_lib.registerLayout)("gForce-gpu", import_lib.GForceGPULayout);
(0, import_lib.registerLayout)("comboForce", import_lib.ComboForceLayout);
(0, import_lib.registerLayout)("comboCombined", import_lib.ComboCombinedLayout);
(0, import_lib.registerLayout)("forceAtlas2", import_lib.ForceAtlas2Layout);
var registerLayout = function registerLayout2(name, layoutOverride) {
  layoutOverride.isCustomLayout = true;
  import_lib.Layouts[name] = (0, import_lib.registerLayout)(name, layoutOverride);
};

// node_modules/@antv/g6-pc/es/layout/worker/work.js
var WebWorker = (
  /** @class */
  function() {
    function WebWorker2(worker, workerScirptURL) {
      var code = worker.toString();
      var blob = new Blob(["importScripts('".concat(workerScirptURL, "');(").concat(code, ")()")], {
        type: "text/javascript"
      });
      return new Worker(URL.createObjectURL(blob));
    }
    return WebWorker2;
  }()
);
var work_default = WebWorker;

// node_modules/@antv/g6-pc/es/layout/worker/layout.js
var LayoutWorker = function LayoutWorker2(workerScriptURL) {
  if (workerScriptURL === void 0) {
    workerScriptURL = "https://unpkg.com/@antv/layout@latest/dist/layout.min.js";
  }
  function workerCode() {
    var LAYOUT_MESSAGE2 = {
      // run layout
      RUN: "LAYOUT_RUN",
      // layout ended with success
      END: "LAYOUT_END",
      // layout error
      ERROR: "LAYOUT_ERROR",
      // layout tick, used in force directed layout
      TICK: "LAYOUT_TICK",
      GPURUN: "GPU_LAYOUT_RUN",
      GPUEND: "GPU_LAYOUT_END"
    };
    layout.registerLayout("grid", layout.GridLayout);
    layout.registerLayout("random", layout.RandomLayout);
    layout.registerLayout("force", layout.ForceLayout);
    layout.registerLayout("circular", layout.CircularLayout);
    layout.registerLayout("dagre", layout.DagreLayout);
    layout.registerLayout("dagreCompound", layout.DagreCompoundLayout);
    layout.registerLayout("radial", layout.RadialLayout);
    layout.registerLayout("concentric", layout.ConcentricLayout);
    layout.registerLayout("mds", layout.MDSLayout);
    layout.registerLayout("fruchterman", layout.FruchtermanLayout);
    layout.registerLayout("fruchterman-gpu", layout.FruchtermanGPULayout);
    layout.registerLayout("gForce", layout.GForceLayout);
    layout.registerLayout("gForce-gpu", layout.GForceGPULayout);
    layout.registerLayout("comboForce", layout.ComboForceLayout);
    layout.registerLayout("comboCombined", layout.ComboCombinedLayout);
    layout.registerLayout("forceAtlas2", layout.ForceAtlas2Layout);
    function isLayoutMessage(event) {
      var type = event.data.type;
      return type === LAYOUT_MESSAGE2.RUN || type === LAYOUT_MESSAGE2.GPURUN;
    }
    function handleLayoutMessage(event) {
      var _this = this;
      var type = event.data.type;
      switch (type) {
        case LAYOUT_MESSAGE2.RUN: {
          var _a2 = event.data, nodes_1 = _a2.nodes, edges = _a2.edges, _b = _a2.layoutCfg, layoutCfg = _b === void 0 ? {} : _b;
          var layoutType = layoutCfg.type;
          var LayoutClass = layout.getLayoutByName(layoutType);
          if (!LayoutClass) {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " not found")
            });
            break;
          }
          var layoutMethod_1;
          layoutCfg.onLayoutEnd = function() {
            _this.postMessage({
              type: LAYOUT_MESSAGE2.END,
              nodes: nodes_1
            });
            layoutMethod_1 === null || layoutMethod_1 === void 0 ? void 0 : layoutMethod_1.destroy();
          };
          layoutMethod_1 = new LayoutClass(layoutCfg);
          layoutMethod_1.init({
            nodes: nodes_1,
            edges
          });
          layoutMethod_1.execute();
          break;
        }
        case LAYOUT_MESSAGE2.GPURUN: {
          var _c = event.data, nodes = _c.nodes, edges = _c.edges, _d = _c.layoutCfg, layoutCfg = _d === void 0 ? {} : _d, canvas = _c.canvas;
          var layoutType = layoutCfg.type;
          var LayoutClass = layout.getLayoutByName(layoutType);
          if (!LayoutClass) {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " not found")
            });
            break;
          }
          if (layoutType.split("-")[1] !== "gpu") {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " does not support GPU")
            });
            break;
          }
          var layoutMethod = new LayoutClass(layoutCfg);
          layoutMethod.init({
            nodes,
            edges
          });
          layoutMethod.executeWithWorker(canvas, this);
          break;
        }
        default:
          break;
      }
    }
    onmessage = function onmessage2(event) {
      if (isLayoutMessage(event)) {
        handleLayoutMessage(event);
      }
    };
  }
  var layoutWorker = new work_default(workerCode, workerScriptURL);
  return layoutWorker;
};

// node_modules/@antv/g6-pc/es/layout/worker/layoutConst.js
var LAYOUT_MESSAGE = {
  // run layout
  RUN: "LAYOUT_RUN",
  // layout ended with success
  END: "LAYOUT_END",
  // layout error
  ERROR: "LAYOUT_ERROR",
  // layout tick, used in force directed layout
  TICK: "LAYOUT_TICK",
  GPURUN: "GPU_LAYOUT_RUN",
  GPUEND: "GPU_LAYOUT_END"
};

// node_modules/@antv/g6-pc/es/graph/controller/layout.js
init_esm();
function _typeof7(obj) {
  "@babel/helpers - typeof";
  return _typeof7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof7(obj);
}
var mockRaf = function mockRaf2(cb) {
  return setTimeout(cb, 16);
};
var mockCaf = function mockCaf2(reqId) {
  return clearTimeout(reqId);
};
var helper = {
  // pollyfill
  requestAnimationFrame: function requestAnimationFrame3(callback) {
    var fn2 = typeof window !== "undefined" ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || mockRaf : mockRaf;
    return fn2(callback);
  },
  cancelAnimationFrame: function cancelAnimationFrame3(requestId) {
    var fn2 = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || mockCaf : mockCaf;
    return fn2(requestId);
  }
};
var GPU_LAYOUT_NAMES = ["fruchterman", "gForce"];
var LAYOUT_PIPES_ADJUST_NAMES = ["force", "grid", "circular"];
var LayoutController2 = (
  /** @class */
  function(_super) {
    __extends(LayoutController3, _super);
    function LayoutController3(graph) {
      var _this = _super.call(this, graph) || this;
      _this.graph = graph;
      _this.layoutCfg = graph.get("layout") || {};
      _this.layoutType = _this.getLayoutType();
      _this.worker = null;
      _this.workerData = {};
      _this.initLayout();
      return _this;
    }
    LayoutController3.prototype.initLayout = function() {
    };
    LayoutController3.prototype.getWorker = function() {
      if (this.worker) {
        return this.worker;
      }
      if (typeof Worker === "undefined") {
        console.warn("Web worker is not supported in current browser.");
        this.worker = null;
      } else {
        this.worker = LayoutWorker(this.layoutCfg.workerScriptURL);
      }
      return this.worker;
    };
    LayoutController3.prototype.stopWorker = function() {
      var workerData = this.workerData;
      if (!this.worker) {
        return;
      }
      this.worker.terminate();
      this.worker = null;
      if (workerData.requestId) {
        helper.cancelAnimationFrame(workerData.requestId);
        workerData.requestId = null;
      }
      if (workerData.requestId2) {
        helper.cancelAnimationFrame(workerData.requestId2);
        workerData.requestId2 = null;
      }
    };
    LayoutController3.prototype.execLayoutMethod = function(layoutCfg, order) {
      var _this = this;
      return new Promise(function(reslove, reject) {
        return __awaiter(_this, void 0, void 0, function() {
          var graph, layoutType, onTick_1, animate_1, isDefaultAnimateLayout_1, tick, enableTick, layoutMethod, onTick_2, tick, layoutData;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                graph = this.graph;
                if (!graph || graph.get("destroyed"))
                  return [
                    2
                    /*return*/
                  ];
                layoutType = layoutCfg.type;
                layoutCfg.onLayoutEnd = function() {
                  graph.emit("aftersublayout", {
                    type: layoutType
                  });
                  reslove();
                };
                if (layoutType && this.isGPU) {
                  if (!this.hasGPUVersion(layoutType)) {
                    console.warn("The '".concat(layoutType, "' layout does not support GPU calculation for now, it will run in CPU."));
                  } else {
                    layoutType = "".concat(layoutType, "-gpu");
                  }
                }
                if (util_default.isForce(layoutType)) {
                  onTick_1 = layoutCfg.onTick, animate_1 = layoutCfg.animate;
                  isDefaultAnimateLayout_1 = animate_1 === void 0 && (layoutType === "force" || layoutType === "force2");
                  tick = function tick2() {
                    if (onTick_1) {
                      onTick_1();
                    }
                    if (animate_1 || isDefaultAnimateLayout_1)
                      graph.refreshPositions();
                  };
                  layoutCfg.tick = tick;
                } else if (layoutType === "comboForce" || layoutType === "comboCombined") {
                  layoutCfg.comboTrees = graph.get("comboTrees");
                }
                enableTick = false;
                try {
                  layoutMethod = new import_lib.Layouts[layoutType](layoutCfg);
                  if (this.layoutMethods[order]) {
                    this.layoutMethods[order].destroy();
                  }
                  this.layoutMethods[order] = layoutMethod;
                } catch (e8) {
                  console.warn("The layout method: '".concat(layoutType, "' does not exist! Please specify it first."));
                  reject();
                }
                enableTick = layoutMethod.enableTick;
                if (enableTick) {
                  onTick_2 = layoutCfg.onTick;
                  tick = function tick2() {
                    if (onTick_2) {
                      onTick_2();
                    }
                    graph.refreshPositions();
                  };
                  layoutMethod.tick = tick;
                }
                layoutData = this.filterLayoutData(this.data, layoutCfg);
                addLayoutOrder(layoutData, order);
                layoutMethod.init(layoutData);
                graph.emit("beforesublayout", {
                  type: layoutType
                });
                return [4, layoutMethod.execute()];
              case 1:
                _a2.sent();
                if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd)
                  layoutCfg.onLayoutEnd();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    };
    LayoutController3.prototype.updateLayoutMethod = function(layoutMethod, layoutCfg) {
      var _this = this;
      return new Promise(function(reslove, reject) {
        return __awaiter(_this, void 0, void 0, function() {
          var graph, layoutType, layoutData;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                graph = this.graph;
                layoutType = layoutCfg === null || layoutCfg === void 0 ? void 0 : layoutCfg.type;
                layoutCfg.onLayoutEnd = function() {
                  graph.emit("aftersublayout", {
                    type: layoutType
                  });
                  reslove();
                };
                layoutData = this.filterLayoutData(this.data, layoutCfg);
                layoutMethod.init(layoutData);
                layoutMethod.updateCfg(layoutCfg);
                graph.emit("beforesublayout", {
                  type: layoutType
                });
                return [4, layoutMethod.execute()];
              case 1:
                _a2.sent();
                if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd)
                  layoutCfg.onLayoutEnd();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    };
    LayoutController3.prototype.layout = function(success) {
      var _this = this;
      var _a2;
      var graph = this.graph;
      if (!graph || graph.get("destroyed"))
        return;
      this.data = this.setDataFromGraph();
      var _b = this.data, nodes = _b.nodes, hiddenNodes = _b.hiddenNodes;
      if (!nodes) {
        return false;
      }
      var width = graph.get("width");
      var height = graph.get("height");
      var layoutCfg = {};
      Object.assign(layoutCfg, {
        width,
        height,
        center: [width / 2, height / 2]
      }, this.layoutCfg);
      this.layoutCfg = layoutCfg;
      var layoutType = layoutCfg.type;
      var prevHasNodes = false;
      (_a2 = this.layoutMethods) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(method) {
        var _a3;
        return prevHasNodes = !!((_a3 = method.nodes) === null || _a3 === void 0 ? void 0 : _a3.length) || prevHasNodes;
      });
      var preLayoutTypes = this.destoryLayoutMethods();
      graph.emit("beforelayout");
      if (prevHasNodes && layoutType && (preLayoutTypes === null || preLayoutTypes === void 0 ? void 0 : preLayoutTypes.length) === 1 && preLayoutTypes[0] === layoutType) {
        this.tweakInit();
      } else {
        this.initPositions(layoutCfg.center, nodes);
      }
      this.initPositions(layoutCfg.center, hiddenNodes);
      if (layoutType && layoutType.split("-")[1] === "gpu") {
        layoutType = layoutType.split("-")[0];
        layoutCfg.gpuEnabled = true;
      }
      var enableGPU = false;
      if (layoutCfg.gpuEnabled) {
        enableGPU = true;
        if (!gpuDetector().webgl) {
          console.warn("Your browser does not support webGL or GPGPU. The layout will run in CPU.");
          enableGPU = false;
        }
      }
      if (enableGPU && !this.hasGPUVersion(layoutType)) {
        console.warn("The '".concat(layoutType, "' layout does not support GPU calculation for now, it will run in CPU."));
        enableGPU = false;
      }
      this.isGPU = enableGPU;
      var onLayoutEnd = layoutCfg.onLayoutEnd, layoutEndFormatted = layoutCfg.layoutEndFormatted, adjust = layoutCfg.adjust;
      if (!layoutEndFormatted) {
        layoutCfg.layoutEndFormatted = true;
        layoutCfg.onAllLayoutEnd = function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  if (onLayoutEnd) {
                    onLayoutEnd(nodes);
                  }
                  this.refreshLayout();
                  if (!(adjust && layoutCfg.pipes))
                    return [3, 2];
                  return [4, this.adjustPipesBox(this.data, adjust)];
                case 1:
                  _a3.sent();
                  this.refreshLayout();
                  _a3.label = 2;
                case 2:
                  graph.emit("afterlayout");
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
      }
      this.stopWorker();
      if (layoutCfg.workerEnabled && this.layoutWithWorker(this.data, success)) {
        return true;
      }
      var start = Promise.resolve();
      var hasLayout = false;
      if (layoutCfg.type) {
        hasLayout = true;
        start = start.then(function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.execLayoutMethod(layoutCfg, 0)];
                case 1:
                  return [2, _a3.sent()];
              }
            });
          });
        });
      } else if (layoutCfg.pipes) {
        hasLayout = true;
        layoutCfg.pipes.forEach(function(cfg, index2) {
          start = start.then(function() {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    return [4, this.execLayoutMethod(cfg, index2)];
                  case 1:
                    return [2, _a3.sent()];
                }
              });
            });
          });
        });
      }
      if (hasLayout) {
        start.then(function() {
          if (layoutCfg.onAllLayoutEnd)
            layoutCfg.onAllLayoutEnd();
          if (success)
            success();
        }).catch(function(error) {
          console.warn("graph layout failed,", error);
        });
      } else {
        graph.refreshPositions();
        success === null || success === void 0 ? void 0 : success();
      }
      return false;
    };
    LayoutController3.prototype.tweakInit = function() {
      var _a2 = this, data = _a2.data, graph = _a2.graph;
      var nodes = data.nodes, edges = data.edges;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
        return;
      var positionMap = {};
      nodes.forEach(function(node) {
        var x4 = node.x, y4 = node.y;
        if (!isNaN(x4) && !isNaN(y4)) {
          positionMap[node.id] = {
            x: x4,
            y: y4
          };
          node.mass = node.mass || 2;
        }
      });
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var sourcePosition = positionMap[source];
        var targetPosition = positionMap[target];
        if (!sourcePosition && targetPosition) {
          positionMap[source] = {
            x: targetPosition.x + (Math.random() - 0.5) * 80,
            y: targetPosition.y + (Math.random() - 0.5) * 80
          };
        } else if (!targetPosition && sourcePosition) {
          positionMap[target] = {
            x: sourcePosition.x + (Math.random() - 0.5) * 80,
            y: sourcePosition.y + (Math.random() - 0.5) * 80
          };
        }
      });
      var width = graph.get("width");
      var height = graph.get("height");
      nodes.forEach(function(node) {
        var position = positionMap[node.id] || {
          x: width / 2 + (Math.random() - 0.5) * 20,
          y: height / 2 + (Math.random() - 0.5) * 20
        };
        node.x = position.x;
        node.y = position.y;
      });
    };
    LayoutController3.prototype.initWithPreset = function() {
      var _a2 = this, layoutCfg = _a2.layoutCfg, data = _a2.data;
      var preset = layoutCfg.preset;
      if (!(preset === null || preset === void 0 ? void 0 : preset.type) || !import_lib.Layouts[preset === null || preset === void 0 ? void 0 : preset.type])
        return false;
      var presetLayout = new import_lib.Layouts[preset === null || preset === void 0 ? void 0 : preset.type](preset);
      presetLayout.layout(data);
      delete layoutCfg.preset;
      return true;
    };
    LayoutController3.prototype.layoutWithWorker = function(data, success) {
      var _this = this;
      var _a2 = this, layoutCfg = _a2.layoutCfg, graph = _a2.graph;
      var worker = this.getWorker();
      var workerData = this.workerData;
      if (!worker) {
        return false;
      }
      workerData.requestId = null;
      workerData.requestId2 = null;
      workerData.currentTick = null;
      workerData.currentTickData = null;
      graph.emit("beforelayout");
      var start = Promise.resolve();
      var hasLayout = false;
      if (layoutCfg.type) {
        hasLayout = true;
        start = start.then(function() {
          return _this.runWebworker(worker, data, layoutCfg);
        });
      } else if (layoutCfg.pipes) {
        hasLayout = true;
        var _loop_1 = function _loop_12(cfg2) {
          start = start.then(function() {
            return _this.runWebworker(worker, data, cfg2);
          });
        };
        for (var _i2 = 0, _b = layoutCfg.pipes; _i2 < _b.length; _i2++) {
          var cfg = _b[_i2];
          _loop_1(cfg);
        }
      }
      if (hasLayout) {
        start.then(function() {
          if (layoutCfg.onAllLayoutEnd)
            layoutCfg.onAllLayoutEnd();
          success === null || success === void 0 ? void 0 : success();
        }).catch(function(error) {
          console.error("layout failed", error);
        });
      }
      return true;
    };
    LayoutController3.prototype.runWebworker = function(worker, allData, layoutCfg) {
      var _this = this;
      var isGPU = this.isGPU;
      var data = this.filterLayoutData(allData, layoutCfg);
      var nodes = data.nodes, edges = data.edges;
      var offScreenCanvas = document.createElement("canvas");
      var gpuWorkerAbility = isGPU && typeof window !== "undefined" && // eslint-disable-next-line @typescript-eslint/dot-notation
      window.navigator && !navigator["gpu"] && // WebGPU 还不支持 OffscreenCanvas
      "OffscreenCanvas" in window && "transferControlToOffscreen" in offScreenCanvas;
      var filteredLayoutCfg = filterObject(layoutCfg, function(value) {
        return typeof value !== "function";
      });
      if (!gpuWorkerAbility) {
        worker.postMessage({
          type: LAYOUT_MESSAGE.RUN,
          nodes,
          edges,
          layoutCfg: filteredLayoutCfg
        });
      } else {
        var offscreen = offScreenCanvas.transferControlToOffscreen();
        filteredLayoutCfg.type = "".concat(filteredLayoutCfg.type, "-gpu");
        worker.postMessage({
          type: LAYOUT_MESSAGE.GPURUN,
          nodes,
          edges,
          layoutCfg: filteredLayoutCfg,
          canvas: offscreen
        }, [offscreen]);
      }
      return new Promise(function(reslove, reject) {
        worker.onmessage = function(event) {
          _this.handleWorkerMessage(reslove, reject, event, data, layoutCfg);
        };
      });
    };
    LayoutController3.prototype.handleWorkerMessage = function(reslove, reject, event, data, layoutCfg) {
      var _a2 = this, graph = _a2.graph, workerData = _a2.workerData;
      var eventData = event.data;
      var type = eventData.type;
      var onTick = function onTick2() {
        if (layoutCfg.onTick) {
          layoutCfg.onTick();
        }
      };
      switch (type) {
        case LAYOUT_MESSAGE.TICK:
          workerData.currentTick = eventData.currentTick;
          workerData.currentTickData = eventData;
          if (!workerData.requestId) {
            workerData.requestId = helper.requestAnimationFrame(function requestId() {
              updateLayoutPosition(data, eventData);
              graph.refreshPositions();
              onTick();
              if (eventData.currentTick === eventData.totalTicks) {
                reslove();
              } else if (workerData.currentTick === eventData.totalTicks) {
                workerData.requestId2 = helper.requestAnimationFrame(function requestId2() {
                  updateLayoutPosition(data, workerData.currentTickData);
                  graph.refreshPositions();
                  workerData.requestId2 = null;
                  onTick();
                  reslove();
                });
              }
              workerData.requestId = null;
            });
          }
          break;
        case LAYOUT_MESSAGE.END:
          if (workerData.currentTick == null) {
            updateLayoutPosition(data, eventData);
            reslove();
          }
          break;
        case LAYOUT_MESSAGE.GPUEND:
          if (workerData.currentTick == null) {
            updateGPUWorkerLayoutPosition(data, eventData);
            reslove();
          }
          break;
        case LAYOUT_MESSAGE.ERROR:
          console.warn("Web-Worker layout error!", eventData.message);
          reject();
          break;
        default:
          reject();
          break;
      }
    };
    LayoutController3.prototype.updateLayoutCfg = function(cfg) {
      var _this = this;
      var _a2 = this, graph = _a2.graph, layoutMethods = _a2.layoutMethods;
      if (!graph || graph.get("destroyed"))
        return;
      var disableTriggerLayout = cfg.disableTriggerLayout, otherCfg = __rest(cfg, ["disableTriggerLayout"]);
      var layoutCfg = mix({}, this.layoutCfg, otherCfg);
      this.layoutCfg = layoutCfg;
      if (disableTriggerLayout) {
        return;
      }
      if (!(layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length)) {
        this.layout();
        return;
      }
      this.data = this.setDataFromGraph();
      this.stopWorker();
      if (otherCfg.workerEnabled && this.layoutWithWorker(this.data, null)) {
        return;
      }
      graph.emit("beforelayout");
      var start = Promise.resolve();
      var hasLayout = false;
      if ((layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length) === 1) {
        hasLayout = true;
        start = start.then(function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, this.updateLayoutMethod(layoutMethods[0], layoutCfg)];
                case 1:
                  return [2, _a3.sent()];
              }
            });
          });
        });
      } else if (layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length) {
        hasLayout = true;
        layoutMethods.forEach(function(layoutMethod, index2) {
          var currentCfg = layoutCfg.pipes[index2];
          start = start.then(function() {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a3) {
                switch (_a3.label) {
                  case 0:
                    return [4, this.updateLayoutMethod(layoutMethod, currentCfg)];
                  case 1:
                    return [2, _a3.sent()];
                }
              });
            });
          });
        });
      }
      if (hasLayout) {
        start.then(function() {
          if (layoutCfg.onAllLayoutEnd)
            layoutCfg.onAllLayoutEnd();
        }).catch(function(error) {
          console.warn("layout failed", error);
        });
      }
    };
    LayoutController3.prototype.adjustPipesBox = function(data, adjust) {
      var _this = this;
      return new Promise(function(resolve) {
        var nodes = data.nodes;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
          resolve();
        }
        if (!LAYOUT_PIPES_ADJUST_NAMES.includes(adjust)) {
          console.warn("The adjust type ".concat(adjust, " is not supported yet, please assign it with 'force', 'grid', or 'circular'."));
          resolve();
        }
        var layoutCfg = {
          center: _this.layoutCfg.center,
          nodeSize: function nodeSize(d2) {
            return Math.max(d2.height, d2.width);
          },
          preventOverlap: true,
          onLayoutEnd: function onLayoutEnd() {
          }
        };
        var _a2 = _this.getLayoutBBox(nodes), groupNodes = _a2.groupNodes, layoutNodes = _a2.layoutNodes;
        var preNodes = clone_default(layoutNodes);
        layoutCfg.onLayoutEnd = function() {
          layoutNodes === null || layoutNodes === void 0 ? void 0 : layoutNodes.forEach(function(ele, index2) {
            var _a3, _b, _c;
            var dx = ele.x - ((_a3 = preNodes[index2]) === null || _a3 === void 0 ? void 0 : _a3.x);
            var dy = ele.y - ((_b = preNodes[index2]) === null || _b === void 0 ? void 0 : _b.y);
            (_c = groupNodes[index2]) === null || _c === void 0 ? void 0 : _c.forEach(function(n2) {
              n2.x += dx;
              n2.y += dy;
            });
          });
          resolve();
        };
        var layoutMethod = new import_lib.Layouts[adjust](layoutCfg);
        layoutMethod.layout({
          nodes: layoutNodes
        });
      });
    };
    LayoutController3.prototype.hasGPUVersion = function(layoutName) {
      return GPU_LAYOUT_NAMES.includes(layoutName);
    };
    LayoutController3.prototype.destroy = function() {
      this.destoryLayoutMethods();
      var worker = this.worker;
      if (worker) {
        worker.terminate();
        this.worker = null;
      }
      this.destroyed = true;
      this.graph.set("layout", void 0);
      this.layoutCfg = void 0;
      this.layoutType = void 0;
      this.layoutMethods = void 0;
      this.graph = null;
    };
    return LayoutController3;
  }(layout_default)
);
var layout_default2 = LayoutController2;
function updateLayoutPosition(data, layoutData) {
  var nodes = data.nodes;
  var layoutNodes = layoutData.nodes;
  var nodeLength = nodes.length;
  for (var i2 = 0; i2 < nodeLength; i2++) {
    var node = nodes[i2];
    node.x = layoutNodes[i2].x;
    node.y = layoutNodes[i2].y;
  }
}
function filterObject(collection, callback) {
  var result = {};
  if (collection && _typeof7(collection) === "object") {
    Object.keys(collection).forEach(function(key) {
      if (collection.hasOwnProperty(key) && callback(collection[key])) {
        result[key] = collection[key];
      }
    });
    return result;
  }
  return collection;
}
function updateGPUWorkerLayoutPosition(data, layoutData) {
  var nodes = data.nodes;
  var vertexEdgeData = layoutData.vertexEdgeData;
  var nodeLength = nodes.length;
  for (var i2 = 0; i2 < nodeLength; i2++) {
    var node = nodes[i2];
    var x4 = vertexEdgeData[4 * i2];
    var y4 = vertexEdgeData[4 * i2 + 1];
    node.x = x4;
    node.y = y4;
  }
}
function addLayoutOrder(data, order) {
  var _a2;
  if (!((_a2 = data === null || data === void 0 ? void 0 : data.nodes) === null || _a2 === void 0 ? void 0 : _a2.length)) {
    return;
  }
  var nodes = data.nodes;
  nodes.forEach(function(node) {
    node.layoutOrder = order;
  });
}

// node_modules/@antv/g6-pc/es/util/image.js
var cloneGElement = function cloneGElement2(element) {
  var vElement = element.clone();
  applyCloneClip(element, vElement);
  return vElement;
};
var applyCloneClip = function applyCloneClip2(element, clonedElement) {
  var _a2;
  if (element.isGroup() && clonedElement.isGroup()) {
    (_a2 = element.get("children")) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child, i2) {
      var clonedChild = clonedElement.get("children")[i2];
      applyCloneClip2(child, clonedChild);
    });
  }
  var type = element.get("type");
  var clonedType = clonedElement.get("type");
  if (type !== "image" || clonedType !== "image")
    return;
  var clipShape = element.get("clipShape");
  if (clipShape) {
    clonedElement.setClip({
      type: clipShape.get("type"),
      attrs: clipShape.attr()
    });
  }
};

// node_modules/@antv/g6-pc/es/graph/graph.js
var transform7 = ext_exports.transform;
var SVG = "svg";
var Graph3 = (
  /** @class */
  function(_super) {
    __extends(Graph4, _super);
    function Graph4(cfg) {
      var _this = _super.call(this, cfg) || this;
      var defaultNode = _this.get("defaultNode");
      if (!defaultNode) {
        _this.set("defaultNode", {
          type: "circle"
        });
      }
      if (!defaultNode.type) {
        defaultNode.type = "circle";
        _this.set("defaultNode", defaultNode);
      }
      _this.destroyed = false;
      return _this;
    }
    Graph4.prototype.initLayoutController = function() {
      var layoutController = new layout_default2(this);
      this.set({
        layoutController
      });
    };
    Graph4.prototype.initEventController = function() {
      var eventController = new event_default2(this);
      this.set({
        eventController
      });
    };
    Graph4.prototype.initCanvas = function() {
      var container = this.get("container");
      if (typeof container === "string") {
        container = document.getElementById(container);
        this.set("container", container);
      }
      if (!container) {
        throw new Error("invalid container");
      }
      var clientWidth = container.clientWidth, clientHeight = container.clientHeight;
      var width = this.get("width") || clientWidth;
      var height = this.get("height") || clientHeight;
      if (!this.get("width") && !this.get("height")) {
        this.set("width", clientWidth);
        this.set("height", clientHeight);
      }
      var renderer = this.get("renderer");
      var canvas;
      if (renderer === SVG) {
        canvas = new canvas_default2({
          container,
          width,
          height
        });
      } else {
        var canvasCfg = {
          container,
          width,
          height
        };
        var pixelRatio = this.get("pixelRatio");
        if (pixelRatio) {
          canvasCfg.pixelRatio = pixelRatio;
          window.devicePixelRatio = pixelRatio;
        }
        canvas = new canvas_default(canvasCfg);
      }
      this.set("canvas", canvas);
    };
    Graph4.prototype.initPlugins = function() {
      var self2 = this;
      each_default(self2.get("plugins"), function(plugin) {
        if (!plugin.destroyed && plugin.initPlugin) {
          plugin.initPlugin(self2);
        }
      });
    };
    Graph4.prototype.downloadImageWatermark = function(watermarker, context, width, height) {
      return __awaiter(this, void 0, void 0, function() {
        var watermarkStr, watermarkbase64, img;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              watermarkStr = watermarker.style.backgroundImage;
              watermarkbase64 = watermarkStr.slice(5, watermarkStr.length - 2);
              img = new Image();
              img.src = watermarkbase64;
              return [4, new Promise(function(resolve) {
                img.onload = function() {
                  var pat = context.createPattern(img, "repeat");
                  context.rect(0, 0, width, height);
                  context.fillStyle = pat;
                  context.fill();
                  resolve("");
                };
              })];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Graph4.prototype.asyncToDataUrl = function(type, backgroundColor, callback, widths, heights, vCanvasEl) {
      var _this = this;
      var watermarker = document.querySelector(".g6-graph-watermarker");
      var canvas = this.get("canvas");
      var renderer = canvas.getRenderer();
      var canvasDom = vCanvasEl || canvas.get("el");
      var dataURL = "";
      if (!type)
        type = "image/png";
      setTimeout(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var cloneNode, svgDocType, svgDoc, svgData, imageData, context, width, height, compositeOperation, pixelRatio;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!(renderer === "svg"))
                  return [3, 1];
                cloneNode = canvasDom.cloneNode(true);
                svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
                svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
                svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
                svgData = new XMLSerializer().serializeToString(svgDoc);
                dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
                return [3, 4];
              case 1:
                imageData = void 0;
                context = canvasDom.getContext("2d");
                width = widths || this.get("width");
                height = heights || this.get("height");
                compositeOperation = void 0;
                if (!watermarker)
                  return [3, 3];
                return [4, this.downloadImageWatermark(watermarker, context, width, height)];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                if (backgroundColor) {
                  pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio : 1;
                  try {
                    imageData = context.getImageData(0, 0, width * pixelRatio, height * pixelRatio);
                    compositeOperation = context.globalCompositeOperation;
                    context.globalCompositeOperation = "destination-over";
                    context.fillStyle = backgroundColor;
                    context.fillRect(0, 0, width, height);
                  } catch (error) {
                    console.error("Download image failed. Out of memory at ImageData creation");
                  }
                }
                dataURL = canvasDom.toDataURL(type);
                if (backgroundColor) {
                  context.clearRect(0, 0, width, height);
                  context.putImageData(imageData, 0, 0);
                  context.globalCompositeOperation = compositeOperation;
                }
                _a2.label = 4;
              case 4:
                if (callback)
                  callback(dataURL);
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, 16);
    };
    Graph4.prototype.toDataURL = function(type, backgroundColor) {
      var canvas = this.get("canvas");
      var renderer = canvas.getRenderer();
      var canvasDom = canvas.get("el");
      if (!type)
        type = "image/png";
      var dataURL = "";
      if (renderer === "svg") {
        var cloneNode = canvasDom.cloneNode(true);
        var svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
        var svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
        svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
        var svgData = new XMLSerializer().serializeToString(svgDoc);
        dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
      } else {
        var imageData = void 0;
        var context = canvasDom.getContext("2d");
        var width = Math.max(this.get("width"), 500);
        var height = Math.max(this.get("height"), 500);
        var compositeOperation = void 0;
        if (backgroundColor) {
          var pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
          try {
            imageData = context.getImageData(0, 0, width * pixelRatio, height * pixelRatio);
            compositeOperation = context.globalCompositeOperation;
            context.globalCompositeOperation = "destination-over";
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, width, height);
          } catch (error) {
            console.error("Download image failed. Out of memory at ImageData creation");
          }
        }
        dataURL = canvasDom.toDataURL(type);
        if (backgroundColor) {
          context.clearRect(0, 0, width, height);
          context.putImageData(imageData, 0, 0);
          context.globalCompositeOperation = compositeOperation;
        }
      }
      return dataURL;
    };
    Graph4.prototype.toFullDataURL = function(callback, type, imageConfig) {
      var bbox = this.get("group").getCanvasBBox();
      var height = bbox.height;
      var width = bbox.width;
      var renderer = this.get("renderer");
      var vContainerDOM = createDom('<div id="virtual-image"></div>');
      var backgroundColor = imageConfig ? imageConfig.backgroundColor : void 0;
      var padding = imageConfig ? imageConfig.padding : void 0;
      if (!padding)
        padding = [0, 0, 0, 0];
      else if (is_number_default(padding))
        padding = [padding, padding, padding, padding];
      var vHeight = height + padding[0] + padding[2];
      var vWidth = width + padding[1] + padding[3];
      var canvasOptions = {
        container: vContainerDOM,
        height: vHeight,
        width: vWidth,
        quickHit: true
      };
      var vCanvas = renderer === "svg" ? new canvas_default2(canvasOptions) : new canvas_default(canvasOptions);
      var group = this.get("group");
      var vGroup = group.clone();
      var matrix = clone_default(vGroup.getMatrix());
      if (!matrix)
        matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var centerX = (bbox.maxX + bbox.minX) / 2;
      var centerY = (bbox.maxY + bbox.minY) / 2;
      matrix = transform7(matrix, [["t", -centerX, -centerY], ["t", width / 2 + padding[3], height / 2 + padding[0]]]);
      vGroup.resetMatrix();
      vGroup.setMatrix(matrix);
      vCanvas.add(vGroup);
      var vCanvasEl = vCanvas.get("el");
      var dataURL = "";
      if (!type)
        type = "image/png";
      setTimeout(function() {
        if (renderer === "svg") {
          var cloneNode = vCanvasEl.cloneNode(true);
          var svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
          var svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
          svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
          var svgData = new XMLSerializer().serializeToString(svgDoc);
          dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
        } else {
          var imageData = void 0;
          var context = vCanvasEl.getContext("2d");
          var compositeOperation = void 0;
          if (backgroundColor) {
            var pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio : 1;
            try {
              imageData = context.getImageData(0, 0, vWidth * pixelRatio, vHeight * pixelRatio);
              compositeOperation = context.globalCompositeOperation;
              context.globalCompositeOperation = "destination-over";
              context.fillStyle = backgroundColor;
              context.fillRect(0, 0, vWidth, vHeight);
            } catch (error) {
              console.error("Download image failed. Out of memory at ImageData creation");
            }
          }
          dataURL = vCanvasEl.toDataURL(type);
          if (backgroundColor) {
            context.clearRect(0, 0, vWidth, vHeight);
            context.putImageData(imageData, 0, 0);
            context.globalCompositeOperation = compositeOperation;
          }
        }
        if (callback)
          callback(dataURL);
      }, 16);
    };
    Graph4.prototype.downloadFullImage = function(name, type, imageConfig) {
      var _this = this;
      var bbox = this.get("group").getCanvasBBox();
      var height = bbox.height;
      var width = bbox.width;
      var renderer = this.get("renderer");
      var vContainerDOM = createDom('<div id="virtual-image"></div>');
      var watermarker = document.querySelector(".g6-graph-watermarker");
      var backgroundColor = imageConfig ? imageConfig.backgroundColor : void 0;
      var padding = imageConfig ? imageConfig.padding : void 0;
      if (!padding)
        padding = [0, 0, 0, 0];
      else if (is_number_default(padding))
        padding = [padding, padding, padding, padding];
      var vHeight = height + padding[0] + padding[2];
      var vWidth = width + padding[1] + padding[3];
      if (watermarker) {
        var _a2 = this.get("graphWaterMarker").cfg || {}, wmWidth = _a2.width, wmHeight = _a2.height;
        vHeight = Math.ceil(vHeight / wmHeight) * wmHeight;
        vWidth = Math.ceil(vWidth / wmWidth) * wmWidth;
      }
      var canvasOptions = {
        container: vContainerDOM,
        height: vHeight,
        width: vWidth
      };
      var vCanvas = renderer === "svg" ? new canvas_default2(canvasOptions) : new canvas_default(canvasOptions);
      var group = this.get("group");
      var vGroup = cloneGElement(group);
      var matrix = clone_default(vGroup.getMatrix());
      if (!matrix)
        matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var centerX = (bbox.maxX + bbox.minX) / 2;
      var centerY = (bbox.maxY + bbox.minY) / 2;
      matrix = transform7(matrix, [["t", -centerX, -centerY], ["t", width / 2 + padding[3], height / 2 + padding[0]]]);
      vGroup.resetMatrix();
      vGroup.setMatrix(matrix);
      vCanvas.add(vGroup);
      var vCanvasEl = vCanvas.get("el");
      if (!type)
        type = "image/png";
      this.asyncToDataUrl(type, backgroundColor, function(dataURL) {
        var link = document.createElement("a");
        var fileName = (name || "graph") + (renderer === "svg" ? ".svg" : ".".concat(type.split("/")[1]));
        _this.dataURLToImage(dataURL, renderer, link, fileName);
        var e8 = document.createEvent("MouseEvents");
        e8.initEvent("click", false, false);
        link.dispatchEvent(e8);
      }, vWidth, vHeight, vCanvasEl);
    };
    Graph4.prototype.downloadImage = function(name, type, backgroundColor) {
      var _this = this;
      var self2 = this;
      self2.stopAnimate();
      var canvas = self2.get("canvas");
      var renderer = canvas.getRenderer();
      if (!type)
        type = "image/png";
      var fileName = (name || "graph") + (renderer === "svg" ? ".svg" : type.split("/")[1]);
      var link = document.createElement("a");
      self2.asyncToDataUrl(type, backgroundColor, function(dataURL) {
        _this.dataURLToImage(dataURL, renderer, link, fileName);
        var e8 = document.createEvent("MouseEvents");
        e8.initEvent("click", false, false);
        link.dispatchEvent(e8);
      });
    };
    Graph4.prototype.dataURLToImage = function(dataURL, renderer, link, fileName) {
      if (!dataURL || dataURL === "data:") {
        console.error("Download image failed. The graph is too large or there is invalid attribute values in graph items");
        return;
      }
      if (typeof window !== "undefined") {
        if (window.Blob && window.URL && renderer !== "svg") {
          var arr = dataURL.split(",");
          var mime = "";
          if (arr && arr.length > 0) {
            var match = arr[0].match(/:(.*?);/);
            if (match && match.length >= 2)
              mime = match[1];
          }
          var bstr = atob(arr[1]);
          var n2 = bstr.length;
          var u8arr = new Uint8Array(n2);
          while (n2--) {
            u8arr[n2] = bstr.charCodeAt(n2);
          }
          var blobObj_1 = new Blob([u8arr], {
            type: mime
          });
          if (window.navigator.msSaveBlob) {
            window.navigator.msSaveBlob(blobObj_1, fileName);
          } else {
            link.addEventListener("click", function() {
              link.download = fileName;
              link.href = window.URL.createObjectURL(blobObj_1);
            });
          }
        } else {
          link.addEventListener("click", function() {
            link.download = fileName;
            link.href = dataURL;
          });
        }
      }
    };
    Graph4.prototype.addPlugin = function(plugin) {
      var self2 = this;
      if (plugin.destroyed) {
        return;
      }
      self2.get("plugins").push(plugin);
      plugin.initPlugin(self2);
    };
    Graph4.prototype.removePlugin = function(plugin) {
      var plugins = this.get("plugins");
      var index2 = plugins.indexOf(plugin);
      if (index2 >= 0) {
        plugin.destroyPlugin();
        plugins.splice(index2, 1);
      }
    };
    Graph4.prototype.setImageWaterMarker = function(imgURL, config) {
      if (imgURL === void 0) {
        imgURL = global_default2.waterMarkerImage;
      }
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      if (!container.style.position) {
        container.style.position = "relative";
      }
      var canvas = this.get("graphWaterMarker");
      var waterMarkerConfig = deep_mix_default({}, global_default2.imageWaterMarkerConfig, config);
      var width = waterMarkerConfig.width, height = waterMarkerConfig.height, compatible = waterMarkerConfig.compatible, image = waterMarkerConfig.image;
      if (!imgURL) {
        var dom = compatible ? container : document.querySelector(".g6-graph-watermarker");
        if (dom)
          dom.style.cssText = void 0;
        if (canvas)
          canvas.clear();
        return;
      }
      if (!canvas) {
        var canvasCfg = {
          container,
          width,
          height,
          capture: false
        };
        var pixelRatio = this.get("pixelRatio");
        if (pixelRatio) {
          canvasCfg.pixelRatio = pixelRatio;
          window.devicePixelRatio = pixelRatio;
        }
        canvas = new canvas_default(canvasCfg);
        this.set("graphWaterMarker", canvas);
      } else {
        canvas.clear();
      }
      canvas.get("el").style.display = "none";
      var ctx = canvas.get("context");
      var rotate3 = image.rotate, x4 = image.x, y4 = image.y;
      ctx.rotate(-rotate3 * Math.PI / 180);
      var img = new Image();
      img.crossOrigin = "anonymous";
      img.src = imgURL;
      img.onload = function() {
        ctx.drawImage(img, x4, y4, image.width, image.height);
        ctx.rotate(rotate3 * Math.PI / 180);
        if (!compatible) {
          var box = document.querySelector(".g6-graph-watermarker");
          if (!box) {
            box = document.createElement("div");
            box.className = "g6-graph-watermarker";
          }
          box.className = "g6-graph-watermarker";
          if (!canvas.destroyed) {
            box.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none;z-index:-1;");
            container.appendChild(box);
          }
        } else {
          container.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;");
        }
      };
    };
    Graph4.prototype.setTextWaterMarker = function(texts, config) {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      if (!container.style.position) {
        container.style.position = "relative";
      }
      var canvas = this.get("graphWaterMarker");
      var waterMarkerConfig = deep_mix_default({}, global_default2.textWaterMarkerConfig, config);
      var width = waterMarkerConfig.width, height = waterMarkerConfig.height, compatible = waterMarkerConfig.compatible, text = waterMarkerConfig.text;
      if (!(texts === null || texts === void 0 ? void 0 : texts.length)) {
        var dom = compatible ? container : document.querySelector(".g6-graph-watermarker");
        if (dom)
          dom.style.cssText = void 0;
        if (canvas)
          canvas.clear();
        return;
      }
      if (!canvas) {
        var canvasCfg = {
          container,
          width,
          height,
          capture: false
        };
        var pixelRatio = this.get("pixelRatio");
        if (pixelRatio) {
          canvasCfg.pixelRatio = pixelRatio;
          window.devicePixelRatio = pixelRatio;
        }
        canvas = new canvas_default(canvasCfg);
        this.set("graphWaterMarker", canvas);
      } else {
        canvas.clear();
      }
      canvas.get("el").style.display = "none";
      var ctx = canvas.get("context");
      var rotate3 = text.rotate, fill = text.fill, fontFamily = text.fontFamily, fontSize = text.fontSize, baseline = text.baseline, x4 = text.x, y4 = text.y, lineHeight = text.lineHeight;
      ctx.rotate(-rotate3 * Math.PI / 180);
      ctx.font = "".concat(fontSize, "px ").concat(fontFamily);
      ctx.fillStyle = fill;
      ctx.textBaseline = baseline;
      var displayTexts = is_string_default(texts) ? [texts] : texts;
      for (var i2 = displayTexts.length - 1; i2 >= 0; i2--) {
        ctx.fillText(displayTexts[i2], x4, y4 + i2 * lineHeight);
      }
      ctx.rotate(rotate3 * Math.PI / 180);
      if (!compatible) {
        var box = document.querySelector(".g6-graph-watermarker");
        if (!box) {
          box = document.createElement("div");
          box.className = "g6-graph-watermarker";
        }
        box.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none;z-index:99;");
        container.appendChild(box);
      } else {
        container.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;");
      }
    };
    Graph4.prototype.destroy = function() {
      var _a2, _b, _c, _d;
      each_default(this.get("plugins"), function(plugin) {
        plugin.destroyPlugin();
      });
      var tooltipDOMs = this.get("tooltips");
      if (tooltipDOMs) {
        for (var i2 = 0; i2 < tooltipDOMs.length; i2++) {
          var container = tooltipDOMs[i2];
          if (!container)
            continue;
          var parent_1 = container.parentElement;
          if (!parent_1)
            continue;
          parent_1.removeChild(container);
        }
      }
      (_a2 = this.get("eventController")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.get("layoutController")) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.get("graphWaterMarker")) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = document.querySelector(".g6-graph-watermarker")) === null || _d === void 0 ? void 0 : _d.remove();
      _super.prototype.destroy.call(this);
    };
    return Graph4;
  }(graph_default)
);
var graph_default2 = Graph3;

// node_modules/@antv/g6-pc/es/graph/tree-graph.js
init_tslib_es6();
var import_hierarchy2 = __toESM(require_hierarchy());
init_esm();
var radialLayout4 = util_default2.radialLayout;
var traverseTree4 = util_default2.traverseTree;
var TreeGraph = (
  /** @class */
  function(_super) {
    __extends(TreeGraph2, _super);
    function TreeGraph2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.layoutAnimating = false;
      _this.set("removeList", []);
      _this.set("layoutMethod", _this.getLayout());
      return _this;
    }
    TreeGraph2.prototype.getLayout = function() {
      var layout2 = this.get("layout");
      if (!layout2) {
        return null;
      }
      if (typeof layout2 === "function") {
        return layout2;
      }
      if (!layout2.type) {
        layout2.type = "dendrogram";
      }
      if (!layout2.direction) {
        layout2.direction = layout2.type === "indented" ? "LR" : "TB";
      }
      if (layout2.radial) {
        return function(data) {
          var layoutData = import_hierarchy2.default[layout2.type](data, layout2);
          radialLayout4(layoutData);
          return layoutData;
        };
      }
      return function(data) {
        return import_hierarchy2.default[layout2.type](data, layout2);
      };
    };
    TreeGraph2.indexOfChild = function(children, id) {
      var index2 = -1;
      each_default(children, function(former, i2) {
        if (id === former.id) {
          index2 = i2;
          return false;
        }
      });
      return index2;
    };
    TreeGraph2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg.animate = true;
      return cfg;
    };
    TreeGraph2.prototype.innerAddChild = function(treeData, parent, animate) {
      var self2 = this;
      var model = treeData.data;
      if (model) {
        model.x = treeData.x;
        model.y = treeData.y;
        model.depth = treeData.depth;
      }
      var node = self2.addItem("node", model, false);
      if (parent) {
        node.set("parent", parent);
        if (animate) {
          var origin_1 = parent.get("originAttrs");
          if (origin_1) {
            node.set("originAttrs", origin_1);
          } else {
            var parentModel = parent.getModel();
            node.set("originAttrs", {
              x: parentModel.x,
              y: parentModel.y
            });
          }
        }
        var childrenList = parent.get("children");
        if (!childrenList) {
          parent.set("children", [node]);
        } else {
          childrenList.push(node);
        }
        self2.addItem("edge", {
          source: parent.get("id"),
          target: node.get("id"),
          id: "".concat(parent.get("id"), ":").concat(node.get("id"))
        }, false);
      }
      each_default(treeData.children || [], function(child) {
        self2.innerAddChild(child, node, animate);
      });
      self2.emit("afteraddchild", {
        item: node,
        parent
      });
      return node;
    };
    TreeGraph2.prototype.innerUpdateChild = function(data, parent, animate) {
      var self2 = this;
      var current = self2.findById(data.id);
      if (!current) {
        self2.innerAddChild(data, parent, animate);
        return;
      }
      each_default(data.children || [], function(child2) {
        self2.innerUpdateChild(child2, current, animate);
      });
      var children = current.get("children");
      if (children) {
        var len = children.length;
        if (len > 0) {
          for (var i2 = children.length - 1; i2 >= 0; i2--) {
            var child = children[i2].getModel();
            if (TreeGraph2.indexOfChild(data.children || [], child.id) === -1) {
              self2.innerRemoveChild(child.id, {
                x: data.x,
                y: data.y
              }, animate);
              children.splice(i2, 1);
            }
          }
        }
      }
      var oriX;
      var oriY;
      if (current.get("originAttrs")) {
        oriX = current.get("originAttrs").x;
        oriY = current.get("originAttrs").y;
      }
      var model = current.getModel();
      if (animate) {
        current.set("originAttrs", {
          x: model.x,
          y: model.y
        });
      }
      current.set("model", Object.assign(model, data.data));
      if (oriX !== data.x || oriY !== data.y) {
        current.updatePosition({
          x: data.x,
          y: data.y
        });
      }
    };
    TreeGraph2.prototype.innerRemoveChild = function(id, to2, animate) {
      var self2 = this;
      var node = self2.findById(id);
      if (!node) {
        return;
      }
      each_default(node.get("children"), function(child) {
        self2.innerRemoveChild(child.getModel().id, to2, animate);
      });
      if (animate) {
        var model = node.getModel();
        node.set("to", to2);
        node.set("originAttrs", {
          x: model.x,
          y: model.y
        });
        self2.get("removeList").push(node);
      } else {
        self2.removeItem(node, false);
      }
    };
    TreeGraph2.prototype.changeData = function(data, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      this.getNodes().map(function(node) {
        return self2.clearItemStates(node);
      });
      this.getEdges().map(function(edge) {
        return self2.clearItemStates(edge);
      });
      if (stack && this.get("enabledStack")) {
        this.pushStack("changedata", {
          before: self2.get("originData"),
          after: data || self2.get("data")
        });
      }
      if (data) {
        self2.data(data);
        self2.render(false);
      } else {
        self2.layout(this.get("fitView"));
      }
    };
    TreeGraph2.prototype.changeLayout = function(layout2) {
      console.warn("Please call updateLayout instead of changeLayout. changeLayout will be discarded soon");
      var self2 = this;
      self2.updateLayout(layout2);
    };
    TreeGraph2.prototype.updateLayout = function(layout2, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      if (!layout2) {
        console.warn("layout cannot be null");
        return;
      }
      if (stack && this.get("enabledStack")) {
        this.pushStack("layout", {
          before: self2.get("layout"),
          after: layout2
        });
      }
      self2.set("layout", layout2);
      self2.set("layoutMethod", self2.getLayout());
      self2.layout();
    };
    TreeGraph2.prototype.refreshLayout = function(fitView) {
      console.warn("Please call layout instead of refreshLayout. refreshLayout will be discarded soon");
      var self2 = this;
      self2.layout(fitView);
    };
    TreeGraph2.prototype.layout = function(fitView) {
      var self2 = this;
      var data = self2.get("data");
      var layoutMethod = self2.get("layoutMethod");
      var layoutData = layoutMethod ? layoutMethod(data, self2.get("layout")) : data;
      var animate = self2.get("animate");
      self2.emit("beforerefreshlayout", {
        data,
        layoutData
      });
      self2.emit("beforelayout");
      self2.innerUpdateChild(layoutData, void 0, animate);
      if (fitView) {
        var viewController = self2.get("viewController");
        viewController.fitView();
      }
      if (!animate) {
        self2.refresh();
        self2.paint();
      } else {
        self2.layoutAnimate(layoutData);
      }
      self2.emit("afterrefreshlayout", {
        data,
        layoutData
      });
      self2.emit("afterlayout");
    };
    TreeGraph2.prototype.addChild = function(data, parent, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      self2.emit("beforeaddchild", {
        model: data,
        parent
      });
      if (!is_string_default(parent)) {
        parent = parent.get("id");
      }
      var parentData = self2.findDataById(parent);
      if (parentData) {
        if (!parentData.children) {
          parentData.children = [];
        }
        parentData.children.push(data);
        var parentItem = self2.findById(parent);
        parentItem.refresh();
        self2.changeData(void 0, stack);
      }
    };
    TreeGraph2.prototype.updateChildren = function(data, parentId, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      var parentItem = self2.findById(parentId);
      if (!parentId || !parentItem) {
        console.warn("Update children failed! There is no node with id '".concat(parentId, "'"));
        return;
      }
      var parentModel = self2.findDataById(parentId);
      parentModel.children = data;
      parentItem.refresh();
      self2.changeData(void 0, stack);
    };
    TreeGraph2.prototype.updateChild = function(data, parentId, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      if (!parentId || !self2.findById(parentId)) {
        self2.changeData(data, stack);
        return;
      }
      var parentModel = self2.findDataById(parentId);
      var current = self2.findById(data.id);
      if (!parentModel.children) {
        parentModel.children = [];
      }
      if (!current) {
        parentModel.children.push(data);
      } else {
        var index2 = TreeGraph2.indexOfChild(parentModel.children, data.id);
        if (index2 > -1)
          parentModel.children[index2] = data;
      }
      var parentItem = self2.findById(parentId);
      parentItem === null || parentItem === void 0 ? void 0 : parentItem.refresh();
      self2.changeData(void 0, stack);
    };
    TreeGraph2.prototype.removeChild = function(id, stack) {
      if (stack === void 0) {
        stack = true;
      }
      var self2 = this;
      var node = self2.findById(id);
      var parent;
      if (!node) {
        parent = self2.getNodes().find(function(node2) {
          var children = node2.getModel().children || [];
          return !!children.find(function(child) {
            return child.id === id;
          });
        });
      } else {
        parent = node === null || node === void 0 ? void 0 : node.get("parent");
      }
      if (parent && !parent.destroyed) {
        var parentId = parent.get("id");
        var parentNode = self2.findDataById(parentId);
        var siblings = parentNode && parentNode.children || [];
        var index2 = TreeGraph2.indexOfChild(siblings, id);
        siblings.splice(index2, 1);
        parent.refresh();
      }
      self2.changeData(void 0, stack);
    };
    TreeGraph2.prototype.findDataById = function(id, parent) {
      var self2 = this;
      if (!parent) {
        parent = self2.get("data");
      }
      if (id === parent.id) {
        return parent;
      }
      var result = null;
      each_default(parent.children || [], function(child) {
        if (child.id === id) {
          result = child;
          return false;
        }
        result = self2.findDataById(id, child);
        if (result) {
          return false;
        }
      });
      return result;
    };
    TreeGraph2.prototype.layoutAnimate = function(data, onFrame) {
      var self2 = this;
      var animateCfg = this.get("animateCfg");
      self2.emit("beforeanimate", {
        data
      });
      self2.getEdges().forEach(function(edge) {
        var model = edge.get("model");
        if (!model.sourceAnchor) {
          model.sourceAnchor = edge.get("sourceAnchorIndex");
        }
      });
      this.get("canvas").animate(function(ratio) {
        traverseTree4(data, function(child) {
          var node = self2.findById(child.id);
          if (node) {
            var origin_2 = node.get("originAttrs");
            var model = node.get("model");
            if (!origin_2) {
              origin_2 = {
                x: model.x,
                y: model.y
              };
              node.set("originAttrs", origin_2);
            }
            if (onFrame) {
              var attrs = onFrame(node, ratio, origin_2, data);
              node.set("model", Object.assign(model, attrs));
            } else {
              model.x = origin_2.x + (child.x - origin_2.x) * ratio;
              model.y = origin_2.y + (child.y - origin_2.y) * ratio;
            }
          }
          return true;
        });
        each_default(self2.get("removeList"), function(node) {
          var model = node.getModel();
          var from = node.get("originAttrs");
          var to2 = node.get("to");
          model.x = from.x + (to2.x - from.x) * ratio;
          model.y = from.y + (to2.y - from.y) * ratio;
        });
        self2.refreshPositions();
      }, {
        duration: animateCfg.duration,
        easing: animateCfg.ease,
        callback: function callback() {
          each_default(self2.getNodes(), function(node) {
            node.set("originAttrs", null);
          });
          each_default(self2.get("removeList"), function(node) {
            self2.removeItem(node, false);
          });
          self2.set("removeList", []);
          if (animateCfg.callback) {
            animateCfg.callback();
          }
          self2.emit("afteranimate", {
            data
          });
        },
        delay: animateCfg.delay
      });
    };
    TreeGraph2.prototype.stopLayoutAnimate = function() {
      this.get("canvas").stopAnimate();
      this.emit("layoutanimateend", {
        data: this.get("data")
      });
      this.layoutAnimating = false;
    };
    TreeGraph2.prototype.isLayoutAnimating = function() {
      return this.layoutAnimating;
    };
    TreeGraph2.prototype.render = function(clearStack) {
      if (clearStack === void 0) {
        clearStack = true;
      }
      var self2 = this;
      var data = self2.get("data");
      if (!data || !is_object_default(data) || !Object.keys(data).length) {
        throw new Error("data must be defined first");
      }
      self2.clear();
      if (clearStack && this.get("enabledStack")) {
        this.clearStack();
      }
      self2.emit("beforerender");
      self2.layout(this.get("fitView"));
      self2.emit("afterrender");
    };
    TreeGraph2.prototype.save = function() {
      return this.get("data");
    };
    TreeGraph2.prototype.data = function(data) {
      _super.prototype.data.call(this, data);
      this.set("originData", JSON.parse(JSON.stringify(data)));
    };
    return TreeGraph2;
  }(graph_default2)
);
var tree_graph_default = TreeGraph;

// node_modules/@antv/g6-plugin/es/base.js
init_esm();
var PluginBase = (
  /** @class */
  function() {
    function PluginBase2(cfgs) {
      this._cfgs = deep_mix_default(this.getDefaultCfgs(), cfgs);
      this._events = {};
      this.destroyed = false;
    }
    PluginBase2.prototype.getDefaultCfgs = function() {
      return {};
    };
    PluginBase2.prototype.initPlugin = function(graph) {
      var self2 = this;
      self2.set("graph", graph);
      var events = self2.getEvents();
      var bindEvents = {};
      each_default(events, function(v2, k2) {
        var event = wrap_behavior_default(self2, v2);
        bindEvents[k2] = event;
        graph.on(k2, event);
      });
      this._events = bindEvents;
      this.init();
    };
    PluginBase2.prototype.getEvents = function() {
      return {};
    };
    PluginBase2.prototype.get = function(key) {
      var _a2;
      return (_a2 = this._cfgs) === null || _a2 === void 0 ? void 0 : _a2[key];
    };
    PluginBase2.prototype.set = function(key, val) {
      this._cfgs[key] = val;
    };
    PluginBase2.prototype.destroy = function() {
    };
    PluginBase2.prototype.destroyPlugin = function() {
      this.destroy();
      var graph = this.get("graph");
      var events = this._events;
      each_default(events, function(v2, k2) {
        graph.off(k2, v2);
      });
      this._events = null;
      this._cfgs = null;
      this.destroyed = true;
    };
    return PluginBase2;
  }()
);
var base_default2 = PluginBase;

// node_modules/@antv/g6-plugin/es/grid/index.js
var __extends2 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var GRID_PNG = "url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHBhdHRlcm4gaWQ9ImdyaWQiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGggZD0iTSAwIDEwIEwgNDAgMTAgTSAxMCAwIEwgMTAgNDAgTSAwIDIwIEwgNDAgMjAgTSAyMCAwIEwgMjAgNDAgTSAwIDMwIEwgNDAgMzAgTSAzMCAwIEwgMzAgNDAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2UwZTBlMCIgb3BhY2l0eT0iMC4yIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNIDQwIDAgTCAwIDAgMCA0MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZTBlMGUwIiBzdHJva2Utd2lkdGg9IjEiLz48L3BhdHRlcm4+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JpZCkiLz48L3N2Zz4=)";
var Grid = (
  /** @class */
  function(_super) {
    __extends2(Grid3, _super);
    function Grid3(config) {
      return _super.call(this, config) || this;
    }
    Grid3.prototype.getDefaultCfgs = function() {
      return {
        img: GRID_PNG,
        follow: true
      };
    };
    Grid3.prototype.init = function() {
      var graph = this.get("graph");
      var graphContainer = graph.get("container");
      var canvas = graph.get("canvas").get("el");
      var img = this.get("img") || GRID_PNG;
      if (!img.includes("url(")) {
        img = 'url("'.concat(img, '")');
      }
      var container = createDom(`<div class='g6-grid-container' style="position:absolute;overflow:hidden;z-index: -1;"></div>`);
      var gridContainer = createDom("<div\n        class='g6-grid'\n        style='position:absolute;\n        background-image: ".concat(img, ";\n        user-select: none\n        '></div>"));
      this.set("container", container);
      this.set("gridContainer", gridContainer);
      this.positionInit();
      container.appendChild(gridContainer);
      graphContainer.insertBefore(container, canvas);
    };
    Grid3.prototype.positionInit = function() {
      var graph = this.get("graph");
      var minZoom = graph.get("minZoom");
      var width = graph.get("width");
      var height = graph.get("height");
      modifyCSS(this.get("container"), {
        width: "".concat(width, "px"),
        height: "".concat(height, "px")
      });
      var gridContainerWidth = width * 80 / minZoom;
      var gridContainerHeight = height * 80 / minZoom;
      modifyCSS(this.get("gridContainer"), {
        width: "".concat(gridContainerWidth, "px"),
        height: "".concat(gridContainerHeight, "px"),
        left: "-".concat(gridContainerWidth / 2, "px"),
        top: "-".concat(gridContainerHeight / 2, "px")
      });
    };
    Grid3.prototype.getEvents = function() {
      return {
        viewportchange: "updateGrid"
      };
    };
    Grid3.prototype.updateGrid = function(param) {
      var gridContainer = this.get("gridContainer");
      var matrix = param.matrix;
      if (!matrix)
        matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var isFollow = this.get("follow");
      var transform13 = "matrix(".concat(matrix[0], ", ").concat(matrix[1], ", ").concat(matrix[3], ", ").concat(matrix[4], ", ").concat(isFollow ? matrix[6] : "0", ", ").concat(isFollow ? matrix[7] : "0", ")");
      modifyCSS(gridContainer, {
        transform: transform13
      });
    };
    Grid3.prototype.getContainer = function() {
      return this.get("container");
    };
    Grid3.prototype.destroy = function() {
      var graph = this.get("graph");
      var graphContainer = graph.get("container");
      var container = this.get("container");
      graphContainer.removeChild(container);
    };
    return Grid3;
  }(base_default2)
);
var grid_default = Grid;

// node_modules/@antv/g6-plugin/es/menu/index.js
init_esm();
var import_insert_css = __toESM(require_insert_css());
var __extends3 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
typeof document !== "undefined" && (0, import_insert_css.default)("\n  .g6-component-contextmenu {\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    background-color: rgba(255, 255, 255, 0.9);\n    padding: 10px 8px;\n    box-shadow: rgb(174, 174, 174) 0px 0px 10px;\n  }\n  .g6-contextmenu-ul {\n    padding: 0;\n    margin: 0;\n    list-style: none;\n  }\n\n");
var Menu = (
  /** @class */
  function(_super) {
    __extends3(Menu3, _super);
    function Menu3(config) {
      return _super.call(this, config) || this;
    }
    Menu3.prototype.getDefaultCfgs = function() {
      return {
        offsetX: 6,
        offsetY: 6,
        handleMenuClick: void 0,
        // 指定菜单内容，function(e) {...}
        getContent: function getContent(e8) {
          return "\n          <ul class='g6-contextmenu-ul'>\n            <li>菜单项1</li>\n            <li>菜单项2</li>\n          </ul>\n        ";
        },
        shouldBegin: function shouldBegin2(e8) {
          return true;
        },
        // 菜单隐藏事件
        onHide: function onHide() {
          return true;
        },
        itemTypes: ["node", "edge", "combo"],
        trigger: "contextmenu"
      };
    };
    Menu3.prototype.getEvents = function() {
      if (this.get("trigger") === "click") {
        return {
          click: "onMenuShow",
          touchend: "onMenuShow"
        };
      }
      return {
        contextmenu: "onMenuShow"
      };
    };
    Menu3.prototype.init = function() {
      var className = this.get("className");
      var menu = createDom("<div class=".concat(className || "g6-component-contextmenu", "></div>"));
      modifyCSS(menu, {
        top: "0px",
        position: "absolute",
        visibility: "hidden"
      });
      var container = this.get("container");
      if (!container) {
        container = this.get("graph").get("container");
      }
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      container.appendChild(menu);
      this.set("menu", menu);
    };
    Menu3.prototype.onMenuShow = function(e8) {
      var self2 = this;
      e8.preventDefault();
      var itemTypes = this.get("itemTypes");
      if (!e8.item) {
        if (itemTypes.indexOf("canvas") === -1) {
          self2.onMenuHide();
          return;
        }
      } else {
        if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1) {
          self2.onMenuHide();
          return;
        }
      }
      var shouldBegin2 = this.get("shouldBegin");
      if (!shouldBegin2(e8))
        return;
      var menuDom = this.get("menu");
      var getContent = this.get("getContent");
      var graph = this.get("graph");
      var menu = getContent(e8, graph);
      if (is_string_default(menu)) {
        menuDom.innerHTML = menu;
      } else {
        menuDom.innerHTML = menu.outerHTML;
      }
      this.removeMenuEventListener();
      var handleMenuClick = this.get("handleMenuClick");
      if (handleMenuClick) {
        var handleMenuClickWrapper = function handleMenuClickWrapper2(evt) {
          handleMenuClick(evt.target, e8.item, graph);
        };
        this.set("handleMenuClickWrapper", handleMenuClickWrapper);
        menuDom.addEventListener("click", handleMenuClickWrapper);
      }
      var width = graph.get("width");
      var height = graph.get("height");
      var bbox = menuDom.getBoundingClientRect();
      var offsetX = this.get("offsetX") || 0;
      var offsetY = this.get("offsetY") || 0;
      var graphTop = graph.getContainer().offsetTop;
      var graphLeft = graph.getContainer().offsetLeft;
      var x4 = e8.canvasX + graphLeft + offsetX;
      var y4 = e8.canvasY + graphTop + offsetY;
      if (x4 + bbox.width > width) {
        x4 = e8.canvasX - bbox.width - offsetX + graphLeft;
      }
      if (y4 + bbox.height > height) {
        y4 = e8.canvasY - bbox.height - offsetY + graphTop;
      }
      modifyCSS(menuDom, {
        top: "".concat(y4, "px"),
        left: "".concat(x4, "px"),
        visibility: "visible"
      });
      var triggeredByFirstClick = this.get("trigger") === "click";
      var handler = function handler2(evt) {
        if (triggeredByFirstClick) {
          triggeredByFirstClick = false;
          return;
        }
        self2.onMenuHide();
      };
      document.body.addEventListener("click", handler);
      this.set("handler", handler);
    };
    Menu3.prototype.removeMenuEventListener = function() {
      var handleMenuClickWrapper = this.get("handleMenuClickWrapper");
      var handler = this.get("handler");
      if (handleMenuClickWrapper) {
        var menuDom = this.get("menu");
        menuDom.removeEventListener("click", handleMenuClickWrapper);
        this.set("handleMenuClickWrapper", null);
      }
      if (handler) {
        document.body.removeEventListener("click", handler);
      }
    };
    Menu3.prototype.onMenuHide = function() {
      var menuDom = this.get("menu");
      if (menuDom) {
        modifyCSS(menuDom, {
          visibility: "hidden"
        });
      }
      this.removeMenuEventListener();
    };
    Menu3.prototype.destroy = function() {
      var menu = this.get("menu");
      this.removeMenuEventListener();
      if (menu) {
        var container = this.get("container");
        if (!container) {
          container = this.get("graph").get("container");
        }
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        container.removeChild(menu);
      }
    };
    return Menu3;
  }(base_default2)
);
var menu_default = Menu;

// node_modules/@antv/g6-plugin/es/minimap/index.js
init_esm();
var __extends4 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};
var max2 = Math.max;
var transform8 = ext_exports.transform;
var DEFAULT_MODE = "default";
var KEYSHAPE_MODE = "keyShape";
var DELEGATE_MODE = "delegate";
var SVG2 = "svg";
var MiniMap = (
  /** @class */
  function(_super) {
    __extends4(MiniMap2, _super);
    function MiniMap2(config) {
      var _this = _super.call(this, config) || this;
      _this.handleUpdateCanvas = debounce_default(function(event) {
        var self2 = _this;
        if (self2.destroyed)
          return;
        self2.updateCanvas();
      }, 100, false);
      return _this;
    }
    MiniMap2.prototype.getDefaultCfgs = function() {
      return {
        container: null,
        className: "g6-minimap",
        viewportClassName: "g6-minimap-viewport",
        // Minimap 中默认展示和主图一样的内容，KeyShape 只展示节点和边的 key shape 部分，delegate表示展示自定义的rect，用户可自定义样式
        type: "default",
        padding: 50,
        size: [200, 120],
        delegateStyle: {
          fill: "#40a9ff",
          stroke: "#096dd9"
        },
        refresh: true,
        hideEdge: false
      };
    };
    MiniMap2.prototype.getEvents = function() {
      return {
        beforepaint: "updateViewport",
        beforeanimate: "disableRefresh",
        afteranimate: "enableRefresh",
        viewportchange: "disableOneRefresh"
      };
    };
    MiniMap2.prototype.disableRefresh = function() {
      this.set("refresh", false);
    };
    MiniMap2.prototype.enableRefresh = function() {
      this.set("refresh", true);
      this.updateCanvas();
    };
    MiniMap2.prototype.disableOneRefresh = function() {
      this.set("viewportChange", true);
    };
    MiniMap2.prototype.initViewport = function() {
      var _this = this;
      var cfgs = this._cfgs;
      var size3 = cfgs.size, graph = cfgs.graph;
      if (this.destroyed)
        return;
      var canvas = this.get("canvas");
      var containerDOM = canvas.get("container");
      var isFireFox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
      var isSafari2 = navigator.userAgent.toLowerCase().indexOf("safari") > -1;
      var viewport = createDom("\n      <div\n        class=".concat(cfgs.viewportClassName, "\n        style='position:absolute;\n          left:0;\n          top:0;\n          box-sizing:border-box;\n          outline: 2px solid #1980ff;\n          cursor:move'\n        draggable=").concat(isSafari2 || isFireFox ? false : true, "\n      </div>"));
      var x4 = 0;
      var y4 = 0;
      var dragging = false;
      var left = 0;
      var top = 0;
      var width = 0;
      var height = 0;
      var ratio = 0;
      var zoom = 0;
      var dragstartevent = isSafari2 || isFireFox ? "mousedown" : "dragstart";
      viewport.addEventListener(dragstartevent, function(e8) {
        var _a2, _b;
        if (e8.dataTransfer) {
          var img = new Image();
          img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' %3E%3Cpath /%3E%3C/svg%3E";
          (_b = (_a2 = e8.dataTransfer).setDragImage) === null || _b === void 0 ? void 0 : _b.call(_a2, img, 0, 0);
          try {
            e8.dataTransfer.setData("text/html", "view-port-minimap");
          } catch (_c) {
            e8.dataTransfer.setData("text", "view-port-minimap");
          }
        }
        cfgs.refresh = false;
        if (e8.target !== viewport) {
          return;
        }
        var style = viewport.style;
        left = parseInt(style.left, 10);
        top = parseInt(style.top, 10);
        width = parseInt(style.width, 10);
        height = parseInt(style.height, 10);
        if (width > size3[0] || height > size3[1]) {
          return;
        }
        zoom = graph.getZoom();
        ratio = _this.get("ratio");
        dragging = true;
        x4 = e8.clientX;
        y4 = e8.clientY;
      }, false);
      var dragListener = function dragListener2(e8) {
        if (!dragging || is_nil_default(e8.clientX) || is_nil_default(e8.clientY)) {
          return;
        }
        var dx = x4 - e8.clientX;
        var dy = y4 - e8.clientY;
        if (left - dx < 0 || left - dx + width >= size3[0]) {
          dx = 0;
        }
        if (top - dy < 0 || top - dy + height >= size3[1]) {
          dy = 0;
        }
        left -= dx;
        top -= dy;
        modifyCSS(viewport, {
          left: "".concat(left, "px"),
          top: "".concat(top, "px")
        });
        graph.translate(dx * zoom / ratio, dy * zoom / ratio);
        x4 = e8.clientX;
        y4 = e8.clientY;
      };
      if (!isSafari2 && !isFireFox) {
        viewport.addEventListener("drag", dragListener, false);
      }
      var dragendListener = function dragendListener2() {
        dragging = false;
        cfgs.refresh = true;
      };
      var dragendevent = isSafari2 || isFireFox ? "mouseup" : "dragend";
      viewport.addEventListener(dragendevent, dragendListener, false);
      containerDOM.addEventListener("mouseleave", dragendListener);
      containerDOM.addEventListener("mouseup", dragendListener);
      if (isSafari2 || isFireFox) {
        containerDOM.addEventListener("mousemove", dragListener, false);
      }
      this.set("viewport", viewport);
      containerDOM.appendChild(viewport);
    };
    MiniMap2.prototype.updateViewport = function() {
      if (this.destroyed)
        return;
      var ratio = this.get("ratio");
      var totaldx = this.get("totaldx");
      var totaldy = this.get("totaldy");
      var graph = this.get("graph");
      var size3 = this.get("size");
      var graphCanvasEl = graph.get("canvas").get("el");
      var graphWidth = graph.get("width") || graphCanvasEl.scrollWidth || 500;
      var graphHeight = graph.get("height") || graphCanvasEl.scrollHeight || 500;
      var topLeft = graph.getPointByCanvas(0, 0);
      var bottomRight = graph.getPointByCanvas(graphWidth, graphHeight);
      var viewport = this.get("viewport");
      if (!viewport) {
        this.initViewport();
      }
      var width = (bottomRight.x - topLeft.x) * ratio;
      var height = (bottomRight.y - topLeft.y) * ratio;
      var left = topLeft.x * ratio + totaldx;
      var top = topLeft.y * ratio + totaldy;
      var right = left + width;
      var bottom = top + height;
      if (left < 0) {
        width += left;
        left = 0;
      }
      if (right > size3[0]) {
        width = width - (right - size3[0]);
      }
      if (top < 0) {
        height += top;
        top = 0;
      }
      if (bottom > size3[1]) {
        height = height - (bottom - size3[1]);
      }
      this.set("ratio", ratio);
      var correctLeft = "".concat(left, "px");
      var correctTop = "".concat(top, "px");
      modifyCSS(viewport, {
        left: correctLeft,
        top: correctTop,
        width: "".concat(width, "px"),
        height: "".concat(height, "px")
      });
    };
    MiniMap2.prototype.updateGraphShapes = function() {
      var graph = this._cfgs.graph;
      var canvas = this.get("canvas");
      var graphGroup = graph.get("group");
      if (graphGroup.destroyed)
        return;
      canvas.clear();
      var clonedGroup;
      if (this.get("hideEdge")) {
        clonedGroup = canvas.addGroup();
        graphGroup.get("children").forEach(function(group) {
          if (group.get("id").includes("-edge"))
            return;
          clonedGroup.add(group.clone());
        });
      } else {
        clonedGroup = graphGroup.clone();
        clonedGroup.resetMatrix();
        canvas.add(clonedGroup);
      }
      var renderer = graph.get("renderer");
      if (renderer === SVG2) {
        this.updateVisible(clonedGroup);
      }
    };
    MiniMap2.prototype.updateVisible = function(ele) {
      var _this = this;
      if (!ele.isGroup() && !ele.get("visible")) {
        ele.hide();
      } else {
        var children = ele.get("children");
        if (!children || !children.length)
          return;
        children.forEach(function(child) {
          if (!child.get("visible"))
            child.hide();
          _this.updateVisible(child);
        });
      }
    };
    MiniMap2.prototype.updateKeyShapes = function() {
      var _this = this;
      var graph = this._cfgs.graph;
      var canvas = this.get("canvas");
      var group = canvas.get("children")[0] || canvas.addGroup();
      if (!this.get("hideEdge")) {
        each_default(graph.getEdges(), function(edge) {
          _this.updateOneEdgeKeyShape(edge, group);
        });
      }
      each_default(graph.getNodes(), function(node) {
        _this.updateOneNodeKeyShape(node, group);
      });
      var combos = graph.getCombos();
      if (combos && combos.length) {
        var comboGroup_1 = group.find(function(e8) {
          return e8.get("name") === "comboGroup";
        }) || group.addGroup({
          name: "comboGroup"
        });
        setTimeout(function() {
          if (_this.destroyed)
            return;
          each_default(combos, function(combo) {
            _this.updateOneComboKeyShape(combo, comboGroup_1);
          });
          comboGroup_1 === null || comboGroup_1 === void 0 ? void 0 : comboGroup_1.sort();
          comboGroup_1 === null || comboGroup_1 === void 0 ? void 0 : comboGroup_1.toBack();
          _this.updateCanvas();
        }, 250);
      }
      this.clearDestroyedShapes();
    };
    MiniMap2.prototype.updateOneComboKeyShape = function(item, comboGroup) {
      if (this.destroyed)
        return;
      var itemMap = this.get("itemMap") || {};
      var mappedItem = itemMap[item.get("id")];
      var bbox = item.getBBox();
      var cKeyShape = item.get("keyShape").clone();
      var keyShapeStyle = cKeyShape.attr();
      var attrs = {
        x: bbox.centerX,
        y: bbox.centerY
      };
      if (!mappedItem) {
        mappedItem = cKeyShape;
        comboGroup.add(mappedItem);
      } else {
        attrs = Object.assign(keyShapeStyle, attrs);
      }
      var shapeType = mappedItem.get("type");
      if (shapeType === "rect" || shapeType === "image") {
        attrs.x = bbox.minX;
        attrs.y = bbox.minY;
      }
      mappedItem.attr(attrs);
      if (!item.isVisible())
        mappedItem.hide();
      else
        mappedItem.show();
      mappedItem.exist = true;
      var zIndex = item.getModel().depth;
      if (!isNaN(zIndex))
        mappedItem.set("zIndex", zIndex);
      itemMap[item.get("id")] = mappedItem;
      this.set("itemMap", itemMap);
    };
    MiniMap2.prototype.updateOneNodeKeyShape = function(item, group) {
      var itemMap = this.get("itemMap") || {};
      var mappedItem = itemMap[item.get("id")];
      var bbox = item.getBBox();
      var cKeyShape = item.get("keyShape").clone();
      var keyShapeStyle = cKeyShape.attr();
      var attrs = {
        x: bbox.centerX,
        y: bbox.centerY
      };
      if (!mappedItem) {
        mappedItem = cKeyShape;
        group.add(mappedItem);
      } else {
        attrs = Object.assign(keyShapeStyle, attrs);
        mappedItem.toFront();
      }
      var shapeType = mappedItem.get("type");
      if (shapeType === "rect" || shapeType === "image") {
        attrs.x = bbox.minX;
        attrs.y = bbox.minY;
      }
      mappedItem.attr(attrs);
      if (!item.isVisible())
        mappedItem.hide();
      else
        mappedItem.show();
      mappedItem.exist = true;
      var zIndex = item.getModel().depth;
      if (!isNaN(zIndex))
        mappedItem.set("zIndex", zIndex);
      itemMap[item.get("id")] = mappedItem;
      this.set("itemMap", itemMap);
    };
    MiniMap2.prototype.updateDelegateShapes = function() {
      var _this = this;
      var graph = this._cfgs.graph;
      var canvas = this.get("canvas");
      var group = canvas.get("children")[0] || canvas.addGroup();
      if (!this.get("hideEdge")) {
        each_default(graph.getEdges(), function(edge) {
          _this.updateOneEdgeKeyShape(edge, group);
        });
      }
      each_default(graph.getNodes(), function(node) {
        _this.updateOneNodeDelegateShape(node, group);
      });
      var combos = graph.getCombos();
      if (combos && combos.length) {
        var comboGroup_2 = group.find(function(e8) {
          return e8.get("name") === "comboGroup";
        }) || group.addGroup({
          name: "comboGroup"
        });
        setTimeout(function() {
          if (_this.destroyed)
            return;
          each_default(combos, function(combo) {
            _this.updateOneComboKeyShape(combo, comboGroup_2);
          });
          comboGroup_2 === null || comboGroup_2 === void 0 ? void 0 : comboGroup_2.sort();
          comboGroup_2 === null || comboGroup_2 === void 0 ? void 0 : comboGroup_2.toBack();
          _this.updateCanvas();
        }, 250);
      }
      this.clearDestroyedShapes();
    };
    MiniMap2.prototype.clearDestroyedShapes = function() {
      var itemMap = this.get("itemMap") || {};
      var keys2 = Object.keys(itemMap);
      if (!keys2 || keys2.length === 0)
        return;
      for (var i2 = keys2.length - 1; i2 >= 0; i2--) {
        var shape = itemMap[keys2[i2]];
        var exist = shape.exist;
        shape.exist = false;
        if (!exist) {
          shape.remove();
          delete itemMap[keys2[i2]];
        }
      }
    };
    MiniMap2.prototype.updateOneEdgeKeyShape = function(item, group) {
      var itemMap = this.get("itemMap") || {};
      var mappedItem = itemMap[item.get("id")];
      if (mappedItem) {
        var path = item.get("keyShape").attr("path");
        mappedItem.attr("path", path);
      } else {
        mappedItem = item.get("keyShape").clone();
        group.add(mappedItem);
      }
      if (!item.isVisible())
        mappedItem.hide();
      else
        mappedItem.show();
      mappedItem.exist = true;
      itemMap[item.get("id")] = mappedItem;
      this.set("itemMap", itemMap);
    };
    MiniMap2.prototype.updateOneNodeDelegateShape = function(item, group) {
      var delegateStyle = this.get("delegateStyle");
      var itemMap = this.get("itemMap") || {};
      var mappedItem = itemMap[item.get("id")];
      var bbox = item.getBBox();
      if (mappedItem) {
        var attrs = {
          x: bbox.minX,
          y: bbox.minY,
          width: bbox.width,
          height: bbox.height
        };
        mappedItem.attr(attrs);
        mappedItem.toFront();
      } else {
        mappedItem = group.addShape("rect", {
          attrs: __assign2({
            x: bbox.minX,
            y: bbox.minY,
            width: bbox.width,
            height: bbox.height
          }, delegateStyle),
          name: "minimap-node-shape"
        });
      }
      if (!item.isVisible())
        mappedItem.hide();
      else
        mappedItem.show();
      mappedItem.exist = true;
      itemMap[item.get("id")] = mappedItem;
      this.set("itemMap", itemMap);
    };
    MiniMap2.prototype.init = function() {
      this.initContainer();
      this.get("graph").on("afterupdateitem", this.handleUpdateCanvas);
      this.get("graph").on("afteritemstatechange", this.handleUpdateCanvas);
      this.get("graph").on("afteradditem", this.handleUpdateCanvas);
      this.get("graph").on("afterremoveitem", this.handleUpdateCanvas);
      this.get("graph").on("afterrender", this.handleUpdateCanvas);
      this.get("graph").on("afterlayout", this.handleUpdateCanvas);
    };
    MiniMap2.prototype.initContainer = function() {
      var self2 = this;
      var graph = self2.get("graph");
      var size3 = self2.get("size");
      var className = self2.get("className");
      var parentNode = self2.get("container");
      var container = createDom("<div class='".concat(className, "' style='width: ").concat(size3[0], "px; height: ").concat(size3[1], "px; overflow: hidden'></div>"));
      if (is_string_default(parentNode)) {
        parentNode = document.getElementById(parentNode);
      }
      if (parentNode) {
        parentNode.appendChild(container);
      } else {
        graph.get("container").appendChild(container);
      }
      self2.set("container", container);
      var containerDOM = createDom('<div class="g6-minimap-container" style="position: relative;"></div>');
      container.appendChild(containerDOM);
      containerDOM.addEventListener("dragenter", function(e8) {
        e8.preventDefault();
      });
      containerDOM.addEventListener("dragover", function(e8) {
        e8.preventDefault();
      });
      var canvas;
      var renderer = graph.get("renderer");
      if (renderer === SVG2) {
        canvas = new canvas_default2({
          container: containerDOM,
          width: size3[0],
          height: size3[1]
        });
      } else {
        canvas = new canvas_default({
          container: containerDOM,
          width: size3[0],
          height: size3[1]
        });
      }
      self2.set("canvas", canvas);
      self2.updateCanvas();
    };
    MiniMap2.prototype.updateCanvas = function() {
      if (this.destroyed)
        return;
      var isRefresh = this.get("refresh");
      if (!isRefresh) {
        return;
      }
      var graph = this.get("graph");
      if (graph.get("destroyed")) {
        return;
      }
      if (this.get("viewportChange")) {
        this.set("viewportChange", false);
        this.updateViewport();
      }
      var size3 = this.get("size");
      var canvas = this.get("canvas");
      var type = this.get("type");
      var padding = this.get("padding");
      if (canvas.destroyed) {
        return;
      }
      switch (type) {
        case DEFAULT_MODE:
          this.updateGraphShapes();
          break;
        case KEYSHAPE_MODE:
          this.updateKeyShapes();
          break;
        case DELEGATE_MODE:
          this.updateDelegateShapes();
          break;
        default:
          break;
      }
      var group = canvas.get("children")[0];
      if (!group)
        return;
      group.resetMatrix();
      var bbox = group.getCanvasBBox();
      var graphBBox = graph.get("canvas").getCanvasBBox();
      var graphZoom = graph.getZoom() || 1;
      var width = graphBBox.width / graphZoom;
      var height = graphBBox.height / graphZoom;
      if (Number.isFinite(bbox.width)) {
        width = max2(bbox.width, width);
        height = max2(bbox.height, height);
      }
      width += 2 * padding;
      height += 2 * padding;
      var ratio = Math.min(size3[0] / width, size3[1] / height);
      var matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var minX = 0;
      var minY = 0;
      if (Number.isFinite(bbox.minX)) {
        minX = -bbox.minX;
      }
      if (Number.isFinite(bbox.minY)) {
        minY = -bbox.minY;
      }
      var dx = (size3[0] - (width - 2 * padding) * ratio) / 2;
      var dy = (size3[1] - (height - 2 * padding) * ratio) / 2;
      matrix = transform8(matrix, [
        ["t", minX, minY],
        ["s", ratio, ratio],
        ["t", dx, dy]
        // 移动到画布中心
      ]);
      group.setMatrix(matrix);
      this.set("ratio", ratio);
      this.set("totaldx", dx + minX * ratio);
      this.set("totaldy", dy + minY * ratio);
      this.set("dx", dx);
      this.set("dy", dy);
      this.updateViewport();
    };
    MiniMap2.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    MiniMap2.prototype.getViewport = function() {
      return this.get("viewport");
    };
    MiniMap2.prototype.getContainer = function() {
      return this.get("container");
    };
    MiniMap2.prototype.destroy = function() {
      var _a2;
      (_a2 = this.get("canvas")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      var container = this.get("container");
      if (container === null || container === void 0 ? void 0 : container.parentNode)
        container.parentNode.removeChild(container);
    };
    return MiniMap2;
  }(base_default2)
);
var minimap_default = MiniMap;

// node_modules/@antv/g6-plugin/es/bundling/index.js
var __extends5 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
function getEucliDis(pointA, pointB, eps) {
  var vx = pointA.x - pointB.x;
  var vy = pointA.y - pointB.y;
  if (!eps || Math.abs(vx) > eps || Math.abs(vy) > eps) {
    return Math.sqrt(vx * vx + vy * vy);
  }
  return eps;
}
function getDotProduct(ei2, ej) {
  return ei2.x * ej.x + ei2.y * ej.y;
}
function projectPointToEdge(p2, e8) {
  var k2 = (e8.source.y - e8.target.y) / (e8.source.x - e8.target.x);
  var x4 = (k2 * k2 * e8.source.x + k2 * (p2.y - e8.source.y) + p2.x) / (k2 * k2 + 1);
  var y4 = k2 * (x4 - e8.source.x) + e8.source.y;
  return {
    x: x4,
    y: y4
  };
}
var Bundling = (
  /** @class */
  function(_super) {
    __extends5(Bundling3, _super);
    function Bundling3(config) {
      return _super.call(this, config) || this;
    }
    Bundling3.prototype.getDefaultCfgs = function() {
      return {
        edgeBundles: [],
        edgePoints: [],
        K: 0.1,
        lambda: 0.1,
        divisions: 1,
        divRate: 2,
        cycles: 6,
        iterations: 90,
        iterRate: 0.6666667,
        bundleThreshold: 0.6,
        eps: 1e-6,
        onLayoutEnd: function onLayoutEnd() {
        },
        onTick: function onTick() {
        }
      };
    };
    Bundling3.prototype.init = function() {
      var graph = this.get("graph");
      var onTick = this.get("onTick");
      var tick = function tick2() {
        if (onTick) {
          onTick();
        }
        graph.refreshPositions();
      };
      this.set("tick", tick);
    };
    Bundling3.prototype.bundling = function(data) {
      var self2 = this;
      self2.set("data", data);
      if (self2.isTicking()) {
        return;
      }
      var edges = data.edges || [];
      var nodes = data.nodes || [];
      var nodeIdMap = {};
      var error = false;
      nodes.forEach(function(node) {
        if (node.x === null || !node.y === null || node.x === void 0 || !node.y === void 0) {
          error = true;
        }
        nodeIdMap[node.id] = node;
      });
      if (error)
        throw new Error("please layout the graph or assign x and y for nodes first");
      self2.set("nodeIdMap", nodeIdMap);
      var divisions = self2.get("divisions");
      var divRate = self2.get("divRate");
      var edgePoints = self2.divideEdges(divisions);
      self2.set("edgePoints", edgePoints);
      var edgeBundles = self2.getEdgeBundles();
      self2.set("edgeBundles", edgeBundles);
      var C2 = self2.get("cycles");
      var iterations = self2.get("iterations");
      var iterRate = self2.get("iterRate");
      var lambda = self2.get("lambda");
      for (var i2 = 0; i2 < C2; i2++) {
        var _loop_1 = function _loop_12(j3) {
          var forces = [];
          edges.forEach(function(e8, k2) {
            if (e8.source === e8.target)
              return;
            var source = nodeIdMap[e8.source];
            var target = nodeIdMap[e8.target];
            forces[k2] = self2.getEdgeForces({
              source,
              target
            }, k2, divisions, lambda);
            for (var p2 = 0; p2 < divisions + 1; p2++) {
              edgePoints[k2][p2].x += forces[k2][p2].x;
              edgePoints[k2][p2].y += forces[k2][p2].y;
            }
          });
        };
        for (var j2 = 0; j2 < iterations; j2++) {
          _loop_1(j2);
        }
        lambda = lambda / 2;
        divisions *= divRate;
        iterations *= iterRate;
        edgePoints = self2.divideEdges(divisions);
        self2.set("edgePoints", edgePoints);
      }
      edges.forEach(function(e8, i3) {
        if (e8.source === e8.target)
          return;
        e8.type = "polyline";
        e8.controlPoints = edgePoints[i3].slice(1, edgePoints[i3].length - 1);
      });
      var graph = self2.get("graph");
      graph.refresh();
    };
    Bundling3.prototype.updateBundling = function(cfg) {
      var self2 = this;
      var data = cfg.data;
      if (data) {
        self2.set("data", data);
      }
      if (self2.get("ticking")) {
        self2.set("ticking", false);
      }
      Object.keys(cfg).forEach(function(key) {
        self2.set(key, cfg[key]);
      });
      if (cfg.onTick) {
        var graph_1 = this.get("graph");
        self2.set("tick", function() {
          cfg.onTick();
          graph_1.refresh();
        });
      }
      self2.bundling(data);
    };
    Bundling3.prototype.divideEdges = function(divisions) {
      var self2 = this;
      var edges = self2.get("data").edges;
      var nodeIdMap = self2.get("nodeIdMap");
      var edgePoints = self2.get("edgePoints");
      if (!edgePoints || edgePoints === void 0)
        edgePoints = [];
      edges.forEach(function(edge, i2) {
        var _a2;
        if (!edgePoints[i2] || edgePoints[i2] === void 0) {
          edgePoints[i2] = [];
        }
        var source = nodeIdMap[edge.source];
        var target = nodeIdMap[edge.target];
        if (divisions === 1) {
          edgePoints[i2].push({
            x: source.x,
            y: source.y
          });
          edgePoints[i2].push({
            x: 0.5 * (source.x + target.x),
            y: 0.5 * (source.y + target.y)
          });
          edgePoints[i2].push({
            x: target.x,
            y: target.y
          });
        } else {
          var edgeLength = 0;
          if (!((_a2 = edgePoints[i2]) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            edgeLength = getEucliDis({
              x: source.x,
              y: source.y
            }, {
              x: target.x,
              y: target.y
            });
          } else {
            edgeLength = self2.getEdgeLength(edgePoints[i2]);
          }
          var divisionLength_1 = edgeLength / (divisions + 1);
          var currentDivisonLength_1 = divisionLength_1;
          var newEdgePoints_1 = [{
            x: source.x,
            y: source.y
          }];
          edgePoints[i2].forEach(function(ep, j2) {
            if (j2 === 0)
              return;
            var oriDivisionLength = getEucliDis(ep, edgePoints[i2][j2 - 1]);
            while (oriDivisionLength > currentDivisonLength_1) {
              var ratio = currentDivisonLength_1 / oriDivisionLength;
              var edgePoint = {
                x: edgePoints[i2][j2 - 1].x,
                y: edgePoints[i2][j2 - 1].y
              };
              edgePoint.x += ratio * (ep.x - edgePoints[i2][j2 - 1].x);
              edgePoint.y += ratio * (ep.y - edgePoints[i2][j2 - 1].y);
              newEdgePoints_1.push(edgePoint);
              oriDivisionLength -= currentDivisonLength_1;
              currentDivisonLength_1 = divisionLength_1;
            }
            currentDivisonLength_1 -= oriDivisionLength;
          });
          newEdgePoints_1.push({
            x: target.x,
            y: target.y
          });
          edgePoints[i2] = newEdgePoints_1;
        }
      });
      return edgePoints;
    };
    Bundling3.prototype.getEdgeLength = function(points) {
      var length = 0;
      points.forEach(function(p2, i2) {
        if (i2 === 0)
          return;
        length += getEucliDis(p2, points[i2 - 1]);
      });
      return length;
    };
    Bundling3.prototype.getEdgeBundles = function() {
      var self2 = this;
      var data = self2.get("data");
      var edges = data.edges || [];
      var bundleThreshold = self2.get("bundleThreshold");
      var nodeIdMap = self2.get("nodeIdMap");
      var edgeBundles = self2.get("edgeBundles");
      if (!edgeBundles)
        edgeBundles = [];
      edges.forEach(function(e8, i2) {
        if (!edgeBundles[i2] || edgeBundles[i2] === void 0) {
          edgeBundles[i2] = [];
        }
      });
      edges.forEach(function(ei2, i2) {
        var iSource = nodeIdMap[ei2.source];
        var iTarget = nodeIdMap[ei2.target];
        edges.forEach(function(ej, j2) {
          if (j2 <= i2)
            return;
          var jSource = nodeIdMap[ej.source];
          var jTarget = nodeIdMap[ej.target];
          var score = self2.getBundleScore({
            source: iSource,
            target: iTarget
          }, {
            source: jSource,
            target: jTarget
          });
          if (score >= bundleThreshold) {
            edgeBundles[i2].push(j2);
            edgeBundles[j2].push(i2);
          }
        });
      });
      return edgeBundles;
    };
    Bundling3.prototype.getBundleScore = function(ei2, ej) {
      var self2 = this;
      ei2.vx = ei2.target.x - ei2.source.x;
      ei2.vy = ei2.target.y - ei2.source.y;
      ej.vx = ej.target.x - ej.source.x;
      ej.vy = ej.target.y - ej.source.y;
      ei2.length = getEucliDis({
        x: ei2.source.x,
        y: ei2.source.y
      }, {
        x: ei2.target.x,
        y: ei2.target.y
      });
      ej.length = getEucliDis({
        x: ej.source.x,
        y: ej.source.y
      }, {
        x: ej.target.x,
        y: ej.target.y
      });
      var aScore = self2.getAngleScore(ei2, ej);
      var sScore = self2.getScaleScore(ei2, ej);
      var pScore = self2.getPositionScore(ei2, ej);
      var vScore = self2.getVisibilityScore(ei2, ej);
      return aScore * sScore * pScore * vScore;
    };
    Bundling3.prototype.getAngleScore = function(ei2, ej) {
      var dotProduct = getDotProduct({
        x: ei2.vx,
        y: ei2.vy
      }, {
        x: ej.vx,
        y: ej.vy
      });
      return dotProduct / (ei2.length * ej.length);
    };
    Bundling3.prototype.getScaleScore = function(ei2, ej) {
      var aLength = (ei2.length + ej.length) / 2;
      var score = 2 / (aLength / Math.min(ei2.length, ej.length) + Math.max(ei2.length, ej.length) / aLength);
      return score;
    };
    Bundling3.prototype.getPositionScore = function(ei2, ej) {
      var aLength = (ei2.length + ej.length) / 2;
      var iMid = {
        x: (ei2.source.x + ei2.target.x) / 2,
        y: (ei2.source.y + ei2.target.y) / 2
      };
      var jMid = {
        x: (ej.source.x + ej.target.x) / 2,
        y: (ej.source.y + ej.target.y) / 2
      };
      var distance6 = getEucliDis(iMid, jMid);
      return aLength / (aLength + distance6);
    };
    Bundling3.prototype.getVisibilityScore = function(ei2, ej) {
      var vij = this.getEdgeVisibility(ei2, ej);
      var vji = this.getEdgeVisibility(ej, ei2);
      return vij < vji ? vij : vji;
    };
    Bundling3.prototype.getEdgeVisibility = function(ei2, ej) {
      var ps = projectPointToEdge(ej.source, ei2);
      var pt2 = projectPointToEdge(ej.target, ei2);
      var pMid = {
        x: (ps.x + pt2.x) / 2,
        y: (ps.y + pt2.y) / 2
      };
      var iMid = {
        x: (ei2.source.x + ei2.target.x) / 2,
        y: (ei2.source.y + ei2.target.y) / 2
      };
      return Math.max(0, 1 - 2 * getEucliDis(pMid, iMid) / getEucliDis(ps, pt2));
    };
    Bundling3.prototype.getEdgeForces = function(e8, eidx, divisions, lambda) {
      var self2 = this;
      var edgePoints = self2.get("edgePoints");
      var K2 = self2.get("K");
      var kp = K2 / (getEucliDis(e8.source, e8.target) * (divisions + 1));
      var edgePointForces = [{
        x: 0,
        y: 0
      }];
      for (var i2 = 1; i2 < divisions; i2++) {
        var force = {
          x: 0,
          y: 0
        };
        var spring = self2.getSpringForce({
          pre: edgePoints[eidx][i2 - 1],
          cur: edgePoints[eidx][i2],
          next: edgePoints[eidx][i2 + 1]
        }, kp);
        var electrostatic = self2.getElectrostaticForce(i2, eidx);
        force.x = lambda * (spring.x + electrostatic.x);
        force.y = lambda * (spring.y + electrostatic.y);
        edgePointForces.push(force);
      }
      edgePointForces.push({
        x: 0,
        y: 0
      });
      return edgePointForces;
    };
    Bundling3.prototype.getSpringForce = function(divisions, kp) {
      var x4 = divisions.pre.x + divisions.next.x - 2 * divisions.cur.x;
      var y4 = divisions.pre.y + divisions.next.y - 2 * divisions.cur.y;
      x4 *= kp;
      y4 *= kp;
      return {
        x: x4,
        y: y4
      };
    };
    Bundling3.prototype.getElectrostaticForce = function(pidx, eidx) {
      var self2 = this;
      var eps = self2.get("eps");
      var edgeBundles = self2.get("edgeBundles");
      var edgePoints = self2.get("edgePoints");
      var edgeBundle = edgeBundles[eidx];
      var resForce = {
        x: 0,
        y: 0
      };
      edgeBundle.forEach(function(eb) {
        var force = {
          x: edgePoints[eb][pidx].x - edgePoints[eidx][pidx].x,
          y: edgePoints[eb][pidx].y - edgePoints[eidx][pidx].y
        };
        if (Math.abs(force.x) > eps || Math.abs(force.y) > eps) {
          var length_1 = getEucliDis(edgePoints[eb][pidx], edgePoints[eidx][pidx]);
          var diff = 1 / length_1;
          resForce.x += force.x * diff;
          resForce.y += force.y * diff;
        }
      });
      return resForce;
    };
    Bundling3.prototype.isTicking = function() {
      return this.get("ticking");
    };
    Bundling3.prototype.getSimulation = function() {
      return this.get("forceSimulation");
    };
    Bundling3.prototype.destroy = function() {
      if (this.get("ticking")) {
        this.getSimulation().stop();
      }
      _super.prototype.destroy.call(this);
    };
    return Bundling3;
  }(base_default2)
);
var bundling_default = Bundling;

// node_modules/@antv/g6-plugin/es/fisheye/index.js
init_esm();
var __extends6 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign3 = function() {
  __assign3 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign3.apply(this, arguments);
};
var DELTA = 0.05;
var lensDelegateStyle = {
  stroke: "#000",
  strokeOpacity: 0.8,
  lineWidth: 2,
  fillOpacity: 0.1,
  fill: "#ccc"
};
var Fisheye = (
  /** @class */
  function(_super) {
    __extends6(Fisheye3, _super);
    function Fisheye3(config) {
      return _super.call(this, config) || this;
    }
    Fisheye3.prototype.getDefaultCfgs = function() {
      return {
        trigger: "mousemove",
        d: 1.5,
        r: 300,
        delegateStyle: clone_default(lensDelegateStyle),
        showLabel: false,
        maxD: 5,
        minD: 0,
        scaleRBy: "unset",
        scaleDBy: "unset",
        showDPercent: true
      };
    };
    Fisheye3.prototype.getEvents = function() {
      var events;
      switch (this.get("trigger")) {
        case "click":
          events = {
            click: "magnify"
          };
          break;
        case "drag":
          events = {
            click: "createDelegate"
          };
          break;
        default:
          events = {
            mousemove: "magnify"
          };
          break;
      }
      return events;
    };
    Fisheye3.prototype.init = function() {
      var self2 = this;
      var r2 = self2.get("r");
      self2.set("cachedMagnifiedModels", []);
      self2.set("cachedOriginPositions", {});
      self2.set("r2", r2 * r2);
      var d2 = self2.get("d");
      self2.set("molecularParam", (d2 + 1) * r2);
    };
    Fisheye3.prototype.createDelegate = function(e8) {
      var _this = this;
      var self2 = this;
      var lensDelegate = self2.get("delegate");
      if (!lensDelegate || lensDelegate.destroyed) {
        self2.magnify(e8);
        lensDelegate = self2.get("delegate");
        lensDelegate.on("dragstart", function(evt) {
          self2.set("delegateCenterDiff", {
            x: lensDelegate.attr("x") - evt.x,
            y: lensDelegate.attr("y") - evt.y
          });
        });
        lensDelegate.on("drag", function(evt) {
          self2.magnify(evt);
        });
        if (this.get("scaleDBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            _this.scaleDByWheel(evt);
          });
        }
        if (this.get("scaleRBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            self2.scaleRByWheel(evt);
          });
        }
      }
    };
    Fisheye3.prototype.scaleRByWheel = function(e8) {
      var self2 = this;
      if (!e8 || !e8.originalEvent)
        return;
      if (e8.preventDefault)
        e8.preventDefault();
      var graph = self2.get("graph");
      var ratio;
      var lensDelegate = self2.get("delegate");
      var lensCenter = lensDelegate ? {
        x: lensDelegate.attr("x"),
        y: lensDelegate.attr("y")
      } : void 0;
      var mousePos = lensCenter || graph.getPointByClient(e8.clientX, e8.clientY);
      if (e8.originalEvent.wheelDelta < 0) {
        ratio = 1 - DELTA;
      } else {
        ratio = 1 / (1 - DELTA);
      }
      var maxR = self2.get("maxR");
      var minR = self2.get("minR");
      var r2 = self2.get("r");
      if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
        ratio = 1;
      }
      r2 *= ratio;
      self2.set("r", r2);
      self2.set("r2", r2 * r2);
      var d2 = self2.get("d");
      self2.set("molecularParam", (d2 + 1) * r2);
      self2.set("delegateCenterDiff", void 0);
      self2.magnify(e8, mousePos);
    };
    Fisheye3.prototype.scaleRByDrag = function(e8) {
      var self2 = this;
      if (!e8)
        return;
      var dragPrePos = self2.get("dragPrePos");
      var graph = self2.get("graph");
      var ratio;
      var mousePos = graph.getPointByClient(e8.clientX, e8.clientY);
      if (e8.x - dragPrePos.x < 0) {
        ratio = 1 - DELTA;
      } else {
        ratio = 1 / (1 - DELTA);
      }
      var maxR = self2.get("maxR");
      var minR = self2.get("minR");
      var r2 = self2.get("r");
      if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
        ratio = 1;
      }
      r2 *= ratio;
      self2.set("r", r2);
      self2.set("r2", r2 * r2);
      var d2 = self2.get("d");
      self2.set("molecularParam", (d2 + 1) * r2);
      self2.magnify(e8, mousePos);
      self2.set("dragPrePos", {
        x: e8.x,
        y: e8.y
      });
    };
    Fisheye3.prototype.scaleDByWheel = function(evt) {
      var self2 = this;
      if (!evt && !evt.originalEvent)
        return;
      if (evt.preventDefault)
        evt.preventDefault();
      var delta = 0;
      if (evt.originalEvent.wheelDelta < 0) {
        delta = -0.1;
      } else {
        delta = 0.1;
      }
      var d2 = self2.get("d");
      var newD = d2 + delta;
      var maxD = self2.get("maxD");
      var minD = self2.get("minD");
      if (newD < maxD && newD > minD) {
        self2.set("d", newD);
        var r2 = self2.get("r");
        self2.set("molecularParam", (newD + 1) * r2);
        var lensDelegate = self2.get("delegate");
        var lensCenter = lensDelegate ? {
          x: lensDelegate.attr("x"),
          y: lensDelegate.attr("y")
        } : void 0;
        self2.set("delegateCenterDiff", void 0);
        self2.magnify(evt, lensCenter);
      }
    };
    Fisheye3.prototype.scaleDByDrag = function(e8) {
      var self2 = this;
      var dragPrePos = self2.get("dragPrePos");
      var delta = e8.x - dragPrePos.x > 0 ? 0.1 : -0.1;
      var d2 = self2.get("d");
      var newD = d2 + delta;
      var maxD = self2.get("maxD");
      var minD = self2.get("minD");
      if (newD < maxD && newD > minD) {
        self2.set("d", newD);
        var r2 = self2.get("r");
        self2.set("molecularParam", (newD + 1) * r2);
        self2.magnify(e8);
      }
      self2.set("dragPrePos", {
        x: e8.x,
        y: e8.y
      });
    };
    Fisheye3.prototype.magnify = function(e8, mousePos) {
      var self2 = this;
      self2.restoreCache();
      var graph = self2.get("graph");
      var cachedMagnifiedModels = self2.get("cachedMagnifiedModels");
      var cachedOriginPositions = self2.get("cachedOriginPositions");
      var showLabel = self2.get("showLabel");
      var r2 = self2.get("r");
      var r22 = self2.get("r2");
      var d2 = self2.get("d");
      var molecularParam = self2.get("molecularParam");
      var nodes = graph.getNodes();
      var nodeLength = nodes.length;
      var mCenter = mousePos ? {
        x: mousePos.x,
        y: mousePos.y
      } : {
        x: e8.x,
        y: e8.y
      };
      if (self2.get("dragging") && (self2.get("trigger") === "mousemove" || self2.get("trigger") === "click")) {
        mCenter = self2.get("cacheCenter");
      }
      var delegateCenterDiff = self2.get("delegateCenterDiff");
      if (delegateCenterDiff) {
        mCenter.x += delegateCenterDiff.x;
        mCenter.y += delegateCenterDiff.y;
      }
      self2.updateDelegate(mCenter, r2);
      for (var i2 = 0; i2 < nodeLength; i2++) {
        var model = nodes[i2].getModel();
        var x4 = model.x, y4 = model.y;
        if (isNaN(x4) || isNaN(y4))
          continue;
        var dist2 = (x4 - mCenter.x) * (x4 - mCenter.x) + (y4 - mCenter.y) * (y4 - mCenter.y);
        if (!isNaN(dist2) && dist2 < r22 && dist2 !== 0) {
          var dist = Math.sqrt(dist2);
          var magnifiedDist = molecularParam * dist / (d2 * dist + r2);
          var cos2 = (x4 - mCenter.x) / dist;
          var sin2 = (y4 - mCenter.y) / dist;
          model.x = cos2 * magnifiedDist + mCenter.x;
          model.y = sin2 * magnifiedDist + mCenter.y;
          if (!cachedOriginPositions[model.id]) {
            cachedOriginPositions[model.id] = {
              x: x4,
              y: y4,
              texts: []
            };
          }
          cachedMagnifiedModels.push(model);
          if (showLabel && 2 * dist < r2) {
            var node = nodes[i2];
            var nodeGroup = node.getContainer();
            var shapes = nodeGroup.getChildren();
            var shapeLength = shapes.length;
            for (var j2 = 0; j2 < shapeLength; j2++) {
              var shape = shapes[j2];
              if (shape.get("type") === "text") {
                cachedOriginPositions[model.id].texts.push({
                  visible: shape.get("visible"),
                  shape
                });
                shape.set("visible", true);
              }
            }
          }
        }
      }
      graph.refreshPositions();
    };
    Fisheye3.prototype.restoreCache = function() {
      var self2 = this;
      var cachedMagnifiedModels = self2.get("cachedMagnifiedModels");
      var cachedOriginPositions = self2.get("cachedOriginPositions");
      var cacheLength = cachedMagnifiedModels.length;
      for (var i2 = 0; i2 < cacheLength; i2++) {
        var node = cachedMagnifiedModels[i2];
        var id = node.id;
        var ori = cachedOriginPositions[id];
        node.x = ori.x;
        node.y = ori.y;
        var textLength = ori.texts.length;
        for (var j2 = 0; j2 < textLength; j2++) {
          var text = ori.texts[j2];
          text.shape.set("visible", text.visible);
        }
      }
      self2.set("cachedMagnifiedModels", []);
      self2.set("cachedOriginPositions", {});
    };
    Fisheye3.prototype.updateParams = function(cfg) {
      var self2 = this;
      var r2 = cfg.r, d2 = cfg.d, trigger = cfg.trigger, minD = cfg.minD, maxD = cfg.maxD, minR = cfg.minR, maxR = cfg.maxR, scaleDBy = cfg.scaleDBy, scaleRBy = cfg.scaleRBy;
      if (!isNaN(cfg.r)) {
        self2.set("r", r2);
        self2.set("r2", r2 * r2);
      }
      if (!isNaN(d2)) {
        self2.set("d", d2);
      }
      if (!isNaN(maxD)) {
        self2.set("maxD", maxD);
      }
      if (!isNaN(minD)) {
        self2.set("minD", minD);
      }
      if (!isNaN(maxR)) {
        self2.set("maxR", maxR);
      }
      if (!isNaN(minR)) {
        self2.set("minR", minR);
      }
      var nd = self2.get("d");
      var nr2 = self2.get("r");
      self2.set("molecularParam", (nd + 1) * nr2);
      if (trigger === "mousemove" || trigger === "click" || trigger === "drag") {
        self2.set("trigger", trigger);
      }
      if (scaleDBy === "drag" || scaleDBy === "wheel" || scaleDBy === "unset") {
        self2.set("scaleDBy", scaleDBy);
        self2.get("delegate").remove();
        self2.get("delegate").destroy();
        var dPercentText = self2.get("dPercentText");
        if (dPercentText) {
          dPercentText.remove();
          dPercentText.destroy();
        }
      }
      if (scaleRBy === "drag" || scaleRBy === "wheel" || scaleRBy === "unset") {
        self2.set("scaleRBy", scaleRBy);
        self2.get("delegate").remove();
        self2.get("delegate").destroy();
        var dPercentText = self2.get("dPercentText");
        if (dPercentText) {
          dPercentText.remove();
          dPercentText.destroy();
        }
      }
    };
    Fisheye3.prototype.updateDelegate = function(mCenter, r2) {
      var _this = this;
      var self2 = this;
      var graph = self2.get("graph");
      var lensDelegate = self2.get("delegate");
      if (!lensDelegate || lensDelegate.destroyed) {
        var parent_1 = graph.get("group");
        var attrs = self2.get("delegateStyle") || lensDelegateStyle;
        lensDelegate = parent_1.addShape("circle", {
          attrs: __assign3({
            r: r2 / 1.5,
            x: mCenter.x,
            y: mCenter.y
          }, attrs),
          name: "lens-shape",
          draggable: true
        });
        if (this.get("trigger") !== "drag") {
          if (this.get("scaleRBy") === "wheel") {
            lensDelegate.on("mousewheel", function(evt) {
              self2.scaleRByWheel(evt);
            });
          } else if (this.get("scaleRBy") === "drag") {
            lensDelegate.on("dragstart", function(e8) {
              self2.set("dragging", true);
              self2.set("cacheCenter", {
                x: e8.x,
                y: e8.y
              });
              self2.set("dragPrePos", {
                x: e8.x,
                y: e8.y
              });
            });
            lensDelegate.on("drag", function(evt) {
              self2.scaleRByDrag(evt);
            });
            lensDelegate.on("dragend", function(e8) {
              self2.set("dragging", false);
            });
          }
          if (this.get("scaleDBy") === "wheel") {
            lensDelegate.on("mousewheel", function(evt) {
              _this.scaleDByWheel(evt);
            });
          } else if (this.get("scaleDBy") === "drag") {
            lensDelegate.on("dragstart", function(evt) {
              self2.set("dragging", true);
              self2.set("cacheCenter", {
                x: evt.x,
                y: evt.y
              });
              self2.set("dragPrePos", {
                x: evt.x,
                y: evt.y
              });
            });
            lensDelegate.on("drag", function(evt) {
              _this.scaleDByDrag(evt);
            });
            lensDelegate.on("dragend", function(evt) {
              self2.set("dragging", false);
            });
          }
        }
      } else {
        lensDelegate.attr({
          x: mCenter.x,
          y: mCenter.y,
          r: r2 / 1.5
        });
      }
      if (self2.get("showDPercent")) {
        var percent = Math.round((self2.get("d") - self2.get("minD")) / (self2.get("maxD") - self2.get("minD")) * 100);
        var dPercentText = self2.get("dPercentText");
        var textY = mCenter.y + r2 / 1.5 + 16;
        if (!dPercentText || dPercentText.destroyed) {
          var parent_2 = graph.get("group");
          dPercentText = parent_2.addShape("text", {
            attrs: {
              text: "".concat(percent, "%"),
              x: mCenter.x,
              y: textY,
              fill: "#aaa",
              stroke: "#fff",
              lineWidth: 1,
              fontSize: 12
            }
          });
          self2.set("dPercentText", dPercentText);
        } else {
          dPercentText.attr({
            text: "".concat(percent, "%"),
            x: mCenter.x,
            y: textY
          });
        }
      }
      self2.set("delegate", lensDelegate);
    };
    Fisheye3.prototype.clear = function() {
      var graph = this.get("graph");
      this.restoreCache();
      graph.refreshPositions();
      var lensDelegate = this.get("delegate");
      if (lensDelegate && !lensDelegate.destroyed) {
        lensDelegate.remove();
        lensDelegate.destroy();
      }
      var dPercentText = this.get("dPercentText");
      if (dPercentText && !dPercentText.destroyed) {
        dPercentText.remove();
        dPercentText.destroy();
      }
    };
    Fisheye3.prototype.destroy = function() {
      this.clear();
    };
    return Fisheye3;
  }(base_default2)
);
var fisheye_default = Fisheye;

// node_modules/@antv/g6-plugin/es/toolBar/index.js
init_esm();
var import_insert_css2 = __toESM(require_insert_css());
var __extends7 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DELTA2 = 0.05;
typeof document !== "undefined" && (0, import_insert_css2.default)("\n  .g6-component-toolbar {\n    position: absolute;\n    list-style-type: none;\n    padding: 6px;\n    left: 0px;\n    top: 0px;\n    background-color: rgba(255, 255, 255, 0.9);\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    margin: 0;\n  }\n  .g6-component-toolbar li {\n    float: left;\n    text-align: center;\n    width: 35px;\n    height: 24px;\n    cursor: pointer;\n		list-style-type:none;\n    list-style: none;\n    margin-left: 0px;\n  }\n  .g6-component-toolbar li .icon {\n    opacity: 0.7;\n  }\n  .g6-component-toolbar li .icon:hover {\n    opacity: 1;\n  }\n");
var getEventPath = function getEventPath2(evt) {
  if (!evt) {
    return [];
  }
  if (evt.composedPath) {
    return evt.composedPath();
  }
  var path = [];
  var el = evt.target;
  while (el) {
    path.push(el);
    if (el.tagName === "HTML") {
      path.push(document, window);
      return path;
    }
    el = el.parentElement;
  }
  return path;
};
var ToolBar = (
  /** @class */
  function(_super) {
    __extends7(ToolBar3, _super);
    function ToolBar3(config) {
      return _super.call(this, config) || this;
    }
    ToolBar3.prototype.getDefaultCfgs = function() {
      return {
        handleClick: void 0,
        // 指定菜单内容，function(e) {...}
        getContent: function getContent(graph) {
          return `
          <ul class='g6-component-toolbar'>
            <li code='redo'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M256 682.666667c0-102.741333 66.730667-213.333333 213.333333-213.333334 107.008 0 190.762667 56.576 230.570667 125.354667L611.968 682.666667H853.333333v-241.365334l-91.562666 91.562667C704.768 448.469333 601.130667 384 469.333333 384c-196.096 0-298.666667 150.229333-298.666666 298.666667h85.333333z" fill="" p-id="2041"></path>
              </svg>
            </li>
            <li code='undo'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M170.666667 682.666667h241.365333l-87.936-87.978667C363.904 525.909333 447.658667 469.333333 554.666667 469.333333c146.602667 0 213.333333 110.592 213.333333 213.333334h85.333333c0-148.437333-102.570667-298.666667-298.666666-298.666667-131.797333 0-235.392 64.469333-292.48 148.821333L170.666667 441.301333V682.666667z" fill="" p-id="2764"></path>
              </svg>
            </li>
            <li  code='zoomOut'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M658.432 428.736a33.216 33.216 0 0 1-33.152 33.152H525.824v99.456a33.216 33.216 0 0 1-66.304 0V461.888H360.064a33.152 33.152 0 0 1 0-66.304H459.52V296.128a33.152 33.152 0 0 1 66.304 0V395.52H625.28c18.24 0 33.152 14.848 33.152 33.152z m299.776 521.792a43.328 43.328 0 0 1-60.864-6.912l-189.248-220.992a362.368 362.368 0 0 1-215.36 70.848 364.8 364.8 0 1 1 364.8-364.736 363.072 363.072 0 0 1-86.912 235.968l192.384 224.64a43.392 43.392 0 0 1-4.8 61.184z m-465.536-223.36a298.816 298.816 0 0 0 298.432-298.432 298.816 298.816 0 0 0-298.432-298.432A298.816 298.816 0 0 0 194.24 428.8a298.816 298.816 0 0 0 298.432 298.432z"></path>
              </svg>
            </li>
            <li code='zoomIn'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M639.936 416a32 32 0 0 1-32 32h-256a32 32 0 0 1 0-64h256a32 32 0 0 1 32 32z m289.28 503.552a41.792 41.792 0 0 1-58.752-6.656l-182.656-213.248A349.76 349.76 0 0 1 480 768 352 352 0 1 1 832 416a350.4 350.4 0 0 1-83.84 227.712l185.664 216.768a41.856 41.856 0 0 1-4.608 59.072zM479.936 704c158.784 0 288-129.216 288-288S638.72 128 479.936 128a288.32 288.32 0 0 0-288 288c0 158.784 129.216 288 288 288z" p-id="3853"></path>
              </svg>
            </li>
            <li code='realZoom'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="24">
                <path d="M384 320v384H320V320h64z m256 0v384H576V320h64zM512 576v64H448V576h64z m0-192v64H448V384h64z m355.968 576H92.032A28.16 28.16 0 0 1 64 931.968V28.032C64 12.608 76.608 0 95.168 0h610.368L896 192v739.968a28.16 28.16 0 0 1-28.032 28.032zM704 64v128h128l-128-128z m128 192h-190.464V64H128v832h704V256z"></path>
              </svg>
            </li>
            <li code='autoZoom'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="24">
                <path d="M684.288 305.28l0.128-0.64-0.128-0.64V99.712c0-19.84 15.552-35.904 34.496-35.712a35.072 35.072 0 0 1 34.56 35.776v171.008h170.944c19.648 0 35.84 15.488 35.712 34.432a35.072 35.072 0 0 1-35.84 34.496h-204.16l-0.64-0.128a32.768 32.768 0 0 1-20.864-7.552c-1.344-1.024-2.816-1.664-3.968-2.816-0.384-0.32-0.512-0.768-0.832-1.088a33.472 33.472 0 0 1-9.408-22.848zM305.28 64a35.072 35.072 0 0 0-34.56 35.776v171.008H99.776A35.072 35.072 0 0 0 64 305.216c0 18.944 15.872 34.496 35.84 34.496h204.16l0.64-0.128a32.896 32.896 0 0 0 20.864-7.552c1.344-1.024 2.816-1.664 3.904-2.816 0.384-0.32 0.512-0.768 0.768-1.088a33.024 33.024 0 0 0 9.536-22.848l-0.128-0.64 0.128-0.704V99.712A35.008 35.008 0 0 0 305.216 64z m618.944 620.288h-204.16l-0.64 0.128-0.512-0.128c-7.808 0-14.72 3.2-20.48 7.68-1.28 1.024-2.752 1.664-3.84 2.752-0.384 0.32-0.512 0.768-0.832 1.088a33.664 33.664 0 0 0-9.408 22.912l0.128 0.64-0.128 0.704v204.288c0 19.712 15.552 35.904 34.496 35.712a35.072 35.072 0 0 0 34.56-35.776V753.28h170.944c19.648 0 35.84-15.488 35.712-34.432a35.072 35.072 0 0 0-35.84-34.496z m-593.92 11.52c-0.256-0.32-0.384-0.768-0.768-1.088-1.088-1.088-2.56-1.728-3.84-2.688a33.088 33.088 0 0 0-20.48-7.68l-0.512 0.064-0.64-0.128H99.84a35.072 35.072 0 0 0-35.84 34.496 35.072 35.072 0 0 0 35.712 34.432H270.72v171.008c0 19.84 15.552 35.84 34.56 35.776a35.008 35.008 0 0 0 34.432-35.712V720l-0.128-0.64 0.128-0.704a33.344 33.344 0 0 0-9.472-22.848zM512 374.144a137.92 137.92 0 1 0 0.128 275.84A137.92 137.92 0 0 0 512 374.08z"></path>
              </svg>
            </li>
          </ul>
        `;
        },
        zoomSensitivity: 2
      };
    };
    ToolBar3.prototype.init = function() {
      var _this = this;
      var graph = this.get("graph");
      var getContent = this.get("getContent");
      var toolBar = getContent(graph);
      var toolBarDOM = toolBar;
      if (is_string_default(toolBar)) {
        toolBarDOM = createDom(toolBar);
      }
      var className = this.get("className");
      toolBarDOM.setAttribute("class", className || "g6-component-toolbar");
      var container = this.get("container");
      if (!container) {
        container = this.get("graph").get("container");
      }
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      container.appendChild(toolBarDOM);
      this.set("toolBar", toolBarDOM);
      var handleClick = this.get("handleClick");
      toolBarDOM.addEventListener("click", function(evt) {
        var current = getEventPath(evt).filter(function(p2) {
          return p2.nodeName === "LI";
        });
        if (current.length === 0) {
          return;
        }
        var code = current[0].getAttribute("code");
        if (!code) {
          return;
        }
        if (handleClick) {
          handleClick(code, graph);
        } else {
          _this.handleDefaultOperator(code);
        }
      });
      var pos = this.get("position");
      if (pos) {
        modifyCSS(toolBarDOM, {
          top: "".concat(pos.y, "px"),
          left: "".concat(pos.x, "px")
        });
      }
      this.bindUndoRedo();
    };
    ToolBar3.prototype.bindUndoRedo = function() {
      var graph = this.get("graph");
      var undoDom = document.querySelector('.g6-component-toolbar li[code="undo"]');
      var undoDomIcon = document.querySelector('.g6-component-toolbar li[code="undo"] svg');
      var redoDom = document.querySelector('.g6-component-toolbar li[code="redo"]');
      var redoDomIcon = document.querySelector('.g6-component-toolbar li[code="redo"] svg');
      if (!undoDom || !undoDomIcon || !redoDom || !redoDomIcon) {
        return;
      }
      undoDom.setAttribute("style", "cursor: not-allowed");
      undoDomIcon.setAttribute("style", "opacity: 0.4");
      redoDom.setAttribute("style", "cursor: not-allowed");
      redoDomIcon.setAttribute("style", "opacity: 0.4");
      graph.on("stackchange", function(evt) {
        var undoStack = evt.undoStack, redoStack = evt.redoStack;
        var undoStackLen = undoStack.length;
        var redoStackLen = redoStack.length;
        if (undoStackLen === 0) {
          undoDom.setAttribute("style", "cursor: not-allowed");
          undoDomIcon.setAttribute("style", "opacity: 0.4");
        } else {
          undoDom.removeAttribute("style");
          undoDomIcon.removeAttribute("style");
        }
        if (redoStackLen === 0) {
          redoDom.setAttribute("style", "cursor: not-allowed");
          redoDomIcon.setAttribute("style", "opacity: 0.4");
        } else {
          redoDom.removeAttribute("style");
          redoDomIcon.removeAttribute("style");
        }
      });
    };
    ToolBar3.prototype.undo = function() {
      var graph = this.get("graph");
      var undoStack = graph.getUndoStack();
      if (!undoStack || undoStack.length === 0) {
        return;
      }
      var currentData = undoStack.pop();
      if (currentData) {
        var action = currentData.action;
        graph.pushStack(action, clone_default(currentData.data), "redo");
        var data_1 = currentData.data.before;
        if (action === "add") {
          data_1 = currentData.data.after;
        }
        if (!data_1)
          return;
        switch (action) {
          case "visible": {
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array)
                return;
              array.forEach(function(model) {
                var item = graph.findById(model.id);
                if (model.visible) {
                  graph.showItem(item, false);
                } else {
                  graph.hideItem(item, false);
                }
              });
            });
            break;
          }
          case "render":
          case "update":
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array)
                return;
              array.forEach(function(model) {
                var item = graph.findById(model.id);
                delete model.id;
                graph.updateItem(item, model, false);
                if (item.getType() === "combo")
                  graph.updateCombo(item);
              });
            });
            break;
          case "changedata":
            graph.changeData(data_1, false);
            break;
          case "delete": {
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array)
                return;
              array.forEach(function(model) {
                var itemType = model.itemType;
                delete model.itemType;
                graph.addItem(itemType, model, false);
              });
            });
            break;
          }
          case "add":
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array)
                return;
              array.forEach(function(model) {
                graph.removeItem(model.id, false);
              });
            });
            break;
          case "updateComboTree":
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array)
                return;
              array.forEach(function(model) {
                graph.updateComboTree(model.id, model.parentId, false);
              });
            });
            break;
          case "createCombo":
            var afterCombos = currentData.data.after.combos;
            var createdCombo = afterCombos[afterCombos.length - 1];
            Object.keys(data_1).forEach(function(key) {
              var array = data_1[key];
              if (!array)
                return;
              array.forEach(function(model) {
                graph.updateComboTree(model.id, model.parentId, false);
              });
            });
            graph.removeItem(createdCombo.id, false);
            break;
          case "uncombo":
            var targetCombo_1 = data_1.combos[data_1.combos.length - 1];
            var childrenIds = data_1.nodes.concat(data_1.combos).map(function(child) {
              return child.id;
            }).filter(function(id) {
              return id !== targetCombo_1.id;
            });
            graph.createCombo(targetCombo_1, childrenIds, false);
            break;
          case "layout":
            graph.updateLayout(data_1, void 0, void 0, false);
            break;
          default:
        }
      }
    };
    ToolBar3.prototype.redo = function() {
      var graph = this.get("graph");
      var redoStack = graph.getRedoStack();
      if (!redoStack || redoStack.length === 0) {
        return;
      }
      var currentData = redoStack.pop();
      if (currentData) {
        var action = currentData.action;
        var data_2 = currentData.data.after;
        graph.pushStack(action, clone_default(currentData.data));
        if (action === "delete") {
          data_2 = currentData.data.before;
        }
        if (!data_2)
          return;
        switch (action) {
          case "visible": {
            Object.keys(data_2).forEach(function(key) {
              var array = data_2[key];
              if (!array)
                return;
              array.forEach(function(model) {
                var item = graph.findById(model.id);
                if (model.visible) {
                  graph.showItem(item, false);
                } else {
                  graph.hideItem(item, false);
                }
              });
            });
            break;
          }
          case "render":
          case "update":
            Object.keys(data_2).forEach(function(key) {
              var array = data_2[key];
              if (!array)
                return;
              array.forEach(function(model) {
                var item = graph.findById(model.id);
                delete model.id;
                graph.updateItem(item, model, false);
                if (item.getType() === "combo")
                  graph.updateCombo(item);
              });
            });
            break;
          case "changedata":
            graph.changeData(data_2, false);
            break;
          case "delete":
            if (data_2.edges) {
              data_2.edges.forEach(function(model) {
                graph.removeItem(model.id, false);
              });
            }
            if (data_2.nodes) {
              data_2.nodes.forEach(function(model) {
                graph.removeItem(model.id, false);
              });
            }
            if (data_2.combos) {
              data_2.combos.forEach(function(model) {
                graph.removeItem(model.id, false);
              });
            }
            break;
          case "add": {
            Object.keys(data_2).forEach(function(key) {
              var array = data_2[key];
              if (!array)
                return;
              array.forEach(function(model) {
                var itemType = model.itemType;
                delete model.itemType;
                graph.addItem(itemType, model, false);
              });
            });
            break;
          }
          case "updateComboTree":
            Object.keys(data_2).forEach(function(key) {
              var array = data_2[key];
              if (!array)
                return;
              array.forEach(function(model) {
                graph.updateComboTree(model.id, model.parentId, false);
              });
            });
            break;
          case "createCombo":
            var createdCombo = data_2.combos[data_2.combos.length - 1];
            graph.createCombo(createdCombo, createdCombo.children.map(function(child) {
              return child.id;
            }), false);
            break;
          case "uncombo":
            var beforeCombos = currentData.data.before.combos;
            var targertCombo = beforeCombos[beforeCombos.length - 1];
            graph.uncombo(targertCombo.id, false);
            break;
          case "layout":
            graph.updateLayout(data_2, void 0, void 0, false);
            break;
          default:
        }
      }
    };
    ToolBar3.prototype.zoomOut = function() {
      var graph = this.get("graph");
      var currentZoom = graph.getZoom();
      var ratioOut = 1 / (1 - DELTA2 * this.get("zoomSensitivity"));
      var maxZoom = this.get("maxZoom") || graph.get("maxZoom");
      if (ratioOut * currentZoom > maxZoom) {
        return;
      }
      graph.zoomTo(currentZoom * ratioOut);
    };
    ToolBar3.prototype.zoomIn = function() {
      var graph = this.get("graph");
      var currentZoom = graph.getZoom();
      var ratioIn = 1 - DELTA2 * this.get("zoomSensitivity");
      var minZoom = this.get("minZoom") || graph.get("minZoom");
      if (ratioIn * currentZoom < minZoom) {
        return;
      }
      graph.zoomTo(currentZoom * ratioIn);
    };
    ToolBar3.prototype.realZoom = function() {
      var graph = this.get("graph");
      graph.zoomTo(1);
    };
    ToolBar3.prototype.autoZoom = function() {
      var graph = this.get("graph");
      graph.fitView([20, 20]);
    };
    ToolBar3.prototype.handleDefaultOperator = function(code) {
      switch (code) {
        case "redo":
          this.redo();
          break;
        case "undo":
          this.undo();
          break;
        case "zoomOut":
          this.zoomOut();
          break;
        case "zoomIn":
          this.zoomIn();
          break;
        case "realZoom":
          this.realZoom();
          break;
        case "autoZoom":
          this.autoZoom();
          break;
        default:
      }
    };
    ToolBar3.prototype.destroy = function() {
      var toolBar = this.get("toolBar");
      if (toolBar) {
        var container = this.get("container");
        if (!container) {
          container = this.get("graph").get("container");
        }
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        container.removeChild(toolBar);
      }
      var handleClick = this.get("handleClick");
      if (handleClick) {
        toolBar.removeEventListener("click", handleClick);
      }
    };
    return ToolBar3;
  }(base_default2)
);
var toolBar_default = ToolBar;

// node_modules/@antv/g6-plugin/es/tooltip/index.js
init_esm();
var import_insert_css3 = __toESM(require_insert_css());
var __extends8 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
typeof document !== "undefined" && (0, import_insert_css3.default)("\n  .g6-component-tooltip {\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    background-color: rgba(255, 255, 255, 0.9);\n    padding: 10px 8px;\n    box-shadow: rgb(174, 174, 174) 0px 0px 10px;\n  }\n  .tooltip-type {\n    padding: 0;\n    margin: 0;\n  }\n  .tooltip-id {\n    color: #531dab;\n  }\n");
var Tooltip = (
  /** @class */
  function(_super) {
    __extends8(Tooltip3, _super);
    function Tooltip3(config) {
      return _super.call(this, config) || this;
    }
    Tooltip3.prototype.getDefaultCfgs = function() {
      return {
        offsetX: 6,
        offsetY: 6,
        // 指定菜单内容，function(e) {...}
        getContent: function getContent(e8) {
          return "\n          <h4 class='tooltip-type'>类型：".concat(e8.item.getType(), "</h4>\n          <span class='tooltip-id'>ID：").concat(e8.item.getID(), "</span>\n        ");
        },
        shouldBegin: function shouldBegin2(e8) {
          return true;
        },
        itemTypes: ["node", "edge", "combo"],
        trigger: "mouseenter",
        fixToNode: void 0
      };
    };
    Tooltip3.prototype.getEvents = function() {
      if (this.get("trigger") === "click") {
        return {
          "node:click": "onClick",
          "edge:click": "onClick",
          "combo:click": "onClick",
          "canvas:click": "onMouseLeave",
          afterremoveitem: "onMouseLeave",
          contextmenu: "onMouseLeave",
          drag: "onMouseLeave"
        };
      }
      return {
        "node:mouseenter": "onMouseEnter",
        "node:mouseleave": "onMouseLeave",
        "node:mousemove": "onMouseMove",
        "edge:mouseenter": "onMouseEnter",
        "edge:mouseleave": "onMouseLeave",
        "edge:mousemove": "onMouseMove",
        "combo:mouseenter": "onMouseEnter",
        "combo:mouseleave": "onMouseLeave",
        "combo:mousemove": "onMouseMove",
        afterremoveitem: "onMouseLeave",
        contextmenu: "onMouseLeave",
        "node:drag": "onMouseLeave"
      };
    };
    Tooltip3.prototype.init = function() {
      var self2 = this;
      var className = self2.get("className") || "g6-component-tooltip";
      var tooltip = createDom("<div class='".concat(className, "'></div>"));
      var container = self2.get("container");
      if (!container) {
        container = self2.get("graph").get("container");
      }
      if (is_string_default(container)) {
        container = document.getElementById(container);
      }
      modifyCSS(tooltip, {
        position: "absolute",
        visibility: "hidden",
        display: "none"
      });
      container.appendChild(tooltip);
      if (self2.get("trigger") !== "click") {
        tooltip.addEventListener("mouseenter", function(e8) {
          modifyCSS(tooltip, {
            visibility: "visible",
            display: "unset"
          });
        });
        tooltip.addEventListener("mouseleave", function(e8) {
          self2.hideTooltip();
        });
      }
      self2.set("tooltip", tooltip);
    };
    Tooltip3.prototype.onClick = function(e8) {
      var itemTypes = this.get("itemTypes");
      if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1)
        return;
      var item = e8.item;
      var graph = this.get("graph");
      if (this.currentTarget === item) {
        this.currentTarget = null;
        this.hideTooltip();
        graph.emit("tooltipchange", {
          item: e8.item,
          action: "hide"
        });
      } else {
        this.currentTarget = item;
        this.showTooltip(e8);
        graph.emit("tooltipchange", {
          item: e8.item,
          action: "show"
        });
      }
    };
    Tooltip3.prototype.onMouseEnter = function(e8) {
      var itemTypes = this.get("itemTypes");
      if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1)
        return;
      var item = e8.item;
      var graph = this.get("graph");
      this.currentTarget = item;
      this.showTooltip(e8);
      graph.emit("tooltipchange", {
        item: e8.item,
        action: "show"
      });
    };
    Tooltip3.prototype.onMouseMove = function(e8) {
      var itemTypes = this.get("itemTypes");
      if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1)
        return;
      if (!this.currentTarget || e8.item !== this.currentTarget) {
        return;
      }
      this.showTooltip(e8);
    };
    Tooltip3.prototype.onMouseLeave = function() {
      this.hideTooltip();
      var graph = this.get("graph");
      graph.emit("tooltipchange", {
        item: this.currentTarget,
        action: "hide"
      });
      this.currentTarget = null;
    };
    Tooltip3.prototype.clearContainer = function() {
      var container = this.get("tooltip");
      if (container) {
        container.innerHTML = "";
      }
    };
    Tooltip3.prototype.showTooltip = function(e8) {
      if (!e8.item) {
        return;
      }
      var itemTypes = this.get("itemTypes");
      if (e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1)
        return;
      var container = this.get("tooltip");
      var getContent = this.get("getContent");
      var tooltip = getContent(e8);
      if (is_string_default(tooltip)) {
        container.innerHTML = tooltip;
      } else {
        this.clearContainer();
        container.appendChild(tooltip);
      }
      this.updatePosition(e8);
    };
    Tooltip3.prototype.hideTooltip = function() {
      var tooltip = this.get("tooltip");
      if (tooltip) {
        modifyCSS(tooltip, {
          visibility: "hidden",
          display: "none"
        });
      }
    };
    Tooltip3.prototype.updatePosition = function(e8) {
      var shouldBegin2 = this.get("shouldBegin");
      var tooltip = this.get("tooltip");
      if (!shouldBegin2(e8)) {
        modifyCSS(tooltip, {
          visibility: "hidden",
          display: "none"
        });
        return;
      }
      var graph = this.get("graph");
      var width = graph.get("width");
      var height = graph.get("height");
      var offsetX = this.get("offsetX") || 0;
      var offsetY = this.get("offsetY") || 0;
      var point = graph.getPointByClient(e8.clientX, e8.clientY);
      var fixToNode = this.get("fixToNode");
      var item = e8.item;
      if (item.getType && item.getType() === "node" && fixToNode && is_array_default(fixToNode) && fixToNode.length >= 2) {
        var itemBBox = item.getBBox();
        point = {
          x: itemBBox.minX + itemBBox.width * fixToNode[0],
          y: itemBBox.minY + itemBBox.height * fixToNode[1]
        };
      }
      var _a2 = graph.getCanvasByPoint(point.x, point.y), x4 = _a2.x, y4 = _a2.y;
      var graphContainer = graph.getContainer();
      var res = {
        x: x4 + graphContainer.offsetLeft + offsetX,
        y: y4 + graphContainer.offsetTop + offsetY
      };
      modifyCSS(tooltip, {
        visibility: "visible",
        display: "unset"
      });
      var bbox = tooltip.getBoundingClientRect();
      if (x4 + bbox.width + offsetX > width) {
        res.x -= bbox.width + offsetX;
      }
      if (y4 + bbox.height + offsetY > height) {
        res.y -= bbox.height + offsetY;
      }
      modifyCSS(tooltip, {
        left: "".concat(res.x, "px"),
        top: "".concat(res.y, "px")
      });
    };
    Tooltip3.prototype.hide = function() {
      this.onMouseLeave();
    };
    Tooltip3.prototype.destroy = function() {
      var tooltip = this.get("tooltip");
      if (tooltip) {
        var container = this.get("container");
        if (!container) {
          container = this.get("graph").get("container");
        }
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        container.removeChild(tooltip);
      }
    };
    return Tooltip3;
  }(base_default2)
);
var tooltip_default = Tooltip;

// node_modules/@antv/g6-plugin/es/timeBar/trendTimeBar.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/path.js
init_esm();
var __spreadArray2 = function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
function pointsToPath(points) {
  return map_default(points, function(p2, idx) {
    var command = idx === 0 ? "M" : "L";
    var x4 = p2[0], y4 = p2[1];
    return [command, x4, y4];
  });
}
function getLinePath(points) {
  return pointsToPath(points);
}
function getSmoothLinePath(points) {
  if (points.length <= 2) {
    return getLinePath(points);
  }
  var data = [];
  each_default(points, function(p2) {
    if (!is_equal_default(p2, data.slice(data.length - 2))) {
      data.push(p2[0], p2[1]);
    }
  });
  var path = catmull_rom_2_bezier_default(data, false);
  var _a2 = head(points), x4 = _a2[0], y4 = _a2[1];
  path.unshift(["M", x4, y4]);
  return path;
}
function dataToPath(data, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  }
  var y4 = new linear_default({
    values: data
  });
  var x4 = new base_default({
    values: map_default(data, function(v2, idx) {
      return idx;
    })
  });
  var points = map_default(data, function(v2, idx) {
    return [x4.scale(idx) * width, height - y4.scale(v2) * height];
  });
  return smooth ? getSmoothLinePath(points) : getLinePath(points);
}
function dataToRectPath(data, width, height, barWidth) {
  if (barWidth === void 0) {
    barWidth = 5;
  }
  var y4 = new linear_default({
    values: data
  });
  var x4 = new base_default({
    values: map_default(data, function(v2, idx) {
      return idx;
    })
  });
  var points = map_default(data, function(v2, idx) {
    return [x4.scale(idx) * width, height - y4.scale(v2) * height];
  });
  var rectPoints = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point = points[i2];
    var param = {
      x: point[0],
      y: point[1],
      y0: height,
      size: barWidth
    };
    var rectPoint = getRectPoints(param);
    rectPoints.push.apply(rectPoints, rectPoint);
  }
  return getRectPath(rectPoints);
}
function getAreaLineY(data, height) {
  var y4 = new linear_default({
    values: data
  });
  var lineY = Math.max(0, y4.min);
  return height - y4.scale(lineY) * height;
}
function linePathToAreaPath(path, width, height, data) {
  var areaPath = __spreadArray2([], path, true);
  var lineYPx = getAreaLineY(data, height);
  areaPath.push(["L", width, lineYPx]);
  areaPath.push(["L", 0, lineYPx]);
  areaPath.push(["Z"]);
  return areaPath;
}
function getRectPoints(pointInfo) {
  var x4 = pointInfo.x, y4 = pointInfo.y, y0 = pointInfo.y0, size3 = pointInfo.size;
  var yMin;
  var yMax;
  if (is_array_default(y4)) {
    yMin = y4[0], yMax = y4[1];
  } else {
    yMin = y0;
    yMax = y4;
  }
  var xMin;
  var xMax;
  if (is_array_default(x4)) {
    xMin = x4[0], xMax = x4[1];
  } else {
    xMin = x4 - size3 / 2;
    xMax = x4 + size3 / 2;
  }
  var points = [{
    x: xMin,
    y: yMin
  }, {
    x: xMin,
    y: yMax
  }];
  points.push({
    x: xMax,
    y: yMax
  }, {
    x: xMax,
    y: yMin
  });
  return points;
}
function getRectPath(points, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path = [];
  var firstPoint = points[0];
  path.push(["M", firstPoint.x, firstPoint.y]);
  for (var i2 = 1, len = points.length; i2 < len; i2++) {
    path.push(["L", points[i2].x, points[i2].y]);
  }
  if (isClosed) {
    path.push(["L", firstPoint.x, firstPoint.y]);
    path.push(["z"]);
  }
  return path;
}

// node_modules/@antv/g6-plugin/es/timeBar/trend.js
var __assign4 = function() {
  __assign4 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign4.apply(this, arguments);
};
var LINE_STYLE = {
  stroke: "#C5C5C5",
  strokeOpacity: 0.85
};
var AREA_STYLE = {
  fill: "#CACED4",
  opacity: 0.85
};
var Trend = (
  /** @class */
  function() {
    function Trend2(cfg) {
      var _a2 = cfg.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y4 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 200 : _c, _d = cfg.height, height = _d === void 0 ? 26 : _d, _e2 = cfg.smooth, smooth = _e2 === void 0 ? true : _e2, _f = cfg.isArea, isArea = _f === void 0 ? false : _f, _g = cfg.data, data = _g === void 0 ? [] : _g, lineStyle = cfg.lineStyle, areaStyle = cfg.areaStyle, group = cfg.group, _h = cfg.interval, interval = _h === void 0 ? null : _h;
      this.group = group;
      this.x = x4;
      this.y = y4;
      this.width = width;
      this.height = height;
      this.data = data;
      this.smooth = smooth;
      this.isArea = isArea;
      this.lineStyle = Object.assign({}, LINE_STYLE, lineStyle);
      this.areaStyle = Object.assign({}, AREA_STYLE, areaStyle);
      this.intervalConfig = interval;
      this.renderLine();
    }
    Trend2.prototype.renderLine = function() {
      var _a2 = this, x4 = _a2.x, y4 = _a2.y, width = _a2.width, height = _a2.height, barWidth = _a2.barWidth, data = _a2.data, smooth = _a2.smooth, isArea = _a2.isArea, lineStyle = _a2.lineStyle, areaStyle = _a2.areaStyle;
      var trendGroup = this.group.addGroup({
        name: "trend-group"
      });
      if (data) {
        var path = dataToPath(data, width, height, smooth);
        trendGroup.addShape("path", {
          attrs: __assign4({
            path
          }, lineStyle),
          name: "trend-line"
        });
        if (isArea) {
          var areaPath = linePathToAreaPath(path, width, height, data);
          trendGroup.addShape("path", {
            attrs: __assign4({
              path: areaPath
            }, areaStyle),
            name: "trend-area"
          });
        }
      }
      if (this.intervalConfig) {
        trendGroup.addShape("path", {
          attrs: __assign4({
            path: dataToRectPath(this.intervalConfig.data, width, height, this.intervalConfig.style.barWidth)
          }, this.intervalConfig.style),
          name: "trend-interval"
        });
      }
      trendGroup.move(x4, y4);
    };
    Trend2.prototype.destory = function() {
      this.group.destroy();
    };
    return Trend2;
  }()
);
var trend_default = Trend;

// node_modules/@antv/g6-plugin/es/timeBar/handler.js
init_esm();
var __assign5 = function() {
  __assign5 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign5.apply(this, arguments);
};
var DEFAULT_STYLE = {
  fill: "#1890ff",
  stroke: "#1890ff",
  type: "trend",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  // 高亮的颜色
  highLightFill: "#0050b3"
};
var SIMPLE_DEFAULT_STYLE = {
  fill: "#fff",
  stroke: "#1890ff",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize"
};
var Handler = (
  /** @class */
  function() {
    function Handler2(cfg) {
      var group = cfg.group, name = cfg.name, type = cfg.type, _a2 = cfg.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y4 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 2 : _c, _d = cfg.height, height = _d === void 0 ? 24 : _d, _e2 = cfg.style, style = _e2 === void 0 ? {} : _e2;
      this.group = group;
      this.name = name;
      this.handleType = type;
      this.x = x4;
      this.y = y4;
      this.width = width;
      this.height = height;
      if (type === "trend") {
        this.style = __assign5(__assign5({}, DEFAULT_STYLE), style);
      } else if (type === "simple") {
        this.style = __assign5(__assign5({}, SIMPLE_DEFAULT_STYLE), style);
      }
      this.renderHandle();
    }
    Handler2.prototype.setX = function(x4) {
      this.setXY(x4, void 0);
    };
    Handler2.prototype.setY = function(y4) {
      this.setXY(void 0, y4);
    };
    Handler2.prototype.setXY = function(x4, y4) {
      if (is_number_default(x4)) {
        this.x = x4;
      }
      if (is_number_default(y4)) {
        this.y = y4;
      }
      this.updateXY();
    };
    Handler2.prototype.renderHandle = function() {
      var _a2 = this, width = _a2.width, height = _a2.height, style = _a2.style, name = _a2.name;
      var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
      this.handleGroup = this.group.addGroup();
      if (this.handleType === "trend") {
        this.verticalLine = this.handleGroup.addShape("rect", {
          attrs: {
            x: 0,
            y: 0,
            width,
            height,
            fill,
            stroke,
            radius,
            opacity,
            cursor
          },
          name: "".concat(name, "-handler")
        });
        this.topCircle = this.handleGroup.addShape("circle", {
          attrs: {
            x: width / 2,
            y: 0,
            r: 2 * width,
            fill,
            stroke,
            radius,
            opacity,
            cursor,
            lineAppendWidth: 12
          },
          name: "".concat(name, "-handler")
        });
        this.bottomCircle = this.handleGroup.addShape("circle", {
          attrs: {
            x: width / 2,
            y: height,
            r: 2 * width,
            fill,
            stroke,
            radius,
            opacity,
            cursor
          },
          name: "".concat(name, "-handler")
        });
      } else if (this.handleType === "simple") {
        this.topCircle = this.handleGroup.addShape("circle", {
          attrs: {
            x: width / 2,
            y: height / 2,
            r: 2 * width,
            fill,
            stroke,
            radius,
            opacity,
            cursor,
            lineWidth: 2
          },
          name: "".concat(name, "-handler")
        });
      }
      this.updateXY();
      if (this.handleType === "trend") {
        this.bindTrendEvents();
      } else if (this.handleType === "simple") {
        this.bindSimpleEvents();
      }
    };
    Handler2.prototype.bindSimpleEvents = function() {
      var _this = this;
      var name = this.name;
      this.handleGroup.on("".concat(name, "-handler:mouseenter"), function() {
        var highLightFill = _this.style.highLightFill;
        _this.topCircle.attr("fill", highLightFill);
      });
      this.handleGroup.on("".concat(name, "-handler:mouseleave"), function() {
        var fill = _this.style.fill;
        _this.topCircle.attr("fill", fill);
      });
    };
    Handler2.prototype.bindTrendEvents = function() {
      var _this = this;
      var name = this.name;
      this.handleGroup.on("".concat(name, "-handler:mouseenter"), function() {
        var highLightFill = _this.style.highLightFill;
        _this.verticalLine.attr("fill", highLightFill);
        _this.topCircle.attr("fill", highLightFill);
        _this.bottomCircle.attr("fill", highLightFill);
      });
      this.handleGroup.on("".concat(name, "-handler:mouseleave"), function() {
        var fill = _this.style.fill;
        _this.verticalLine.attr("fill", fill);
        _this.topCircle.attr("fill", fill);
        _this.bottomCircle.attr("fill", fill);
      });
    };
    Handler2.prototype.show = function() {
      this.handleGroup.show();
    };
    Handler2.prototype.hide = function() {
      this.handleGroup.hide();
    };
    Handler2.prototype.updateXY = function() {
      this.handleGroup.setMatrix([1, 0, 0, 0, 1, 0, this.x, this.y, 1]);
    };
    return Handler2;
  }()
);
var handler_default = Handler;

// node_modules/@antv/g6-plugin/es/timeBar/trendTimeBar.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/controllerBtn.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/timeButton.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/constant.js
var TIMELINE_START = "timebarstartplay";
var TIMELINE_END = "timebarendplay";
var VALUE_CHANGE = "valuechange";
var TIMEBAR_CONFIG_CHANGE = "timebarConfigChanged";
var PLAY_PAUSE_BTN = "playPauseBtn";
var NEXT_STEP_BTN = "nextStepBtn";
var PRE_STEP_BTN = "preStepBtn";

// node_modules/@antv/g6-plugin/es/timeBar/timeButton.js
var __assign6 = function() {
  __assign6 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign6.apply(this, arguments);
};
var Button = (
  /** @class */
  function() {
    function Button2(cfg) {
      this.config = deep_mix_default({}, cfg);
      this.init();
    }
    Button2.prototype.update = function(cfg) {
      this.config = deep_mix_default({}, this.config, cfg);
      this.updateElement();
      this.renderMarker();
    };
    Button2.prototype.init = function() {
      this.initElement();
      this.renderMarker();
    };
    Button2.prototype.initElement = function() {
      var _a2 = this.config, group = _a2.group, style = _a2.style;
      var _b = style.scale, scale3 = _b === void 0 ? 1 : _b, _c = style.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = style.offsetY, offsetY = _d === void 0 ? 0 : _d;
      var x4 = this.config.x + offsetX;
      var y4 = this.config.y + offsetY;
      var buttonGroup = group.addGroup({
        name: PLAY_PAUSE_BTN
      });
      this.startMarkerGroup = buttonGroup.addGroup({
        name: PLAY_PAUSE_BTN
      });
      this.circle = group.addShape("circle", {
        attrs: __assign6({
          x: x4,
          y: y4,
          r: this.config.r * scale3
        }, style),
        name: PLAY_PAUSE_BTN
      });
      this.startMarker = this.startMarkerGroup.addShape("path", {
        attrs: {
          path: this.getStartMarkerPath(x4, y4, scale3),
          fill: style.stroke || "#aaa"
        },
        name: "start-marker"
      });
      this.pauseMarkerGroup = buttonGroup.addGroup({
        name: PLAY_PAUSE_BTN
      });
      var width = 0.25 * this.config.r * scale3;
      var height = 0.5 * this.config.r * Math.sqrt(3) * scale3;
      this.pauseLeftMarker = this.pauseMarkerGroup.addShape("rect", {
        attrs: {
          x: x4 - 0.375 * this.config.r * scale3,
          y: y4 - height / 2,
          width,
          height,
          fill: style.stroke || "#aaa",
          lineWidth: 0
        }
      });
      this.pauseRightMarker = this.pauseMarkerGroup.addShape("rect", {
        attrs: {
          x: x4 + 1 / 8 * this.config.r * scale3,
          y: y4 - height / 2,
          width,
          height,
          fill: style.stroke || "#aaa",
          lineWidth: 0
        }
      });
    };
    Button2.prototype.updateElement = function() {
      var _a2 = this.config.style, _b = _a2.scale, scale3 = _b === void 0 ? 1 : _b, _c = _a2.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _a2.offsetY, offsetY = _d === void 0 ? 0 : _d;
      var x4 = this.config.x + offsetX;
      var y4 = this.config.y + offsetY;
      this.circle.attr("x", x4);
      this.circle.attr("y", y4);
      this.circle.attr("r", this.config.r * scale3);
      this.startMarker.attr("path", this.getStartMarkerPath(x4, y4, scale3));
      var width = 0.25 * this.config.r * scale3;
      var height = 0.5 * this.config.r * Math.sqrt(3) * scale3;
      this.pauseLeftMarker.attr("x", x4 - (1 / 4 + 1 / 8) * this.config.r * scale3);
      this.pauseLeftMarker.attr("y", y4 - height / 2);
      this.pauseLeftMarker.attr("width", width);
      this.pauseLeftMarker.attr("height", height);
      this.pauseRightMarker.attr("x", x4 + 1 / 8 * this.config.r * scale3);
      this.pauseRightMarker.attr("y", y4 - height / 2);
      this.pauseRightMarker.attr("width", width);
      this.pauseRightMarker.attr("height", height);
    };
    Button2.prototype.renderMarker = function() {
      if (this.config.isPlay) {
        this.startMarkerGroup.hide();
        this.pauseMarkerGroup.show();
      } else {
        this.startMarkerGroup.show();
        this.pauseMarkerGroup.hide();
      }
    };
    Button2.prototype.getStartMarkerPath = function(x4, y4, scale3) {
      var sideLength = 0.5 * this.config.r * Math.sqrt(3) * scale3;
      return [["M", x4 - sideLength / Math.sqrt(3) / 2, y4 - sideLength / 2], ["L", x4 + sideLength / Math.sqrt(3), y4], ["L", x4 - sideLength / Math.sqrt(3) / 2, y4 + sideLength / 2]];
    };
    return Button2;
  }()
);
var timeButton_default = Button;

// node_modules/@antv/g6-plugin/es/timeBar/controllerBtn.js
var __assign7 = function() {
  __assign7 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign7.apply(this, arguments);
};
var transform9 = ext_exports.transform;
var DEFAULT_RECT_FILL = "#aaa";
var DEFAULT_RECT_STROKE = "green";
var DEFAULT_PLAYBTN_STYLE = {
  fill: "#aaa",
  fillOpacity: 0.35,
  stroke: "#aaa"
};
var DEFAULT_PREBTN_STYLE = {
  fill: "#fff"
};
var DEFAULT_NEXTBTN_STYLE = {
  fill: "green"
};
var DEFAULT_SPEED_CONTROLLER_STYLE = {
  pointer: {
    fill: "#aaa",
    lineWidth: 0
  },
  scroller: {
    stroke: "#aaa",
    fill: "#aaa",
    lineWidth: 1,
    lineAppendWidth: 5,
    cursor: "pointer"
  },
  text: {
    fill: "#aaa",
    textBaseline: "top"
  }
};
var DEFAULT_TIMETYPE_CONTROLLER_STYLE = {
  check: {
    stroke: "green",
    lineWidth: 3
  },
  box: {
    fill: "#fff",
    stroke: "#aaa",
    lineWidth: 2,
    radius: 3,
    width: 12,
    height: 12
  },
  text: {
    fill: "#aaa",
    fontSize: 12,
    textBaseline: "top"
  }
};
var DEFAULT_CONTROLLER_CONFIG = {
  speed: 1,
  loop: false,
  fill: "#fff",
  stroke: "#fff",
  hideTimeTypeController: false,
  preBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa"
  },
  nextBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa"
  },
  playBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa",
    fillOpacity: 0.05
  },
  speedControllerStyle: DEFAULT_SPEED_CONTROLLER_STYLE,
  timeTypeControllerStyle: DEFAULT_TIMETYPE_CONTROLLER_STYLE
};
var SPEED_CONTROLLER_OFFSET = 110;
var TOGGLE_MODEL_OFFSET = 50;
var TIME_TYPE = {
  SINGLE: "single",
  RANGE: "range"
};
var ControllerBtn = (
  /** @class */
  function() {
    function ControllerBtn2(cfg) {
      this.controllerCfg = deep_mix_default({}, DEFAULT_CONTROLLER_CONFIG, cfg);
      this.group = cfg.group;
      this.controllerGroup = this.group.addGroup({
        name: "controller-group"
      });
      this.speedAxisY = [];
      this.currentSpeed = this.controllerCfg.speed;
      this.currentType = this.controllerCfg.defaultTimeType || TIME_TYPE.RANGE;
      this.fontFamily = cfg.fontFamily || "Arial, sans-serif";
      this.init();
    }
    ControllerBtn2.prototype.init = function() {
      this.renderPlayButton();
    };
    ControllerBtn2.prototype.getNextMarkerPath = function(x4, y4, len) {
      return [["M", x4, y4 - len], ["L", x4 + len, y4], ["L", x4, y4 + len], ["Z", x4, y4 - len], ["M", x4, y4], ["L", x4 - len, y4 - len], ["L", x4 - len, y4 + len], ["Z"]];
    };
    ControllerBtn2.prototype.getPreMarkerPath = function(x4, y4, len) {
      return [["M", x4, y4 - len], ["L", x4 - len, y4], ["L", x4, y4 + len], ["L", x4, y4 - len], ["M", x4, y4], ["L", x4 + len, y4 - len], ["L", x4 + len, y4 + len], ["Z"]];
    };
    ControllerBtn2.prototype.renderPlayButton = function() {
      var controllerCfg = this.controllerCfg;
      var width = controllerCfg.width, height = controllerCfg.height, x4 = controllerCfg.x, y4 = controllerCfg.y, hideTimeTypeController = controllerCfg.hideTimeTypeController, _a2 = controllerCfg.fill, fill = _a2 === void 0 ? DEFAULT_RECT_FILL : _a2, _b = controllerCfg.stroke, stroke = _b === void 0 ? DEFAULT_RECT_STROKE : _b, _c = controllerCfg.containerStyle, containerStyle = _c === void 0 ? {} : _c;
      var playBtnStyle = __assign7(__assign7({}, DEFAULT_PLAYBTN_STYLE), controllerCfg.playBtnStyle || {});
      var preBtnStyle = __assign7(__assign7({}, DEFAULT_PREBTN_STYLE), controllerCfg.preBtnStyle || {});
      var nextBtnStyle = __assign7(__assign7({}, DEFAULT_NEXTBTN_STYLE), controllerCfg.nextBtnStyle || {});
      var r2 = height / 2 - 5;
      var realY = y4 + 10;
      var container = this.controllerGroup.addShape("rect", {
        attrs: __assign7({
          x: x4,
          y: realY,
          width,
          height,
          stroke,
          fill
        }, containerStyle),
        name: "container-rect"
      });
      if (this.playButton) {
        this.playButton.update({
          x: width / 2,
          y: realY,
          r: r2
        });
      } else {
        this.playButton = new timeButton_default({
          group: this.controllerGroup,
          x: width / 2,
          y: realY + r2 + 5,
          r: r2,
          isPlay: this.isPlay,
          style: playBtnStyle
        });
      }
      var prePaddingX = preBtnStyle.offsetX || 0;
      var prePaddingY = preBtnStyle.offsetY || 0;
      var preR = (preBtnStyle.scale || 1) * r2;
      this.controllerGroup.addShape("path", {
        attrs: __assign7({
          path: this.getPreMarkerPath(width / 2 - 5 * r2 + prePaddingX, realY + r2 + 5 + prePaddingY, preR * 0.5)
        }, preBtnStyle),
        name: PRE_STEP_BTN
      });
      var nxtPaddingX = nextBtnStyle.offsetX || 0;
      var nxtPaddingY = nextBtnStyle.offsetY || 0;
      var nxtR = (nextBtnStyle.scale || 1) * r2;
      this.controllerGroup.addShape("path", {
        attrs: __assign7({
          path: this.getNextMarkerPath(width / 2 + 5 * r2 + nxtPaddingX, realY + r2 + 5 + nxtPaddingY, nxtR * 0.5)
        }, nextBtnStyle),
        name: NEXT_STEP_BTN
      });
      container.toBack();
      this.renderSpeedBtn();
      if (!hideTimeTypeController) {
        this.renderToggleTime();
      }
      this.bindEvent();
      var _d = this.controllerCfg.scale, scale3 = _d === void 0 ? 1 : _d;
      var currentBBox = this.controllerGroup.getCanvasBBox();
      var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
      var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
      var matrix = transform9([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -centerX, -centerY], ["s", scale3, scale3], ["t", centerX, centerY]]);
      this.controllerGroup.setMatrix(matrix);
    };
    ControllerBtn2.prototype.renderSpeedBtn = function() {
      var _a2 = this.controllerCfg, y4 = _a2.y, width = _a2.width, hideTimeTypeController = _a2.hideTimeTypeController;
      var speedControllerStyle = __assign7(__assign7({}, DEFAULT_SPEED_CONTROLLER_STYLE), this.controllerCfg.speedControllerStyle || {});
      var _b = speedControllerStyle.scroller, scroller = _b === void 0 ? {} : _b, _c = speedControllerStyle.text, text = _c === void 0 ? {} : _c, _d = speedControllerStyle.pointer, pointer = _d === void 0 ? {} : _d, _e2 = speedControllerStyle.scale, scale3 = _e2 === void 0 ? 1 : _e2, _f = speedControllerStyle.offsetX, offsetX = _f === void 0 ? 0 : _f, _g = speedControllerStyle.offsetY, offsetY = _g === void 0 ? 0 : _g;
      var speedGroup = this.controllerGroup.addGroup({
        name: "speed-group"
      });
      this.speedGroup = speedGroup;
      var speedNum = [];
      var maxSpeed = 5;
      this.speedAxisY = [19, 22, 26, 32, 39];
      for (var i2 = 0; i2 < 5; i2++) {
        var axisY = y4 + this.speedAxisY[i2];
        var startX = width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET);
        speedGroup.addShape("line", {
          attrs: __assign7({
            x1: startX,
            x2: startX + 15,
            y1: axisY,
            y2: axisY
          }, scroller),
          speed: maxSpeed,
          name: "speed-rect"
        });
        this.speedAxisY[i2] = axisY;
        speedNum.push(maxSpeed);
        maxSpeed = maxSpeed - 1;
      }
      this.speedText = speedGroup.addShape("text", {
        attrs: __assign7({
          x: width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET) + 20,
          y: this.speedAxisY[0] + 4,
          text: "1.0X",
          fontFamily: this.fontFamily || "Arial, sans-serif"
        }, text),
        name: "speed-text"
      });
      this.speedPoint = speedGroup.addShape("path", {
        attrs: __assign7({
          path: this.getPointerPath(width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET), 0),
          matrix: [1, 0, 0, 0, 1, 0, 0, this.speedAxisY[4], 1]
        }, pointer),
        name: "speed-pointer"
      });
      var currentBBox = this.speedGroup.getCanvasBBox();
      var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
      var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
      var matrix = this.speedGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      matrix = transform9(matrix, [["t", -centerX, -centerY], ["s", scale3, scale3], ["t", centerX + offsetX * scale3, centerY + offsetY * scale3]]);
      this.speedGroup.setMatrix(matrix);
    };
    ControllerBtn2.prototype.getPointerPath = function(x4, y4) {
      return [["M", x4, y4], ["L", x4 - 10, y4 - 4], ["L", x4 - 10, y4 + 4], ["Z"]];
    };
    ControllerBtn2.prototype.renderToggleTime = function() {
      var _a2, _b;
      var _c = this.controllerCfg, width = _c.width, defaultTimeType = _c.defaultTimeType;
      var timeTypeControllerStyle = __assign7(__assign7({}, DEFAULT_TIMETYPE_CONTROLLER_STYLE), this.controllerCfg.timeTypeControllerStyle || {});
      var _d = timeTypeControllerStyle.scale, scale3 = _d === void 0 ? 1 : _d, _e2 = timeTypeControllerStyle.offsetX, offsetX = _e2 === void 0 ? 0 : _e2, _f = timeTypeControllerStyle.offsetY, offsetY = _f === void 0 ? 0 : _f, _g = timeTypeControllerStyle.box, box = _g === void 0 ? {} : _g, _h = timeTypeControllerStyle.check, check = _h === void 0 ? {} : _h, _j = timeTypeControllerStyle.text, text = _j === void 0 ? {} : _j;
      this.toggleGroup = this.controllerGroup.addGroup({
        name: "toggle-group"
      });
      var isChecked = defaultTimeType === TIME_TYPE.SINGLE;
      this.toggleGroup.addShape("rect", {
        attrs: __assign7({
          x: width - TOGGLE_MODEL_OFFSET,
          y: this.speedAxisY[0] + 3.5
        }, box),
        isChecked,
        name: "toggle-model"
      });
      this.checkedIcon = this.toggleGroup.addShape("path", {
        attrs: __assign7({
          path: [["M", width - TOGGLE_MODEL_OFFSET + 3, this.speedAxisY[1] + 6], ["L", width - TOGGLE_MODEL_OFFSET + 7, this.speedAxisY[1] + 10], ["L", width - TOGGLE_MODEL_OFFSET + 12, this.speedAxisY[1] + 4]]
        }, check),
        capture: false,
        name: "check-icon"
      });
      if (!isChecked)
        this.checkedIcon.hide();
      this.checkedText = this.toggleGroup.addShape("text", {
        attrs: __assign7({
          text: isChecked ? ((_a2 = this.controllerCfg) === null || _a2 === void 0 ? void 0 : _a2.timeRangeControllerText) || "时间范围" : ((_b = this.controllerCfg) === null || _b === void 0 ? void 0 : _b.timePointControllerText) || "单一时间",
          x: width - TOGGLE_MODEL_OFFSET + 15,
          y: this.speedAxisY[0] + 4,
          fontFamily: typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif"
        }, text),
        name: "checked-text"
      });
      var currentBBox = this.toggleGroup.getCanvasBBox();
      var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
      var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
      var matrix = this.toggleGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      matrix = transform9(matrix, [["t", -centerX, -centerY], ["s", scale3, scale3], ["t", centerX + offsetX * scale3, centerY + offsetY * scale3]]);
      this.toggleGroup.setMatrix(matrix);
    };
    ControllerBtn2.prototype.bindEvent = function() {
      var _this = this;
      this.speedGroup.on("speed-rect:click", function(evt) {
        var currentPointerY = evt.target.attr("y1");
        var pointerMatrix = _this.speedPoint.attr("matrix");
        var currentYIdx = _this.speedAxisY.indexOf(pointerMatrix[7] || 0);
        var targetYIdx = _this.speedAxisY.indexOf(currentPointerY);
        var yDiff = _this.speedAxisY[targetYIdx] - _this.speedAxisY[currentYIdx];
        pointerMatrix = transform9(pointerMatrix, [["t", 0, yDiff]]);
        _this.speedPoint.setMatrix(pointerMatrix);
        _this.currentSpeed = _this.speedAxisY.length - targetYIdx;
        _this.speedText.attr("text", "".concat(_this.currentSpeed, ".0X"));
        _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
          speed: _this.currentSpeed,
          type: _this.currentType
        });
      });
      this.speedGroup.on("mousewheel", function(evt) {
        evt.preventDefault();
        var pointerMatrix = _this.speedPoint.attr("matrix") || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        var currentPointerY = pointerMatrix[7];
        var currentYIdx = _this.speedAxisY.indexOf(currentPointerY);
        if (currentYIdx === -1) {
          var minDist_1 = Infinity;
          _this.speedAxisY.forEach(function(y4, idx) {
            var dist = Math.abs(y4 - currentPointerY);
            if (minDist_1 > dist) {
              minDist_1 = dist;
              currentYIdx = idx;
            }
          });
        }
        if (evt.originalEvent.deltaY > 0)
          currentYIdx = Math.max(0, currentYIdx - 1);
        else
          currentYIdx = Math.min(_this.speedAxisY.length - 1, currentYIdx + 1);
        var yDiff = _this.speedAxisY[currentYIdx] - currentPointerY;
        pointerMatrix = transform9(pointerMatrix, [["t", 0, yDiff]]);
        _this.speedPoint.setMatrix(pointerMatrix);
        _this.currentSpeed = _this.speedAxisY.length - currentYIdx;
        _this.speedText.attr("text", "".concat(_this.currentSpeed, ".0X"));
        _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
          speed: _this.currentSpeed,
          type: _this.currentType
        });
      });
      if (this.toggleGroup) {
        this.toggleGroup.on("toggle-model:click", function(evt) {
          var _a2, _b;
          var isChecked = evt.target.get("isChecked");
          if (!isChecked) {
            _this.checkedIcon.show();
            _this.checkedText.attr("text", ((_a2 = _this.controllerCfg) === null || _a2 === void 0 ? void 0 : _a2.timeRangeControllerText) || "时间范围");
            _this.currentType = TIME_TYPE.SINGLE;
          } else {
            _this.checkedIcon.hide();
            _this.checkedText.attr("text", ((_b = _this.controllerCfg) === null || _b === void 0 ? void 0 : _b.timePointControllerText) || "单一时间");
            _this.currentType = TIME_TYPE.RANGE;
          }
          evt.target.set("isChecked", !isChecked);
          _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
            type: _this.currentType,
            speed: _this.currentSpeed
          });
        });
      }
    };
    ControllerBtn2.prototype.destroy = function() {
      this.speedGroup.off("speed-rect:click");
      if (this.toggleGroup) {
        this.toggleGroup.off("toggle-model:click");
        this.toggleGroup.destroy();
      }
      this.speedGroup.destroy();
    };
    return ControllerBtn2;
  }()
);
var controllerBtn_default = ControllerBtn;

// node_modules/@antv/g6-plugin/es/timeBar/trendTimeBar.js
var __assign8 = function() {
  __assign8 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign8.apply(this, arguments);
};
var transform10 = ext_exports.transform;
var BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.05
};
var SIMPLE_BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.15,
  radius: 5
};
var FOREGROUND_STYLE = {
  fill: "#5B8FF9",
  opacity: 0.3,
  cursor: "grab"
};
var DEFAULT_HANDLER_WIDTH = 2;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
var TEXT_STYLE = {
  textBaseline: "middle",
  fill: "#000",
  opacity: 0.45
};
var TICK_LABEL_STYLE = {
  textAlign: "center",
  textBaseline: "top",
  fill: "#607889",
  opacity: 0.35
};
var TICK_LINE_STYLE = {
  lineWidth: 1,
  stroke: "#ccc"
};
var TrendTimeBar = (
  /** @class */
  function() {
    function TrendTimeBar2(cfg) {
      var _this = this;
      this.prevX = 0;
      this.onMouseDown = function(handler) {
        return function(e8) {
          _this.currentHandler = handler;
          var event = e8.originalEvent;
          event.stopPropagation();
          event.preventDefault();
          _this.prevX = get_default(event, "touches.0.pageX", event.pageX);
          var containerDOM = _this.canvas.get("container");
          containerDOM.addEventListener("mousemove", _this.onMouseMove);
          containerDOM.addEventListener("mouseup", _this.onMouseUp);
          containerDOM.addEventListener("mouseleave", _this.onMouseUp);
          containerDOM.addEventListener("touchmove", _this.onMouseMove);
          containerDOM.addEventListener("touchend", _this.onMouseUp);
          containerDOM.addEventListener("touchcancel", _this.onMouseUp);
        };
      };
      this.onMouseMove = function(e8) {
        e8.stopPropagation();
        e8.preventDefault();
        var x5 = get_default(e8, "touches.0.pageX", e8.pageX);
        var offsetX = x5 - _this.prevX;
        var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width);
        _this.updateStartEnd(offsetXRange);
        _this.updateUI();
        _this.prevX = x5;
      };
      this.onMouseUp = function() {
        if (_this.currentHandler) {
          _this.currentHandler = void 0;
        }
        var containerDOM = _this.canvas.get("container");
        if (containerDOM) {
          containerDOM.removeEventListener("mousemove", _this.onMouseMove);
          containerDOM.removeEventListener("mouseup", _this.onMouseUp);
          containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
          containerDOM.removeEventListener("touchmove", _this.onMouseMove);
          containerDOM.removeEventListener("touchend", _this.onMouseUp);
          containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
        }
      };
      var _a2 = cfg.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y4 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 100 : _c, height = cfg.height, _d = cfg.padding, padding = _d === void 0 ? 10 : _d, trendCfg = cfg.trendCfg, _e2 = cfg.controllerCfg, controllerCfg = _e2 === void 0 ? {
        speed: 1
      } : _e2, _f = cfg.backgroundStyle, backgroundStyle = _f === void 0 ? {} : _f, _g = cfg.foregroundStyle, foregroundStyle = _g === void 0 ? {} : _g, _h = cfg.handlerStyle, handlerStyle = _h === void 0 ? {} : _h, _j = cfg.textStyle, textStyle = _j === void 0 ? {} : _j, _k = cfg.start, start = _k === void 0 ? 0 : _k, _l = cfg.end, end2 = _l === void 0 ? 1 : _l, _m = cfg.minText, minText = _m === void 0 ? "" : _m, _o2 = cfg.maxText, maxText = _o2 === void 0 ? "" : _o2, group = cfg.group, graph = cfg.graph, canvas = cfg.canvas, _p = cfg.tick, tick = _p === void 0 ? {
        tickLabelStyle: {},
        tickLineStyle: {},
        tickLabelFormatter: function tickLabelFormatter(d2) {
          return d2;
        },
        ticks: []
      } : _p, type = cfg.type;
      this.graph = graph;
      this.canvas = canvas;
      this.group = group;
      this.timeBarType = type;
      this.x = x4;
      this.y = y4;
      this.width = width;
      this.height = height;
      this.padding = padding;
      this.ticks = tick.ticks;
      this.trendCfg = trendCfg;
      this.controllerCfg = controllerCfg;
      this.currentSpeed = controllerCfg.speed || 1;
      this.tickLabelFormatter = tick.tickLabelFormatter;
      if (type === "trend") {
        this.backgroundStyle = __assign8(__assign8({}, BACKGROUND_STYLE), backgroundStyle);
      } else if (type === "simple") {
        this.backgroundStyle = __assign8(__assign8({}, SIMPLE_BACKGROUND_STYLE), backgroundStyle);
      }
      this.foregroundStyle = __assign8(__assign8({}, FOREGROUND_STYLE), foregroundStyle);
      this.handlerStyle = __assign8(__assign8({}, HANDLER_STYLE), handlerStyle);
      this.textStyle = __assign8(__assign8({}, TEXT_STYLE), textStyle);
      this.tickLabelStyle = __assign8(__assign8({}, TICK_LABEL_STYLE), tick.tickLabelStyle);
      this.tickLineStyle = __assign8(__assign8({}, TICK_LINE_STYLE), tick.tickLineStyle);
      this.currentMode = controllerCfg.defaultTimeType || TIME_TYPE.RANGE;
      this.start = start;
      this.end = end2;
      this.minText = minText;
      this.maxText = maxText;
      this.fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
      this.renderSlider();
    }
    TrendTimeBar2.prototype.update = function(cfg) {
      var x4 = cfg.x, y4 = cfg.y, width = cfg.width, height = cfg.height, minText = cfg.minText, maxText = cfg.maxText, start = cfg.start, end2 = cfg.end;
      this.start = Math.min(1, Math.max(start, 0));
      this.end = Math.min(1, Math.max(end2, 0));
      mix(this, {
        x: x4,
        y: y4,
        width,
        height,
        minText,
        maxText
      });
      this.updateUI();
    };
    TrendTimeBar2.prototype.setText = function(minText, maxText) {
      this.minTextShape.attr("text", minText);
      this.maxTextShape.attr("text", maxText);
    };
    TrendTimeBar2.prototype.renderSlider = function() {
      var _this = this;
      var _a2 = this, width = _a2.width, height = _a2.height, timeBarType = _a2.timeBarType;
      if (timeBarType === "trend" && size(get_default(this.trendCfg, "data"))) {
        var trendComponent = new trend_default(__assign8(__assign8({
          x: this.x,
          y: this.y,
          width,
          height
        }, this.trendCfg), {
          group: this.group
        }));
        this.trendComponent = trendComponent;
      }
      var sliderGroup = this.group.addGroup({
        name: "slider-group"
      });
      sliderGroup.addShape("rect", {
        attrs: __assign8({
          x: 0,
          y: 0,
          width,
          height
        }, this.backgroundStyle),
        name: "background"
      });
      var textGroup = this.group.addGroup();
      if (timeBarType === "trend") {
        this.minTextShape = textGroup.addShape("text", {
          attrs: __assign8({
            x: 0,
            y: height / 2 + this.y,
            textAlign: "right",
            text: this.minText,
            silent: false,
            fontFamily: this.fontFamily || "Arial, sans-serif",
            stroke: "#fff",
            lineWidth: 5
          }, this.textStyle),
          capture: false,
          name: "min-text-shape"
        });
        this.maxTextShape = textGroup.addShape("text", {
          attrs: __assign8({
            y: height / 2 + this.y,
            textAlign: "left",
            text: this.maxText,
            silent: false,
            fontFamily: this.fontFamily || "Arial, sans-serif",
            stroke: "#fff",
            lineWidth: 5
          }, this.textStyle),
          capture: false,
          name: "max-text-shape"
        });
      } else {
        this.minTextShape = textGroup.addShape("text", {
          attrs: __assign8({
            x: 0,
            y: this.y - 10,
            textAlign: "center",
            text: this.minText,
            silent: false,
            fontFamily: this.fontFamily || "Arial, sans-serif",
            stroke: "#fff",
            lineWidth: 5
          }, this.textStyle),
          capture: false,
          name: "min-text-shape"
        });
        this.maxTextShape = textGroup.addShape("text", {
          attrs: __assign8({
            y: this.y - 10,
            textAlign: "center",
            text: this.maxText,
            silent: false,
            fontFamily: this.fontFamily || "Arial, sans-serif",
            stroke: "#fff",
            lineWidth: 5
          }, this.textStyle),
          capture: false,
          name: "max-text-shape"
        });
      }
      this.foregroundShape = this.group.addGroup().addShape("rect", {
        attrs: __assign8({
          x: 0,
          y: this.y,
          height
        }, this.foregroundStyle),
        name: "foreground-shape"
      });
      this.foregroundShape.on("mousedown", function(e8) {
        e8.target.attr("cursor", "grabbing");
      });
      this.foregroundShape.on("mouseup", function(e8) {
        e8.target.attr("cursor", _this.foregroundStyle.cursor || "grab");
      });
      var handlerWidth = get_default(this.handlerStyle, "width", 2);
      var handlerHeight = get_default(this.handlerStyle, "height", 24);
      var minHandleGroup = this.group.addGroup({
        name: "minHandlerShape"
      });
      this.minHandlerShape = new handler_default({
        name: "minHandlerShape",
        group: minHandleGroup,
        type: timeBarType,
        x: this.x,
        y: this.y,
        width: handlerWidth,
        height: handlerHeight,
        style: this.handlerStyle
      });
      var maxHandleGroup = this.group.addGroup({
        name: "maxHandlerShape"
      });
      this.maxHandlerShape = new handler_default({
        name: "maxHandlerShape",
        group: maxHandleGroup,
        type: timeBarType,
        x: this.x,
        y: this.y,
        width: handlerWidth,
        height: handlerHeight,
        style: this.handlerStyle
      });
      var tickData = this.ticks;
      var interval = width / (tickData.length - 1);
      this.tickPosList = [];
      if (this.textList && this.textList.length) {
        this.textList.forEach(function(text) {
          text.destroy();
        });
      }
      var lastX = -Infinity;
      var rotate3 = this.tickLabelStyle.rotate;
      delete this.tickLabelStyle.rotate;
      this.textList = tickData.map(function(data, index2) {
        _this.tickPosList.push(_this.x + index2 * interval);
        var label;
        if (_this.tickLabelFormatter) {
          label = _this.tickLabelFormatter(data);
          if (!is_string_default(label) && label) {
            label = data.date;
          }
        } else {
          label = data.date;
        }
        var textX = _this.x + index2 * interval, textY = _this.y + height + 5;
        var text = _this.group.addShape("text", {
          attrs: __assign8({
            x: textX,
            y: textY,
            text: label,
            fontFamily: _this.fontFamily || "Arial, sans-serif"
          }, _this.tickLabelStyle),
          name: "tick-label"
        });
        if (is_number_default(rotate3) && index2 !== tickData.length - 1) {
          var matrix = transform10([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -textX, -textY], ["r", rotate3], ["t", textX - 5, textY + 2]]);
          text.attr({
            textAlign: "left",
            matrix
          });
        }
        if (index2 === 0) {
          text.attr({
            textAlign: "left"
          });
        } else if (index2 !== tickData.length - 1) {
          text.attr({
            textAlign: "right"
          });
        }
        var line = _this.group.addShape("line", {
          attrs: __assign8({
            x1: _this.x + index2 * interval,
            y1: _this.y + height + 2,
            x2: _this.x + index2 * interval,
            y2: _this.y + height + 6
          }, _this.tickLineStyle),
          name: "tick-line"
        });
        line.toBack();
        var bbox = text.getBBox();
        if (bbox.minX > lastX) {
          text.show();
          line.show();
          lastX = bbox.minX + bbox.width + 10;
        } else {
          text.hide();
          line.hide();
        }
        return text;
      });
      this.controllerBtnGroup = new controllerBtn_default(__assign8({
        group: this.group,
        x: this.x,
        y: this.y + height + 25,
        width,
        height: 35
      }, this.controllerCfg));
      this.updateStartEnd(0);
      this.updateUI();
      sliderGroup.move(this.x, this.y);
      this.bindEvents();
      if (this.currentMode === TIME_TYPE.SINGLE) {
        this.minHandlerShape.hide();
        this.foregroundShape.hide();
        this.minTextShape.hide();
      }
    };
    TrendTimeBar2.prototype.bindEvents = function() {
      var _this = this;
      var minHandleShapeGroup = this.group.find(function(group) {
        return group.get("name") === "minHandlerShape";
      });
      if (minHandleShapeGroup) {
        minHandleShapeGroup.on("minHandlerShape-handler:mousedown", this.onMouseDown(this.minHandlerShape));
        minHandleShapeGroup.on("minHandlerShape-handler:touchstart", this.onMouseDown(this.minHandlerShape));
      }
      var maxHandleShapeGroup = this.group.find(function(group) {
        return group.get("name") === "maxHandlerShape";
      });
      if (maxHandleShapeGroup) {
        maxHandleShapeGroup.on("maxHandlerShape-handler:mousedown", this.onMouseDown(this.maxHandlerShape));
        maxHandleShapeGroup.on("maxHandlerShape-handler:touchstart", this.onMouseDown(this.maxHandlerShape));
      }
      this.foregroundShape.on("mousedown", this.onMouseDown(this.foregroundShape));
      this.foregroundShape.on("touchstart", this.onMouseDown(this.foregroundShape));
      this.group.on("".concat(PLAY_PAUSE_BTN, ":click"), function() {
        _this.isPlay = !_this.isPlay;
        _this.currentHandler = _this.maxHandlerShape;
        _this.changePlayStatus();
      });
      this.group.on("".concat(NEXT_STEP_BTN, ":click"), function() {
        _this.currentHandler = _this.maxHandlerShape;
        _this.updateStartEnd(0.01);
        _this.updateUI();
      });
      this.group.on("".concat(PRE_STEP_BTN, ":click"), function() {
        _this.currentHandler = _this.maxHandlerShape;
        _this.updateStartEnd(-0.01);
        _this.updateUI();
      });
      this.group.on(TIMEBAR_CONFIG_CHANGE, function(_a2) {
        var type = _a2.type, speed = _a2.speed;
        _this.currentSpeed = speed;
        _this.currentMode = type;
        if (type === TIME_TYPE.SINGLE) {
          _this.minHandlerShape.hide();
          _this.foregroundShape.hide();
          _this.minTextShape.hide();
        } else if (type === TIME_TYPE.RANGE) {
          _this.minHandlerShape.show();
          _this.foregroundShape.show();
          _this.minTextShape.show();
        }
      });
    };
    TrendTimeBar2.prototype.adjustTickIndex = function(timeSelectX) {
      for (var i2 = 0; i2 < this.tickPosList.length - 1; i2++) {
        if (this.tickPosList[i2] <= timeSelectX && timeSelectX <= this.tickPosList[i2 + 1]) {
          return Math.abs(this.tickPosList[i2] - timeSelectX) < Math.abs(timeSelectX - this.tickPosList[i2 + 1]) ? i2 : i2 + 1;
        }
      }
      return 0;
    };
    TrendTimeBar2.prototype.adjustOffsetRange = function(offsetRange) {
      switch (this.currentHandler) {
        case this.minHandlerShape: {
          var min3 = 0 - this.start;
          var max4 = 1 - this.start;
          return Math.min(max4, Math.max(min3, offsetRange));
        }
        case this.maxHandlerShape: {
          var min3 = 0 - this.end;
          var max4 = 1 - this.end;
          return Math.min(max4, Math.max(min3, offsetRange));
        }
        case this.foregroundShape: {
          var min3 = 0 - this.start;
          var max4 = 1 - this.end;
          return Math.min(max4, Math.max(min3, offsetRange));
        }
        default:
          return 0;
      }
    };
    TrendTimeBar2.prototype.updateStartEnd = function(offsetRange) {
      var minData = this.ticks[this.adjustTickIndex(this.start * this.width)];
      var maxData = this.ticks[this.adjustTickIndex(this.end * this.width)];
      if (!this.currentHandler) {
        this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData === null || minData === void 0 ? void 0 : minData.date;
        this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData === null || maxData === void 0 ? void 0 : maxData.date;
        return;
      }
      switch (this.currentHandler) {
        case this.minHandlerShape:
          this.maxText = this.maxTextShape.attr("text");
          this.start += offsetRange;
          this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData.date;
          break;
        case this.maxHandlerShape:
          this.minText = this.minTextShape.attr("text");
          this.end += offsetRange;
          this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData.date;
          break;
        case this.foregroundShape:
          this.start += offsetRange;
          this.end += offsetRange;
          this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData.date;
          this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData.date;
          break;
        default:
          break;
      }
    };
    TrendTimeBar2.prototype.updateUI = function() {
      var _this = this;
      if (this.start < 0) {
        this.start = 0;
      }
      if (this.end > 1) {
        this.end = 1;
      }
      var min3 = this.x + this.start * this.width;
      var max4 = this.x + this.end * this.width;
      this.foregroundShape.attr("x", min3);
      this.foregroundShape.attr("width", max4 - min3);
      var handlerWidth = get_default(this.handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      this.setText(this.minText, this.maxText);
      var _a2 = this.dodgeText([min3, max4]), minAttrs = _a2[0], maxAttrs = _a2[1];
      this.minHandlerShape.setX(min3 - handlerWidth / 2);
      each_default(minAttrs, function(v2, k2) {
        return _this.minTextShape.attr(k2, v2);
      });
      this.maxHandlerShape.setX(max4 - handlerWidth / 2);
      each_default(maxAttrs, function(v2, k2) {
        return _this.maxTextShape.attr(k2, v2);
      });
      if (this.currentMode === TIME_TYPE.RANGE) {
        this.graph.emit(VALUE_CHANGE, {
          value: [this.start, this.end].sort()
        });
      } else if (this.currentMode === TIME_TYPE.SINGLE) {
        this.graph.emit(VALUE_CHANGE, {
          value: [this.end, this.end]
        });
      }
    };
    TrendTimeBar2.prototype.dodgeText = function(range) {
      var _a2, _b;
      var TEXTPADDING = 2;
      var handlerWidth = get_default(this.handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var minTextShape = this.minTextShape;
      var maxTextShape = this.maxTextShape;
      var min3 = range[0], max4 = range[1];
      var sorted = false;
      if (min3 > max4) {
        _a2 = [max4, min3], min3 = _a2[0], max4 = _a2[1];
        _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
        sorted = true;
      }
      var minBBox = minTextShape.getBBox();
      var maxBBox = maxTextShape.getBBox();
      var minAttrs = null;
      var maxAttrs = null;
      if (this.timeBarType === "trend") {
        minAttrs = min3 - minBBox.width < this.x + TEXTPADDING ? {
          x: min3 + handlerWidth / 2 + TEXTPADDING,
          textAlign: "left"
        } : {
          x: min3 - handlerWidth / 2 - TEXTPADDING,
          textAlign: "right"
        };
        maxAttrs = max4 + maxBBox.width > this.x + this.width ? {
          x: max4 - handlerWidth / 2 - TEXTPADDING,
          textAlign: "right"
        } : {
          x: max4 + handlerWidth / 2 + TEXTPADDING,
          textAlign: "left"
        };
      } else if (this.timeBarType === "simple") {
        minAttrs = minTextShape.attr("x") > minBBox.width ? {
          x: min3,
          textAlign: "center"
        } : {
          x: min3,
          textAlign: "left"
        };
        maxAttrs = maxTextShape.attr("x") > this.width - maxBBox.width ? {
          x: max4,
          textAlign: "right"
        } : {
          x: max4,
          textAlign: "center"
        };
      }
      return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
    };
    TrendTimeBar2.prototype.startPlay = function() {
      var _this = this;
      return typeof window !== "undefined" ? window.requestAnimationFrame(function() {
        var _a2 = _this, ticks = _a2.ticks, width = _a2.width;
        var speed = _this.currentSpeed;
        var tickInterval = width / ticks.length;
        var offsetX = tickInterval / ((10 - speed) * 1e3 / 60);
        var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width);
        _this.updateStartEnd(offsetXRange);
        _this.updateUI();
        if (_this.isPlay) {
          _this.playHandler = _this.startPlay();
        }
      }) : void 0;
    };
    TrendTimeBar2.prototype.changePlayStatus = function(isSync) {
      if (isSync === void 0) {
        isSync = true;
      }
      this.controllerBtnGroup.playButton.update({
        isPlay: this.isPlay
      });
      if (this.isPlay) {
        this.playHandler = this.startPlay();
        this.graph.emit(TIMELINE_START, null);
      } else {
        if (this.playHandler) {
          if (typeof window !== "undefined")
            window.cancelAnimationFrame(this.playHandler);
          if (isSync) {
            this.graph.emit(TIMELINE_END, null);
          }
        }
      }
    };
    TrendTimeBar2.prototype.destory = function() {
      this.graph.off(VALUE_CHANGE, function() {
      });
      var group = this.group;
      var minHandleShapeGroup = group.find(function(g2) {
        return g2.get("name") === "minHandlerShape";
      });
      if (minHandleShapeGroup) {
        minHandleShapeGroup.off("minHandlerShape-handler:mousedown");
        minHandleShapeGroup.off("minHandlerShape-handler:touchstart");
        minHandleShapeGroup.destroy();
      }
      var maxHandleShapeGroup = group.find(function(g2) {
        return g2.get("name") === "maxHandlerShape";
      });
      if (maxHandleShapeGroup) {
        maxHandleShapeGroup.off("maxHandlerShape-handler:mousedown");
        maxHandleShapeGroup.off("maxHandlerShape-handler:touchstart");
        maxHandleShapeGroup.destroy();
      }
      this.foregroundShape.off("mousedown");
      this.foregroundShape.off("touchstart");
      this.foregroundShape.destroy();
      group.off("".concat(PLAY_PAUSE_BTN, ":click"));
      group.off("".concat(NEXT_STEP_BTN, ":click"));
      group.off("".concat(PRE_STEP_BTN, ":click"));
      group.off(TIMEBAR_CONFIG_CHANGE);
      group.destroy();
      if (this.trendComponent) {
        this.trendComponent.destory();
      }
    };
    return TrendTimeBar2;
  }()
);
var trendTimeBar_default = TrendTimeBar;

// node_modules/@antv/g6-plugin/es/timeBar/timeBarSlice.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/timeBarTooltip.js
init_esm();
var TimeBarTooltip = (
  /** @class */
  function() {
    function TimeBarTooltip2(cfg) {
      var _a2 = cfg.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y4 = _b === void 0 ? 0 : _b, container = cfg.container, text = cfg.text, _c = cfg.padding, padding = _c === void 0 ? [4, 4, 4, 4] : _c, _d = cfg.className, className = _d === void 0 ? "g6-component-timebar-tooltip" : _d, _e2 = cfg.backgroundColor, backgroundColor = _e2 === void 0 ? "#000" : _e2, _f = cfg.textColor, textColor3 = _f === void 0 ? "#fff" : _f, _g = cfg.opacity, opacity = _g === void 0 ? 0.8 : _g, _h = cfg.fontSize, fontSize = _h === void 0 ? 12 : _h;
      this.container = container;
      this.className = className;
      this.backgroundColor = backgroundColor;
      this.textColor = textColor3;
      this.x = x4;
      this.y = y4;
      this.text = text;
      this.padding = padding;
      this.opacity = opacity;
      this.fontSize = fontSize;
      this.render();
    }
    TimeBarTooltip2.prototype.render = function() {
      var self2 = this;
      var className = self2.className, x4 = self2.x, y4 = self2.y, backgroundColor = self2.backgroundColor, textColor3 = self2.textColor, text = self2.text, padding = self2.padding, opacity = self2.opacity, fontSize = self2.fontSize;
      var parentNode = self2.container;
      var container = createDom("<div class='".concat(className, `' style="position: absolute; width: fit-content; height: fit-content; opacity: `).concat(opacity, '"></div>'));
      if (is_string_default(parentNode)) {
        parentNode = document.getElementById(parentNode);
      }
      parentNode.appendChild(container);
      self2.parentHeight = parentNode.offsetHeight;
      self2.parentWidth = parentNode.offsetWidth;
      modifyCSS(container, {
        visibility: "hidden",
        top: 0,
        left: 0
      });
      var background = createDom("\n      <div style='position: absolute; white-space:nowrap; background-color: ".concat(backgroundColor, "; font-size: ").concat(fontSize, "px; border-radius: 4px; width: fit-content; height: fit-content; color: ").concat(textColor3, "; padding: ").concat(padding[0], "px ").concat(padding[1], "px ").concat(padding[2], "px ").concat(padding[3], "px'></div>"));
      background.innerHTML = text;
      container.appendChild(background);
      self2.backgroundDOM = background;
      var arrow = createDom("<div style='position: absolute; width: 0px; height: 0px; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 10px solid ".concat(backgroundColor, "'></div>"));
      container.appendChild(arrow);
      self2.arrowDOM = arrow;
      self2.container = container;
    };
    TimeBarTooltip2.prototype.show = function(cfg) {
      var self2 = this;
      var text = cfg.text, x4 = cfg.x, y4 = cfg.y, clientX = cfg.clientX, clientY = cfg.clientY;
      self2.backgroundDOM.innerHTML = text;
      var backgroundWidth = self2.backgroundDOM.offsetWidth;
      var backgroundHeight = self2.backgroundDOM.offsetHeight;
      var arrowWidth = self2.arrowDOM.offsetWidth;
      var arrowHeight = self2.arrowDOM.offsetHeight;
      modifyCSS(self2.container, {
        top: "".concat(-backgroundHeight - arrowHeight, "px"),
        left: "".concat(x4, "px"),
        visibility: "visible"
      });
      modifyCSS(self2.backgroundDOM, {
        marginLeft: "".concat(-backgroundWidth / 2, "px")
      });
      modifyCSS(self2.arrowDOM, {
        marginLeft: "".concat(-arrowWidth / 2, "px"),
        top: "".concat(backgroundHeight, "px")
      });
      var left = x4 - backgroundWidth / 2;
      var right = x4 + backgroundWidth / 2;
      if (left < 0) {
        modifyCSS(self2.backgroundDOM, {
          marginLeft: "".concat(-backgroundWidth / 2 - left, "px")
        });
      } else if (right > self2.parentWidth) {
        modifyCSS(self2.backgroundDOM, {
          marginLeft: "".concat(-backgroundWidth / 2 - right + self2.parentWidth + 12, "px")
        });
      }
    };
    TimeBarTooltip2.prototype.hide = function() {
      modifyCSS(this.container, {
        top: 0,
        left: 0,
        visibility: "hidden"
      });
    };
    return TimeBarTooltip2;
  }()
);
var timeBarTooltip_default = TimeBarTooltip;

// node_modules/@antv/g6-plugin/es/timeBar/timeBarSlice.js
var __assign9 = function() {
  __assign9 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign9.apply(this, arguments);
};
var transform11 = ext_exports.transform;
var DEFAULT_SELECTEDTICK_STYLE = {
  fill: "#5B8FF9"
};
var DEFAULT_UNSELECTEDTICK_STYLE = {
  fill: "#e6e8e9"
};
var TimeBarSlice = (
  /** @class */
  function() {
    function TimeBarSlice2(cfgs) {
      this.frameCount = 0;
      this.fontFamily = "Arial, sans-serif";
      var graph = cfgs.graph, canvas = cfgs.canvas, group = cfgs.group, width = cfgs.width, height = cfgs.height, padding = cfgs.padding, data = cfgs.data, start = cfgs.start, end2 = cfgs.end, _a2 = cfgs.x, x4 = _a2 === void 0 ? 0 : _a2, _b = cfgs.y, y4 = _b === void 0 ? 0 : _b, tickLabelFormatter = cfgs.tickLabelFormatter, _c = cfgs.selectedTickStyle, selectedTickStyle = _c === void 0 ? DEFAULT_SELECTEDTICK_STYLE : _c, _d = cfgs.unselectedTickStyle, unselectedTickStyle = _d === void 0 ? DEFAULT_UNSELECTEDTICK_STYLE : _d, tooltipBackgroundColor = cfgs.tooltipBackgroundColor, tooltipFomatter = cfgs.tooltipFomatter, tickLabelStyle = cfgs.tickLabelStyle, _e2 = cfgs.controllerCfg, controllerCfg = _e2 === void 0 ? {
        speed: 1
      } : _e2;
      this.graph = graph;
      this.group = group;
      this.sliceGroup = group.addGroup({
        name: "slice-group"
      });
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this.padding = padding;
      this.data = data;
      this.start = start;
      this.end = end2;
      this.tickLabelFormatter = tickLabelFormatter;
      this.tickLabelStyle = tickLabelStyle || {};
      this.selectedTickStyle = selectedTickStyle;
      this.unselectedTickStyle = unselectedTickStyle;
      this.controllerCfg = controllerCfg;
      this.currentSpeed = controllerCfg.speed || 1;
      this.x = x4;
      this.y = y4;
      this.tooltipBackgroundColor = tooltipBackgroundColor;
      this.tooltipFomatter = tooltipFomatter;
      this.fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
      this.renderSlices();
      this.initEvent();
    }
    TimeBarSlice2.prototype.renderSlices = function() {
      var _this = this;
      var _a2 = this, width = _a2.width, height = _a2.height, padding = _a2.padding, data = _a2.data, start = _a2.start, end2 = _a2.end, tickLabelFormatter = _a2.tickLabelFormatter, selectedTickStyle = _a2.selectedTickStyle, unselectedTickStyle = _a2.unselectedTickStyle, tickLabelStyle = _a2.tickLabelStyle;
      var realWidth = width - 2 * padding;
      var fontSize = 10;
      var labelLineHeight = 4;
      var labelAreaHeight = 3 * padding + labelLineHeight + fontSize;
      var ticksAreaHeight = height - labelAreaHeight - 2 * padding;
      var gap = 2;
      var ticksLength = data.length;
      var tickWidth = (realWidth - gap * (ticksLength - 1)) / ticksLength;
      this.tickWidth = tickWidth;
      var sliceGroup = this.sliceGroup;
      var tickRects = [];
      var labels = [];
      var startTickId = Math.round(ticksLength * start);
      var endTickId = Math.round(ticksLength * end2);
      this.startTickRectId = startTickId;
      this.endTickRectId = endTickId;
      var rotate3 = tickLabelStyle.rotate;
      delete tickLabelStyle.rotate;
      data.forEach(function(d2, i2) {
        var selected = i2 >= startTickId && i2 <= endTickId;
        var tickStyle = selected ? selectedTickStyle : unselectedTickStyle;
        var rect2 = sliceGroup.addShape("rect", {
          attrs: __assign9({
            x: padding + i2 * (tickWidth + gap),
            y: padding,
            width: tickWidth,
            height: ticksAreaHeight
          }, tickStyle),
          draggable: true,
          name: "tick-rect-".concat(i2)
        });
        var pickRect = sliceGroup.addShape("rect", {
          attrs: {
            x: padding + i2 * tickWidth + gap * (2 * i2 - 1) / 2,
            y: padding,
            width: i2 === 0 || i2 === ticksLength - 1 ? tickWidth + gap / 2 : tickWidth + gap,
            height: ticksAreaHeight,
            fill: "#fff",
            opacity: 0
          },
          draggable: true,
          name: "pick-rect-".concat(i2)
        });
        pickRect.toFront();
        var rectBBox = rect2.getBBox();
        var centerX = (rectBBox.minX + rectBBox.maxX) / 2;
        tickRects.push({
          rect: rect2,
          pickRect,
          value: d2.date,
          x: centerX,
          y: rectBBox.minY
        });
        var label;
        if (tickLabelFormatter) {
          label = tickLabelFormatter(d2);
          if (!is_string_default(label) && label) {
            label = d2.date;
          }
        } else if (i2 % Math.round(ticksLength / 10) === 0) {
          label = d2.date;
        }
        if (label) {
          labels.push(label);
          var lineStartY = rectBBox.maxY + padding * 2;
          sliceGroup.addShape("line", {
            attrs: {
              stroke: "#BFBFBF",
              x1: centerX,
              y1: lineStartY,
              x2: centerX,
              y2: lineStartY + labelLineHeight
            },
            name: "tick-line"
          });
          var labelStartY = lineStartY + labelLineHeight + padding;
          var text = sliceGroup.addShape("text", {
            attrs: __assign9({
              fill: "#8c8c8c",
              stroke: "#fff",
              lineWidth: 1,
              x: centerX,
              y: labelStartY,
              textAlign: "center",
              text: label,
              textBaseline: "top",
              fontSize: 10,
              fontFamily: _this.fontFamily || "Arial, sans-serif"
            }, tickLabelStyle),
            capture: false,
            name: "tick-label"
          });
          var textBBox = text.getBBox();
          if (textBBox.maxX > width) {
            text.attr("textAlign", "right");
          } else if (textBBox.minX < 0) {
            text.attr("textAlign", "left");
          }
          if (is_number_default(rotate3) && labels.length !== 10) {
            var matrix = transform11([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -centerX, -labelStartY], ["r", rotate3], ["t", centerX - 5, labelStartY + 2]]);
            text.attr({
              textAlign: "left",
              matrix
            });
          }
          if (labels.length === 1) {
            text.attr({
              textAlign: "left"
            });
          } else if (labels.length === 10) {
            text.attr({
              textAlign: "right"
            });
          }
        }
      });
      this.tickRects = tickRects;
      var group = this.group;
      this.currentSpeed = 1;
      this.controllerBtnGroup = new controllerBtn_default(__assign9({
        group,
        x: this.x,
        y: this.y + height + 5,
        width,
        height: 40,
        hideTimeTypeController: true,
        speed: this.currentSpeed,
        fontFamily: this.fontFamily || "Arial, sans-serif"
      }, this.controllerCfg));
    };
    TimeBarSlice2.prototype.initEvent = function() {
      var _this = this;
      var sliceGroup = this.sliceGroup;
      sliceGroup.on("click", function(e8) {
        var targetRect = e8.target;
        if (targetRect.get("type") !== "rect" || !targetRect.get("name"))
          return;
        var id = parseInt(targetRect.get("name").split("-")[2], 10);
        if (!isNaN(id)) {
          var tickRects_1 = _this.tickRects;
          var unselectedTickStyle_1 = _this.unselectedTickStyle;
          tickRects_1.forEach(function(tickRect) {
            tickRect.rect.attr(unselectedTickStyle_1);
          });
          var selectedTickStyle = _this.selectedTickStyle;
          tickRects_1[id].rect.attr(selectedTickStyle);
          _this.startTickRectId = id;
          _this.endTickRectId = id;
          var ticksLength = tickRects_1.length;
          var start = id / ticksLength;
          _this.graph.emit(VALUE_CHANGE, {
            value: [start, start]
          });
        }
      });
      sliceGroup.on("dragstart", function(e8) {
        var tickRects2 = _this.tickRects;
        var unselectedTickStyle = _this.unselectedTickStyle;
        tickRects2.forEach(function(tickRect) {
          tickRect.rect.attr(unselectedTickStyle);
        });
        var targetRect = e8.target;
        var id = parseInt(targetRect.get("name").split("-")[2], 10);
        var selectedTickStyle = _this.selectedTickStyle;
        tickRects2[id].rect.attr(selectedTickStyle);
        _this.startTickRectId = id;
        var ticksLength = tickRects2.length;
        var start = id / ticksLength;
        _this.graph.emit(VALUE_CHANGE, {
          value: [start, start]
        });
        _this.dragging = true;
      });
      sliceGroup.on("dragover", function(e8) {
        if (!_this.dragging)
          return;
        if (e8.target.get("type") !== "rect")
          return;
        var id = parseInt(e8.target.get("name").split("-")[2], 10);
        var startTickRectId = _this.startTickRectId;
        var tickRects2 = _this.tickRects;
        var selectedTickStyle = _this.selectedTickStyle;
        var unselectedTickStyle = _this.unselectedTickStyle;
        for (var i2 = 0; i2 < tickRects2.length; i2++) {
          var style = i2 >= startTickRectId && i2 <= id ? selectedTickStyle : unselectedTickStyle;
          tickRects2[i2].rect.attr(style);
        }
        var ticksLength = tickRects2.length;
        _this.endTickRectId = id;
        var start = startTickRectId / ticksLength;
        var end2 = id / ticksLength;
        _this.graph.emit(VALUE_CHANGE, {
          value: [start, end2]
        });
      });
      sliceGroup.on("drop", function(e8) {
        if (!_this.dragging)
          return;
        _this.dragging = false;
        if (e8.target.get("type") !== "rect")
          return;
        var startTickRectId = _this.startTickRectId;
        var id = parseInt(e8.target.get("name").split("-")[2], 10);
        if (id < startTickRectId)
          return;
        var selectedTickStyle = _this.selectedTickStyle;
        var tickRects2 = _this.tickRects;
        tickRects2[id].rect.attr(selectedTickStyle);
        _this.endTickRectId = id;
        var ticksLength = tickRects2.length;
        var start = startTickRectId / ticksLength;
        var end2 = id / ticksLength;
        _this.graph.emit(VALUE_CHANGE, {
          value: [start, end2]
        });
      });
      var _a2 = this, tooltipBackgroundColor = _a2.tooltipBackgroundColor, tooltipFomatter = _a2.tooltipFomatter, canvas = _a2.canvas;
      var tooltip = new timeBarTooltip_default({
        container: canvas.get("container"),
        backgroundColor: tooltipBackgroundColor
      });
      var tickRects = this.tickRects;
      tickRects.forEach(function(tickRect) {
        var pickRect = tickRect.pickRect;
        pickRect.on("mouseenter", function(e8) {
          var rect2 = e8.target;
          if (rect2.get("type") !== "rect")
            return;
          var id = parseInt(rect2.get("name").split("-")[2], 10);
          var clientPoint = canvas.getClientByPoint(tickRects[id].x, tickRects[id].y);
          tooltip.show({
            x: tickRects[id].x,
            y: tickRects[id].y,
            clientX: clientPoint.x,
            clientY: clientPoint.y,
            text: tooltipFomatter ? tooltipFomatter(tickRects[id].value) : tickRects[id].value
          });
        });
        pickRect.on("mouseleave", function(e8) {
          tooltip.hide();
        });
      });
      var group = this.group;
      group.on("".concat(PLAY_PAUSE_BTN, ":click"), function() {
        _this.isPlay = !_this.isPlay;
        _this.changePlayStatus();
      });
      group.on("".concat(NEXT_STEP_BTN, ":click"), function() {
        _this.updateStartEnd(1);
      });
      group.on("".concat(PRE_STEP_BTN, ":click"), function() {
        _this.updateStartEnd(-1);
      });
      group.on(TIMEBAR_CONFIG_CHANGE, function(_a3) {
        var type = _a3.type, speed = _a3.speed;
        _this.currentSpeed = speed;
      });
    };
    TimeBarSlice2.prototype.changePlayStatus = function(isSync) {
      if (isSync === void 0) {
        isSync = true;
      }
      this.controllerBtnGroup.playButton.update({
        isPlay: this.isPlay
      });
      if (this.isPlay) {
        this.playHandler = this.startPlay();
        this.graph.emit(TIMELINE_START, null);
      } else {
        if (this.playHandler) {
          if (typeof window !== "undefined")
            window.cancelAnimationFrame(this.playHandler);
          if (isSync) {
            this.graph.emit(TIMELINE_END, null);
          }
        }
      }
    };
    TimeBarSlice2.prototype.startPlay = function() {
      var _this = this;
      return typeof window !== "undefined" ? window.requestAnimationFrame(function() {
        var speed = _this.currentSpeed;
        if (_this.frameCount % (60 / speed) === 0) {
          _this.frameCount = 0;
          _this.updateStartEnd(1);
        }
        _this.frameCount++;
        if (_this.isPlay) {
          _this.playHandler = _this.startPlay();
        }
      }) : void 0;
    };
    TimeBarSlice2.prototype.updateStartEnd = function(sign) {
      var self2 = this;
      var tickRects = this.tickRects;
      var ticksLength = tickRects.length;
      var unselectedTickStyle = this.unselectedTickStyle;
      var selectedTickStyle = this.selectedTickStyle;
      var previousEndTickRectId = self2.endTickRectId;
      if (sign > 0) {
        self2.endTickRectId++;
      } else {
        tickRects[self2.endTickRectId].rect.attr(unselectedTickStyle);
        self2.endTickRectId--;
      }
      if (previousEndTickRectId !== self2.startTickRectId) {
        if (self2.endTickRectId < self2.startTickRectId) {
          self2.startTickRectId = self2.endTickRectId;
        }
      } else {
        for (var i2 = self2.startTickRectId; i2 <= self2.endTickRectId - 1; i2++) {
          tickRects[i2].rect.attr(unselectedTickStyle);
        }
        self2.startTickRectId = self2.endTickRectId;
      }
      if (tickRects[self2.endTickRectId]) {
        tickRects[self2.endTickRectId].rect.attr(selectedTickStyle);
        var start = self2.startTickRectId / ticksLength;
        var end2 = self2.endTickRectId / ticksLength;
        this.graph.emit(VALUE_CHANGE, {
          value: [start, end2]
        });
      }
    };
    TimeBarSlice2.prototype.destory = function() {
      var group = this.sliceGroup;
      group.off("click");
      group.off("dragstart");
      group.off("dragover");
      group.off("drop");
      this.tickRects.forEach(function(tickRect) {
        var pickRect = tickRect.pickRect;
        pickRect.off("mouseenter");
        pickRect.off("mouseleave");
      });
      this.tickRects.length = 0;
      group.off("".concat(PLAY_PAUSE_BTN, ":click"));
      group.off("".concat(NEXT_STEP_BTN, ":click"));
      group.off("".concat(PRE_STEP_BTN, ":click"));
      group.off(TIMEBAR_CONFIG_CHANGE);
      this.sliceGroup.destroy();
    };
    return TimeBarSlice2;
  }()
);
var timeBarSlice_default = TimeBarSlice;

// node_modules/@antv/g6-plugin/es/timeBar/index.js
init_esm();
var __extends9 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign10 = function() {
  __assign10 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign10.apply(this, arguments);
};
var __rest2 = function(s2, e8) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var DEFAULT_SIMPLE_HEIGHT = 4;
var DEFAULT_TREND_HEIGHT = 26;
var TimeBar = (
  /** @class */
  function(_super) {
    __extends9(TimeBar3, _super);
    function TimeBar3(config) {
      var _this = _super.call(this, config) || this;
      _this.afterrenderListener = function(e8) {
        return _this.filterData({});
      };
      _this.valueChangeListener = throttle_default(
        function(e8) {
          return _this.filterData(e8);
        },
        // 不可简写，否则 filterData 中 this 指针不对
        200,
        {
          trailing: true,
          leading: true
        }
      );
      _this.changeData = function(e8) {
        var graph = _this.get("graph");
        _this.cacheGraphData = graph.get("data");
        _this.filterData({});
      };
      return _this;
    }
    TimeBar3.prototype.getDefaultCfgs = function() {
      return {
        container: null,
        className: "g6-component-timebar",
        padding: 10,
        type: "trend",
        trend: {
          data: [],
          isArea: false,
          smooth: true
        },
        controllerCfg: {
          speed: 1,
          loop: false
        },
        slider: {
          start: 0.1,
          end: 0.9,
          minText: "min",
          maxText: "max"
        },
        tick: {
          start: 0.1,
          end: 0.9,
          data: []
        },
        textStyle: {},
        filterEdge: false,
        filterItemTypes: ["node"],
        containerCSS: {}
      };
    };
    TimeBar3.prototype.initContainer = function() {
      var graph = this.get("graph");
      var _a2 = this._cfgs, width = _a2.width, height = _a2.height;
      var className = this.get("className") || "g6-component-timebar";
      var container = this.get("container");
      var graphContainer = this.get("graph").get("container");
      var timeBarContainer;
      if (!container) {
        timeBarContainer = createDom("<div class='".concat(className, "'></div>"));
        modifyCSS(timeBarContainer, {
          position: "relative"
        });
      } else {
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        timeBarContainer = container;
      }
      graphContainer.appendChild(timeBarContainer);
      this.set("timeBarContainer", timeBarContainer);
      var canvas;
      var renderer = graph.get("renderer");
      if (renderer === "SVG") {
        canvas = new canvas_default2({
          container: timeBarContainer,
          width,
          height
        });
      } else {
        canvas = new canvas_default({
          container: timeBarContainer,
          width,
          height
        });
      }
      if (this.get("containerCSS"))
        modifyCSS(timeBarContainer, this.get("containerCSS"));
      this.set("canvas", canvas);
    };
    TimeBar3.prototype.init = function() {
      this.initContainer();
      var canvas = this.get("canvas");
      var timeBarGroup = canvas.addGroup({
        name: "timebar-group"
      });
      this.set("timeBarGroup", timeBarGroup);
      this.renderTrend();
      this.initEvent();
      var fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
      this.set("fontFamily", fontFamily);
    };
    TimeBar3.prototype.play = function() {
      this.togglePlay(true);
    };
    TimeBar3.prototype.pause = function() {
      this.togglePlay(false);
    };
    TimeBar3.prototype.togglePlay = function(play) {
      var timebar = this.get("timebar");
      if (!timebar)
        return;
      timebar.isPlay = !!play;
      timebar.changePlayStatus();
    };
    TimeBar3.prototype.renderTrend = function() {
      var _this = this;
      var _a2 = this._cfgs, width = _a2.width, x4 = _a2.x, y4 = _a2.y, padding = _a2.padding, type = _a2.type, trend = _a2.trend, slider = _a2.slider, controllerCfg = _a2.controllerCfg, textStyle = _a2.textStyle, tick = _a2.tick, backgroundStyle = _a2.backgroundStyle, foregroundStyle = _a2.foregroundStyle;
      var data = trend.data, other = __rest2(trend, ["data"]);
      var realWidth = width - 2 * padding;
      var defaultHeight = type === "trend" ? DEFAULT_TREND_HEIGHT : DEFAULT_SIMPLE_HEIGHT;
      var graph = this.get("graph");
      var group = this.get("timeBarGroup");
      var canvas = this.get("canvas");
      var timebar = null;
      if (type === "trend" || type === "simple") {
        var getValue_1 = this.get("getValue");
        timebar = new trendTimeBar_default(__assign10(__assign10({
          graph,
          canvas,
          group,
          type,
          x: x4 + padding,
          y: type === "trend" ? y4 + padding : y4 + padding + 15,
          width: realWidth,
          height: defaultHeight,
          padding,
          backgroundStyle,
          foregroundStyle,
          trendCfg: __assign10(__assign10({}, other), {
            data: data.map(function(d2) {
              return (getValue_1 === null || getValue_1 === void 0 ? void 0 : getValue_1(d2)) || d2.value;
            })
          })
        }, slider), {
          tick: {
            ticks: data,
            tickLabelFormatter: tick.tickLabelFormatter,
            tickLabelStyle: tick.tickLabelStyle,
            tickLineStyle: tick.tickLineStyle
          },
          handlerStyle: __assign10(__assign10({}, slider.handlerStyle), {
            height: slider.height || defaultHeight
          }),
          controllerCfg,
          textStyle
        }));
      } else if (type === "tick") {
        timebar = new timeBarSlice_default(__assign10({
          graph,
          canvas,
          group,
          x: x4 + padding,
          y: y4 + padding,
          width,
          height: 42,
          padding: 2,
          controllerCfg
        }, tick));
      }
      var handleMouseUp = function handleMouseUp2() {
        var timebarInstance = _this.get("timebar");
        timebarInstance.draggingHandler = false;
        if (timebarInstance.isPlay) {
          timebarInstance.isPlay = false;
          timebarInstance.currentHandler = timebarInstance.maxHandlerShape;
          timebarInstance.changePlayStatus();
        }
        document.removeEventListener("mouseup", handleMouseUp2);
      };
      canvas.on("mousedown", function(e8) {
        if (e8.target.get("name") === "maxHandlerShape-handler" || e8.target.get("name") === "minHandlerShape-handler" || e8.target === timebar.foregroundShape) {
          document.addEventListener("mouseup", handleMouseUp);
        }
      });
      this.set("timebar", timebar);
    };
    TimeBar3.prototype.filterData = function(evt) {
      var _a2;
      var value = evt.value;
      if (!value) {
        value = [];
        var type_1 = this._cfgs.type;
        if (!type_1 || type_1 === "trend" || type_1 === "simple") {
          value[0] = this._cfgs.slider.start;
          value[1] = this._cfgs.slider.end;
        } else if (type_1 === "tick") {
          value[0] = this._cfgs.tick.start;
          value[1] = this._cfgs.tick.end;
        }
      }
      var trendData = null;
      var type = this._cfgs.type;
      if (type === "trend" || type === "simple") {
        trendData = this._cfgs.trend.data;
      } else if (type === "tick") {
        trendData = this._cfgs.tick.data;
      }
      if (!trendData || trendData.length === 0) {
        console.warn("请配置 TimeBar 组件的数据");
        return;
      }
      var rangeChange = this.get("rangeChange");
      var graph = this.get("graph");
      var min3 = Math.round(trendData.length * value[0]);
      var max4 = Math.round(trendData.length * value[1]);
      max4 = max4 >= trendData.length ? trendData.length - 1 : max4;
      min3 = min3 >= trendData.length ? trendData.length - 1 : min3;
      var tickLabelFormatter = (_a2 = this._cfgs.tick) === null || _a2 === void 0 ? void 0 : _a2.tickLabelFormatter;
      var minText = tickLabelFormatter ? tickLabelFormatter(trendData[min3]) : trendData[min3].date;
      var maxText = tickLabelFormatter ? tickLabelFormatter(trendData[max4]) : trendData[max4].date;
      if (type !== "tick") {
        var timebar = this.get("timebar");
        timebar.setText(minText, maxText);
      }
      if (rangeChange) {
        rangeChange(graph, minText, maxText);
      } else {
        if (!this.cacheGraphData || this.cacheGraphData.nodes && this.cacheGraphData.nodes.length === 0) {
          this.cacheGraphData = graph.get("data");
        }
        var filterItemTypes = this.get("filterItemTypes");
        var changeData = this.get("changeData");
        var getDate_1 = this.get("getDate");
        var shouldIgnore_1 = this.get("shouldIgnore");
        var minDate_1 = trendData[min3].date, maxDate_1 = trendData[max4].date;
        if (changeData || changeData === void 0) {
          var originNodes = this.cacheGraphData.nodes;
          var originEdges = this.cacheGraphData.edges;
          var currentNodeExistMap_1 = {};
          var currentEdgeExistMap_1 = {};
          graph.getNodes().forEach(function(node) {
            return currentNodeExistMap_1[node.getID()] = true;
          });
          graph.getEdges().forEach(function(edge) {
            return currentEdgeExistMap_1[edge.getID()] = true;
          });
          if (filterItemTypes.includes("node")) {
            originNodes.forEach(function(node) {
              var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(node)) || node.date);
              var hitRange = date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("node", node, {
                min: minDate_1,
                max: maxDate_1
              }));
              var exist = currentNodeExistMap_1[node.id];
              if (exist && !hitRange) {
                graph.removeItem(node.id);
                currentNodeExistMap_1[node.id] = false;
              } else if (!exist && hitRange) {
                graph.addItem("node", node);
                currentNodeExistMap_1[node.id] = true;
              }
            });
            originEdges === null || originEdges === void 0 ? void 0 : originEdges.forEach(function(edge) {
              var shouldShow = currentNodeExistMap_1[edge.source] && currentNodeExistMap_1[edge.target] || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", edge, {
                min: minDate_1,
                max: maxDate_1
              }));
              var exist = !!graph.findById(edge.id);
              if (exist && !shouldShow) {
                graph.removeItem(edge.id);
                currentEdgeExistMap_1[edge.id] = false;
              } else if (!exist && shouldShow) {
                graph.addItem("edge", edge);
                currentEdgeExistMap_1[edge.id] = true;
              } else if (!exist) {
                currentEdgeExistMap_1[edge.id] = false;
              }
            });
          }
          if (this.get("filterEdge") || filterItemTypes.includes("edge")) {
            originEdges === null || originEdges === void 0 ? void 0 : originEdges.filter(function(edge) {
              var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(edge)) || edge.date);
              var hitRange = date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", edge, {
                min: minDate_1,
                max: maxDate_1
              }));
              var endsExist = currentNodeExistMap_1[edge.source] && currentNodeExistMap_1[edge.target];
              var shouldShow = hitRange && endsExist;
              var exist = currentEdgeExistMap_1[edge.id];
              if (exist && !shouldShow) {
                currentEdgeExistMap_1[edge.id] = false;
                graph.removeItem(edge.id);
              } else if (!exist && shouldShow) {
                currentEdgeExistMap_1[edge.id] = true;
                graph.addItem("edge", edge);
              }
            });
          }
        } else {
          if (filterItemTypes.includes("node")) {
            graph.getNodes().forEach(function(node) {
              var model = node.getModel();
              if (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("node", model, {
                min: minDate_1,
                max: maxDate_1
              }))
                return;
              var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(model)) || model.date);
              if (date < minDate_1 || date > maxDate_1) {
                graph.hideItem(node);
              } else {
                graph.showItem(node);
              }
            });
          }
          if (this.get("filterEdge") || filterItemTypes.includes("edge")) {
            graph.getEdges().forEach(function(edge) {
              var model = edge.getModel();
              if (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", model, {
                min: trendData[min3].date,
                max: trendData[max4].date
              }))
                return;
              var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(model)) || model.date);
              if (date < trendData[min3].date || date > trendData[max4].date) {
                graph.hideItem(edge);
              } else {
                var sourceVisible = edge.getSource().isVisible();
                var targetVisible = edge.getTarget().isVisible();
                if (sourceVisible && targetVisible)
                  graph.showItem(edge);
              }
            });
          }
        }
      }
    };
    TimeBar3.prototype.initEvent = function() {
      var graph = this.get("graph");
      graph.on("afterchangedata", this.changeData);
      graph.on("afterrender", this.afterrenderListener);
      graph.on(VALUE_CHANGE, this.valueChangeListener);
    };
    TimeBar3.prototype.destroy = function() {
      var graph = this.get("graph");
      graph.off("afterchangedata", this.changeData);
      graph.off("afterrender", this.afterrenderListener);
      graph.off(VALUE_CHANGE, this.valueChangeListener);
      var timebar = this.get("timebar");
      if (timebar && timebar.destory) {
        timebar.destory();
      }
      _super.prototype.destroy.call(this);
      var timeBarContainer = this.get("timeBarContainer");
      if (timeBarContainer) {
        var container = this.get("container");
        if (!container) {
          container = this.get("graph").get("container");
        }
        if (is_string_default(container)) {
          container = document.getElementById(container);
        }
        container.removeChild(timeBarContainer);
      }
    };
    return TimeBar3;
  }(base_default2)
);
var timeBar_default = TimeBar;

// node_modules/@antv/g6-plugin/es/imageMinimap/index.js
init_esm();
var __extends10 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var applyMatrix3 = util_default.applyMatrix;
function getImgNaturalDimension(img, callback) {
  var nWidth, nHeight;
  if (img.naturalWidth) {
    nWidth = img.naturalWidth;
    nHeight = img.naturalHeight;
  } else {
    var image_1 = new Image();
    image_1.src = img.src;
    image_1.onload = function() {
      if (callback)
        callback(image_1.width, image_1.height);
    };
  }
  return [nWidth, nHeight];
}
var ImageMiniMap = (
  /** @class */
  function(_super) {
    __extends10(ImageMiniMap2, _super);
    function ImageMiniMap2(config) {
      return _super.call(this, config) || this;
    }
    ImageMiniMap2.prototype.getDefaultCfgs = function() {
      return {
        container: null,
        className: "g6-minimap",
        viewportClassName: "g6-minimap-viewport",
        width: 200,
        delegateStyle: {
          fill: "#40a9ff",
          stroke: "#096dd9"
        },
        refresh: true
      };
    };
    ImageMiniMap2.prototype.getEvents = function() {
      return {
        beforepaint: "updateViewport",
        beforeanimate: "disableRefresh",
        afteranimate: "enableRefresh",
        viewportchange: "disableOneRefresh"
      };
    };
    ImageMiniMap2.prototype.disableRefresh = function() {
      this.set("refresh", false);
    };
    ImageMiniMap2.prototype.enableRefresh = function() {
      this.set("refresh", true);
      this.updateCanvas();
    };
    ImageMiniMap2.prototype.disableOneRefresh = function() {
      this.set("viewportChange", true);
    };
    ImageMiniMap2.prototype.initViewport = function() {
      var _this = this;
      var cfgs = this._cfgs;
      var graph = cfgs.graph;
      if (this.destroyed)
        return;
      var containerDOM = this.get("container");
      if (is_string_default(containerDOM)) {
        containerDOM = document.getElementById(containerDOM);
      }
      var viewport = createDom("<div class=".concat(cfgs.viewportClassName, "\n      style='position:absolute;\n        left:0;\n        top:0;\n        box-sizing:border-box;\n        border: 2px solid #1980ff;\n        cursor:move'\n      </div>"));
      var x4 = 0;
      var y4 = 0;
      var dragging = false;
      var left = 0;
      var top = 0;
      var width = 0;
      var height = 0;
      var ratio = 0;
      var zoom = 0;
      containerDOM.addEventListener("mousedown", function(e8) {
        cfgs.refresh = false;
        if (e8.target !== viewport) {
          return;
        }
        var style = viewport.style;
        width = parseInt(style.width, 10);
        height = parseInt(style.height, 10);
        var cWidth = _this.get("width");
        var cHeight = _this.get("height");
        if (width > cWidth || height > cHeight) {
          return;
        }
        zoom = graph.getZoom();
        ratio = _this.get("ratio");
        dragging = true;
        x4 = e8.clientX;
        y4 = e8.clientY;
      }, false);
      containerDOM.addEventListener("mousemove", function(e8) {
        if (!dragging || is_nil_default(e8.clientX) || is_nil_default(e8.clientY)) {
          return;
        }
        var cWidth = _this.get("width");
        var cHeight = _this.get("height");
        var style = viewport.style;
        left = parseInt(style.left, 10);
        top = parseInt(style.top, 10);
        width = parseInt(style.width, 10);
        height = parseInt(style.height, 10);
        var dx = x4 - e8.clientX;
        var dy = y4 - e8.clientY;
        if (left - dx < 0) {
          dx = left;
        } else if (left - dx + width >= cWidth) {
          dx = 0;
        }
        if (top - dy < 0) {
          dy = top;
        } else if (top - dy + height >= cHeight) {
          dy = 0;
        }
        left -= dx;
        top -= dy;
        modifyCSS(viewport, {
          left: "".concat(left, "px"),
          top: "".concat(top, "px")
        });
        graph.translate(dx * zoom / ratio, dy * zoom / ratio);
        x4 = e8.clientX;
        y4 = e8.clientY;
      }, false);
      containerDOM.addEventListener("mouseleave", function() {
        dragging = false;
        cfgs.refresh = true;
      }, false);
      containerDOM.addEventListener("mouseup", function() {
        dragging = false;
        cfgs.refresh = true;
      }, false);
      this.set("viewport", viewport);
      containerDOM.appendChild(viewport);
    };
    ImageMiniMap2.prototype.updateViewport = function() {
      if (this.destroyed)
        return;
      var ratio = this.get("ratio");
      var cWidth = this.get("width");
      var cHeight = this.get("height");
      var graph = this.get("graph");
      var graphWidth = graph.get("width");
      var graphHeight = graph.get("height");
      var aspectRatio = graphWidth / graphHeight;
      var graphGroup = graph.getGroup();
      var graphCanvasBBox = graphGroup.getCanvasBBox();
      var graphCanvasBBoxMean = [(graphCanvasBBox.minX + graphCanvasBBox.maxX) / 2, (graphCanvasBBox.minY + graphCanvasBBox.maxY) / 2];
      var graphCanvasBBoxSize = [graphCanvasBBox.maxX - graphCanvasBBox.minX, graphCanvasBBox.maxY - graphCanvasBBox.minY];
      var expandedGraphCanvasBBox = {
        centerX: graphCanvasBBoxMean[0],
        centerY: graphCanvasBBoxMean[1],
        width: 0,
        height: 0,
        minX: 0,
        minY: 0
      };
      if (graphCanvasBBox[0] / graphCanvasBBox[1] > aspectRatio) {
        expandedGraphCanvasBBox.width = graphCanvasBBoxSize[0];
        expandedGraphCanvasBBox.height = expandedGraphCanvasBBox.width / aspectRatio;
      } else {
        expandedGraphCanvasBBox.height = graphCanvasBBoxSize[1];
        expandedGraphCanvasBBox.width = expandedGraphCanvasBBox.height * aspectRatio;
      }
      expandedGraphCanvasBBox.minX = graphCanvasBBoxMean[0] - expandedGraphCanvasBBox.width / 2;
      expandedGraphCanvasBBox.minY = graphCanvasBBoxMean[1] - expandedGraphCanvasBBox.height / 2;
      var graphMatrix = graphGroup.getMatrix();
      if (!graphMatrix)
        graphMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var invertGraphMatrix = mat3_exports.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], graphMatrix);
      var minXY = applyMatrix3({
        x: expandedGraphCanvasBBox.minX,
        y: expandedGraphCanvasBBox.minY
      }, invertGraphMatrix);
      var topLeft = graph.getCanvasByPoint(minXY.x, minXY.y);
      var viewport = this.get("viewport");
      if (!viewport) {
        this.initViewport();
      }
      var vpToMc = graphWidth / expandedGraphCanvasBBox.width;
      var width = vpToMc * cWidth;
      var height = vpToMc * cHeight;
      var left = cWidth * -topLeft.x / expandedGraphCanvasBBox.width;
      var top = cHeight * -topLeft.y / expandedGraphCanvasBBox.height;
      var right = left + width;
      var bottom = top + height;
      if (left < 0) {
        width += left;
        left = 0;
      }
      if (right > cWidth) {
        width = width - (right - cWidth);
      }
      if (top < 0) {
        height += top;
        top = 0;
      }
      if (bottom > cHeight) {
        height = height - (bottom - cHeight);
      }
      this.set("ratio", ratio);
      var correctLeft = "".concat(left, "px");
      var correctTop = "".concat(top, "px");
      modifyCSS(viewport, {
        left: correctLeft,
        top: correctTop,
        width: "".concat(width, "px"),
        height: "".concat(height, "px")
      });
    };
    ImageMiniMap2.prototype.init = function() {
      this.initContainer();
    };
    ImageMiniMap2.prototype.initContainer = function() {
      var self2 = this;
      var graph = self2.get("graph");
      var graphWidth = graph.get("width");
      var graphHeight = graph.get("height");
      var aspectRatio = graphHeight / graphWidth;
      var className = self2.get("className");
      var parentNode = self2.get("container");
      var cWidth = self2.get("width");
      var cHeight = self2.get("height");
      if (!cWidth && !cHeight) {
        cWidth = 200;
      }
      if (cWidth) {
        cHeight = aspectRatio * cWidth;
        self2.set("height", cHeight);
      } else {
        cWidth = 1 / aspectRatio * cHeight;
        self2.set("width", cWidth);
      }
      var container = createDom("<div class='".concat(className, "' style='width: ").concat(cWidth, "px; height: ").concat(cHeight, "px; overflow: hidden; position: relative;'></div>"));
      if (is_string_default(parentNode)) {
        parentNode = document.getElementById(parentNode);
      }
      if (parentNode) {
        parentNode.appendChild(container);
      } else {
        graph.get("container").appendChild(container);
      }
      self2.set("container", container);
      var containerDOM = createDom('<div class="g6-minimap-container" style="position: relative; width: 100%; height: 100%; text-align: center; display: table;"></div>');
      container.appendChild(containerDOM);
      var span = createDom('<span style="display: table-cell; vertical-align: middle; "></span>');
      containerDOM.appendChild(span);
      self2.set("containerDOM", containerDOM);
      self2.set("containerSpan", span);
      var img = createDom('<img alt="" src="'.concat(this.get("graphImg"), '" style="display: inline-block; user-select: none;" draggable="false" />'));
      self2.set("imgDOM", img);
      self2.updateImgSize();
      span.appendChild(img);
      self2.updateCanvas();
    };
    ImageMiniMap2.prototype.updateImgSize = function() {
      var self2 = this;
      var imgDOM = self2.get("imgDOM");
      var cWidth = self2.get("width");
      var cHeight = self2.get("height");
      imgDOM.onload = function() {
        var naturalSize = getImgNaturalDimension(imgDOM);
        if (naturalSize[0] > naturalSize[1]) {
          imgDOM.width = cWidth;
        } else {
          imgDOM.height = cHeight;
        }
      };
    };
    ImageMiniMap2.prototype.updateCanvas = function() {
      var isRefresh = this.get("refresh");
      if (!isRefresh) {
        return;
      }
      var graph = this.get("graph");
      if (graph.get("destroyed")) {
        return;
      }
      if (this.get("viewportChange")) {
        this.set("viewportChange", false);
        this.updateViewport();
      }
      var cWidth = this.get("width");
      var graphBBox = graph.get("canvas").getCanvasBBox();
      var width = graphBBox.width;
      var ratio = cWidth / width;
      this.set("ratio", ratio);
      this.updateViewport();
    };
    ImageMiniMap2.prototype.getViewport = function() {
      return this.get("viewport");
    };
    ImageMiniMap2.prototype.getContainer = function() {
      return this.get("container");
    };
    ImageMiniMap2.prototype.updateGraphImg = function(img) {
      var self2 = this;
      var oriImgDOM = self2.get("imgDOM");
      oriImgDOM.remove();
      self2.set("graphImg", img);
      var imgDOM = createDom('<img alt="" src="'.concat(img, '" style="display: inline-block;" ondragstart="return false;" onselectstart="return false;"/>'));
      self2.set("imgDOM", imgDOM);
      imgDOM.src = img;
      self2.updateImgSize();
      var span = self2.get("containerSpan");
      span.appendChild(imgDOM);
      self2.updateCanvas();
    };
    ImageMiniMap2.prototype.destroy = function() {
      var container = this.get("container");
      container.parentNode.removeChild(container);
    };
    return ImageMiniMap2;
  }(base_default2)
);
var imageMinimap_default = ImageMiniMap;

// node_modules/@antv/g6-plugin/es/edgeFilterLens/index.js
init_esm();
var __extends11 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign11 = function() {
  __assign11 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign11.apply(this, arguments);
};
var distance3 = util_default.distance;
var DELTA3 = 0.05;
var lensDelegateStyle2 = {
  stroke: "#000",
  strokeOpacity: 0.8,
  lineWidth: 2,
  fillOpacity: 1,
  fill: "#fff"
};
var EdgeFilterLens = (
  /** @class */
  function(_super) {
    __extends11(EdgeFilterLens3, _super);
    function EdgeFilterLens3(config) {
      return _super.call(this, config) || this;
    }
    EdgeFilterLens3.prototype.getDefaultCfgs = function() {
      return {
        type: "both",
        trigger: "mousemove",
        r: 60,
        delegateStyle: clone_default(lensDelegateStyle2),
        showLabel: "edge",
        scaleRBy: "wheel"
      };
    };
    EdgeFilterLens3.prototype.getEvents = function() {
      var events;
      switch (this.get("trigger")) {
        case "click":
          events = {
            click: "filter"
          };
          break;
        case "drag":
          events = {
            click: "createDelegate"
          };
          break;
        default:
          events = {
            mousemove: "filter"
          };
          break;
      }
      return events;
    };
    EdgeFilterLens3.prototype.init = function() {
      var self2 = this;
      var showLabel = self2.get("showLabel");
      var showNodeLabel = showLabel === "node" || showLabel === "both";
      var showEdgeLabel = showLabel === "edge" || showLabel === "both";
      self2.set("showNodeLabel", showNodeLabel);
      self2.set("showEdgeLabel", showEdgeLabel);
      var shouldShow = self2.get("shouldShow");
      if (!shouldShow)
        self2.set("shouldShow", function() {
          return true;
        });
    };
    EdgeFilterLens3.prototype.createDelegate = function(e8) {
      var self2 = this;
      var lensDelegate = self2.get("delegate");
      if (!lensDelegate || lensDelegate.destroyed) {
        self2.filter(e8);
        lensDelegate = self2.get("delegate");
        lensDelegate.on("dragstart", function(evt) {
        });
        lensDelegate.on("drag", function(evt) {
          self2.filter(evt);
        });
        if (this.get("scaleRBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            self2.scaleRByWheel(evt);
          });
        }
      }
    };
    EdgeFilterLens3.prototype.scaleRByWheel = function(e8) {
      var self2 = this;
      if (!e8 || !e8.originalEvent)
        return;
      if (e8.preventDefault)
        e8.preventDefault();
      var graph = self2.get("graph");
      var ratio;
      var lensDelegate = self2.get("delegate");
      var lensCenter = lensDelegate ? {
        x: lensDelegate.attr("x"),
        y: lensDelegate.attr("y")
      } : void 0;
      var mousePos = lensCenter || graph.getPointByClient(e8.clientX, e8.clientY);
      if (e8.originalEvent.wheelDelta < 0) {
        ratio = 1 - DELTA3;
      } else {
        ratio = 1 / (1 - DELTA3);
      }
      var maxR = self2.get("maxR");
      var minR = self2.get("minR");
      var r2 = self2.get("r");
      if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
        ratio = 1;
      }
      r2 *= ratio;
      self2.set("r", r2);
      self2.filter(e8);
    };
    EdgeFilterLens3.prototype.filter = function(e8) {
      var self2 = this;
      var graph = self2.get("graph");
      var nodes = graph.getNodes();
      var hitNodesMap = {};
      var r2 = self2.get("r");
      var type = self2.get("type");
      var fCenter = {
        x: e8.x,
        y: e8.y
      };
      self2.updateDelegate(fCenter, r2);
      var shouldShow = self2.get("shouldShow");
      var vShapes = self2.get("vShapes");
      if (vShapes) {
        vShapes.forEach(function(shape) {
          shape.remove();
          shape.destroy();
        });
      }
      vShapes = [];
      nodes.forEach(function(node) {
        var model = node.getModel();
        var x4 = model.x, y4 = model.y;
        if (distance3({
          x: x4,
          y: y4
        }, fCenter) < r2) {
          hitNodesMap[model.id] = node;
        }
      });
      var edges = graph.getEdges();
      var hitEdges = [];
      edges.forEach(function(edge) {
        var model = edge.getModel();
        var sourceId = model.source;
        var targetId = model.target;
        if (shouldShow(model)) {
          if (type === "only-source" || type === "one") {
            if (hitNodesMap[sourceId] && !hitNodesMap[targetId])
              hitEdges.push(edge);
          } else if (type === "only-target" || type === "one") {
            if (hitNodesMap[targetId] && !hitNodesMap[sourceId])
              hitEdges.push(edge);
          } else if (type === "both" && hitNodesMap[sourceId] && hitNodesMap[targetId]) {
            hitEdges.push(edge);
          }
        }
      });
      var showNodeLabel = self2.get("showNodeLabel");
      var showEdgeLabel = self2.get("showEdgelabel");
      var group = graph.get("group");
      hitEdges.forEach(function(edge) {
        var shapes = edge.get("group").get("children");
        shapes.forEach(function(shape) {
          var shapeType = shape.get("type");
          var vShape = group.addShape(shapeType, {
            attrs: shape.attr()
          });
          vShapes.push(vShape);
          if (showNodeLabel && shapeType === "text") {
            vShape.set("visible", true);
          }
        });
      });
      Object.keys(hitNodesMap).forEach(function(key) {
        var node = hitNodesMap[key];
        var clonedGroup = node.get("group").clone();
        group.add(clonedGroup);
        vShapes.push(clonedGroup);
        if (showEdgeLabel) {
          var shapes = clonedGroup.get("children");
          for (var j2 = 0; j2 < shapes.length; j2++) {
            var shape = shapes[j2];
            if (shape.get("type") === "text") {
              shape.set("visible", true);
            }
          }
        }
      });
      self2.set("vShapes", vShapes);
    };
    EdgeFilterLens3.prototype.updateParams = function(cfg) {
      var self2 = this;
      var r2 = cfg.r, trigger = cfg.trigger, minR = cfg.minR, maxR = cfg.maxR, scaleRBy = cfg.scaleRBy, showLabel = cfg.showLabel, shouldShow = cfg.shouldShow;
      if (!isNaN(cfg.r)) {
        self2.set("r", r2);
      }
      if (!isNaN(maxR)) {
        self2.set("maxR", maxR);
      }
      if (!isNaN(minR)) {
        self2.set("minR", minR);
      }
      if (trigger === "mousemove" || trigger === "click") {
        self2.set("trigger", trigger);
      }
      if (scaleRBy === "wheel" || scaleRBy === "unset") {
        self2.set("scaleRBy", scaleRBy);
        self2.get("delegate").remove();
        self2.get("delegate").destroy();
        var dPercentText = self2.get("dPercentText");
        if (dPercentText) {
          dPercentText.remove();
          dPercentText.destroy();
        }
      }
      if (showLabel === "node" || showLabel === "both") {
        self2.set("showNodeLabel", true);
      }
      if (showLabel === "edge" || showLabel === "both") {
        self2.set("showEdgeLabel", true);
      }
      if (shouldShow) {
        self2.set("shouldShow", shouldShow);
      }
    };
    EdgeFilterLens3.prototype.updateDelegate = function(mCenter, r2) {
      var self2 = this;
      var graph = self2.get("graph");
      var lensDelegate = self2.get("delegate");
      if (!lensDelegate || lensDelegate.destroyed) {
        var parent_1 = graph.get("group");
        var attrs = self2.get("delegateStyle") || lensDelegateStyle2;
        lensDelegate = parent_1.addShape("circle", {
          attrs: __assign11({
            r: r2,
            x: mCenter.x,
            y: mCenter.y
          }, attrs),
          name: "lens-shape",
          draggable: true
        });
        if (this.get("trigger") !== "drag") {
          if (this.get("scaleRBy") === "wheel") {
            lensDelegate.on("mousewheel", function(evt) {
              self2.scaleRByWheel(evt);
            });
          }
        }
      } else {
        lensDelegate.attr({
          x: mCenter.x,
          y: mCenter.y,
          r: r2
        });
      }
      self2.set("delegate", lensDelegate);
    };
    EdgeFilterLens3.prototype.clear = function() {
      var self2 = this;
      var vShapes = self2.get("vShapes");
      if (vShapes) {
        vShapes.forEach(function(shape) {
          shape.remove();
          shape.destroy();
        });
      }
      vShapes = [];
      self2.set("vShapes", vShapes);
      var lensDelegate = self2.get("delegate");
      if (lensDelegate && !lensDelegate.destroyed) {
        lensDelegate.remove();
        lensDelegate.destroy();
      }
    };
    EdgeFilterLens3.prototype.destroy = function() {
      this.clear();
    };
    return EdgeFilterLens3;
  }(base_default2)
);
var edgeFilterLens_default = EdgeFilterLens;

// node_modules/@antv/g6-plugin/es/snapline/index.js
init_esm();
var __extends12 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var pointLineDistance3 = util_default.pointLineDistance;
var alignLineStyle = {
  stroke: "#FA8C16",
  lineWidth: 1
};
var SnapLine = (
  /** @class */
  function(_super) {
    __extends12(SnapLine3, _super);
    function SnapLine3(props) {
      return _super.call(this, props) || this;
    }
    SnapLine3.prototype.getDefaultCfgs = function() {
      return {
        line: alignLineStyle,
        /**
         * item align type
         * @type {String|True|False}
         */
        itemAlignType: "center",
        /**
         * tolerance to item force align
         * @type {String|True|False}
         */
        tolerance: 5,
        horizontalLines: {},
        verticalLines: {},
        alignLines: []
      };
    };
    SnapLine3.prototype.init = function() {
    };
    SnapLine3.prototype.getEvents = function() {
      return {
        "node:dragstart": "onDragStart",
        "node:drag": "onDrag",
        "node:dragend": "onDragEnd"
      };
    };
    SnapLine3.prototype.onDragStart = function() {
      this.initBoxLine();
    };
    SnapLine3.prototype.onDrag = function(e8) {
      var item = e8.item;
      var delegateShape = item.get("delegateShape") || item;
      var bbox = delegateShape.getBBox();
      var model = item.getModel();
      var dx = model.x - bbox.x;
      var dy = model.y - bbox.y;
      this.show({
        x: bbox.minX + dx,
        y: bbox.minY + dy
      }, {
        width: bbox.width,
        height: bbox.height
      });
    };
    SnapLine3.prototype.onDragEnd = function() {
      this.destory();
    };
    SnapLine3.prototype.initBoxLine = function() {
      var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines, itemAlignType = _a2.itemAlignType;
      var graph = this.get("graph");
      var nodes = graph.getNodes();
      nodes.forEach(function(item) {
        var bbox = item.getBBox();
        var nodeId = item.get("id");
        if (itemAlignType === true || itemAlignType === "horizontal") {
          horizontalLines["".concat(nodeId, "tltr")] = [bbox.minX, bbox.minY, bbox.maxX, bbox.minY, item];
          horizontalLines["".concat(nodeId, "lcrc")] = [bbox.minX, bbox.centerY, bbox.maxX, bbox.centerY, item];
          horizontalLines["".concat(nodeId, "blbr")] = [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY, item];
        } else if (itemAlignType === "center") {
          horizontalLines["".concat(nodeId, "lcrc")] = [bbox.minX, bbox.centerY, bbox.maxX, bbox.centerY, item];
        }
        if (itemAlignType === true || itemAlignType === "vertical") {
          verticalLines["".concat(nodeId, "tlbl")] = [bbox.minX, bbox.minY, bbox.minX, bbox.maxY, item];
          verticalLines["".concat(nodeId, "tcbc")] = [bbox.centerX, bbox.minY, bbox.centerX, bbox.maxY, item];
          verticalLines["".concat(nodeId, "trbr")] = [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY, item];
        } else if (itemAlignType === "center") {
          verticalLines["".concat(nodeId, "tcbc")] = [bbox.centerX, bbox.minY, bbox.centerX, bbox.maxY, item];
        }
      });
    };
    SnapLine3.prototype.show = function(point, bbox) {
      var originPoint = mix({}, point);
      this.itemAlign(point, bbox, originPoint);
      return point;
    };
    SnapLine3.prototype.itemAlign = function(point, bbox, originPoint) {
      var _this = this;
      var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines, tolerance2 = _a2.tolerance;
      var tc2 = {
        x: originPoint.x + bbox.width / 2,
        y: originPoint.y
      };
      var cc2 = {
        x: originPoint.x + bbox.width / 2,
        y: originPoint.y + bbox.height / 2
      };
      var bc = {
        x: originPoint.x + bbox.width / 2,
        y: originPoint.y + bbox.height
      };
      var lc = {
        x: originPoint.x,
        y: originPoint.y + bbox.height / 2
      };
      var rc2 = {
        x: originPoint.x + bbox.width,
        y: originPoint.y + bbox.height / 2
      };
      var horizontalDis = [];
      var verticalDis = [];
      var alignCfg = null;
      this.clearAlignLine();
      each_default(horizontalLines, function(line) {
        if (line[4].isVisible) {
          horizontalDis.push(_this.getLineDisObject(line, tc2));
          horizontalDis.push(_this.getLineDisObject(line, cc2));
          horizontalDis.push(_this.getLineDisObject(line, bc));
        }
      });
      each_default(verticalLines, function(line) {
        if (line[4].isVisible) {
          verticalDis.push(_this.getLineDisObject(line, lc));
          verticalDis.push(_this.getLineDisObject(line, cc2));
          verticalDis.push(_this.getLineDisObject(line, rc2));
        }
      });
      horizontalDis.sort(function(a3, b2) {
        return a3.dis - b2.dis;
      });
      verticalDis.sort(function(a3, b2) {
        return a3.dis - b2.dis;
      });
      if (horizontalDis.length !== 0 && horizontalDis[0].dis < tolerance2) {
        point.y = horizontalDis[0].line[1] - horizontalDis[0].point.y + originPoint.y;
        alignCfg = {
          type: "item",
          horizontals: [horizontalDis[0]]
        };
        for (var i2 = 1; i2 < 3; i2++) {
          if (horizontalDis[0].dis === horizontalDis[i2].dis) {
            alignCfg.horizontals.push(horizontalDis[i2]);
          }
        }
      }
      if (verticalDis.length !== 0 && verticalDis[0].dis < tolerance2) {
        point.x = verticalDis[0].line[0] - verticalDis[0].point.x + originPoint.x;
        if (!alignCfg) {
          alignCfg = {
            type: "item",
            verticals: [verticalDis[0]]
          };
        } else {
          alignCfg.verticals = [verticalDis[0]];
        }
        for (var i2 = 1; i2 < 3; i2++) {
          if (verticalDis[0].dis === verticalDis[i2].dis) {
            alignCfg.verticals.push(verticalDis[i2]);
          }
        }
      }
      if (alignCfg) {
        alignCfg.bbox = bbox;
        this.addAlignLine(alignCfg);
      }
    };
    SnapLine3.prototype.addAlignLine = function(cfg) {
      var bbox = cfg.bbox, type = cfg.type, horizontals = cfg.horizontals, verticals = cfg.verticals;
      var _a2 = this._cfgs, lineStyle = _a2.line, alignLines = _a2.alignLines;
      var graph = this.get("graph");
      var group = graph.get("group");
      if (type === "item") {
        if (horizontals) {
          each_default(horizontals, function(horizontal) {
            var refLine = horizontal.line, refPoint = horizontal.point;
            var lineCenterX = (refLine[0] + refLine[2]) / 2;
            var x1;
            var x22;
            if (refPoint.x < lineCenterX) {
              x1 = refPoint.x - bbox.width / 2;
              x22 = Math.max(refLine[0], refLine[2]);
            } else {
              x1 = refPoint.x + bbox.width / 2;
              x22 = Math.min(refLine[0], refLine[2]);
            }
            var lineAttrs = mix({
              x1,
              y1: refLine[1],
              x2: x22,
              y2: refLine[1]
            }, lineStyle);
            var line = group.addShape("line", {
              attrs: lineAttrs,
              capture: false
            });
            alignLines.push(line);
          });
        }
        if (verticals) {
          each_default(verticals, function(vertical2) {
            var refLine = vertical2.line, refPoint = vertical2.point;
            var lineCenterY = (refLine[1] + refLine[3]) / 2;
            var y1;
            var y22;
            if (refPoint.y < lineCenterY) {
              y1 = refPoint.y - bbox.height / 2;
              y22 = Math.max(refLine[1], refLine[3]);
            } else {
              y1 = refPoint.y + bbox.height / 2;
              y22 = Math.min(refLine[1], refLine[3]);
            }
            var lineAtts = mix({
              x1: refLine[0],
              y1,
              x2: refLine[0],
              y2: y22
            }, lineStyle);
            var line = group.addShape("line", {
              attrs: lineAtts,
              capture: false
            });
            alignLines.push(line);
          });
        }
      }
    };
    SnapLine3.prototype.getLineDisObject = function(line, point) {
      return {
        line,
        point,
        dis: pointLineDistance3(line, point)
      };
    };
    SnapLine3.prototype.getContainer = function() {
      return this.get("container");
    };
    SnapLine3.prototype.clearAlignLine = function() {
      var alignLines = this._cfgs.alignLines;
      each_default(alignLines, function(line) {
        line.remove();
      });
      alignLines.length = 0;
    };
    SnapLine3.prototype.destory = function() {
      var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines;
      var graph = this.get("graph");
      var nodes = graph.getNodes();
      nodes.forEach(function(node) {
        var itemId = node.get("id");
        delete horizontalLines["".concat(itemId, "tltr")];
        delete horizontalLines["".concat(itemId, "lcrc")];
        delete horizontalLines["".concat(itemId, "blbr")];
        delete verticalLines["".concat(itemId, "tlbl")];
        delete verticalLines["".concat(itemId, "tcbc")];
        delete verticalLines["".concat(itemId, "trbr")];
      });
      this.clearAlignLine();
    };
    return SnapLine3;
  }(base_default2)
);
var snapline_default = SnapLine;

// node_modules/@antv/g6-plugin/es/legend/index.js
init_esm();
var __extends13 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign12 = function() {
  __assign12 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign12.apply(this, arguments);
};
var ALLOW_EVENTS = ["click", "mouseenter"];
var Legend = (
  /** @class */
  function(_super) {
    __extends13(Legend3, _super);
    function Legend3(config) {
      return _super.call(this, config) || this;
    }
    Legend3.prototype.getDefaultCfgs = function() {
      return {
        data: {},
        position: "top",
        padding: 8,
        margin: 8,
        offsetX: 0,
        offsetY: 0,
        layout: "horizontal",
        flipPage: false,
        containerStyle: {},
        align: void 0,
        horiSep: 8,
        vertiSep: 8,
        filter: {
          enable: false,
          trigger: "click"
        }
      };
    };
    Legend3.prototype.init = function() {
      this.formatArray("padding");
      this.formatArray("margin");
      var filter2 = this.get("filter") || {};
      var multiple = filter2.multiple;
      if (multiple && filter2.trigger === "mouseenter")
        this.set("multiple", false);
      var align = this.get("align");
      if (!align) {
        var positions = this.get("position").split("-");
        if (positions.includes("left"))
          align = "left";
        if (positions.includes("right"))
          align = "right";
        else
          align = "center";
        this.set("align", align);
      }
      var graph = this.get("graph");
      var graphContainer = graph.get("container");
      var container = createDom(`<div class='g6-legend-container' style="position: absolute;"></div>`);
      graphContainer.appendChild(container);
      this.set("container", container);
      var size3 = this.render();
      modifyCSS(container, this.getContainerPos(size3));
      this.bindEvents();
    };
    Legend3.prototype.getContainerPos = function(size3) {
      if (size3 === void 0) {
        size3 = [0, 0];
      }
      var self2 = this;
      var graph = self2.get("graph");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      var margin = this.get("margin");
      var positions = this.get("position").split("-");
      var posIdxMap = {
        "top": 0,
        "right": 1,
        "bottom": 2,
        "left": 3
      };
      var x4 = 0, y4 = 0;
      var containerCSS = {
        left: (graph.getWidth() - size3[0]) / 2 + x4,
        top: (graph.getHeight() - size3[1]) / 2 + y4
      };
      positions.forEach(function(pos) {
        var marginValue = margin[posIdxMap[pos]];
        var key = pos;
        switch (pos) {
          case "top":
            marginValue += y4;
            break;
          case "left":
            marginValue += x4;
            break;
          case "bottom":
            marginValue = graph.getHeight() - size3[1] - marginValue + y4;
            key = "top";
            break;
          default:
            marginValue = graph.getWidth() - size3[0] - marginValue + x4;
            key = "left";
            break;
        }
        containerCSS[key] = marginValue;
      });
      containerCSS.top += offsetY + graph.getContainer().offsetTop;
      containerCSS.left += offsetX + graph.getContainer().offsetLeft;
      Object.keys(containerCSS).forEach(function(key) {
        containerCSS[key] = "".concat(containerCSS[key], "px");
      });
      return containerCSS;
    };
    Legend3.prototype.bindEvents = function() {
      var self2 = this;
      var filter2 = self2.get("filter");
      if (!filter2 || !filter2.enable)
        return;
      var trigger = filter2.trigger || "click";
      if (!ALLOW_EVENTS.includes(trigger)) {
        console.warn("Trigger for legend filterling must be 'click' or 'mouseenter', 'click' will take effect by default.");
        trigger = "click";
      }
      var lc = self2.get("legendCanvas");
      if (trigger === "mouseenter") {
        lc.on("node-container:mouseenter", function(e8) {
          return self2.filterData(e8);
        });
        lc.on("node-container:mouseleave", function(e8) {
          self2.clearFilter();
          self2.clearActiveLegend();
        });
      } else {
        lc.on("node-container:click", function(e8) {
          return self2.filterData(e8);
        });
        lc.on("click", function(e8) {
          if (e8.target && e8.target.isCanvas && e8.target.isCanvas()) {
            self2.clearFilter();
            self2.clearActiveLegend();
          }
        });
      }
    };
    Legend3.prototype.changeData = function(data) {
      this.set("data", data);
      var size3 = this.render();
      modifyCSS(this.get("container"), this.getContainerPos(size3));
    };
    Legend3.prototype.activateLegend = function(shape) {
      var filter2 = this.get("filter");
      var multiple = filter2 === null || filter2 === void 0 ? void 0 : filter2.multiple;
      if (!multiple)
        this.clearActiveLegend();
      var shapeGroup = shape.get("parent");
      if (shapeGroup.get("active")) {
        shapeGroup.set("active", false);
        if (this.findLegendItemsByState("active").length)
          shapeGroup.set("inactive", true);
      } else {
        shapeGroup.set("inactive", false);
        shapeGroup.set("active", true);
      }
      if (this.findLegendItemsByState("active").length) {
        this.findLegendItemsByState("active", "all", false).forEach(function(subGroup) {
          subGroup.set("inactive", true);
        });
      } else {
        this.clearActiveLegend();
      }
      var stateStyles = (filter2 === null || filter2 === void 0 ? void 0 : filter2.legendStateStyles) || {};
      var legendInactive = (stateStyles === null || stateStyles === void 0 ? void 0 : stateStyles.inactive) || {
        opacity: 0.5,
        "text-shape": {
          opacity: 0.5
        }
      };
      var legendTextInactive = legendInactive["text-shape"] || {};
      this.findLegendItemsByState("inactive").forEach(function(subGroup) {
        var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
        keyShape.attr(__assign12(__assign12({}, keyShape.get("oriAttrs")), legendInactive));
        text.attr(__assign12(__assign12({}, text.get("oriAttrs")), legendTextInactive));
      });
      var legendActive = (stateStyles === null || stateStyles === void 0 ? void 0 : stateStyles.active) || {
        stroke: "#000",
        lineWidth: 2,
        "text-shape": {
          fontWeight: "bold"
        }
      };
      var legendTextActive = legendActive["text-shape"] || {};
      this.findLegendItemsByState("active").forEach(function(subGroup) {
        var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
        keyShape.attr(__assign12(__assign12({}, keyShape.get("oriAttrs")), legendActive));
        text.attr(__assign12(__assign12({}, text.get("oriAttrs")), legendTextActive));
      });
    };
    Legend3.prototype.findLegendItemsByState = function(stateName, type, value) {
      if (type === void 0) {
        type = "all";
      }
      if (value === void 0) {
        value = true;
      }
      var group = this.get("legendCanvas").find(function(e8) {
        return e8.get("name") === "root";
      });
      var nodeGroup = group.find(function(e8) {
        return e8.get("name") === "node-group";
      });
      var edgeGroup = group.find(function(e8) {
        return e8.get("name") === "edge-group";
      });
      if (type === "node")
        return nodeGroup.get("children").filter(function(g2) {
          return !!g2.get(stateName) === value;
        });
      if (type === "edge")
        return edgeGroup.get("children").filter(function(g2) {
          return !!g2.get(stateName) === value;
        });
      return nodeGroup.get("children").filter(function(g2) {
        return !!g2.get(stateName) === value;
      }).concat(edgeGroup.get("children").filter(function(g2) {
        return !!g2.get(stateName) === value;
      }));
    };
    Legend3.prototype.clearActiveLegend = function() {
      var lg = this.get("legendCanvas");
      var group = lg.find(function(e8) {
        return e8.get("name") === "root";
      });
      var groups = [group.find(function(e8) {
        return e8.get("name") === "node-group";
      }), group.find(function(e8) {
        return e8.get("name") === "edge-group";
      })];
      groups.forEach(function(itemGroup) {
        itemGroup.get("children").forEach(function(subGroup) {
          subGroup.set("active", false);
          subGroup.set("inactive", false);
          var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
          keyShape.attr(keyShape.get("oriAttrs"));
          text.attr(text.get("oriAttrs"));
        });
      });
    };
    Legend3.prototype.filterData = function(e8) {
      var filter2 = this.get("filter");
      var filterFunctions = filter2 === null || filter2 === void 0 ? void 0 : filter2.filterFunctions;
      if (!filter2 || !filterFunctions)
        return;
      var lc = this.get("legendCanvas");
      var graph = this.get("graph");
      var activeState = filter2.graphActiveState || "active";
      var inactiveState = filter2.graphInactiveState || "inactive";
      var multiple = filter2.multiple;
      this.clearFilter();
      if (!multiple)
        this.clearActiveLegend();
      this.activateLegend(e8.target);
      var group = lc.find(function(e9) {
        return e9.get("name") === "root";
      });
      var nodeGroup = group.find(function(e9) {
        return e9.get("name") === "node-group";
      });
      var edgeGroup = group.find(function(e9) {
        return e9.get("name") === "edge-group";
      });
      var activeNodeLegend = nodeGroup.get("children").filter(function(e9) {
        return e9.get("active");
      });
      var activeEdgeLegend = edgeGroup.get("children").filter(function(e9) {
        return e9.get("active");
      });
      var activeCount = 0;
      var typeFuncs = ["getNodes", "getEdges"];
      typeFuncs.forEach(function(typeFunc) {
        graph[typeFunc]().forEach(function(graphItem) {
          var active = false;
          var activeLegend = typeFunc === "getNodes" ? activeNodeLegend : activeEdgeLegend;
          activeLegend.forEach(function(itemGroup) {
            var func = filterFunctions[itemGroup.get("id")];
            active = active || func(graphItem.getModel());
          });
          if (active) {
            graph.setItemState(graphItem, inactiveState, false);
            graph.setItemState(graphItem, activeState, true);
            activeCount++;
          } else {
            graph.setItemState(graphItem, activeState, false);
            graph.setItemState(graphItem, inactiveState, true);
          }
        });
      });
      if (!activeCount)
        typeFuncs.forEach(function(typeFunc) {
          graph[typeFunc]().forEach(function(graphItem) {
            graph.clearItemStates(graphItem, [inactiveState]);
          });
        });
    };
    Legend3.prototype.clearFilter = function() {
      var graph = this.get("graph");
      var filter2 = this.get("filter");
      if (!filter2)
        return;
      var activeState = filter2.graphActiveState || "active";
      var inactiveState = filter2.graphInactiveState || "inactive";
      graph.getNodes().forEach(function(node) {
        graph.clearItemStates(node, [activeState, inactiveState]);
      });
      graph.getEdges().forEach(function(edge) {
        graph.clearItemStates(edge, [activeState, inactiveState]);
      });
    };
    Legend3.prototype.render = function() {
      var _this = this;
      this.processData();
      var lc = this.get("legendCanvas");
      if (!lc) {
        lc = new canvas_default({
          container: this.get("container"),
          width: 200,
          height: 200
        });
      } else {
        lc.clear();
      }
      var group = lc.addGroup({
        name: "root"
      });
      var nodeGroup = group.addGroup({
        name: "node-group"
      });
      var edgeGroup = group.addGroup({
        name: "edge-group"
      });
      this.set("legendCanvas", lc);
      var itemsData = this.get("itemsData");
      var itemTypes = ["nodes", "edges"];
      var itemGroup = [nodeGroup, edgeGroup];
      itemTypes.forEach(function(itemType, i2) {
        itemsData[itemType].forEach(function(data) {
          var _a2;
          var subGroup = itemGroup[i2].addGroup({
            id: data.id,
            name: "node-container"
          });
          var attrs;
          var shapeType = data.type;
          var _b = _this.getShapeSize(data), width = _b.width, height = _b.height, r2 = _b.r;
          var style2 = _this.getStyle(itemType.substr(0, 4), data);
          switch (data.type) {
            case "circle":
              attrs = {
                r: r2,
                x: 0,
                y: 0
              };
              break;
            case "rect":
              attrs = {
                width,
                height,
                x: -width / 2,
                y: -height / 2
              };
              break;
            case "ellipse":
              attrs = {
                rx: width,
                ry: height,
                x: 0,
                y: 0
              };
              shapeType = "ellipse";
              break;
            case "line":
              attrs = {
                x1: -width / 2,
                y1: 0,
                x2: width / 2,
                y2: 0
              };
              shapeType = "line";
              break;
            case "quadratic":
              attrs = {
                path: [["M", -width / 2, 0], ["Q", 0, width / 2, width / 2, 0]]
              };
              shapeType = "path";
              break;
            case "cubic":
              attrs = {
                path: [["M", -width / 2, 0], ["C", -width / 6, width / 2, width / 6, -width / 2, width / 2, 0]]
              };
              shapeType = "path";
              break;
            case "diamond":
              attrs = {
                path: [["M", 0, -height], ["L", width, 0], ["L", 0, height], ["L", -width, 0], ["Z"]]
              };
              shapeType = "path";
              break;
            case "triangle":
              attrs = {
                path: [["M", -width, height], ["L", 0, -height], ["L", width, height], ["Z"]]
              };
              shapeType = "path";
              break;
            case "star":
              attrs = {
                path: util_default.getStarPath(r2 * 3, r2 * 1.2)
              };
              shapeType = "path";
              break;
            default:
              attrs = {
                r: r2,
                x: 0,
                y: 0
              };
              break;
          }
          var keyShape = subGroup.addShape(shapeType, {
            attrs: __assign12(__assign12({}, attrs), style2),
            name: "".concat(data.type, "-node-keyShape"),
            oriAttrs: __assign12({
              opacity: 1
            }, style2)
          });
          if (data.label) {
            var keyShapeBBox = keyShape.getBBox();
            var labelStyle = ((_a2 = data.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
            var attrs_1 = __assign12({
              textAlign: "begin",
              fontSize: 12,
              textBaseline: "middle",
              fill: "#000",
              opacity: 1,
              fontWeight: "normal"
            }, labelStyle);
            subGroup.addShape("text", {
              attrs: __assign12({
                x: keyShapeBBox.maxX + 4,
                y: 0,
                text: data.label
              }, attrs_1),
              className: "legend-label",
              name: "".concat(data.type, "-node-text"),
              oriAttrs: attrs_1
            });
          }
        });
      });
      var padding = this.get("padding");
      var titleShape;
      var titleGroup = group.find(function(e8) {
        return e8.get("name") === "title-container";
      });
      var titleGroupBBox = {
        height: 0,
        maxY: 0,
        width: 0
      };
      if (this.get("title")) {
        if (!titleGroup) {
          titleGroup = group.addGroup({
            name: "title-container"
          });
        }
        var defaultTitleStyle = {
          fontSize: 20,
          fontFamily: "Arial",
          fontWeight: 300,
          textBaseline: "top",
          textAlign: "center",
          fill: "#000",
          x: 0,
          y: padding[0]
        };
        var titleConfig = this.get("titleConfig") || {};
        var style = Object.assign(defaultTitleStyle, titleConfig.style || {});
        titleShape = titleGroup.addShape("text", {
          attrs: __assign12({
            text: this.get("title")
          }, style)
        });
        titleGroupBBox = titleGroup.getCanvasBBox();
        titleGroup.setMatrix([1, 0, 0, 0, 1, 0, titleConfig.offsetX, titleConfig.offsetY, 1]);
      }
      this.layoutItems();
      var lcBBox = group.getCanvasBBox();
      var nodeGroupBBox = nodeGroup.getCanvasBBox();
      var nodeGroupBeginX = nodeGroupBBox.minX < 0 ? Math.abs(nodeGroupBBox.minX) + padding[3] : padding[3];
      var nodeGroupBeginY = titleGroupBBox.maxY < nodeGroupBBox.minY ? Math.abs(titleGroupBBox.maxY - nodeGroupBBox.minY) + padding[0] : titleGroupBBox.maxY + padding[0];
      var nodeGroupMatrix = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
      nodeGroup.setMatrix(nodeGroupMatrix);
      lcBBox = group.getCanvasBBox();
      var size3 = [lcBBox.minX + lcBBox.width + padding[1], lcBBox.minY + lcBBox.height + padding[2]];
      if (titleShape) {
        var titleConfig = __assign12({
          position: "center",
          offsetX: 0,
          offsetY: 0
        }, this.get("titleConfig"));
        titleGroupBBox = titleGroup.getCanvasBBox();
        var titleGroupMatrix = titleGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (titleConfig.position === "center") {
          titleGroupMatrix[6] = size3[0] / 2 + titleConfig.offsetX;
        } else if (titleConfig.position === "right") {
          titleGroupMatrix[6] = size3[0] - padding[3] + titleConfig.offsetX;
          titleShape.attr({
            textAlign: "right"
          });
        } else {
          titleGroupMatrix[6] = padding[3] + titleConfig.offsetX;
          titleShape.attr({
            textAlign: "left"
          });
        }
        titleGroup.setMatrix(titleGroupMatrix);
        titleGroupBBox = titleGroup.getCanvasBBox();
        nodeGroupBeginX = nodeGroupBBox.minX < 0 ? Math.abs(nodeGroupBBox.minX) + padding[3] : padding[3];
        nodeGroupBeginY = nodeGroupBBox.minY < titleGroupBBox.maxY ? Math.abs(titleGroupBBox.maxY - nodeGroupBBox.minY) + padding[0] : titleGroupBBox.maxY + padding[0];
        nodeGroupMatrix = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
        nodeGroup.setMatrix(nodeGroupMatrix);
        var edgeGroupMatrix_1 = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
        if (this.get("layout") === "vertical")
          edgeGroupMatrix_1[6] += nodeGroupBBox.maxX + this.get("horiSep");
        else
          edgeGroupMatrix_1[7] += nodeGroupBBox.maxY + this.get("vertiSep");
        edgeGroup.setMatrix(edgeGroupMatrix_1);
      } else {
        nodeGroupBBox = nodeGroup.getCanvasBBox();
        var edgeGroupMatrix_2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (this.get("layout") === "vertical")
          edgeGroupMatrix_2[6] += nodeGroupMatrix[6] + nodeGroupBBox.maxX + this.get("horiSep");
        else
          edgeGroupMatrix_2[7] += nodeGroupMatrix[7] + nodeGroupBBox.maxY + this.get("vertiSep");
        edgeGroup.setMatrix(edgeGroupMatrix_2);
      }
      lcBBox = group.getCanvasBBox();
      nodeGroupBBox = nodeGroup.getCanvasBBox();
      nodeGroupMatrix = nodeGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var edgeGroupMatrix = edgeGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var edgeGroupBBox = edgeGroup.getCanvasBBox();
      size3 = [Math.max(nodeGroupBBox.width + nodeGroupMatrix[6], edgeGroupBBox.width + edgeGroupMatrix[6]) + padding[1], Math.max(nodeGroupBBox.height + nodeGroupMatrix[7], edgeGroupBBox.height + edgeGroupMatrix[7]) + padding[2]];
      lc.changeSize(size3[0], size3[1]);
      var containerStyle = this.get("containerStyle");
      var viewportMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var beginPos = util_default.invertMatrix({
        x: 0,
        y: 0
      }, viewportMatrix);
      var backRect = group.addShape("rect", {
        attrs: __assign12({
          x: beginPos.x + (containerStyle.lineWidth || 1),
          y: beginPos.y + (containerStyle.lineWidth || 1),
          width: size3[0] - 2 * (containerStyle.lineWidth || 1),
          height: size3[1] - 2 * (containerStyle.lineWidth || 1),
          fill: "#f00",
          stroke: "#000",
          lineWidth: 1,
          opacity: 0.5
        }, containerStyle),
        name: "legend-back-rect",
        capture: false
      });
      backRect.toBack();
      return size3;
    };
    Legend3.prototype.layoutItems = function() {
      var lc = this.get("legendCanvas");
      var horiSep = this.get("horiSep");
      var vertiSep = this.get("vertiSep");
      var layout2 = this.get("layout");
      var align = this.get("align");
      var begin = [0, 0];
      var group = lc.find(function(e8) {
        return e8.get("name") === "root";
      });
      var nodeGroup = group.find(function(e8) {
        return e8.get("name") === "node-group";
      });
      var edgeGroup = group.find(function(e8) {
        return e8.get("name") === "edge-group";
      });
      var nodeLegendSize = {
        min: 0,
        max: -Infinity
      };
      var rowMaxY = -Infinity;
      nodeGroup.get("children").forEach(function(cNodeGroup, i2) {
        if (i2 === 0)
          nodeLegendSize.min = begin[0];
        var keyShape = cNodeGroup.get("children")[0];
        var bbox = cNodeGroup.getCanvasBBox();
        var _a2 = keyShape.getBBox(), keyShapeWidth = _a2.width, keyShapeHeight = _a2.height;
        var curHeight = 0, x4 = 0, y4 = 0;
        if (layout2 === "vertical") {
          x4 = begin[1];
          y4 = begin[0] + keyShapeWidth / 2;
          begin[0] = y4 + bbox.height + vertiSep;
          curHeight = bbox.maxX + x4 + keyShapeWidth / 2;
        } else {
          x4 = begin[0] + keyShapeWidth / 2;
          y4 = begin[1];
          begin[0] = x4 + bbox.width + horiSep;
          curHeight = bbox.maxY + y4 + keyShapeHeight / 2;
        }
        if (begin[0] > nodeLegendSize.max)
          nodeLegendSize.max = begin[0];
        if (curHeight > rowMaxY)
          rowMaxY = curHeight;
        cNodeGroup.setMatrix([1, 0, 0, 0, 1, 0, x4, y4, 1]);
      });
      var nw = nodeLegendSize.max - nodeLegendSize.min;
      var edgeLegendSize = {
        min: 0,
        max: -Infinity
      };
      var nodeGroupBBox = nodeGroup.getCanvasBBox();
      begin[0] = 0;
      begin[1] = layout2 === "vertical" ? nodeGroupBBox.maxX + horiSep : nodeGroupBBox.maxY + vertiSep;
      edgeGroup.get("children").forEach(function(subGroup, i2) {
        if (i2 === 0)
          edgeLegendSize.min = begin[0];
        var keyShape = subGroup.get("children")[0];
        var bbox = subGroup.getCanvasBBox();
        var _a2 = keyShape.getBBox(), keyShapeWidth = _a2.width, keyShapeHeight = _a2.height;
        var x4 = 0, y4 = 0;
        if (layout2 === "vertical") {
          x4 = begin[1];
          y4 = begin[0];
          begin[0] = y4 + bbox.height + vertiSep;
          subGroup.setMatrix([1, 0, 0, 0, 1, 0, 0, y4 + keyShapeHeight / 2, 1]);
        } else {
          x4 = begin[0];
          y4 = begin[1];
          begin[0] = x4 + bbox.width + horiSep;
          subGroup.setMatrix([1, 0, 0, 0, 1, 0, x4 + keyShapeWidth / 2, 0, 1]);
        }
        if (begin[0] > edgeLegendSize.max)
          edgeLegendSize.max = begin[0];
      });
      var ew = edgeLegendSize.max - edgeLegendSize.min;
      if (align && align !== "" && align !== "left") {
        var widthDiff = nw - ew;
        var movement_1 = align === "center" ? Math.abs(widthDiff) / 2 : Math.abs(widthDiff);
        var shouldAdjustGroup = widthDiff < 0 ? nodeGroup : edgeGroup;
        shouldAdjustGroup.get("children").forEach(function(subGroup) {
          var matrix = subGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (layout2 === "vertical")
            matrix[7] += movement_1;
          else
            matrix[6] += movement_1;
          subGroup.setMatrix(matrix);
        });
      }
    };
    Legend3.prototype.processData = function() {
      var data = this.get("data");
      var itemsData = {
        nodes: [],
        edges: []
      };
      if (data.nodes) {
        data.nodes.sort(function(a3, b2) {
          return a3.order - b2.order;
        });
        data.nodes.forEach(function(node) {
          var _a2, _b, _c, _d, _e2;
          var size3 = node.size || [((_a2 = node.style) === null || _a2 === void 0 ? void 0 : _a2.width) || ((_b = node.style) === null || _b === void 0 ? void 0 : _b.r) || 8, ((_c = node.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = node.style) === null || _d === void 0 ? void 0 : _d.r) || 8];
          var labelStyle = ((_e2 = node.labelCfg) === null || _e2 === void 0 ? void 0 : _e2.style) || {};
          itemsData.nodes.push({
            id: node.id || unique_id_default(),
            type: node.type || "circle",
            style: __assign12({}, node.style),
            order: node.order,
            label: node.label,
            itemType: "node",
            size: size3,
            labelCfg: {
              position: "right",
              style: __assign12({
                fontFamily: "Arial"
              }, labelStyle)
            }
          });
        });
      }
      if (data.edges) {
        data.edges.sort(function(a3, b2) {
          return a3.order - b2.order;
        });
        data.edges.forEach(function(edge) {
          var _a2, _b;
          var type = edge.type || "line";
          if (edge.type === "cubic-horizontal")
            type = "cubic";
          var labelStyle = ((_a2 = edge.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
          var size3 = edge.size || [((_b = edge.style) === null || _b === void 0 ? void 0 : _b.width) || 8, 1];
          itemsData.edges.push({
            id: edge.id || unique_id_default(),
            type,
            size: size3,
            style: __assign12({
              lineWidth: is_array_default(size3) ? size3[1] : 1
            }, edge.style),
            order: edge.order,
            label: edge.label,
            itemType: "edge",
            labelCfg: {
              position: "right",
              style: __assign12({
                fontFamily: "Arial"
              }, labelStyle)
            }
          });
        });
      }
      this.set("itemsData", itemsData);
    };
    Legend3.prototype.getContainer = function() {
      return this.get("container");
    };
    Legend3.prototype.formatArray = function(key) {
      var value = this.get(key);
      if (is_number_default(value))
        this.set(key, [value, value, value, value]);
      else if (is_array_default(value)) {
        switch (value.length) {
          case 0:
            this.set(key, [0, 0, 0, 0]);
            break;
          case 1:
            this.set(key, [value[0], value[0], value[0], value[0]]);
            break;
          case 2:
            this.set(key, [value[0], value[1], value[0], value[1]]);
            break;
          case 3:
            this.set(key, [value[0], value[1], value[2], value[1]]);
            break;
          default:
            break;
        }
      }
      return this.get(key);
    };
    Legend3.prototype.getShapeSize = function(data) {
      var width, height, r2;
      if (data.size) {
        if (is_array_default(data.size)) {
          width = data.size[0];
          height = data.size[1] || data.size[0];
          r2 = data.size[0] / 2;
        } else if (is_number_default(data.size)) {
          width = data.size;
          height = data.size;
          r2 = data.size / 2;
        }
      }
      if (data.style) {
        if (data.style.width)
          width = data.style.width;
        if (data.style.height)
          height = data.style.height;
        if (data.style.r)
          r2 = data.style.r;
      }
      if (!r2)
        r2 = 5;
      if (!width)
        width = r2;
      if (!height)
        height = r2;
      return {
        width,
        height,
        r: r2
      };
    };
    Legend3.prototype.getStyle = function(type, data) {
      var defaultStyle = type === "node" ? {
        fill: "#ccc",
        lineWidth: 0
      } : {
        stroke: "#000",
        lineWidth: 1
      };
      return __assign12(__assign12({}, defaultStyle), data.style || {});
    };
    Legend3.prototype.destroy = function() {
      var lc = this.get("legendCanvas");
      lc === null || lc === void 0 ? void 0 : lc.destroy();
      var graph = this.get("graph");
      var graphContainer = graph.get("container");
      var container = this.get("container");
      graphContainer.removeChild(container);
    };
    return Legend3;
  }(base_default2)
);
var legend_default = Legend;

// node_modules/@antv/g6-plugin/es/annotation/index.js
init_esm();
var import_insert_css4 = __toESM(require_insert_css());
var __extends14 = function() {
  var _extendStatics = function extendStatics(d2, b2) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return _extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    _extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign13 = function() {
  __assign13 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign13.apply(this, arguments);
};
var __rest3 = function(s2, e8) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
typeof document !== "undefined" && (0, import_insert_css4.default)("\n  .g6-annotation-container {\n    background-color: rgba(255, 255, 255, 0.3);\n    padding: 8px;\n  }\n  .g6-annotation-wrapper {\n    background-color: #fff;\n    box-shadow: 0 0 8px rgba(0, 0, 0, 0.85);\n  }\n  .g6-annotation-header-wapper {\n    height: fit-content;\n    width: 100%;\n    background-color: #5B8FF9;\n    display: inline-flex;\n    cursor: move;\n  }\n  .g6-annotation-title {\n    margin: 4px 40px 4px 8px;\n    cursor: text;\n    min-width: 32px;\n  }\n  .g6-annotation-collapse {\n    margin: 4px;\n    cursor: pointer;\n  }\n  .g6-annotation-expand {\n    margin: 4px;\n    cursor: pointer;\n  }\n  .g6-annotation-close {\n    margin: 4px 8px 4px 0;\n    cursor: pointer;\n  }\n  .g6-annotation-content {\n    padding: 8px;\n    width: fit-content;\n    cursor: text;\n    word-break: break-all;\n    min-width: 32px;\n  }\n  .g6-annotation-title-input-wrapper {\n    margin: 4px 40px 4px 8px;\n  }\n  .g6-annotation-content-input {\n    height: 100%;\n    word-break: break-all;\n  }\n  .g6-annotation-content-input-wrapper {\n    margin: 8px;\n    height: 100%;\n  }\n");
var CANVAS_ANNOTATION_ID = "canvas-annotation";
var Annotation = (
  /** @class */
  function(_super) {
    __extends14(Annotation3, _super);
    function Annotation3(config) {
      return _super.call(this, config) || this;
    }
    Annotation3.prototype.getDefaultCfgs = function() {
      return {
        trigger: "click",
        editable: true,
        itemHighlightState: "highlight",
        linkHighlightStyle: {
          shadowColor: "#5B8FF9",
          shadowBlur: 10
        },
        cardCfg: {
          minHeight: 60,
          width: "fit-content",
          height: "fit-content",
          collapseType: "minimize",
          closeType: "hide",
          borderRadius: 5,
          maxTitleLength: 20
        }
      };
    };
    Annotation3.prototype.getEvents = function() {
      var events = {
        "viewportchange": "updateLinks",
        "afterlayout": "updateLinks",
        "aftergraphrefreshposition": "updateLinks",
        "afterupdateitem": "updateLink",
        "afterchangedata": "onGraphDataChange",
        "afteritemvisibilitychange": "onGraphItemVisibilityChange"
      };
      switch (this.get("trigger")) {
        case "click":
          events = __assign13(__assign13({}, events), {
            "node:click": "showAnnotation",
            "edge:click": "showAnnotation"
          });
      }
      return events;
    };
    Annotation3.prototype.getDOMContent = function(cfg) {
      if (this.destroyed)
        return;
      var collapsed = cfg.collapsed, maxWidth = cfg.maxWidth, _a2 = cfg.title, title = _a2 === void 0 ? "" : _a2, _b = cfg.content, content = _b === void 0 ? "" : _b, _c = cfg.borderRadius, r2 = _c === void 0 ? 5 : _c;
      var collapseExpandDOM = collapsed ? "<p class='g6-annotation-expand'>+</p>" : "<p class='g6-annotation-collapse'>-</p>";
      var contentDOM = collapsed ? "" : " <p class='g6-annotation-content'>".concat(content, "</p>");
      var closeDOM = "<p class='g6-annotation-close'>x</p>";
      var borderRadius = collapsed ? "".concat(r2, "px") : "".concat(r2, "px ").concat(r2, "px 0 0");
      return '<div class="g6-annotation-wrapper" style="border-radius: '.concat(r2, "px; max-width: ").concat(maxWidth, 'px">\n        <div\n          class="g6-annotation-header-wapper"\n          style="border-radius: ').concat(borderRadius, `;"
        >
          <h4 class='g6-annotation-title'>`).concat(title, "</h4>\n          ").concat(collapseExpandDOM, "\n          ").concat(closeDOM, "\n        </div>\n        ").concat(contentDOM, "\n      </div>");
    };
    Annotation3.prototype.init = function() {
      var self2 = this;
      if (self2.destroyed)
        return;
      var graph = self2.get("graph");
      var graphCantainer = graph.getContainer();
      var container = self2.get("container");
      var containerCfg = this.get("containerCfg");
      if (containerCfg) {
        container = this.createContainer();
        graphCantainer.appendChild(container);
      } else {
        container = graphCantainer;
      }
      this.set("container", container);
      var graphContainerBBox = graphCantainer.getBoundingClientRect();
      var linkCanvas = new canvas_default({
        container: graphCantainer,
        width: graphContainerBBox.right - graphContainerBBox.left,
        height: graphContainerBBox.bottom - graphContainerBBox.top
      });
      modifyCSS(linkCanvas.get("el"), {
        position: "absolute",
        top: 0,
        left: 0,
        pointerEvents: "none"
      });
      window.addEventListener("resize", debounce_default(function() {
        return self2.resizeCanvas(self2);
      }, 100));
      var linkGroup = linkCanvas.addGroup({
        id: "annotation-link-group"
      });
      self2.set("linkGroup", linkGroup);
      self2.set("canvas", linkCanvas);
      if (!self2.get("getTitle")) {
        self2.set("getTitle", function(item) {
          var _a2;
          var _b = ((_a2 = item === null || item === void 0 ? void 0 : item.getModel) === null || _a2 === void 0 ? void 0 : _a2.call(item)) || {}, label = _b.label, id = _b.id;
          return label || id || "-";
        });
      }
      if (!self2.get("getContent")) {
        self2.set("getContent", function(item) {
          var _a2, _b;
          if (!item)
            return "-";
          var _c = ((_a2 = item.getModel) === null || _a2 === void 0 ? void 0 : _a2.call(item)) || {}, label = _c.label, id = _c.id;
          var type = (_b = item.getType) === null || _b === void 0 ? void 0 : _b.call(item);
          var suffix = type ? "".concat(type, ": ") : "";
          return "".concat(suffix).concat(label || id || "");
        });
      }
      var defaultData = self2.get("defaultData");
      if (defaultData)
        this.readData(defaultData);
    };
    Annotation3.prototype.createContainer = function() {
      var _this = this;
      if (this.destroyed)
        return;
      var containerCfg = this.get("containerCfg");
      var graph = this.get("graph");
      var graphContainer = graph.getContainer();
      var _a2 = graphContainer.getBoundingClientRect(), gLeft = _a2.left, gRight = _a2.right, gTop = _a2.top, gBottom = _a2.bottom;
      var graphContainerHeight = gBottom - gTop;
      var graphContainerWidth = gRight - gLeft;
      var _b = containerCfg.position, position = _b === void 0 ? "top" : _b, _c = containerCfg.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = containerCfg.offsetY, offsetY = _d === void 0 ? 0 : _d, otherStyle = __rest3(containerCfg, ["position", "offsetX", "offsetY"]);
      var _e2 = containerCfg.height, height = _e2 === void 0 ? "fit-content" : _e2, _f = containerCfg.width, width = _f === void 0 ? graph.getWidth() : _f;
      if (height === "100%")
        height = graphContainerHeight;
      if (width === "100%")
        width = graphContainerWidth;
      var maxHeight = "unset", maxWidth = "unset";
      var containerPosition = {};
      switch (position) {
        case "right":
          maxHeight = "".concat(graphContainerHeight, "px");
          containerPosition = {
            top: 0,
            right: 0
          };
          containerPosition.right += gLeft + offsetX;
          containerPosition.top += gTop + offsetY;
          break;
        case "bottom":
          maxWidth = "".concat(graphContainerWidth, "px");
          containerPosition = {
            bottom: 0,
            left: 0
          };
          containerPosition.left += gLeft + offsetX;
          containerPosition.bottom += gTop + offsetY;
          break;
        case "top":
          maxWidth = "".concat(graphContainerWidth, "px");
        case "left":
          maxHeight = "".concat(graphContainerHeight, "px");
        default:
          containerPosition = {
            top: 0,
            left: 0
          };
          containerPosition.left += gLeft + offsetX;
          containerPosition.top += gTop + offsetY;
          break;
      }
      Object.keys(containerPosition).forEach(function(key) {
        containerPosition[key] = "".concat(containerPosition[key], "px");
      });
      var container = createDom("<div class='".concat(containerCfg.className, " g6-annotation-container'></div>"));
      modifyCSS(container, __assign13(__assign13({
        position: "absolute",
        display: position === "top" || position === "bottom" ? "inline-flex" : "unset",
        width: is_number_default(width) ? "".concat(width, "px") : width,
        height: is_number_default(height) ? "".concat(height, "px") : height,
        maxHeight,
        maxWidth,
        overflow: "scroll"
      }, containerPosition), otherStyle));
      graphContainer.appendChild(container);
      container.addEventListener("scroll", function(e8) {
        _this.updateLinks();
      });
      return container;
    };
    Annotation3.prototype.resizeCanvas = function(self2) {
      clearTimeout(self2.resizeTimer);
      self2.resizeTimer = setTimeout(function() {
        if (!self2 || self2.destroyed)
          return;
        var cBBox = self2.get("container").getBoundingClientRect();
        var newWidth = cBBox.right - cBBox.left;
        var newHeight = cBBox.bottom - cBBox.top;
        self2.get("canvas").changeSize(newWidth, newHeight);
        self2.updateOutsideCards(self2);
      }, 250);
    };
    Annotation3.prototype.updateOutsideCards = function(selfObj) {
      var self2 = selfObj || this;
      var cardInfoMap = self2.get("cardInfoMap") || {};
      var graph = self2.get("graph");
      var graphLeftTopCanvas = graph.getPointByCanvas(0, 0);
      var graphRightBottomCanvas = graph.getPointByCanvas(graph.getWidth(), graph.getHeight());
      var _a2 = graph.getClientByPoint(graphLeftTopCanvas.x, graphLeftTopCanvas.y), graphLeft = _a2.x, graphTop = _a2.y;
      var _b = graph.getClientByPoint(graphRightBottomCanvas.x, graphRightBottomCanvas.y), graphRight = _b.x, graphBottom = _b.y;
      Object.values(cardInfoMap).forEach(function(cardInfo) {
        var card = cardInfo.card;
        if (!card)
          return;
        var style = card.style;
        var left = px2Num(style.left);
        var top = px2Num(style.top);
        var _a3 = card.getBoundingClientRect(), width = _a3.width, height = _a3.height;
        var newLeft = left;
        var newTop = top;
        if (left + width > graphRight - graphLeft) {
          newLeft = graphRight - graphLeft - width;
        }
        if (left < 0) {
          newLeft = 0;
        }
        if (top + height > graphBottom - graphTop) {
          newTop = graphBottom - graphTop - height;
        }
        if (top < 0) {
          newTop = 0;
        }
        modifyCSS(card, {
          left: "".concat(newLeft, "px"),
          top: "".concat(newTop, "px")
        });
      });
      self2.updateLinks();
    };
    Annotation3.prototype.showAnnotation = function(evt) {
      if (this.destroyed)
        return;
      var item = evt.item;
      this.toggleAnnotation(item);
    };
    Annotation3.prototype.hideCards = function() {
      var self2 = this;
      if (self2.destroyed)
        return;
      var cardInfoMap = self2.get("cardInfoMap") || {};
      Object.keys(cardInfoMap).forEach(function(itemId) {
        self2.hideCard(itemId);
      });
    };
    Annotation3.prototype.toggleAnnotation = function(item, cfg) {
      var _a2, _b;
      if (cfg === void 0) {
        cfg = {};
      }
      var self2 = this;
      if (self2.destroyed)
        return;
      var cardInfoMap = self2.get("cardInfoMap") || {};
      var graph = self2.get("graph");
      var container = self2.get("container");
      var containerCfg = self2.get("containerCfg");
      var _c = Object.assign({}, self2.get("cardCfg") || {}, cfg), minHeight = _c.minHeight, minWidth = _c.minWidth, width = _c.width, height = _c.height, _d = _c.collapsed, collapsed = _d === void 0 ? false : _d, propsX = _c.x, propsY = _c.y, propsTitle = _c.title, propsContent = _c.content, maxTitleLength = _c.maxTitleLength, defaultBegin = _c.defaultBegin, otherCardCfg = __rest3(_c, ["minHeight", "minWidth", "width", "height", "collapsed", "x", "y", "title", "content", "maxTitleLength", "defaultBegin"]);
      var linkGroup = self2.get("linkGroup");
      var rows = this.get("rows") || [[]];
      var isCanvas = (_a2 = item.isCanvas) === null || _a2 === void 0 ? void 0 : _a2.call(item);
      var itemId = isCanvas ? CANVAS_ANNOTATION_ID : item.getID();
      var _e2 = cardInfoMap[itemId] || {}, card = _e2.card, link = _e2.link, x4 = _e2.x, y4 = _e2.y, title = _e2.title, content = _e2.content;
      var getTitle = this.get("getTitle");
      var getContent = this.get("getContent");
      var getContentPlaceholder = this.get("getContentPlaceholder") || function() {
        return "";
      };
      var getTitlePlaceHolder = this.get("getTitlePlaceHolder") || function() {
        return "";
      };
      var contentPlaceholder = getContentPlaceholder(item);
      var titlePlaceholder = getTitlePlaceHolder(item);
      var newCard = createDom(this.getDOMContent(__assign13({
        itemId,
        collapsed,
        title: ((_b = title || propsTitle || (getTitle === null || getTitle === void 0 ? void 0 : getTitle(item))) === null || _b === void 0 ? void 0 : _b.substr(0, maxTitleLength)) || titlePlaceholder,
        content: content || propsContent || (getContent === null || getContent === void 0 ? void 0 : getContent(item)) || contentPlaceholder
      }, otherCardCfg)));
      var minHeightPx = is_number_default(minHeight) ? "".concat(minHeight, "px") : minHeight;
      modifyCSS(newCard, {
        minHeight: collapsed ? "unset" : minHeightPx,
        minWidth: is_number_default(minWidth) ? "".concat(minWidth, "px") : minWidth,
        height,
        width
      });
      var exist = !!card;
      if (exist) {
        link === null || link === void 0 ? void 0 : link.remove(true);
        container.replaceChild(newCard, card);
      } else {
        container.appendChild(newCard);
      }
      var containerBBox;
      if (!containerCfg) {
        containerBBox = container.getBoundingClientRect() || {};
        if (propsX !== void 0 && propsY !== void 0) {
          x4 = propsX;
          y4 = propsY;
        } else if (!exist && !isCanvas) {
          var containerTop = containerBBox.top;
          var _f = defaultBegin || {}, beginLeft = _f.left, _g = _f.right, propsBeginRight = _g === void 0 ? 16 : _g, _h = _f.top, propsBeginTop = _h === void 0 ? 8 : _h, beginBottom = _f.bottom;
          var beginRight = propsBeginRight;
          var beginTop = propsBeginTop;
          if (!isNaN(beginLeft)) {
            beginRight = container.scrollWidth - beginLeft;
          }
          if (!isNaN(beginBottom)) {
            beginTop = container.scrollHeight - beginBottom;
          }
          var cardWidth = is_number_default(minWidth) ? minWidth : 100;
          x4 = container.scrollWidth - newCard.scrollWidth - (rows.length - 1) * cardWidth - beginRight;
          var currentRow = rows[rows.length - 1];
          var lastCardBBox = (currentRow[currentRow.length - 1] || {}).bbox;
          y4 = (lastCardBBox === null || lastCardBBox === void 0 ? void 0 : lastCardBBox.bottom) - containerTop || beginTop;
        }
        modifyCSS(newCard, {
          position: "absolute",
          left: "".concat(x4, "px"),
          top: "".concat(y4, "px"),
          cusor: containerCfg ? "unset" : "move"
        });
      }
      this.bindListener(newCard, itemId);
      var cardBBox = newCard.getBoundingClientRect();
      if (!isCanvas) {
        var path = getPathItem2Card(item, cardBBox, graph, this.get("canvas"));
        var linkStyle = this.get("linkStyle");
        link = linkGroup.addShape("path", {
          attrs: __assign13({
            lineWidth: 1,
            lineDash: [5, 5],
            stroke: "#ccc",
            path
          }, linkStyle)
        });
      }
      cardInfoMap[itemId] = __assign13(__assign13({}, cardInfoMap[itemId] || {}), {
        id: itemId,
        collapsed,
        card: newCard,
        link,
        x: x4,
        y: y4,
        cardBBox,
        content: content || propsContent,
        title: title || propsTitle,
        contentPlaceholder,
        titlePlaceholder,
        isCanvas
      });
      self2.set("cardInfoMap", cardInfoMap);
      if (containerCfg) {
        this.updateCardPositionsInConatainer();
        this.updateLinks();
      } else {
        var hasPropsPosition = !isNaN(propsX) && !isNaN(propsY);
        if (!exist && !isCanvas && !hasPropsPosition) {
          var _j = containerBBox.bottom, containerBottom = _j === void 0 ? 0 : _j, containerTop = containerBBox.top;
          rows[rows.length - 1].push({
            id: itemId,
            bbox: cardBBox
          });
          if (cardBBox.top > containerBottom - containerTop - cardBBox.height - 16)
            rows.push([]);
          this.set("rows", rows);
        }
      }
      this.updateCardSize(itemId);
      var onAnnotationChange = this.get("onAnnotationChange");
      onAnnotationChange === null || onAnnotationChange === void 0 ? void 0 : onAnnotationChange(cardInfoMap[itemId], exist ? "update" : "create");
    };
    Annotation3.prototype.updateCardPositionsInConatainer = function() {
      if (this.destroyed)
        return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var container = this.get("container");
      var position = this.get("containerCfg").position;
      var containerWidth = container.getBoundingClientRect().width;
      var computeStyle = getComputedStyle(container);
      var sidePadding = px2Num(computeStyle["paddingLeft"]) + px2Num(computeStyle["paddingRight"]);
      containerWidth -= sidePadding;
      Object.values(cardInfoMap).forEach(function(_a2) {
        var card = _a2.card;
        var cardWidth = card.getBoundingClientRect().width;
        switch (position) {
          case "right":
            modifyCSS(card, {
              marginLeft: containerWidth ? "".concat(containerWidth - cardWidth, "px") : "0px"
            });
            break;
          case "top":
          case "bottom":
            modifyCSS(card, {
              marginLeft: "8px"
            });
          default:
            break;
        }
      });
    };
    Annotation3.prototype.handleExpandCollapseCard = function(id) {
      if (this.destroyed)
        return;
      var graph = this.get("graph");
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var collapsed = cardInfoMap[id].collapsed;
      var item = graph.findById(id);
      if (!item)
        return;
      var collapseType = this.get("cardCfg").collapseType;
      if (collapseType === "hide" && !collapsed) {
        this.hideCard(id);
      } else {
        this.toggleAnnotation(item, {
          collapsed: !collapsed
        });
      }
      cardInfoMap[id] = __assign13(__assign13({}, cardInfoMap[id]), {
        collapsed: !collapsed
      });
    };
    Annotation3.prototype.hideCard = function(id) {
      if (this.destroyed)
        return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap || !cardInfoMap[id])
        return;
      var _a2 = cardInfoMap[id], card = _a2.card, link = _a2.link;
      modifyCSS(card, {
        display: "none"
      });
      link === null || link === void 0 ? void 0 : link.hide();
      var onAnnotationChange = this.get("onAnnotationChange");
      onAnnotationChange(cardInfoMap[id], "hide");
    };
    Annotation3.prototype.removeCard = function(id) {
      if (this.destroyed)
        return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var cardInfo = cardInfoMap[id];
      var card = cardInfo.card, link = cardInfo.link;
      var container = this.get("container");
      container.removeChild(card);
      link === null || link === void 0 ? void 0 : link.remove(true);
      delete cardInfoMap[id];
      var onAnnotationChange = this.get("onAnnotationChange");
      onAnnotationChange(cardInfo, "remove");
    };
    Annotation3.prototype.bindListener = function(card, itemId) {
      var _this = this;
      if (this.destroyed)
        return;
      card.addEventListener("mousemove", function(e8) {
        var iconType;
        if (e8.target.className === "g6-annotation-collapse") {
          iconType = "collapse";
        } else if (e8.target.className === "g6-annotation-expand") {
          iconType = "expand";
        } else if (e8.target.className === "g6-annotation-close") {
          iconType = "close";
        }
        if (iconType) {
          var _a2 = _this.get("cardCfg").onMouseEnterIcon, onMouseEnterIcon = _a2 === void 0 ? function() {
          } : _a2;
          onMouseEnterIcon(e8, itemId, iconType);
        }
      });
      card.addEventListener("mouseout", function(e8) {
        var iconType;
        if (e8.target.className === "g6-annotation-collapse") {
          iconType = "collapse";
        } else if (e8.target.className === "g6-annotation-expand") {
          iconType = "expand";
        } else if (e8.target.className === "g6-annotation-close") {
          iconType = "close";
        }
        if (iconType) {
          var _a2 = _this.get("cardCfg").onMouseLeaveIcon, onMouseLeaveIcon = _a2 === void 0 ? function() {
          } : _a2;
          onMouseLeaveIcon(e8, itemId, iconType);
        }
      });
      card.addEventListener("mouseenter", function(e8) {
        var cardInfoMap = _this.get("cardInfoMap");
        if (!cardInfoMap)
          return;
        var graph = _this.get("graph");
        var item = graph.findById(itemId);
        if (item) {
          var itemHighlightState = _this.get("itemHighlightState");
          graph.setItemState(item, itemHighlightState, true);
        }
        var link = cardInfoMap[itemId].link;
        if (link) {
          var linkHighlightStyle = _this.get("linkHighlightStyle") || {};
          link.attr(linkHighlightStyle);
        }
      });
      card.addEventListener("mouseleave", function(e8) {
        var cardInfoMap = _this.get("cardInfoMap");
        if (!cardInfoMap)
          return;
        var graph = _this.get("graph");
        var item = graph.findById(itemId);
        if (item) {
          var itemHighlightState = _this.get("itemHighlightState");
          graph.setItemState(item, itemHighlightState, false);
        }
        var link = cardInfoMap[itemId].link;
        if (link) {
          var linkHighlightStyle = _this.get("linkHighlightStyle") || {};
          Object.keys(linkHighlightStyle).forEach(function(key) {
            link.attr(key, void 0);
            link.attr(key, void 0);
          });
          var linkStyle = _this.get("linkStyle");
          link.attr(linkStyle);
        }
      });
      card.addEventListener("click", function(e8) {
        var onClickIcon = (_this.get("cardCfg") || {}).onClickIcon;
        if (e8.target.className === "g6-annotation-collapse" || e8.target.className === "g6-annotation-expand") {
          var collapseType = _this.get("cardCfg").collapseType;
          if (collapseType === "hide") {
            _this.hideCard(itemId);
          } else {
            _this.handleExpandCollapseCard(itemId);
          }
          onClickIcon === null || onClickIcon === void 0 ? void 0 : onClickIcon(e8, itemId, e8.target.className === "g6-annotation-collapse" ? "collapse" : "expand");
        } else if (e8.target.className === "g6-annotation-close") {
          var closeType = _this.get("cardCfg").closeType;
          if (closeType === "remove") {
            _this.removeCard(itemId);
          } else {
            _this.hideCard(itemId);
          }
          onClickIcon === null || onClickIcon === void 0 ? void 0 : onClickIcon(e8, itemId, "close");
        }
      });
      var editable = this.get("editable");
      if (editable) {
        card.addEventListener("dblclick", function(e8) {
          var cardInfoMap = _this.get("cardInfoMap");
          var _a2 = (_this.get("cardCfg") || {}).maxTitleLength, maxTitleLength = _a2 === void 0 ? 20 : _a2;
          if (!cardInfoMap)
            return;
          var target = e8.target;
          var targetClass = target.className;
          if (targetClass !== "g6-annotation-title" && targetClass !== "g6-annotation-content")
            return;
          var _b = targetClass === "g6-annotation-title" ? target.getBoundingClientRect() : target.parentNode.getBoundingClientRect(), width = _b.width, height = _b.height;
          var computeStyle = getComputedStyle(target);
          var inputTag = targetClass === "g6-annotation-title" ? "input" : "textarea";
          var input = createDom("<".concat(inputTag, ' class="').concat(targetClass, '-input" type="textarea" style="width:').concat(width, "px; height: ").concat(height, 'px; min-width: 16px;"/>'));
          var inputWrapper = createDom('<div class="'.concat(targetClass, '-input-wrapper" style="width: ').concat(width, "px; height: ").concat(height, "px; min-width: 16px; margin-right: ").concat(computeStyle["marginRight"], '" />'));
          inputWrapper.appendChild(input);
          target.parentNode.replaceChild(inputWrapper, target);
          var cardInfo = cardInfoMap[itemId];
          var contentPlaceholder = cardInfo.contentPlaceholder, titlePlaceholder = cardInfo.titlePlaceholder, content = cardInfo.content, title = cardInfo.title;
          var value = content;
          if (targetClass === "g6-annotation-title") {
            input.name = "title";
            input.maxLength = maxTitleLength;
            value = title;
          } else {
            input.name = "content";
          }
          if (value) {
            input.innerHTML = target.innerHTML;
            input.value = target.innerHTML;
          } else {
            input.placeholder = targetClass === "g6-annotation-title" ? titlePlaceholder : contentPlaceholder;
          }
          input.focus();
          input.addEventListener("blur", function(blurEvt) {
            if (input.value) {
              target.innerHTML = input.value;
              cardInfo[input.name || "title"] = input.value;
            }
            inputWrapper.parentNode.replaceChild(target, inputWrapper);
            _this.updateCardSize(itemId);
            var onAnnotationChange = _this.get("onAnnotationChange");
            onAnnotationChange === null || onAnnotationChange === void 0 ? void 0 : onAnnotationChange(cardInfo, "update");
          });
        });
      }
      var unmovableClasses = ["g6-annotation-title", "g6-annotation-content", "g6-annotation-title-input", "g6-annotation-content-input"];
      card.draggable = true;
      card.addEventListener("dragstart", function(e8) {
        var targetClass = e8.target.className;
        if (unmovableClasses.includes(targetClass))
          return;
        var style = card.style;
        _this.set("dragging", {
          card,
          x: e8.clientX,
          y: e8.clientY,
          left: px2Num(style.left),
          top: px2Num(style.top)
        });
      });
      card.addEventListener("drag", function(e8) {
        e8.preventDefault();
        var cardInfoMap = _this.get("cardInfoMap");
        if (!cardInfoMap)
          return;
        var clientX = e8.clientX, clientY = e8.clientY;
        var dragging = _this.get("dragging");
        if (isNaN(clientX) || isNaN(clientY) || !dragging)
          return;
        var x4 = dragging.x, y4 = dragging.y, left = dragging.left, top = dragging.top, draggingCard = dragging.card;
        var dx = clientX - x4;
        var dy = clientY - y4;
        left += dx;
        top += dy;
        var graph = _this.get("graph");
        var graphLeftTopCanvas = graph.getPointByCanvas(0, 0);
        var graphRightBottomCanvas = graph.getPointByCanvas(graph.getWidth(), graph.getHeight());
        var _a2 = graph.getClientByPoint(graphLeftTopCanvas.x, graphLeftTopCanvas.y), graphLeft = _a2.x, graphTop = _a2.y;
        var _b = graph.getClientByPoint(graphRightBottomCanvas.x, graphRightBottomCanvas.y), graphRight = _b.x, graphBottom = _b.y;
        var cardBBox = draggingCard.getBoundingClientRect();
        var cardWidth = cardBBox.right - cardBBox.left;
        var cardHeight = cardBBox.bottom - cardBBox.top;
        if (left > graphRight - graphLeft - cardWidth && dx > 0 || left < 0 && dx < 0)
          left -= dx;
        if (top > graphBottom - graphTop - cardHeight && dy > 0 || top < 0 && dy < 0)
          top -= dy;
        modifyCSS(draggingCard, {
          left: "".concat(left, "px"),
          top: "".concat(top, "px"),
          visibility: "hidden"
        });
        x4 = clientX;
        y4 = clientY;
        var link = (cardInfoMap[itemId] || {}).link;
        if (link) {
          var item = graph.findById(itemId);
          link.attr("path", getPathItem2Card(item, cardBBox, graph, _this.get("canvas")));
        }
        _this.set("dragging", {
          x: x4,
          y: y4,
          left,
          top,
          card: draggingCard
        });
      });
      var dragendListener = function dragendListener2(e8) {
        var cardInfoMap = _this.get("cardInfoMap");
        if (!cardInfoMap)
          return;
        var dragging = _this.get("dragging");
        if (dragging) {
          var left = dragging.left, top_1 = dragging.top, draggingCard = dragging.card;
          cardInfoMap[itemId].x = left;
          cardInfoMap[itemId].y = top_1;
          modifyCSS(draggingCard, {
            visibility: "visible"
          });
          _this.set("dragging", false);
          var rows = _this.get("rows");
          rows === null || rows === void 0 ? void 0 : rows.forEach(function(rowItems) {
            for (var i2 = rowItems.length - 1; i2 >= 0; i2--) {
              if (rowItems[i2].id === itemId)
                rowItems.splice(i2, 1);
            }
          });
          var onAnnotationChange = _this.get("onAnnotationChange");
          onAnnotationChange === null || onAnnotationChange === void 0 ? void 0 : onAnnotationChange(cardInfoMap[itemId], "update");
        }
      };
      card.addEventListener("dragend", dragendListener);
    };
    Annotation3.prototype.updateCardSize = function(id) {
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var card = cardInfoMap[id].card;
      var width = card.getBoundingClientRect().width;
      var title = card.getElementsByClassName("g6-annotation-title")[0];
      if (title) {
        var computeStyle = getComputedStyle(title);
        var sideMargin = px2Num(computeStyle["marginLeft"]);
        var titleWidth = title.getBoundingClientRect().width;
        modifyCSS(title, {
          marginRight: "".concat(width - sideMargin - 24 - 16 - titleWidth, "px")
        });
      }
    };
    Annotation3.prototype.updateLink = function(_a2) {
      var item = _a2.item;
      if (!item)
        return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var canvas = this.get("canvas");
      var graph = this.get("graph");
      var id = item.getID();
      var _b = cardInfoMap[id] || {}, link = _b.link, card = _b.card;
      if (link) {
        var path = getPathItem2Card(item, card.getBoundingClientRect(), graph, canvas);
        link.attr("path", path);
      }
    };
    Annotation3.prototype.updateLinks = function() {
      var _this = this;
      if (this.destroyed)
        return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var graph = this.get("graph");
      Object.values(cardInfoMap).forEach(function(cardInfo) {
        var id = cardInfo.id;
        var item = graph.findById(id);
        _this.updateLink({
          item
        });
      });
    };
    Annotation3.prototype.onGraphDataChange = function() {
      var _this = this;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var graph = this.get("graph");
      Object.values(cardInfoMap).forEach(function(info) {
        var id = info.id, card = info.card, isCanvas = info.isCanvas;
        if (!card || isCanvas || card.style.display === "none")
          return;
        var item = graph.findById(id);
        if (item && item.isVisible()) {
          _this.toggleAnnotation(item);
        } else {
          _this.hideCard(id);
        }
      });
    };
    Annotation3.prototype.onGraphItemVisibilityChange = function(_a2) {
      var item = _a2.item, visible = _a2.visible;
      if (!item || item.destroyed)
        return;
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var id = item.getID();
      if (!cardInfoMap[id])
        return;
      if (!visible)
        this.hideCard(id);
    };
    Annotation3.prototype.saveData = function(saveClosed) {
      if (saveClosed === void 0) {
        saveClosed = false;
      }
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var graph = this.get("graph");
      var getTitle = this.get("getTitle");
      var getContent = this.get("getContent");
      var data = [];
      Object.values(cardInfoMap).forEach(function(info) {
        var title = info.title, content = info.content, x4 = info.x, y4 = info.y, id = info.id, collapsed = info.collapsed, card = info.card;
        if (card && card.style.display === "none" && !saveClosed)
          return;
        var item = graph.findById(id) || graph.get("canvas");
        data.push({
          id,
          x: x4,
          y: y4,
          collapsed,
          title: title || (getTitle === null || getTitle === void 0 ? void 0 : getTitle(item)),
          content: content || (getContent === null || getContent === void 0 ? void 0 : getContent(item)),
          visible: card && card.style.display !== "none"
        });
      });
      return data;
    };
    Annotation3.prototype.readData = function(data) {
      var _this = this;
      var graph = this.get("graph");
      data.forEach(function(info) {
        var id = info.id, x4 = info.x, y4 = info.y, title = info.title, content = info.content, collapsed = info.collapsed, visible = info.visible;
        var item = graph.findById(id);
        if (!item && id === CANVAS_ANNOTATION_ID) {
          item = graph.get("canvas");
        }
        if (!item) {
          var cardInfoMap = _this.get("cardInfoMap") || {};
          cardInfoMap[id] = info;
          _this.set("cardInfoMap", cardInfoMap);
          return;
        }
        _this.toggleAnnotation(item, {
          x: x4,
          y: y4,
          title,
          content,
          collapsed
        });
        if (!visible)
          _this.hideCard(id);
      });
    };
    Annotation3.prototype.clear = function() {
      var cardInfoMap = this.get("cardInfoMap");
      if (!cardInfoMap)
        return;
      var container = this.get("container");
      Object.values(cardInfoMap).forEach(function(cardInfo) {
        var card = cardInfo.card, link = cardInfo.link;
        container.removeChild(card);
        link === null || link === void 0 ? void 0 : link.remove(true);
      });
      this.set("cardInfoMap", {});
    };
    Annotation3.prototype.destroy = function() {
      var _a2;
      this.clear();
      (_a2 = this.get("canvas")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      var graph = this.get("graph");
      if (!graph || graph.destroyed)
        return;
      if (this.get("containerCfg")) {
        graph.getContainer().removeChild(this.get("container"));
      }
      this.destroyed = true;
    };
    return Annotation3;
  }(base_default2)
);
var annotation_default = Annotation;
var getPath6 = function getPath7(startPoints, endPoints) {
  var startPoint, endPoint, posKeys, distance6 = Infinity;
  Object.keys(startPoints).forEach(function(skey) {
    var spos = startPoints[skey];
    Object.keys(endPoints).forEach(function(ekey) {
      var epos = endPoints[ekey];
      var xdist = spos.x - epos.x;
      var ydist = spos.y - epos.y;
      var dist = xdist * xdist + ydist * ydist;
      if (distance6 > dist) {
        distance6 = dist;
        startPoint = spos;
        endPoint = epos;
        posKeys = [skey, ekey];
      }
    });
  });
  var curveOffset = 20;
  var controlPoint = util_default.getControlPoint(startPoint, endPoint, 0.5, curveOffset);
  return [["M", startPoint.x, startPoint.y], ["Q", controlPoint.x, controlPoint.y, endPoint.x, endPoint.y]];
};
var getPathItem2Card = function getPathItem2Card2(item, cardBBox, graph, annotationCanvas) {
  var _a2;
  var itemLinkPoints;
  var itemType = item.getType();
  if (itemType === "edge") {
    itemLinkPoints = [item.getKeyShape().getPoint(0.5)];
  } else {
    var _b = (_a2 = item.getKeyShape) === null || _a2 === void 0 ? void 0 : _a2.call(item).getBBox(), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
    var _c = item.getModel(), x4 = _c.x, y4 = _c.y;
    minX += x4;
    minY += y4;
    maxX += x4;
    maxY += y4;
    itemLinkPoints = {
      left: {
        x: minX,
        y: (minY + maxY) / 2
      },
      right: {
        x: maxX,
        y: (minY + maxY) / 2
      },
      top: {
        x: (minX + maxX) / 2,
        y: minY
      },
      bottom: {
        x: (minX + maxX) / 2,
        y: maxY
      }
    };
  }
  Object.keys(itemLinkPoints).forEach(function(key) {
    var _a3 = itemLinkPoints[key], x5 = _a3.x, y5 = _a3.y;
    var clientPos = graph.getClientByPoint(x5, y5);
    itemLinkPoints[key] = annotationCanvas.getPointByClient(clientPos.x, clientPos.y);
  });
  var _d = cardBBox.top, cardTop = _d === void 0 ? 0 : _d, _e2 = cardBBox.left, cardLeft = _e2 === void 0 ? 0 : _e2, _f = cardBBox.right, cardRight = _f === void 0 ? 0 : _f, _g = cardBBox.bottom, cardBottom = _g === void 0 ? 0 : _g;
  var cardLinkPoints = {
    left: annotationCanvas.getPointByClient(cardLeft, (cardTop + cardBottom) / 2),
    right: annotationCanvas.getPointByClient(cardRight, (cardTop + cardBottom) / 2),
    top: annotationCanvas.getPointByClient((cardLeft + cardRight) / 2, cardTop),
    bottom: annotationCanvas.getPointByClient((cardLeft + cardRight) / 2, cardBottom)
  };
  return getPath6(itemLinkPoints, cardLinkPoints);
};
var px2Num = function px2Num2(px) {
  return Number(px.replace(/\s+|px/gi, "")) || 0;
};

// node_modules/@antv/g6-plugin/es/index.js
var Plugin = {
  PluginBase: base_default2,
  Menu: menu_default,
  Grid: grid_default,
  Minimap: minimap_default,
  Bundling: bundling_default,
  ToolBar: toolBar_default,
  Tooltip: tooltip_default,
  Fisheye: fisheye_default,
  TimeBar: timeBar_default,
  ImageMinimap: imageMinimap_default,
  EdgeFilterLens: edgeFilterLens_default,
  SnapLine: snapline_default,
  Legend: legend_default,
  Annotation: annotation_default
};
var es_default3 = Plugin;

// node_modules/@antv/g6-pc/es/plugin/index.js
var plugin_default = es_default3;

// node_modules/@antv/g6-element/es/nodes/circle.js
init_tslib_es6();
init_esm();
registerNode("circle", {
  // 自定义节点时的配置
  options: {
    size: BaseGlobal.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "circle",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape11(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, defaultIcon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var icon = deep_mix_default({}, defaultIcon, cfg.icon);
    var name = "".concat(this.type, "-keyShape");
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: name,
      name,
      draggable: true
    });
    group["shapeMap"][name] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      var iconName = "".concat(this.type, "-icon");
      if (text) {
        group["shapeMap"][iconName] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: iconName,
          name: iconName,
          draggable: true
        });
      } else {
        group["shapeMap"][iconName] = group.addShape("image", {
          attrs: __assign({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: iconName,
          name: iconName,
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints(cfg, group) {
    var linkPoints = (this.mergeStyle || this.getOptions(cfg)).linkPoints;
    if (!linkPoints)
      return;
    var _a2 = linkPoints || {}, top = _a2.top, left = _a2.left, right = _a2.right, bottom = _a2.bottom, markSize = _a2.size, markR = _a2.r, markStyle = __rest(_a2, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var r2 = size3[0] / 2;
    if (left) {
      var name_1 = "link-point-left";
      group["shapeMap"][name_1] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -r2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: name_1,
        name: name_1,
        isAnchorPoint: true
      });
    }
    if (right) {
      var name_2 = "link-point-right";
      group["shapeMap"][name_2] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: r2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: name_2,
        name: name_2,
        isAnchorPoint: true
      });
    }
    if (top) {
      var name_3 = "link-point-top";
      group["shapeMap"][name_3] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -r2,
          r: markSize / 2 || markR || 5
        }),
        className: name_3,
        name: name_3,
        isAnchorPoint: true
      });
    }
    if (bottom) {
      var name_4 = "link-point-bottom";
      group["shapeMap"][name_4] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: r2,
          r: markSize / 2 || markR || 5
        }),
        className: name_4,
        name: name_4,
        isAnchorPoint: true
      });
    }
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle8(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = deep_mix_default({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var r2 = size3[0] / 2;
    var styles = __assign({
      x: 0,
      y: 0,
      r: r2
    }, style);
    return styles;
  },
  update: function update6(cfg, item, updateType) {
    var group = item.getContainer();
    var size3 = this.getSize(cfg);
    var style = __assign({}, cfg.style);
    if (cfg.style.stroke === void 0 && cfg.color) {
      style.stroke = cfg.color;
    }
    if (cfg.style.r === void 0 && !isNaN(size3[0])) {
      style.r = size3[0] / 2;
    }
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/rect.js
init_tslib_es6();
init_esm();
registerNode("rect", {
  // 自定义节点时的配置
  options: {
    size: [100, 30],
    style: {
      radius: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    // 连接点，默认为左右
    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "rect",
  labelPosition: "center",
  drawShape: function drawShape12(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints2(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle9(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var width = style.width || size3[0];
    var height = style.height || size3[1];
    var styles = __assign({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update7(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var size3 = this.getSize(cfg);
    var keyShape = item.get("keyShape");
    if (!cfg.size) {
      size3[0] = keyShape.attr("width") || defaultStyle.width;
      size3[1] = keyShape.attr("height") || defaultStyle.height;
    }
    var strokeStyle = {
      stroke: cfg.color,
      x: -size3[0] / 2,
      y: -size3[1] / 2,
      width: size3[0],
      height: size3[1]
    };
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, false, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/ellipse.js
init_tslib_es6();
init_esm();
registerNode("ellipse", {
  // 自定义节点时的配置
  options: {
    size: [80, 40],
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "ellipse",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape13(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("ellipse", {
      attrs: style,
      className: "ellipse-keyShape",
      name: "ellipse-keyShape",
      draggable: true
    });
    group["shapeMap"]["ellipse-keyShape"] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints3(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var rx = size3[0] / 2;
    var ry = size3[1] / 2;
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -rx,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: rx,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -ry,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: ry,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle10(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var rx = size3[0] / 2;
    var ry = size3[1] / 2;
    var styles = __assign({
      x: 0,
      y: 0,
      rx,
      ry
    }, style);
    return styles;
  },
  update: function update8(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var size3 = this.getSize(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      rx: size3[0] / 2,
      ry: size3[1] / 2
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/diamond.js
init_tslib_es6();
init_esm();
registerNode("diamond", {
  // 自定义节点时的配置
  options: {
    size: [80, 80],
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "diamond",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape14(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: -w2 / 2,
            y: -h2 / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints4(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  getPath: function getPath8(cfg) {
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    var path = [
      ["M", 0, -height / 2],
      ["L", width / 2, 0],
      ["L", 0, height / 2],
      ["L", -width / 2, 0],
      ["Z"]
      // 封闭
    ];
    return path;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle11(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign({
      path
    }, style);
    return styles;
  },
  update: function update9(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/triangle.js
init_tslib_es6();
init_esm();
registerNode("triangle", {
  // 自定义节点时的配置
  options: {
    size: 40,
    direction: "up",
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize
      },
      offset: 15
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20,
      offset: 6
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "triangle",
  // 文本位置
  labelPosition: "bottom",
  drawShape: function drawShape15(cfg, group) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.icon, icon = _b === void 0 ? {} : _b, defaultDirection = _a2.direction;
    var style = this.getShapeStyle(cfg);
    var direction2 = cfg.direction || defaultDirection;
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, offset = icon.offset, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        var iconW = -w2 / 2;
        var iconH = -h2 / 2;
        if (direction2 === "up" || direction2 === "down") {
          iconH += offset;
        }
        if (direction2 === "left" || direction2 === "right") {
          iconW += offset;
        }
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: iconW,
            y: iconH
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints5(cfg, group) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.linkPoints, linkPoints = _b === void 0 ? {} : _b, defaultDirection = _a2.direction;
    var direction2 = cfg.direction || defaultDirection;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var len = size3[0];
    if (left) {
      var leftPos = null;
      var diffY = len * Math.sin(1 / 3 * Math.PI);
      var r2 = len * Math.sin(1 / 3 * Math.PI);
      if (direction2 === "up") {
        leftPos = [-r2, diffY];
      } else if (direction2 === "down") {
        leftPos = [-r2, -diffY];
      } else if (direction2 === "left") {
        leftPos = [-r2, r2 - diffY];
      }
      if (leftPos) {
        group["shapeMap"]["link-point-left"] = group.addShape("circle", {
          attrs: __assign(__assign({}, markStyle), {
            x: leftPos[0],
            y: leftPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-left",
          name: "link-point-left"
        });
      }
    }
    if (right) {
      var rightPos = null;
      var diffY = len * Math.sin(1 / 3 * Math.PI);
      var r2 = len * Math.sin(1 / 3 * Math.PI);
      if (direction2 === "up") {
        rightPos = [r2, diffY];
      } else if (direction2 === "down") {
        rightPos = [r2, -diffY];
      } else if (direction2 === "right") {
        rightPos = [r2, r2 - diffY];
      }
      if (rightPos) {
        group["shapeMap"]["link-point-right"] = group.addShape("circle", {
          attrs: __assign(__assign({}, markStyle), {
            x: rightPos[0],
            y: rightPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-right",
          name: "link-point-right"
        });
      }
    }
    if (top) {
      var topPos = null;
      var diffY = len * Math.sin(1 / 3 * Math.PI);
      var r2 = len * Math.sin(1 / 3 * Math.PI);
      if (direction2 === "up") {
        topPos = [r2 - diffY, -diffY];
      } else if (direction2 === "left") {
        topPos = [r2, -diffY];
      } else if (direction2 === "right") {
        topPos = [-r2, -diffY];
      }
      if (topPos) {
        group["shapeMap"]["link-point-top"] = group.addShape("circle", {
          attrs: __assign(__assign({}, markStyle), {
            x: topPos[0],
            y: topPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-top",
          name: "link-point-top"
        });
      }
    }
    if (bottom) {
      var bottomPos = null;
      var diffY = len * Math.sin(1 / 3 * Math.PI);
      var r2 = len * Math.sin(1 / 3 * Math.PI);
      if (direction2 === "down") {
        bottomPos = [-r2 + diffY, diffY];
      } else if (direction2 === "left") {
        bottomPos = [r2, diffY];
      } else if (direction2 === "right") {
        bottomPos = [-r2, diffY];
      }
      if (bottomPos) {
        group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
          attrs: __assign(__assign({}, markStyle), {
            x: bottomPos[0],
            y: bottomPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-bottom",
          name: "link-point-bottom"
        });
      }
    }
  },
  getPath: function getPath9(cfg) {
    var defaultDirection = (this.mergeStyle || this.getOptions(cfg)).direction;
    var direction2 = cfg.direction || defaultDirection;
    var size3 = this.getSize(cfg);
    var len = size3[0];
    var diffY = len * Math.sin(1 / 3 * Math.PI);
    var r2 = len * Math.sin(1 / 3 * Math.PI);
    var path = [
      ["M", -r2, diffY],
      ["L", 0, -diffY],
      ["L", r2, diffY],
      ["Z"]
      // 封闭
    ];
    if (direction2 === "down") {
      path = [
        ["M", -r2, -diffY],
        ["L", r2, -diffY],
        ["L", 0, diffY],
        ["Z"]
        // 封闭
      ];
    } else if (direction2 === "left") {
      path = [
        ["M", -r2, r2 - diffY],
        ["L", r2, -r2],
        ["L", r2, r2],
        ["Z"]
        // 封闭
      ];
    } else if (direction2 === "right") {
      path = [
        ["M", r2, r2 - diffY],
        ["L", -r2, r2],
        ["L", -r2, -r2],
        ["Z"]
        // 封闭
      ];
    }
    return path;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle12(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign({
      path
    }, style);
    return styles;
  },
  update: function update10(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  },
  /**
   * 更新linkPoints
   * @param {Object} cfg 节点数据配置项
   * @param {Group} group Item所在的group
   */
  updateLinkPoints: function updateLinkPoints2(cfg, group) {
    var _a2 = this.getOptions({}), defaultLinkPoints = _a2.linkPoints, defaultDirection = _a2.direction;
    var direction2 = cfg.direction || defaultDirection;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markBottom = group["shapeMap"]["link-point-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-bottom";
    });
    var currentLinkPoints = defaultLinkPoints;
    var existLinkPoint = markLeft || markRight || markTop || markBottom;
    if (existLinkPoint) {
      currentLinkPoints = existLinkPoint.attr();
    }
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize)
      markSize = linkPoints.r;
    var _b = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0
    }, left = _b.left, right = _b.right, top = _b.top, bottom = _b.bottom;
    var size3 = this.getSize(cfg);
    var len = size3[0];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    var leftPos = null;
    var diffY = len * Math.sin(1 / 3 * Math.PI);
    var r2 = len * Math.sin(1 / 3 * Math.PI);
    if (direction2 === "up") {
      leftPos = [-r2, diffY];
    } else if (direction2 === "down") {
      leftPos = [-r2, -diffY];
    } else if (direction2 === "left") {
      leftPos = [-r2, r2 - diffY];
    }
    if (leftPos) {
      if (markLeft) {
        if (!left && left !== void 0) {
          markLeft.remove();
          delete group["shapeMap"]["link-point-left"];
        } else {
          markLeft.attr(__assign(__assign({}, styles), {
            x: leftPos[0],
            y: leftPos[1]
          }));
        }
      } else if (left) {
        group["shapeMap"]["link-point-left"] = group.addShape("circle", {
          attrs: __assign(__assign({}, styles), {
            x: leftPos[0],
            y: leftPos[1]
          }),
          className: "link-point-left",
          name: "link-point-left",
          isAnchorPoint: true
        });
      }
    }
    var rightPos = null;
    if (direction2 === "up") {
      rightPos = [r2, diffY];
    } else if (direction2 === "down") {
      rightPos = [r2, -diffY];
    } else if (direction2 === "right") {
      rightPos = [r2, r2 - diffY];
    }
    if (rightPos) {
      if (markRight) {
        if (!right && right !== void 0) {
          markRight.remove();
          delete group["shapeMap"]["link-point-right"];
        } else {
          markRight.attr(__assign(__assign({}, styles), {
            x: rightPos[0],
            y: rightPos[1]
          }));
        }
      } else if (right) {
        group["shapeMap"]["link-point-right"] = group.addShape("circle", {
          attrs: __assign(__assign({}, styles), {
            x: rightPos[0],
            y: rightPos[1]
          }),
          className: "link-point-right",
          name: "link-point-right",
          isAnchorPoint: true
        });
      }
    }
    var topPos = null;
    if (direction2 === "up") {
      topPos = [r2 - diffY, -diffY];
    } else if (direction2 === "left") {
      topPos = [r2, -diffY];
    } else if (direction2 === "right") {
      topPos = [-r2, -diffY];
    }
    if (topPos) {
      if (markTop) {
        if (!top && top !== void 0) {
          markTop.remove();
          delete group["shapeMap"]["link-point-top"];
        } else {
          markTop.attr(__assign(__assign({}, styles), {
            x: topPos[0],
            y: topPos[1]
          }));
        }
      } else if (top) {
        group["shapeMap"]["link-point-top"] = group.addShape("circle", {
          attrs: __assign(__assign({}, styles), {
            x: topPos[0],
            y: topPos[1]
          }),
          className: "link-point-top",
          name: "link-point-top",
          isAnchorPoint: true
        });
      }
    }
    var bottomPos = null;
    if (direction2 === "down") {
      bottomPos = [-r2 + diffY, diffY];
    } else if (direction2 === "left") {
      bottomPos = [r2, diffY];
    } else if (direction2 === "right") {
      bottomPos = [-r2, diffY];
    }
    if (bottomPos) {
      if (markBottom) {
        if (!bottom && bottom !== void 0) {
          markBottom.remove();
          delete group["shapeMap"]["link-point-bottom"];
        } else {
          markBottom.attr(__assign(__assign({}, styles), {
            x: bottomPos[0],
            y: bottomPos[1]
          }));
        }
      } else if (bottom) {
        group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
          attrs: __assign(__assign({}, styles), {
            x: bottomPos[0],
            y: bottomPos[1]
          }),
          className: "link-point-bottom",
          name: "link-point-bottom",
          isAnchorPoint: true
        });
      }
    }
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/modelRect.js
init_tslib_es6();
init_esm();
registerNode("modelRect", {
  // 自定义节点时的配置
  options: {
    size: [185, 70],
    style: {
      radius: 5,
      stroke: "#69c0ff",
      fill: "#ffffff",
      lineWidth: BaseGlobal.defaultNode.style.lineWidth,
      fillOpacity: 1
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: "#595959",
        fontSize: 14,
        fontFamily: BaseGlobal.windowFontFamily
      },
      offset: 30
      // 距离左侧的 offset，没有设置 y 轴上移动的配置
    },
    descriptionCfg: {
      style: {
        fontSize: 12,
        fill: "#bfbfbf",
        fontFamily: BaseGlobal.windowFontFamily
      },
      paddingTop: 0
    },
    preRect: {
      show: true,
      width: 4,
      fill: "#40a9ff",
      radius: 2
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: 10,
      lineWidth: 1,
      fill: "#72CC4A",
      stroke: "#72CC4A"
    },
    // 节点中icon配置
    logoIcon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: true,
      x: 0,
      y: 0,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/basement_prod/4f81893c-1806-4de4-aff3-9a6b266bc8a2.svg",
      width: 16,
      height: 16,
      // 用于调整图标的左右位置
      offset: 0
    },
    // 节点中表示状态的icon配置
    stateIcon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: true,
      x: 0,
      y: 0,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/basement_prod/300a2523-67e0-4cbf-9d4a-67c077b40395.svg",
      width: 16,
      height: 16,
      // 用于调整图标的左右位置
      offset: -5
    },
    // 连接点，默认为左右
    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]
    anchorPoints: [[0, 0.5], [1, 0.5]]
  },
  shapeType: "modelRect",
  drawShape: function drawShape16(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).preRect, preRect = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var preRectShow = preRect.show, preRectStyle = __rest(preRect, ["show"]);
    if (preRectShow) {
      group["shapeMap"]["pre-rect"] = group.addShape("rect", {
        attrs: __assign({
          x: -width / 2,
          y: -height / 2,
          height
        }, preRectStyle),
        className: "pre-rect",
        name: "pre-rect",
        draggable: true
      });
    }
    this.drawLogoIcon(cfg, group);
    this.drawStateIcon(cfg, group);
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制模型矩形左边的logo图标
   * @param {Object} cfg 数据配置项
   * @param {Group} group Group实例
   */
  drawLogoIcon: function drawLogoIcon(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).logoIcon, logoIcon = _a2 === void 0 ? {} : _a2;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    if (logoIcon.show) {
      var w2 = logoIcon.width, h2 = logoIcon.height, x4 = logoIcon.x, y4 = logoIcon.y, offset = logoIcon.offset, text = logoIcon.text, logoIconStyle = __rest(logoIcon, ["width", "height", "x", "y", "offset", "text"]);
      if (text) {
        group["shapeMap"]["rect-logo-icon"] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, logoIconStyle),
          className: "rect-logo-icon",
          name: "rect-logo-icon",
          draggable: true
        });
      } else {
        group["shapeMap"]["rect-logo-icon"] = group.addShape("image", {
          attrs: __assign(__assign({}, logoIconStyle), {
            x: x4 || -width / 2 + w2 + offset,
            y: y4 || -h2 / 2,
            width: w2,
            height: h2
          }),
          className: "rect-logo-icon",
          name: "rect-logo-icon",
          draggable: true
        });
      }
    }
  },
  /**
   * 绘制模型矩形右边的状态图标
   * @param {Object} cfg 数据配置项
   * @param {Group} group Group实例
   */
  drawStateIcon: function drawStateIcon(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).stateIcon, stateIcon = _a2 === void 0 ? {} : _a2;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    if (stateIcon.show) {
      var w2 = stateIcon.width, h2 = stateIcon.height, x4 = stateIcon.x, y4 = stateIcon.y, offset = stateIcon.offset, text = stateIcon.text, iconStyle = __rest(stateIcon, ["width", "height", "x", "y", "offset", "text"]);
      if (text) {
        group["shapeMap"]["rect-state-icon"] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, iconStyle),
          className: "rect-state-icon",
          name: "rect-state-icon",
          draggable: true
        });
      } else {
        group["shapeMap"]["rect-state-icon"] = group.addShape("image", {
          attrs: __assign(__assign({}, iconStyle), {
            x: x4 || width / 2 - w2 + offset,
            y: y4 || -h2 / 2,
            width: w2,
            height: h2
          }),
          className: "rect-state-icon",
          name: "rect-state-icon",
          draggable: true
        });
      }
    }
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints6(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  drawLabel: function drawLabel3(cfg, group) {
    var _a2 = this.getOptions(cfg), _b = _a2.labelCfg, labelCfg = _b === void 0 ? {} : _b, _c = _a2.logoIcon, logoIcon = _c === void 0 ? {} : _c, _d = _a2.descriptionCfg, descriptionCfg = _d === void 0 ? {} : _d;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var label = null;
    var show = logoIcon.show, w2 = logoIcon.width;
    var offsetX = -width / 2 + labelCfg.offset;
    if (show) {
      offsetX = -width / 2 + w2 + labelCfg.offset;
    }
    var fontStyle = labelCfg.style;
    var descriptionStyle = descriptionCfg.style, descriptionPaddingTop = descriptionCfg.paddingTop;
    if (is_string_default(cfg.description)) {
      label = group.addShape("text", {
        attrs: __assign(__assign({}, fontStyle), {
          x: offsetX,
          y: -5,
          text: cfg.label
        }),
        className: "text-shape",
        name: "text-shape",
        draggable: true,
        labelRelated: true
      });
      group["shapeMap"]["text-shape"] = label;
      group["shapeMap"]["rect-description"] = group.addShape("text", {
        attrs: __assign(__assign({}, descriptionStyle), {
          x: offsetX,
          y: 17 + (descriptionPaddingTop || 0),
          text: cfg.description
        }),
        className: "rect-description",
        name: "rect-description",
        draggable: true,
        labelRelated: true
      });
    } else {
      label = group.addShape("text", {
        attrs: __assign(__assign({}, fontStyle), {
          x: offsetX,
          y: 7,
          text: cfg.label
        }),
        className: "text-shape",
        name: "text-shape",
        draggable: true,
        labelRelated: true
      });
      group["shapeMap"]["text-shape"] = label;
    }
    return label;
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle13(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size3 = this.getSize(cfg);
    var width = style.width || size3[0];
    var height = style.height || size3[1];
    var styles = __assign({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update11(cfg, item) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.style, style = _b === void 0 ? {} : _b, _c = _a2.labelCfg, labelCfg = _c === void 0 ? {} : _c, _d = _a2.descriptionCfg, descriptionCfg = _d === void 0 ? {} : _d;
    var size3 = this.getSize(cfg);
    var width = size3[0];
    var height = size3[1];
    var keyShape = item.get("keyShape");
    keyShape.attr(__assign(__assign({}, style), {
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }));
    var group = item.getContainer();
    var logoIconShape = group["shapeMap"]["rect-logo-icon"] || group.find(function(element) {
      return element.get("className") === "rect-logo-icon";
    });
    var currentLogoIconAttr = logoIconShape ? logoIconShape.attr() : {};
    var logoIcon = mix({}, currentLogoIconAttr, cfg.logoIcon);
    var w2 = logoIcon.width;
    if (w2 === void 0) {
      w2 = this.options.logoIcon.width;
    }
    var show = cfg.logoIcon ? cfg.logoIcon.show : void 0;
    var offset = labelCfg.offset;
    var offsetX = -width / 2 + w2 + offset;
    if (!show && show !== void 0) {
      offsetX = -width / 2 + offset;
    }
    var label = group["shapeMap"]["node-label"] || group.find(function(element) {
      return element.get("className") === "node-label";
    });
    var description = group["shapeMap"]["rect-description"] || group.find(function(element) {
      return element.get("className") === "rect-description";
    });
    if (cfg.label) {
      if (!label) {
        group["shapeMap"]["node-label"] = group.addShape("text", {
          attrs: __assign(__assign({}, labelCfg.style), {
            x: offsetX,
            y: cfg.description ? -5 : 7,
            text: cfg.label
          }),
          className: "node-label",
          name: "node-label",
          draggable: true,
          labelRelated: true
        });
      } else {
        var cfgStyle = cfg.labelCfg ? cfg.labelCfg.style : {};
        var labelStyle = mix({}, label.attr(), cfgStyle);
        if (cfg.label)
          labelStyle.text = cfg.label;
        labelStyle.x = offsetX;
        if (is_string_default(cfg.description))
          labelStyle.y = -5;
        if (description) {
          description.resetMatrix();
          description.attr({
            x: offsetX
          });
        }
        label.resetMatrix();
        label.attr(labelStyle);
      }
    }
    if (is_string_default(cfg.description)) {
      var paddingTop = descriptionCfg.paddingTop;
      if (!description) {
        group["shapeMap"]["rect-description"] = group.addShape("text", {
          attrs: __assign(__assign({}, descriptionCfg.style), {
            x: offsetX,
            y: 17 + (paddingTop || 0),
            text: cfg.description
          }),
          className: "rect-description",
          name: "rect-description",
          draggable: true,
          labelRelated: true
        });
      } else {
        var cfgStyle = cfg.descriptionCfg ? cfg.descriptionCfg.style : {};
        var descriptionStyle = mix({}, description.attr(), cfgStyle);
        if (is_string_default(cfg.description))
          descriptionStyle.text = cfg.description;
        descriptionStyle.x = offsetX;
        description.resetMatrix();
        description.attr(__assign(__assign({}, descriptionStyle), {
          y: 17 + (paddingTop || 0)
        }));
      }
    }
    var preRectShape = group["shapeMap"]["pre-rect"] || group.find(function(element) {
      return element.get("className") === "pre-rect";
    });
    if (preRectShape && !preRectShape.destroyed) {
      var preRect = mix({}, preRectShape.attr(), cfg.preRect);
      preRectShape.attr(__assign(__assign({}, preRect), {
        x: -width / 2,
        y: -height / 2,
        height
      }));
    }
    if (logoIconShape && !logoIconShape.destroyed) {
      if (!show && show !== void 0) {
        logoIconShape.remove();
        delete group["shapeMap"]["pre-rect"];
      } else {
        var logoW = logoIcon.width, h2 = logoIcon.height, x4 = logoIcon.x, y4 = logoIcon.y, logoOffset = logoIcon.offset, logoIconStyle = __rest(logoIcon, ["width", "height", "x", "y", "offset"]);
        logoIconShape.attr(__assign(__assign({}, logoIconStyle), {
          x: x4 || -width / 2 + logoW + logoOffset,
          y: y4 || -h2 / 2,
          width: logoW,
          height: h2
        }));
      }
    } else if (show) {
      this.drawLogoIcon(cfg, group);
    }
    var stateIconShape = group["shapeMap"]["rect-state-icon"] || group.find(function(element) {
      return element.get("className") === "rect-state-icon";
    });
    var currentStateIconAttr = stateIconShape ? stateIconShape.attr() : {};
    var stateIcon = mix({}, currentStateIconAttr, cfg.stateIcon);
    if (stateIconShape) {
      if (!stateIcon.show && stateIcon.show !== void 0) {
        stateIconShape.remove();
        delete group["shapeMap"]["rect-state-icon"];
      }
      var stateW = stateIcon.width, h2 = stateIcon.height, x4 = stateIcon.x, y4 = stateIcon.y, stateOffset = stateIcon.offset, stateIconStyle = __rest(stateIcon, ["width", "height", "x", "y", "offset"]);
      stateIconShape.attr(__assign(__assign({}, stateIconStyle), {
        x: x4 || width / 2 - stateW + stateOffset,
        y: y4 || -h2 / 2,
        width: stateW,
        height: h2
      }));
    } else if (stateIcon.show) {
      this.drawStateIcon(cfg, group);
    }
    this.updateLinkPoints(cfg, group);
  },
  getOptions: function getOptions2(cfg, updateType) {
    if (updateType === "move")
      return cfg;
    return deep_mix_default({}, this.options, this.getCustomConfig(cfg) || {}, cfg);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/star.js
init_tslib_es6();
init_esm();
registerNode("star", {
  // 自定义节点时的配置
  options: {
    size: 60,
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "star",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape17(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: -w2 / 2,
            y: -h2 / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  /**
   * 绘制节点上的LinkPoints
   * @param {Object} cfg data数据配置项
   * @param {Group} group Group实例
   */
  drawLinkPoints: function drawLinkPoints7(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, leftBottom = linkPoints.leftBottom, rightBottom = linkPoints.rightBottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "leftBottom", "rightBottom", "size", "r"]);
    var size3 = this.getSize(cfg);
    var outerR = size3[0];
    if (right) {
      var x1 = Math.cos((18 + 72 * 0) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 0) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right"
      });
    }
    if (top) {
      var x1 = Math.cos((18 + 72 * 1) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 1) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top"
      });
    }
    if (left) {
      var x1 = Math.cos((18 + 72 * 2) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 2) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left"
      });
    }
    if (leftBottom) {
      var x1 = Math.cos((18 + 72 * 3) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 3) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left-bottom",
        name: "link-point-left-bottom"
      });
    }
    if (rightBottom) {
      var x1 = Math.cos((18 + 72 * 4) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 4) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-right-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right-bottom",
        name: "link-point-right-bottom"
      });
    }
  },
  getPath: function getPath10(cfg) {
    var size3 = this.getSize(cfg);
    var outerR = size3[0];
    var defaultInnerR = outerR * 3 / 8;
    var innerR = cfg.innerR || defaultInnerR;
    return util_default.getStarPath(outerR, innerR);
  },
  /**
   * 获取节点的样式，供基于该节点自定义时使用
   * @param {Object} cfg 节点数据模型
   * @return {Object} 节点的样式
   */
  getShapeStyle: function getShapeStyle14(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign({
      path
    }, style);
    return styles;
  },
  update: function update12(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  },
  /**
   * 更新linkPoints
   * @param {Object} cfg 节点数据配置项
   * @param {Group} group Item所在的group
   */
  updateLinkPoints: function updateLinkPoints3(cfg, group) {
    var defaultLinkPoints = this.getOptions({}).linkPoints;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markLeftBottom = group["shapeMap"]["link-point-left-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-left-bottom";
    });
    var markRightBottom = group["shapeMap"]["link-point-left-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-right-bottom";
    });
    var currentLinkPoints = defaultLinkPoints;
    var existLinkPoint = markLeft || markRight || markTop || markLeftBottom || markRightBottom;
    if (existLinkPoint) {
      currentLinkPoints = existLinkPoint.attr();
    }
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize)
      markSize = linkPoints.r;
    var _a2 = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      leftBottom: void 0,
      rightBottom: void 0
    }, left = _a2.left, right = _a2.right, top = _a2.top, leftBottom = _a2.leftBottom, rightBottom = _a2.rightBottom;
    var size3 = this.getSize(cfg);
    var outerR = size3[0];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    var x4 = Math.cos((18 + 72 * 0) / 180 * Math.PI) * outerR;
    var y4 = Math.sin((18 + 72 * 0) / 180 * Math.PI) * outerR;
    if (markRight) {
      if (!right && right !== void 0) {
        markRight.remove();
        delete group["shapeMap"]["link-point-right"];
      } else {
        markRight.attr(__assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    x4 = Math.cos((18 + 72 * 1) / 180 * Math.PI) * outerR;
    y4 = Math.sin((18 + 72 * 1) / 180 * Math.PI) * outerR;
    if (markTop) {
      if (!top && top !== void 0) {
        markTop.remove();
        delete group["shapeMap"]["link-point-top"];
      } else {
        markTop.attr(__assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    x4 = Math.cos((18 + 72 * 2) / 180 * Math.PI) * outerR;
    y4 = Math.sin((18 + 72 * 2) / 180 * Math.PI) * outerR;
    if (markLeft) {
      if (!left && left !== void 0) {
        markLeft.remove();
        delete group["shapeMap"]["link-point-left"];
      } else {
        markLeft.attr(__assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    x4 = Math.cos((18 + 72 * 3) / 180 * Math.PI) * outerR;
    y4 = Math.sin((18 + 72 * 3) / 180 * Math.PI) * outerR;
    if (markLeftBottom) {
      if (!leftBottom && leftBottom !== void 0) {
        markLeftBottom.remove();
        delete group["shapeMap"]["link-point-left-bottom"];
      } else {
        markLeftBottom.attr(__assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (leftBottom) {
      group["shapeMap"]["link-point-left-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-left-bottom",
        name: "link-point-left-bottom",
        isAnchorPoint: true
      });
    }
    x4 = Math.cos((18 + 72 * 4) / 180 * Math.PI) * outerR;
    y4 = Math.sin((18 + 72 * 4) / 180 * Math.PI) * outerR;
    if (markRightBottom) {
      if (!rightBottom && rightBottom !== void 0) {
        markRightBottom.remove();
        delete group["shapeMap"]["link-point-right-bottom"];
      } else {
        markRightBottom.attr(__assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }));
      }
    } else if (rightBottom) {
      group["shapeMap"]["link-point-right-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x4,
          y: -y4
        }),
        className: "link-point-right-bottom",
        name: "link-point-right-bottom",
        isAnchorPoint: true
      });
    }
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/donut.js
init_tslib_es6();
init_esm();
var defaultSubjectColors2 = util_default.defaultSubjectColors;
var FAN_NAME_PREFIX = "fan-shape-";
registerNode("donut", {
  // 自定义节点时的配置
  options: {
    size: BaseGlobal.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    // 节点上左右上下四个方向上的链接circle配置
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      // circle的大小
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    // 节点中icon配置
    icon: {
      // 是否显示icon，值为 false 则不渲染icon
      show: false,
      // icon的地址，字符串类型
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "circle",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape18(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, defaultIcon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var icon = deep_mix_default({}, defaultIcon, cfg.icon);
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      draggable: true,
      name: "".concat(this.type, "-keyShape")
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    drawFans(cfg, group, keyShape);
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  updateShape: function updateShape3(cfg, item, keyShapeStyle, hasIcon, updateType) {
    var keyShape = item.get("keyShape");
    keyShape.attr(__assign({}, keyShapeStyle));
    updateFans(cfg, item, keyShape);
    if (true) {
      this.updateLabel(cfg, item, updateType);
    }
    if (hasIcon) {
      this.updateIcon(cfg, item);
    }
  }
}, "circle");
var drawFans = function drawFans2(cfg, group, keyShape) {
  var _a2 = cfg.donutAttrs, donutAttrs = _a2 === void 0 ? {} : _a2, _b = cfg.donutColorMap, donutColorMap = _b === void 0 ? {} : _b;
  var attrNum = Object.keys(donutAttrs).length;
  if (donutAttrs && attrNum > 1) {
    var _c = getDonutConfig(donutAttrs, donutColorMap), configs = _c.configs, totalValue = _c.totalValue;
    if (totalValue) {
      var _d = getDonutSize(keyShape), lineWidth = _d.lineWidth, arcR = _d.arcR;
      var arcBegin = [arcR, 0];
      var beginAngle = 0;
      if (attrNum === 1) {
        drawFan(group, {
          arcR,
          arcBegin,
          beginAngle,
          config: configs[0],
          fanIndex: 0,
          lineWidth,
          totalValue,
          drawWhole: true
        });
        return;
      }
      for (var i2 = 0; i2 < configs.length; i2++) {
        var result = drawFan(group, {
          arcR,
          arcBegin,
          beginAngle,
          config: configs[i2],
          fanIndex: i2,
          lineWidth,
          totalValue
        });
        if (result.shouldEnd)
          return;
        arcBegin = result.arcBegin;
        beginAngle = result.beginAngle;
      }
    }
  }
};
var drawFan = function drawFan2(group, fanConfig) {
  var arcR = fanConfig.arcR, arcBegin = fanConfig.arcBegin, beginAngle = fanConfig.beginAngle, config = fanConfig.config, fanIndex = fanConfig.fanIndex, lineWidth = fanConfig.lineWidth, totalValue = fanConfig.totalValue, _a2 = fanConfig.drawWhole, drawWhole = _a2 === void 0 ? false : _a2, _b = fanConfig.updateShape, updateShape4 = _b === void 0 ? void 0 : _b;
  var percent = config.value / totalValue;
  if (percent < 1e-3) {
    return {
      beginAngle,
      arcBegin,
      shape: void 0,
      shouldEnd: false
    };
  }
  var arcEnd, endAngle, isBig;
  if (drawWhole || percent > 0.999) {
    arcEnd = [arcR, 1e-4];
    isBig = true;
  } else {
    var angle = percent * Math.PI * 2;
    endAngle = beginAngle + angle;
    arcEnd = [arcR * Math.cos(endAngle), -arcR * Math.sin(endAngle)];
    isBig = angle > Math.PI ? 1 : 0;
  }
  var style = {
    path: [["M", arcBegin[0], arcBegin[1]], ["A", arcR, arcR, 0, isBig, 0, arcEnd[0], arcEnd[1]], ["L", arcEnd[0], arcEnd[1]]],
    stroke: config.color || (updateShape4 === null || updateShape4 === void 0 ? void 0 : updateShape4.attr("stroke")) || defaultSubjectColors2[fanIndex % defaultSubjectColors2.length],
    lineWidth
  };
  if (updateShape4) {
    updateShape4.attr(style);
  } else {
    group["shapeMap"]["".concat(FAN_NAME_PREFIX).concat(fanIndex)] = group.addShape("path", {
      attrs: style,
      name: "".concat(FAN_NAME_PREFIX).concat(fanIndex),
      draggable: true
    });
  }
  return {
    beginAngle: endAngle,
    arcBegin: arcEnd,
    shape: group["shapeMap"]["".concat(FAN_NAME_PREFIX).concat(fanIndex)],
    shouldEnd: drawWhole || percent > 0.999
  };
};
var updateFans = function updateFans2(cfg, item, keyShape) {
  var donutAttrs = cfg.donutAttrs, _a2 = cfg.donutColorMap, donutColorMap = _a2 === void 0 ? {} : _a2;
  var visitMap = {};
  var group = item.getContainer();
  if (donutAttrs) {
    var _b = getDonutConfig(donutAttrs, donutColorMap), configs = _b.configs, totalValue = _b.totalValue;
    if (totalValue) {
      var _c = getDonutSize(keyShape), lineWidth = _c.lineWidth, arcR = _c.arcR;
      var arcBegin = [arcR, 0];
      var beginAngle = 0;
      for (var i2 = 0; i2 < configs.length; i2++) {
        var shapeName = "".concat(FAN_NAME_PREFIX).concat(i2);
        var result = drawFan(group, {
          arcR,
          arcBegin,
          beginAngle,
          config: configs[i2],
          fanIndex: i2,
          lineWidth,
          totalValue,
          drawWhole: configs.length === 1,
          updateShape: group["shapeMap"][shapeName]
        });
        if (result.shape)
          visitMap[shapeName] = true;
        if (result.shouldEnd)
          break;
        arcBegin = result.arcBegin;
        beginAngle = result.beginAngle;
      }
    }
  }
  var fanKeys = Object.keys(group["shapeMap"]).filter(function(key) {
    return key.includes(FAN_NAME_PREFIX);
  });
  fanKeys.forEach(function(key) {
    if (!visitMap[key]) {
      group["shapeMap"][key].remove(true);
      delete group["shapeMap"][key];
    }
  });
};
var getDonutConfig = function getDonutConfig2(donutAttrs, donutColorMap) {
  var totalValue = 0;
  var configs = [];
  Object.keys(donutAttrs).forEach(function(name) {
    var value = +donutAttrs[name];
    if (isNaN(value))
      return;
    configs.push({
      key: name,
      value,
      color: donutColorMap[name]
    });
    totalValue += value;
  });
  return {
    totalValue,
    configs
  };
};
var getDonutSize = function getDonutSize2(keyShape) {
  var keyShapeR = keyShape.attr("r");
  var innerR = 0.6 * keyShapeR;
  var arcR = (keyShapeR + innerR) / 2;
  var lineWidth = keyShapeR - innerR;
  return {
    lineWidth,
    arcR
  };
};

// node_modules/@antv/g6-element/es/edges/polyline.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g6-element/es/edges/polyline-util.js
var getBBoxFromPoint = function getBBoxFromPoint2(point) {
  var x4 = point.x, y4 = point.y;
  return {
    x: x4,
    y: y4,
    centerX: x4,
    centerY: y4,
    minX: x4,
    minY: y4,
    maxX: x4,
    maxY: y4,
    height: 0,
    width: 0
  };
};
var getBBoxFromPoints = function getBBoxFromPoints2(points) {
  if (points === void 0) {
    points = [];
  }
  var xs = [];
  var ys = [];
  points.forEach(function(p2) {
    xs.push(p2.x);
    ys.push(p2.y);
  });
  var minX = Math.min.apply(Math, xs);
  var maxX = Math.max.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxY = Math.max.apply(Math, ys);
  return {
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
    maxX,
    maxY,
    minX,
    minY,
    height: maxY - minY,
    width: maxX - minX
  };
};
var filterConnectPoints = function filterConnectPoints2(points) {
  var result = [];
  var map3 = {};
  var pointsLength = points.length;
  for (var i2 = pointsLength - 1; i2 >= 0; i2--) {
    var p2 = points[i2];
    p2.id = "".concat(p2.x, "|||").concat(p2.y);
    if (!map3[p2.id]) {
      map3[p2.id] = p2;
      result.push(p2);
    }
  }
  return result;
};
var simplifyPolyline = function simplifyPolyline2(points) {
  return filterConnectPoints(points);
};
var getExpandedBBox = function getExpandedBBox2(bbox, offset) {
  if (bbox.width || bbox.height) {
    return {
      centerX: bbox.centerX,
      centerY: bbox.centerY,
      minX: bbox.minX - offset,
      minY: bbox.minY - offset,
      maxX: bbox.maxX + offset,
      maxY: bbox.maxY + offset,
      height: bbox.height + 2 * offset,
      width: bbox.width + 2 * offset
    };
  }
  return bbox;
};
var isHorizontalPort = function isHorizontalPort2(port, bbox) {
  var dx = Math.abs(port.x - bbox.centerX);
  var dy = Math.abs(port.y - bbox.centerY);
  if (dx === 0 && dy === 0)
    return 0;
  return dx / bbox.width > dy / bbox.height;
};
var getExpandedBBoxPoint = function getExpandedBBoxPoint2(bbox, point, anotherPoint) {
  var isHorizontal = isHorizontalPort(point, bbox);
  if (isHorizontal === 0) {
    var x4 = bbox.centerX;
    var y4 = bbox.centerY;
    if (anotherPoint.y < point.y) {
      y4 = bbox.minY;
    } else if (anotherPoint.x > point.x) {
      x4 = bbox.maxX;
    } else if (anotherPoint.x < point.x) {
      x4 = bbox.minX;
    } else if (anotherPoint.x === point.x) {
      y4 = bbox.maxY;
    }
    return {
      x: x4,
      y: y4
    };
  }
  if (isHorizontal) {
    return {
      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,
      y: point.y
    };
  }
  return {
    x: point.x,
    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY
  };
};
var mergeBBox = function mergeBBox2(b1, b2) {
  var minX = Math.min(b1.minX, b2.minX);
  var minY = Math.min(b1.minY, b2.minY);
  var maxX = Math.max(b1.maxX, b2.maxX);
  var maxY = Math.max(b1.maxY, b2.maxY);
  return {
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
    minX,
    minY,
    maxX,
    maxY,
    height: maxY - minY,
    width: maxX - minX
  };
};
var getPointsFromBBox = function getPointsFromBBox2(bbox) {
  return [{
    x: bbox.minX,
    y: bbox.minY
  }, {
    x: bbox.maxX,
    y: bbox.minY
  }, {
    x: bbox.maxX,
    y: bbox.maxY
  }, {
    x: bbox.minX,
    y: bbox.maxY
  }];
};
var isPointOutsideBBox = function isPointOutsideBBox2(point, bbox) {
  var x4 = point.x, y4 = point.y;
  return x4 < bbox.minX || x4 > bbox.maxX || y4 < bbox.minY || y4 > bbox.maxY;
};
var getBBoxXCrossPoints = function getBBoxXCrossPoints2(bbox, x4) {
  if (x4 < bbox.minX || x4 > bbox.maxX) {
    return [];
  }
  return [{
    x: x4,
    y: bbox.minY
  }, {
    x: x4,
    y: bbox.maxY
  }];
};
var getBBoxYCrossPoints = function getBBoxYCrossPoints2(bbox, y4) {
  if (y4 < bbox.minY || y4 > bbox.maxY) {
    return [];
  }
  return [{
    x: bbox.minX,
    y: y4
  }, {
    x: bbox.maxX,
    y: y4
  }];
};
var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint2(bbox, point) {
  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));
};
var distance4 = function distance5(p1, p2) {
  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
};
var _costByPoints = function _costByPoints2(p2, points) {
  var offset = -2;
  var result = 0;
  points.forEach(function(point) {
    if (point) {
      if (p2.x === point.x) {
        result += offset;
      }
      if (p2.y === point.y) {
        result += offset;
      }
    }
  });
  return result;
};
var heuristicCostEstimate = function heuristicCostEstimate2(p2, ps, pt2, source, target) {
  return distance4(p2, ps) + distance4(p2, pt2) + _costByPoints(p2, [ps, pt2, source, target]);
};
var reconstructPath = function reconstructPath2(pathPoints, pointById, cameFrom, currentId, iterator) {
  if (iterator === void 0) {
    iterator = 0;
  }
  pathPoints.unshift(pointById[currentId]);
  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {
    reconstructPath2(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);
  }
};
var isSegmentsIntersected = function isSegmentsIntersected2(p0, p1, p2, p3) {
  var v1x = p2.x - p0.x;
  var v1y = p2.y - p0.y;
  var v2x = p3.x - p0.x;
  var v2y = p3.y - p0.y;
  var v3x = p2.x - p1.x;
  var v3y = p2.y - p1.y;
  var v4x = p3.x - p1.x;
  var v4y = p3.y - p1.y;
  var pd1 = v1x * v2y - v1y * v2x;
  var pd2 = v3x * v4y - v3y * v4x;
  var pd3 = v1x * v3y - v1y * v3x;
  var pd4 = v2x * v4y - v2y * v4x;
  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;
};
var isSegmentCrossingBBox = function isSegmentCrossingBBox2(p1, p2, bbox) {
  if (bbox.width || bbox.height) {
    var _a2 = getPointsFromBBox(bbox), pa2 = _a2[0], pb = _a2[1], pc = _a2[2], pd = _a2[3];
    return isSegmentsIntersected(p1, p2, pa2, pb) || isSegmentsIntersected(p1, p2, pa2, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);
  }
  return false;
};
var getNeighborPoints = function getNeighborPoints2(points, point, bbox1, bbox2) {
  var neighbors = [];
  points.forEach(function(p2) {
    if (p2 === point)
      return;
    if (p2.x === point.x || p2.y === point.y) {
      if (isSegmentCrossingBBox(p2, point, bbox1) || isSegmentCrossingBBox(p2, point, bbox2))
        return;
      neighbors.push(p2);
    }
  });
  return filterConnectPoints(neighbors);
};
var pathFinder = function pathFinder2(points, start, goal, sBBox, tBBox, os, ot2) {
  var _a2;
  var closedSet = [];
  var openSet = (_a2 = {}, _a2[start.id] = start, _a2);
  var cameFrom = {};
  var gScore = {};
  var fScore = {};
  gScore[start.id] = 0;
  fScore[start.id] = heuristicCostEstimate(start, goal, start);
  var sortedOpenSet = new SortedArray();
  sortedOpenSet.add({
    id: start.id,
    value: fScore[start.id]
  });
  var pointById = {};
  points.forEach(function(p2) {
    pointById[p2.id] = p2;
  });
  var current;
  while (Object.keys(openSet).length) {
    var minId = sortedOpenSet.minId(false);
    if (minId) {
      current = openSet[minId];
    } else {
      break;
    }
    if (current === goal) {
      var pathPoints = [];
      reconstructPath(pathPoints, pointById, cameFrom, goal.id);
      return pathPoints;
    }
    delete openSet[current.id];
    sortedOpenSet.remove(current.id);
    closedSet.push(current);
    var neighborPoints = getNeighborPoints(points, current, sBBox, tBBox);
    var iterateNeighbors = function iterateNeighbors2(items) {
      items.forEach(function(neighbor) {
        if (closedSet.indexOf(neighbor) !== -1) {
          return;
        }
        var neighborId = neighbor.id;
        if (!openSet[neighborId]) {
          openSet[neighborId] = neighbor;
        }
        var tentativeGScore = fScore[current.id] + distance4(current, neighbor);
        if (gScore[neighborId] && tentativeGScore >= gScore[neighborId]) {
          sortedOpenSet.add({
            id: neighborId,
            value: fScore[neighborId]
          });
          return;
        }
        cameFrom[neighborId] = current.id;
        gScore[neighborId] = tentativeGScore;
        fScore[neighborId] = gScore[neighborId] + heuristicCostEstimate(neighbor, goal, start, os, ot2);
        sortedOpenSet.add({
          id: neighborId,
          value: fScore[neighborId]
        });
      });
    };
    iterateNeighbors(neighborPoints);
  }
  return [start, goal];
};
var isBending = function isBending2(p0, p1, p2) {
  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);
};
var getBorderRadiusPoints = function getBorderRadiusPoints2(p0, p1, p2, r2) {
  var d0 = distance4(p0, p1);
  var d1 = distance4(p2, p1);
  if (d0 < r2) {
    r2 = d0;
  }
  if (d1 < r2) {
    r2 = d1;
  }
  var ps = {
    x: p1.x - r2 / d0 * (p1.x - p0.x),
    y: p1.y - r2 / d0 * (p1.y - p0.y)
  };
  var pt2 = {
    x: p1.x - r2 / d1 * (p1.x - p2.x),
    y: p1.y - r2 / d1 * (p1.y - p2.y)
  };
  return [ps, pt2];
};
var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline2(points, borderRadius) {
  var pathSegments = [];
  var startPoint = points[0];
  pathSegments.push("M".concat(startPoint.x, " ").concat(startPoint.y));
  points.forEach(function(p2, i2) {
    var p1 = points[i2 + 1];
    var p22 = points[i2 + 2];
    if (p1 && p22) {
      if (isBending(p2, p1, p22)) {
        var _a2 = getBorderRadiusPoints(p2, p1, p22, borderRadius), ps = _a2[0], pt2 = _a2[1];
        pathSegments.push("L".concat(ps.x, " ").concat(ps.y));
        pathSegments.push("Q".concat(p1.x, " ").concat(p1.y, " ").concat(pt2.x, " ").concat(pt2.y));
        pathSegments.push("L".concat(pt2.x, " ").concat(pt2.y));
      } else {
        pathSegments.push("L".concat(p1.x, " ").concat(p1.y));
      }
    } else if (p1) {
      pathSegments.push("L".concat(p1.x, " ").concat(p1.y));
    }
  });
  return pathSegments.join("");
};
var getPolylinePoints = function getPolylinePoints2(start, end2, sNode, tNode, offset) {
  var sBBox, tBBox;
  if (!sNode || !sNode.getType()) {
    sBBox = getBBoxFromPoint(start);
  } else if (sNode.getType() === "combo") {
    var sKeyShapeBBox = sNode.getKeyShape().getBBox();
    if (sKeyShapeBBox) {
      var _a2 = sNode.getModel(), sx = _a2.x, sy = _a2.y;
      sBBox = {
        x: sx,
        y: sy,
        width: sKeyShapeBBox.width,
        height: sKeyShapeBBox.height,
        minX: sKeyShapeBBox.minX + sx,
        maxX: sKeyShapeBBox.maxX + sx,
        minY: sKeyShapeBBox.minY + sy,
        maxY: sKeyShapeBBox.maxY + sy
      };
      sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;
      sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;
    } else {
      sBBox = getBBoxFromPoint(start);
    }
  } else {
    sBBox = sNode && sNode.getBBox();
  }
  if (!tNode || !tNode.getType()) {
    tBBox = getBBoxFromPoint(end2);
  } else if (tNode.getType() === "combo") {
    var tKeyShapeBBox = tNode.getKeyShape().getBBox();
    if (tKeyShapeBBox) {
      var _b = tNode.getModel(), tx = _b.x, ty = _b.y;
      tBBox = {
        x: tx,
        y: ty,
        width: tKeyShapeBBox.width,
        height: tKeyShapeBBox.height,
        minX: tKeyShapeBBox.minX + tx,
        maxX: tKeyShapeBBox.maxX + tx,
        minY: tKeyShapeBBox.minY + ty,
        maxY: tKeyShapeBBox.maxY + ty
      };
      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;
      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;
    } else {
      tBBox = getBBoxFromPoint(end2);
    }
  } else {
    tBBox = tNode && tNode.getBBox();
  }
  var sxBBox = getExpandedBBox(sBBox, offset);
  var txBBox = getExpandedBBox(tBBox, offset);
  var sPoint = getExpandedBBoxPoint(sxBBox, start, end2);
  var tPoint = getExpandedBBoxPoint(txBBox, end2, start);
  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);
  var sMixBBox = mergeBBox(sxBBox, lineBBox);
  var tMixBBox = mergeBBox(txBBox, lineBBox);
  var connectPoints = [];
  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));
  var centerPoint = {
    x: (start.x + end2.x) / 2,
    y: (start.y + end2.y) / 2
  };
  [lineBBox, sMixBBox, tMixBBox].forEach(function(bbox) {
    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function(p2) {
      return isPointOutsideBBox(p2, sxBBox) && isPointOutsideBBox(p2, txBBox);
    }));
  });
  [{
    x: sPoint.x,
    y: tPoint.y
  }, {
    x: tPoint.x,
    y: sPoint.y
  }].forEach(function(p2) {
    if (isPointOutsideBBox(p2, sxBBox) && isPointOutsideBBox(p2, txBBox)) {
      connectPoints.push(p2);
    }
  });
  connectPoints.unshift(sPoint);
  connectPoints.push(tPoint);
  connectPoints = filterConnectPoints(connectPoints);
  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end2);
  pathPoints.unshift(start);
  pathPoints.push(end2);
  return simplifyPolyline(pathPoints);
};
var removeRedundantPoint = function removeRedundantPoint2(points) {
  if (!(points === null || points === void 0 ? void 0 : points.length))
    return points;
  var beginPoint = points[points.length - 1];
  var current = {
    x: beginPoint.x,
    y: beginPoint.y
  };
  var continueSameX = [beginPoint];
  var continueSameY = [beginPoint];
  for (var i2 = points.length - 2; i2 >= 0; i2--) {
    var point = points[i2];
    if (point.x === current.x) {
      continueSameX.push(point);
    } else {
      continueSameX = [point];
      current.x = point.x;
    }
    if (point.y === current.y) {
      continueSameY.push(point);
    } else {
      continueSameY = [point];
      current.y = point.y;
    }
    if (continueSameX.length > 2) {
      var removeIdx = points.indexOf(continueSameX[1]);
      if (removeIdx > -1)
        points.splice(removeIdx, 1);
      continue;
    }
    if (continueSameY.length > 2) {
      var removeIdx = points.indexOf(continueSameY[1]);
      if (removeIdx > -1)
        points.splice(removeIdx, 1);
    }
  }
  return points;
};
var SortedArray = (
  /** @class */
  function() {
    function SortedArray2() {
      this.arr = [];
      this.map = {};
      this.arr = [];
      this.map = {};
    }
    SortedArray2.prototype._innerAdd = function(item, length) {
      var idxRange = [0, length - 1];
      while (idxRange[1] - idxRange[0] > 1) {
        var midIdx = Math.floor((idxRange[0] + idxRange[1]) / 2);
        if (this.arr[midIdx].value > item.value) {
          idxRange[1] = midIdx;
        } else if (this.arr[midIdx].value < item.value) {
          idxRange[0] = midIdx;
        } else {
          this.arr.splice(midIdx, 0, item);
          this.map[item.id] = true;
          return;
        }
      }
      this.arr.splice(idxRange[1], 0, item);
      this.map[item.id] = true;
    };
    SortedArray2.prototype.add = function(item) {
      delete this.map[item.id];
      var length = this.arr.length;
      if (!length) {
        this.arr.push(item);
        this.map[item.id] = true;
        return;
      }
      if (this.arr[length - 1].value < item.value) {
        this.arr.push(item);
        this.map[item.id] = true;
        return;
      }
      this._innerAdd(item, length);
    };
    SortedArray2.prototype.remove = function(id) {
      if (!this.map[id])
        return;
      delete this.map[id];
    };
    SortedArray2.prototype._clearAndGetMinId = function() {
      var res;
      for (var i2 = this.arr.length - 1; i2 >= 0; i2--) {
        if (this.map[this.arr[i2].id])
          res = this.arr[i2].id;
        else
          this.arr.splice(i2, 1);
      }
      return res;
    };
    SortedArray2.prototype._findFirstId = function() {
      while (this.arr.length) {
        var first = this.arr.shift();
        if (this.map[first.id])
          return first.id;
      }
    };
    SortedArray2.prototype.minId = function(clear) {
      if (clear) {
        return this._clearAndGetMinId();
      } else {
        return this._findFirstId();
      }
    };
    return SortedArray2;
  }()
);

// node_modules/@antv/g6-element/es/edges/router.js
init_esm();
var manhattanDist = function manhattanDist2(p1, p2) {
  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
};
var eucliDist = function eucliDist2(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
};
var straightPath = function straightPath2(start, end2) {
  return [start, end2];
};
var simplePolyline = function simplePolyline2(start, end2, startNode, endNode, cfg) {
  return simplifyPolyline(getPolylinePoints(start, end2, startNode, endNode, cfg.offset));
};
var defaultCfg = {
  offset: 20,
  maxAllowedDirectionChange: Math.PI / 2,
  maximumLoops: 2e3,
  gridSize: 10,
  directions: [
    {
      stepX: 1,
      stepY: 0
    },
    {
      stepX: -1,
      stepY: 0
    },
    {
      stepX: 0,
      stepY: 1
    },
    {
      stepX: 0,
      stepY: -1
    }
    // top
  ],
  get penalties() {
    return {
      0: 0,
      45: this.gridSize / 2,
      90: this.gridSize / 2
    };
  },
  distFunc: manhattanDist,
  fallbackRoute: simplePolyline
};
var octolinearCfg = {
  maxAllowedDirectionChange: Math.PI / 4,
  // 8 个方向: 上下左右 + 45度斜线方向
  directions: [{
    stepX: 1,
    stepY: 0
  }, {
    stepX: 1,
    stepY: 1
  }, {
    stepX: 0,
    stepY: 1
  }, {
    stepX: -1,
    stepY: 1
  }, {
    stepX: -1,
    stepY: 0
  }, {
    stepX: -1,
    stepY: -1
  }, {
    stepX: 0,
    stepY: -1
  }, {
    stepX: 1,
    stepY: -1
  }],
  distFunc: eucliDist,
  fallbackRoute: straightPath
};
var pos2GridIx = function pos2GridIx2(pos, gridSize) {
  var gridIx = Math.round(Math.abs(pos / gridSize));
  var sign = pos < 0 ? -1 : 1;
  return gridIx < 0 ? 0 : sign * gridIx;
};
var getObstacleMap = function getObstacleMap2(items, gridSize, offset) {
  var map3 = {};
  items.forEach(function(item) {
    if (!item)
      return;
    var bbox = getExpandedBBox(item.getBBox(), offset);
    for (var x4 = pos2GridIx(bbox.minX, gridSize); x4 <= pos2GridIx(bbox.maxX, gridSize); x4 += 1) {
      for (var y4 = pos2GridIx(bbox.minY, gridSize); y4 <= pos2GridIx(bbox.maxY, gridSize); y4 += 1) {
        map3["".concat(x4, "|||").concat(y4)] = true;
      }
    }
  });
  return map3;
};
var getDirectionAngle = function getDirectionAngle2(p1, p2) {
  var deltaX = p2.x - p1.x;
  var deltaY = p2.y - p1.y;
  if (deltaX || deltaY) {
    return Math.atan2(deltaY, deltaX);
  }
  return 0;
};
var getAngleDiff = function getAngleDiff2(angle1, angle2) {
  var directionChange = Math.abs(angle1 - angle2);
  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;
};
var estimateCost = function estimateCost2(from, endPoints, distFunc) {
  var min3 = Infinity;
  for (var i2 = 0, len = endPoints.length; i2 < len; i2++) {
    var cost = distFunc(from, endPoints[i2]);
    if (cost < min3) {
      min3 = cost;
    }
  }
  return min3;
};
var getBoxPoints = function getBoxPoints2(point, oriPoint, node, anotherPoint, cfg) {
  var points = [];
  if (!node) {
    return [point];
  }
  var directions = cfg.directions, offset = cfg.offset;
  var bbox = node.getBBox();
  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;
  var expandBBox = getExpandedBBox(bbox, offset);
  for (var i2 in expandBBox) {
    expandBBox[i2] = pos2GridIx(expandBBox[i2], cfg.gridSize);
  }
  if (isInside) {
    for (var _i2 = 0, directions_1 = directions; _i2 < directions_1.length; _i2++) {
      var dir = directions_1[_i2];
      var bounds = [[{
        x: expandBBox.minX,
        y: expandBBox.minY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.minY
      }], [{
        x: expandBBox.minX,
        y: expandBBox.minY
      }, {
        x: expandBBox.minX,
        y: expandBBox.maxY
      }], [{
        x: expandBBox.maxX,
        y: expandBBox.minY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.maxY
      }], [{
        x: expandBBox.minX,
        y: expandBBox.maxY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.maxY
      }]];
      for (var i2 = 0; i2 < 4; i2++) {
        var boundLine = bounds[i2];
        var insterctP_1 = util_default.getLineIntersect(point, {
          x: point.x + dir.stepX * expandBBox.width,
          y: point.y + dir.stepY * expandBBox.height
        }, boundLine[0], boundLine[1]);
        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {
          insterctP_1.id = "".concat(insterctP_1.x, "|||").concat(insterctP_1.y);
          points.push(insterctP_1);
        }
      }
    }
    return points;
  }
  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);
  insterctP.id = "".concat(insterctP.x, "|||").concat(insterctP.y);
  return [insterctP];
};
var getDirectionChange = function getDirectionChange2(current, neighbor, cameFrom, scaleStartPoint) {
  var directionAngle = getDirectionAngle(current, neighbor);
  var currentCameFrom = cameFrom[current.id];
  if (!currentCameFrom) {
    var startAngle = getDirectionAngle(scaleStartPoint, current);
    return getAngleDiff(startAngle, directionAngle);
  }
  var prevDirectionAngle = getDirectionAngle({
    x: currentCameFrom.x,
    y: currentCameFrom.y
  }, current);
  return getAngleDiff(prevDirectionAngle, directionAngle);
};
var getControlPoints12 = function getControlPoints13(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {
  var controlPoints = [endPoint];
  var pointZero = endPoint;
  var currentId = current.id;
  var currentX = current.x;
  var currentY = current.y;
  var lastPoint = {
    x: currentX,
    y: currentY,
    id: currentId
  };
  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {
    pointZero = {
      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,
      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize
    };
    controlPoints.unshift(pointZero);
  }
  var currentCameFrom = cameFrom[currentId];
  while (currentCameFrom && currentCameFrom.id !== currentId) {
    var point = {
      x: currentX,
      y: currentY,
      id: currentId
    };
    var prePoint = {
      x: currentCameFrom.x,
      y: currentCameFrom.y,
      id: currentCameFrom.id
    };
    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);
    if (directionChange) {
      pointZero = {
        x: prePoint.x === point.x ? pointZero.x : prePoint.x * gridSize,
        y: prePoint.y === point.y ? pointZero.y : prePoint.y * gridSize
      };
      controlPoints.unshift(pointZero);
    }
    currentId = prePoint.id;
    currentX = prePoint.x;
    currentY = prePoint.y;
    currentCameFrom = cameFrom[currentId];
  }
  controlPoints[0].x = currentX === scaleStartPoint.x ? startPoint.x : pointZero.x;
  controlPoints[0].y = currentY === scaleStartPoint.y ? startPoint.y : pointZero.y;
  controlPoints.unshift(startPoint);
  return controlPoints;
};
var pathFinder3 = function pathFinder4(startPoint, endPoint, startNode, endNode, routerCfg) {
  if (isNaN(startPoint.x) || isNaN(endPoint.x))
    return [];
  var cfg = deep_mix_default(defaultCfg, routerCfg);
  cfg.obstacles = cfg.obstacles || [];
  var penalties = cfg.penalties, gridSize = cfg.gridSize;
  var map3 = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);
  var scaleStartPoint = {
    x: pos2GridIx(startPoint.x, gridSize),
    y: pos2GridIx(startPoint.y, gridSize)
  };
  var scaleEndPoint = {
    x: pos2GridIx(endPoint.x, gridSize),
    y: pos2GridIx(endPoint.y, gridSize)
  };
  startPoint.id = "".concat(scaleStartPoint.x, "|||").concat(scaleStartPoint.y);
  endPoint.id = "".concat(scaleEndPoint.x, "|||").concat(scaleEndPoint.y);
  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);
  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);
  startPoints.forEach(function(point) {
    delete map3[point.id];
  });
  endPoints.forEach(function(point) {
    delete map3[point.id];
  });
  var openSet = {};
  var closedSet = {};
  var cameFrom = {};
  var gScore = {};
  var fScore = {};
  var sortedOpenSet = new SortedArray();
  for (var i2 = 0; i2 < startPoints.length; i2++) {
    var firstStep = startPoints[i2];
    openSet[firstStep.id] = firstStep;
    gScore[firstStep.id] = 0;
    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);
    sortedOpenSet.add({
      id: firstStep.id,
      value: fScore[firstStep.id]
    });
  }
  var remainLoops = cfg.maximumLoops;
  var current, direction2, neighbor, neighborCost, costFromStart, directionChange;
  var curCost = Infinity;
  var endPointMap = {};
  endPoints.forEach(function(point) {
    endPointMap["".concat(point.x, "|||").concat(point.y)] = true;
  });
  Object.keys(openSet).forEach(function(key) {
    var id = openSet[key].id;
    if (fScore[id] <= curCost) {
      curCost = fScore[id];
      current = openSet[id];
    }
  });
  while (Object.keys(openSet).length > 0 && remainLoops > 0) {
    var minId = sortedOpenSet.minId((remainLoops + 1) % 30 === 0);
    if (minId) {
      current = openSet[minId];
    } else {
      break;
    }
    if (endPointMap["".concat(current.x, "|||").concat(current.y)]) {
      return getControlPoints12(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);
    }
    delete openSet[current.id];
    sortedOpenSet.remove(current.id);
    closedSet[current.id] = true;
    for (var i2 = 0; i2 < cfg.directions.length; i2++) {
      direction2 = cfg.directions[i2];
      var neighborId = "".concat(Math.round(current.x) + direction2.stepX, "|||").concat(Math.round(current.y) + direction2.stepY);
      neighbor = {
        x: current.x + direction2.stepX,
        y: current.y + direction2.stepY,
        id: neighborId
      };
      if (closedSet[neighborId])
        continue;
      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);
      if (directionChange > cfg.maxAllowedDirectionChange)
        continue;
      if (map3[neighborId])
        continue;
      if (!openSet[neighborId]) {
        openSet[neighborId] = neighbor;
      }
      var directionPenalties = penalties[directionChange];
      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);
      costFromStart = gScore[current.id] + neighborCost;
      var neighborGScore = gScore[neighborId];
      if (neighborGScore && costFromStart >= neighborGScore) {
        continue;
      }
      cameFrom[neighborId] = current;
      gScore[neighborId] = costFromStart;
      fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);
      sortedOpenSet.add({
        id: neighborId,
        value: fScore[neighborId]
      });
    }
    remainLoops -= 1;
  }
  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);
};

// node_modules/@antv/g6-element/es/edges/polyline.js
registerEdge("polyline", {
  options: {
    color: BaseGlobal.defaultEdge.color,
    size: BaseGlobal.defaultEdge.size,
    style: {
      radius: 0,
      offset: 15,
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultEdge.style.stroke,
      lineAppendWidth: BaseGlobal.defaultEdge.style.lineAppendWidth
    },
    // 文本样式配置
    labelCfg: {
      style: {
        fill: BaseGlobal.edgeLabel.style.fill,
        fontSize: BaseGlobal.edgeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    routeCfg: {
      obstacles: [],
      maxAllowedDirectionChange: Math.PI,
      maximumLoops: 500,
      gridSize: 10
      // 指定精度
    },
    stateStyles: __assign({}, BaseGlobal.edgeStateStyles)
  },
  shapeType: "polyline",
  // 文本位置
  labelPosition: "center",
  drawShape: function drawShape19(cfg, group) {
    var shapeStyle = this.getShapeStyle(cfg);
    if (shapeStyle.radius === 0)
      delete shapeStyle.radius;
    var keyShape = group.addShape("path", {
      className: "edge-shape",
      name: "edge-shape",
      attrs: shapeStyle
    });
    group["shapeMap"]["edge-shape"] = keyShape;
    return keyShape;
  },
  getShapeStyle: function getShapeStyle15(cfg) {
    var defaultStyle = this.options.style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    cfg = this.getPathPoints(cfg);
    this.radius = style.radius;
    this.offset = style.offset;
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var radius = style.radius;
    var defaultRouteCfg = this.options.routeCfg;
    var routeCfg = mix({}, defaultRouteCfg, cfg.routeCfg);
    routeCfg.offset = style.offset;
    var path = this.getPath(points, source, target, radius, routeCfg, !Boolean(controlPoints));
    if (is_array_default(path) && path.length <= 1 || is_string_default(path) && path.indexOf("L") === -1) {
      path = "M0 0, L0 0";
    }
    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {
      path = "M0 0, L0 0";
    }
    var attrs = mix({}, BaseGlobal.defaultEdge.style, style, {
      lineWidth: cfg.size,
      path
    });
    return attrs;
  },
  updateShapeStyle: function updateShapeStyle4(cfg, item) {
    var group = item.getContainer();
    if (!item.isVisible())
      return;
    var strokeStyle = {
      stroke: cfg.color
    };
    var shape = group["shapeMap"]["edge-shape"] || group.find(function(element) {
      return element.get("className") === "edge-shape";
    }) || item.getKeyShape();
    var size3 = cfg.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var currentAttr = shape.attr();
    var previousStyle = mix({}, strokeStyle, currentAttr, cfg.style);
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var radius = previousStyle.radius;
    var defaultRouteCfg = this.options.routeCfg;
    var routeCfg = mix({}, defaultRouteCfg, cfg.routeCfg);
    routeCfg.offset = previousStyle.offset;
    var path = this.getPath(points, source, target, radius, routeCfg, !Boolean(controlPoints));
    if (is_array_default(path) && path.length <= 1 || is_string_default(path) && path.indexOf("L") === -1) {
      path = "M0 0, L0 0";
    }
    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {
      path = "M0 0, L0 0";
    }
    if (currentAttr.endArrow && previousStyle.endArrow === false) {
      cfg.style.endArrow = {
        path: ""
      };
    }
    if (currentAttr.startArrow && previousStyle.startArrow === false) {
      cfg.style.startArrow = {
        path: ""
      };
    }
    var style = mix(strokeStyle, shape.attr(), {
      lineWidth: size3,
      path
    }, cfg.style);
    if (shape) {
      shape.attr(style);
    }
  },
  getPath: function getPath11(points, source, target, radius, routeCfg, auto) {
    var offset = routeCfg.offset, obstacles = routeCfg.obstacles;
    var simple = routeCfg.simple;
    if (!offset || points.length > 2 || auto === false) {
      if (radius) {
        return getPathWithBorderRadiusByPolyline(points, radius);
      }
      var pathArray_1 = [];
      each_default(points, function(point, index2) {
        if (index2 === 0) {
          pathArray_1.push(["M", point.x, point.y]);
        } else {
          pathArray_1.push(["L", point.x, point.y]);
        }
      });
      return pathArray_1;
    }
    if (simple !== false && !(obstacles === null || obstacles === void 0 ? void 0 : obstacles.length))
      simple = true;
    var polylinePoints = simple ? getPolylinePoints(points[points.length - 1], points[0], target, source, offset) : pathFinder3(points[0], points[points.length - 1], source, target, routeCfg);
    if (!polylinePoints || !polylinePoints.length)
      return "M0 0, L0 0";
    if (radius) {
      var res_1 = getPathWithBorderRadiusByPolyline(polylinePoints, radius);
      return res_1;
    }
    polylinePoints = removeRedundantPoint(polylinePoints);
    var res = util_default.pointsToPolygon(polylinePoints);
    return res;
  }
}, "single-edge");

// node_modules/@antv/g6-pc/es/behavior/index.js
init_esm();

// node_modules/@antv/g6-pc/es/behavior/drag-canvas.js
init_esm();
var cloneEvent4 = util_default2.cloneEvent;
var isNaN4 = util_default2.isNaN;
var abs = Math.abs;
var DRAG_OFFSET = 10;
var ALLOW_EVENTS2 = ["shift", "ctrl", "alt", "control"];
var drag_canvas_default = {
  getDefaultCfg: function getDefaultCfg2() {
    return {
      direction: "both",
      enableOptimize: false,
      // drag-canvas 可拖动的扩展范围，默认为 0，即最多可以拖动一屏的位置
      // 当设置的值大于 0 时，即拖动可以超过一屏
      // 当设置的值小于 0 时，相当于缩小了可拖动范围
      // 具体实例可参考：https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*IFfoS67_HssAAAAAAAAAAAAAARQnAQ
      scalableRange: 0,
      allowDragOnItem: false
    };
  },
  getEvents: function getEvents2() {
    return {
      "mousedown": "onMouseDown",
      "drag": "onDragMove",
      "dragend": "onMouseUp",
      "canvas:click": "onMouseUp",
      "keyup": "onKeyUp",
      "focus": "onKeyUp",
      "keydown": "onKeyDown",
      "touchstart": "onTouchStart",
      "touchmove": "onTouchMove",
      "touchend": "onMouseUp"
    };
  },
  updateViewport: function updateViewport(e8) {
    var origin = this.origin;
    var clientX = +e8.clientX;
    var clientY = +e8.clientY;
    if (isNaN4(clientX) || isNaN4(clientY)) {
      return;
    }
    var dx = clientX - origin.x;
    var dy = clientY - origin.y;
    if (this.get("direction") === "x") {
      dy = 0;
    } else if (this.get("direction") === "y") {
      dx = 0;
    }
    this.origin = {
      x: clientX,
      y: clientY
    };
    var width = this.graph.get("width");
    var height = this.graph.get("height");
    var graphCanvasBBox = this.graph.get("canvas").getCanvasBBox();
    var expandWidth = this.scalableRange;
    var expandHeight = this.scalableRange;
    if (expandWidth < 1 && expandWidth > -1) {
      expandWidth = width * expandWidth;
      expandHeight = height * expandHeight;
    }
    if (graphCanvasBBox.minX <= width + expandWidth && graphCanvasBBox.minX + dx > width + expandWidth || graphCanvasBBox.maxX + expandWidth >= 0 && graphCanvasBBox.maxX + expandWidth + dx < 0) {
      dx = 0;
    }
    if (graphCanvasBBox.minY <= height + expandHeight && graphCanvasBBox.minY + dy > height + expandHeight || graphCanvasBBox.maxY + expandHeight >= 0 && graphCanvasBBox.maxY + expandHeight + dy < 0) {
      dy = 0;
    }
    this.graph.translate(dx, dy);
  },
  onTouchStart: function onTouchStart(e8) {
    var self2 = this;
    var touches = e8.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (event1 && event2) {
      return;
    }
    e8.preventDefault();
    this.mousedown = true;
    self2.onDragStart(e8);
  },
  onMouseDown: function onMouseDown(e8) {
    this.mousedown = true;
  },
  onDragMove: function onDragMove(evt) {
    if (!this.mousedown)
      return;
    if (!this.dragstart) {
      this.dragstart = true;
      this.onDragStart(evt);
    } else {
      this.onDrag(evt);
    }
  },
  onDragStart: function onDragStart(e8) {
    var self2 = this;
    var event = e8.originalEvent;
    if (event && e8.name !== "touchstart" && event.button !== 0) {
      return;
    }
    if (e8.name !== "touchstart" && typeof window !== "undefined" && window.event && !window.event.buttons && !window.event.button) {
      return;
    }
    if (!this.shouldBegin(e8, this)) {
      return;
    }
    if (self2.keydown)
      return;
    if (!this.allowDrag(e8))
      return;
    self2.origin = {
      x: e8.clientX,
      y: e8.clientY
    };
    self2.dragging = false;
    if (this.enableOptimize) {
      var graph = this.graph;
      var edges = graph.getEdges();
      for (var i2 = 0, len = edges.length; i2 < len; i2++) {
        var shapes = edges[i2].get("group").get("children");
        if (!shapes)
          continue;
        shapes.forEach(function(shape) {
          shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
          shape.hide();
        });
      }
      var nodes = graph.getNodes();
      for (var j2 = 0, nodeLen = nodes.length; j2 < nodeLen; j2++) {
        var container = nodes[j2].getContainer();
        var children = container.get("children");
        for (var _i2 = 0, children_1 = children; _i2 < children_1.length; _i2++) {
          var child = children_1[_i2];
          var isKeyShape = child.get("isKeyShape");
          if (!isKeyShape) {
            child.set("ori-visibility", child.get("ori-visibility") || child.get("visible"));
            child.hide();
          }
        }
      }
    }
    if (typeof window !== "undefined") {
      var self_1 = this;
      this.handleDOMContextMenu = function(e9) {
        return self_1.onMouseUp(e9);
      };
      document.body.addEventListener("contextmenu", this.handleDOMContextMenu);
    }
  },
  onTouchMove: function onTouchMove(e8) {
    var self2 = this;
    var touches = e8.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (event1 && event2) {
      this.onMouseUp(e8);
      return;
    }
    e8.preventDefault();
    self2.onDrag(e8);
  },
  onDrag: function onDrag(e8) {
    if (!this.mousedown)
      return;
    var graph = this.graph;
    if (this.keydown)
      return;
    if (!this.allowDrag(e8))
      return;
    e8 = cloneEvent4(e8);
    if (!this.origin) {
      return;
    }
    if (!this.dragging) {
      if (abs(this.origin.x - e8.clientX) + abs(this.origin.y - e8.clientY) < DRAG_OFFSET) {
        return;
      }
      if (this.shouldBegin(e8, this)) {
        e8.type = "dragstart";
        graph.emit("canvas:dragstart", e8);
        this.originPosition = {
          x: e8.clientX,
          y: e8.clientY
        };
        this.dragging = true;
      }
    } else {
      e8.type = "drag";
      graph.emit("canvas:drag", e8);
    }
    if (this.shouldUpdate(e8, this)) {
      this.updateViewport(e8);
    }
  },
  onMouseUp: function onMouseUp(e8) {
    var _a2, _b;
    this.mousedown = false;
    this.dragstart = false;
    var graph = this.graph;
    if (this.keydown)
      return;
    var currentZoom = graph.getZoom();
    var modeController = graph.get("modeController");
    var zoomCanvas = (_b = (_a2 = modeController === null || modeController === void 0 ? void 0 : modeController.modes[modeController.mode]) === null || _a2 === void 0 ? void 0 : _a2.filter(function(behavior) {
      return behavior.type === "zoom-canvas";
    })) === null || _b === void 0 ? void 0 : _b[0];
    var optimizeZoom = zoomCanvas ? zoomCanvas.optimizeZoom || 0.1 : 0;
    if (this.enableOptimize) {
      var edges = graph.getEdges();
      for (var i2 = 0, len = edges.length; i2 < len; i2++) {
        var shapes = edges[i2].get("group").get("children");
        if (!shapes)
          continue;
        shapes.forEach(function(shape) {
          var oriVis2 = shape.get("ori-visibility");
          shape.set("ori-visibility", void 0);
          if (oriVis2)
            shape.show();
        });
      }
      if (currentZoom > optimizeZoom) {
        var nodes = graph.getNodes();
        for (var j2 = 0, nodeLen = nodes.length; j2 < nodeLen; j2++) {
          var container = nodes[j2].getContainer();
          var children = container.get("children");
          for (var _i2 = 0, children_2 = children; _i2 < children_2.length; _i2++) {
            var child = children_2[_i2];
            var isKeyShape = child.get("isKeyShape");
            if (!isKeyShape) {
              var oriVis = child.get("ori-visibility");
              child.set("ori-visibility", void 0);
              if (oriVis)
                child.show();
            }
          }
        }
      }
    }
    if (!this.dragging) {
      this.origin = null;
      return;
    }
    e8 = cloneEvent4(e8);
    if (this.shouldEnd(e8, this)) {
      this.updateViewport(e8);
    }
    e8.type = "dragend";
    e8.dx = e8.clientX - this.originPosition.x;
    e8.dy = e8.clientY - this.originPosition.y;
    graph.emit("canvas:dragend", e8);
    this.endDrag();
    if (typeof window !== "undefined") {
      document.body.removeEventListener("contextmenu", this.handleDOMContextMenu);
    }
  },
  endDrag: function endDrag() {
    this.origin = null;
    this.dragging = false;
    this.dragbegin = false;
    this.mousedown = false;
    this.dragstart = false;
  },
  onKeyDown: function onKeyDown(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (ALLOW_EVENTS2.indexOf(code.toLowerCase()) > -1) {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp() {
    this.keydown = false;
    this.origin = null;
    this.dragging = false;
    this.dragbegin = false;
  },
  allowDrag: function allowDrag(evt) {
    var _a2, _b;
    var target = evt.target;
    var targetIsCanvas = target && target.isCanvas && target.isCanvas();
    if (is_boolean_default(this.allowDragOnItem) && !this.allowDragOnItem && !targetIsCanvas)
      return false;
    if (is_object_default(this.allowDragOnItem)) {
      var _c = this.allowDragOnItem, node = _c.node, edge = _c.edge, combo = _c.combo;
      var itemType = (_b = (_a2 = evt.item) === null || _a2 === void 0 ? void 0 : _a2.getType) === null || _b === void 0 ? void 0 : _b.call(_a2);
      if (!node && itemType === "node")
        return false;
      if (!edge && itemType === "edge")
        return false;
      if (!combo && itemType === "combo")
        return false;
    }
    return true;
  }
};

// node_modules/@antv/g6-pc/es/behavior/drag-node.js
init_tslib_es6();
init_esm();
var drag_node_default = {
  getDefaultCfg: function getDefaultCfg3() {
    return {
      updateEdge: true,
      delegateStyle: {},
      // 是否开启delegate
      enableDelegate: false,
      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构
      onlyChangeComboSize: false,
      // 拖动过程中目标 combo 状态样式
      comboActiveState: "",
      selectedState: "selected",
      enableOptimize: false,
      enableDebounce: false,
      enableStack: true
    };
  },
  getEvents: function getEvents3() {
    return {
      "node:mousedown": "onMouseDown",
      drag: "onDragMove",
      dragend: "onDragEnd",
      "combo:dragenter": "onDragEnter",
      "combo:dragleave": "onDragLeave",
      "combo:drop": "onDropCombo",
      "node:drop": "onDropNode",
      "canvas:drop": "onDropCanvas",
      touchstart: "onTouchStart",
      touchmove: "onTouchMove",
      touchend: "onDragEnd",
      afterchangedata: "onDragEnd"
    };
  },
  validationCombo: function validationCombo(item) {
    if (!this.origin || !item || item.destroyed) {
      return false;
    }
    var type = item.getType();
    if (type !== "combo") {
      return false;
    }
    return true;
  },
  onTouchStart: function onTouchStart2(evt) {
    if (!evt.item)
      return;
    var self2 = this;
    try {
      var touches = evt.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      evt.preventDefault();
    } catch (e8) {
      console.warn("Touch original event not exist!");
    }
    this.mousedown = {
      item: evt.item,
      target: evt.target
    };
    this.dragstart = true;
    self2.onDragStart(evt);
  },
  onTouchMove: function onTouchMove2(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        self2.onDragEnd(e8);
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.onDrag(e8);
  },
  /**
   * cache the manipulated item and target, since drag and dragend are global events but not node:*
   * @param evt event param
   */
  onMouseDown: function onMouseDown2(evt) {
    this.mousedown = {
      item: evt.item,
      target: evt.target
    };
    if (typeof window !== "undefined" && !this.windowEventBinded) {
      this.windowEventBinded = true;
      document.body.addEventListener("contextmenu", this.onDragEnd.bind(this));
      document.body.addEventListener("mouseup", this.onDragEnd.bind(this));
    }
  },
  /**
   * trigger dragstart/drag by mousedown and drag events
   * @param evt event param
   */
  onDragMove: function onDragMove2(evt) {
    var _a2, _b;
    if (((_b = (_a2 = evt.item) === null || _a2 === void 0 ? void 0 : _a2.getType) === null || _b === void 0 ? void 0 : _b.call(_a2)) !== "node") {
      this.onDragEnd();
      return;
    }
    if (!this.mousedown)
      return;
    if (!this.dragstart) {
      this.dragstart = true;
      this.onDragStart(evt);
    } else {
      this.onDrag(__assign(__assign({}, evt), this.mousedown));
    }
  },
  /**
   * 开始拖动节点
   * @param evt
   */
  onDragStart: function onDragStart2(evt) {
    var _this = this;
    this.currentShouldEnd = true;
    if (!this.shouldBegin(__assign(__assign({}, evt), this.mousedown), this)) {
      return;
    }
    var _a2 = this.mousedown, item = _a2.item, target = _a2.target;
    if (!item || item.destroyed || item.hasLocked()) {
      return;
    }
    var group = item.getContainer();
    group.set("capture", false);
    if (!this.cachedCaptureItems)
      this.cachedCaptureItems = [];
    this.cachedCaptureItems.push(item);
    if (target) {
      var isAnchorPoint = target.get("isAnchorPoint");
      if (isAnchorPoint) {
        return;
      }
    }
    var graph = this.graph;
    this.targets = [];
    this.targetCombo = null;
    var nodes = graph.findAllByState("node", this.selectedState);
    var currentNodeId = item.get("id");
    var dragNodes = nodes.filter(function(node) {
      var nodeId = node.get("id");
      return currentNodeId === nodeId;
    });
    if (dragNodes.length === 0) {
      this.targets.push(item);
    } else if (nodes.length > 1) {
      nodes.forEach(function(node) {
        var locked = node.hasLocked();
        if (!locked) {
          _this.targets.push(node);
        }
      });
    } else {
      this.targets.push(item);
    }
    if (this.graph.get("enabledStack") && this.enableStack) {
      var beforeDragNodes_1 = [];
      this.targets.forEach(function(t2) {
        var _a3 = t2.getModel(), x4 = _a3.x, y4 = _a3.y, id = _a3.id;
        beforeDragNodes_1.push({
          x: x4,
          y: y4,
          id
        });
      });
      this.set("beforeDragNodes", beforeDragNodes_1);
    }
    this.hidenEdge = {};
    if (this.get("updateEdge") && this.enableOptimize && !this.enableDelegate) {
      this.targets.forEach(function(node) {
        var edges = node.getEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible())
            return;
          _this.hidenEdge[edge.getID()] = true;
          edge.hide();
        });
      });
    }
    this.origin = {
      x: evt.x,
      y: evt.y
    };
    this.point = {};
    this.originPoint = {};
  },
  /**
   * 持续拖动节点
   * @param evt
   */
  onDrag: function onDrag2(evt) {
    var _this = this;
    if (!this.mousedown || !this.origin)
      return;
    if (!this.shouldUpdate(evt, this))
      return;
    if (this.get("enableDelegate")) {
      this.updateDelegate(evt);
    } else {
      if (this.enableDebounce) {
        this.debounceUpdate({
          targets: this.targets,
          graph: this.graph,
          point: this.point,
          origin: this.origin,
          evt,
          updateEdge: this.get("updateEdge"),
          onlyChangeComboSize: this.onlyChangeComboSize,
          updateParentCombos: this.updateParentCombos
        });
      } else {
        var parentComboMap_1 = {};
        this.targets.map(function(target) {
          _this.update(target, evt);
          var parentComboId = target.getModel().comboId;
          if (parentComboId)
            parentComboMap_1[parentComboId] = _this.graph.findById(parentComboId);
        });
        if (this.onlyChangeComboSize) {
          this.updateParentCombos();
        }
      }
    }
  },
  /**
   * 拖动结束，设置拖动元素capture为true，更新元素位置，如果是拖动涉及到 combo，则更新 combo 结构
   * @param evt
   */
  onDragEnd: function onDragEnd(evt) {
    var _this = this;
    var _a2;
    this.mousedown = false;
    this.dragstart = false;
    if (typeof window !== "undefined" && this.windowEventBinded) {
      this.windowEventBinded = false;
      document.body.removeEventListener("contextmenu", this.onDragEnd.bind(this));
      document.body.removeEventListener("mouseup", this.onDragEnd.bind(this));
    }
    if (!this.origin) {
      return;
    }
    (_a2 = this.cachedCaptureItems) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(item) {
      var group = item.getContainer();
      group.set("capture", true);
    });
    this.cachedCaptureItems = [];
    if (this.delegateRect) {
      this.delegateRect.remove();
      this.delegateRect = null;
    }
    if (this.get("updateEdge") && this.enableOptimize && !this.enableDelegate) {
      this.targets.forEach(function(node) {
        var edges = node.getEdges();
        edges.forEach(function(edge) {
          if (_this.hidenEdge[edge.getID()])
            edge.show();
          edge.refresh();
        });
      });
    }
    this.hidenEdge = {};
    var graph = this.graph;
    if (graph.get("enabledStack") && this.enableStack) {
      var stackData_1 = {
        before: {
          nodes: [],
          edges: [],
          combos: []
        },
        after: {
          nodes: [],
          edges: [],
          combos: []
        }
      };
      this.get("beforeDragNodes").forEach(function(model) {
        stackData_1.before.nodes.push(model);
      });
      this.targets.forEach(function(target) {
        var _a3 = target.getModel(), x4 = _a3.x, y4 = _a3.y, id = _a3.id;
        stackData_1.after.nodes.push({
          x: x4,
          y: y4,
          id
        });
      });
      graph.pushStack("update", clone_default(stackData_1));
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: null
    });
    this.point = {};
    this.origin = null;
    this.originPoint = {};
    this.targets.length = 0;
    this.targetCombo = null;
  },
  /**
   * 拖动过程中将节点放置到 combo 上
   * @param evt
   */
  onDropCombo: function onDropCombo(evt) {
    var item = evt.item;
    this.currentShouldEnd = this.shouldEnd(evt, item, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd || !this.validationCombo(item))
      return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, false);
    }
    this.targetCombo = item;
    if (this.onlyChangeComboSize) {
      graph.updateCombos();
    } else {
      var targetComboModel_1 = item.getModel();
      this.targets.map(function(node) {
        var nodeModel = node.getModel();
        if (nodeModel.comboId !== targetComboModel_1.id) {
          graph.updateComboTree(node, targetComboModel_1.id);
        }
      });
      graph.updateCombo(item);
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: this.targetCombo
    });
  },
  onDropCanvas: function onDropCanvas(evt) {
    var graph = this.graph;
    this.currentShouldEnd = this.shouldEnd(evt, void 0, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.targets || this.targets.length === 0 || !this.currentShouldEnd)
      return;
    if (this.onlyChangeComboSize) {
      this.updateParentCombos();
    } else {
      this.targets.map(function(node) {
        var model = node.getModel();
        if (model.comboId) {
          graph.updateComboTree(node);
        }
      });
    }
  },
  /**
   * 拖动放置到某个 combo 中的子 node 上
   * @param evt
   */
  onDropNode: function onDropNode(evt) {
    if (!this.targets || this.targets.length === 0)
      return;
    var self2 = this;
    var item = evt.item;
    var graph = self2.graph;
    var comboId = item.getModel().comboId;
    var newParentCombo = comboId ? graph.findById(comboId) : void 0;
    this.currentShouldEnd = this.shouldEnd(evt, newParentCombo, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd)
      return;
    if (this.onlyChangeComboSize) {
      this.updateParentCombos();
    } else if (comboId) {
      var combo = graph.findById(comboId);
      if (self2.comboActiveState) {
        graph.setItemState(combo, self2.comboActiveState, false);
      }
      this.targets.map(function(node) {
        var nodeModel = node.getModel();
        if (comboId !== nodeModel.comboId) {
          graph.updateComboTree(node, comboId);
        }
      });
      graph.updateCombo(combo);
    } else {
      this.targets.map(function(node) {
        var model = node.getModel();
        if (model.comboId) {
          graph.updateComboTree(node);
        }
      });
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: item
    });
  },
  /**
   * 将节点拖入到 Combo 中
   * @param evt
   */
  onDragEnter: function onDragEnter(evt) {
    var item = evt.item;
    if (!this.validationCombo(item))
      return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, true);
    }
  },
  /**
   * 将节点从 Combo 中拖出
   * @param evt
   */
  onDragLeave: function onDragLeave(evt) {
    var item = evt.item;
    if (!this.validationCombo(item))
      return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, false);
    }
  },
  updatePositions: function updatePositions(evt, restore) {
    var _this = this;
    if (!this.targets || this.targets.length === 0)
      return;
    if (this.get("enableDelegate")) {
      if (this.enableDebounce)
        this.debounceUpdate({
          targets: this.targets,
          graph: this.graph,
          point: this.point,
          origin: this.origin,
          evt,
          updateEdge: this.get("updateEdge"),
          onlyChangeComboSize: this.onlyChangeComboSize,
          updateParentCombos: this.updateParentCombos
        });
      else if (!restore)
        this.targets.map(function(node) {
          return _this.update(node, evt);
        });
    } else
      this.targets.map(function(node) {
        return _this.update(node, evt, restore);
      });
  },
  /**
   * 更新节点
   * @param item 拖动的节点实例
   * @param evt
   */
  update: function update13(item, evt, restore) {
    var origin = this.origin;
    var model = item.get("model");
    var nodeId = item.get("id");
    if (!this.point[nodeId]) {
      this.point[nodeId] = {
        x: model.x || 0,
        y: model.y || 0
      };
    }
    var x4 = evt.x - origin.x + this.point[nodeId].x;
    var y4 = evt.y - origin.y + this.point[nodeId].y;
    if (restore) {
      x4 += origin.x - evt.x;
      y4 += origin.y - evt.y;
    }
    var pos = {
      x: x4,
      y: y4
    };
    if (this.get("updateEdge")) {
      this.graph.updateItem(item, pos, false);
    } else {
      item.updatePosition(pos);
    }
  },
  /**
   * 限流更新节点
   * @param item 拖动的节点实例
   * @param evt
   */
  debounceUpdate: debounce_default(function(event) {
    var targets = event.targets, graph = event.graph, point = event.point, origin = event.origin, evt = event.evt, updateEdge = event.updateEdge, onlyChangeComboSize = event.onlyChangeComboSize, updateParentCombos3 = event.updateParentCombos;
    targets.map(function(item) {
      var model = item.get("model");
      var nodeId = item.get("id");
      if (!point[nodeId]) {
        point[nodeId] = {
          x: model.x || 0,
          y: model.y || 0
        };
      }
      var x4 = evt.x - origin.x + point[nodeId].x;
      var y4 = evt.y - origin.y + point[nodeId].y;
      var pos = {
        x: x4,
        y: y4
      };
      if (updateEdge) {
        graph.updateItem(item, pos, false);
      } else {
        item.updatePosition(pos);
      }
    });
    if (onlyChangeComboSize) {
      updateParentCombos3(graph, targets);
    }
  }, 50, true),
  /**
   * 更新拖动元素时的delegate
   * @param {Event} evt 事件句柄
   * @param {number} x 拖动单个元素时候的x坐标
   * @param {number} y 拖动单个元素时候的y坐标
   */
  updateDelegate: function updateDelegate(evt) {
    var graph = this.graph;
    if (!this.delegateRect) {
      var parent_1 = graph.get("group");
      var attrs = deep_mix_default({}, global_default2.delegateStyle, this.delegateStyle);
      var _a2 = this.calculationGroupPosition(evt), cx = _a2.x, cy = _a2.y, width = _a2.width, height = _a2.height, minX = _a2.minX, minY = _a2.minY;
      this.originPoint = {
        x: cx,
        y: cy,
        width,
        height,
        minX,
        minY
      };
      this.delegateRect = parent_1.addShape("rect", {
        attrs: __assign({
          width,
          height,
          x: cx,
          y: cy
        }, attrs),
        name: "rect-delegate-shape"
      });
      this.delegate = this.delegateRect;
      this.delegateRect.set("capture", false);
    } else {
      var clientX = evt.x - this.origin.x + this.originPoint.minX;
      var clientY = evt.y - this.origin.y + this.originPoint.minY;
      this.delegateRect.attr({
        x: clientX,
        y: clientY
      });
    }
  },
  /**
   * 计算delegate位置，包括左上角左边及宽度和高度
   * @memberof ItemGroup
   * @return {object} 计算出来的delegate坐标信息及宽高
   */
  calculationGroupPosition: function calculationGroupPosition(evt) {
    var nodes = this.targets;
    if (nodes.length === 0) {
      nodes.push(evt.item);
    }
    var minx = Infinity;
    var maxx = -Infinity;
    var miny = Infinity;
    var maxy = -Infinity;
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var element = nodes[i2];
      var bbox = element.getBBox();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (minX < minx) {
        minx = minX;
      }
      if (minY < miny) {
        miny = minY;
      }
      if (maxX > maxx) {
        maxx = maxX;
      }
      if (maxY > maxy) {
        maxy = maxY;
      }
    }
    var x4 = Math.floor(minx);
    var y4 = Math.floor(miny);
    var width = Math.ceil(maxx) - Math.floor(minx);
    var height = Math.ceil(maxy) - Math.floor(miny);
    return {
      x: x4,
      y: y4,
      width,
      height,
      minX: minx,
      minY: miny
    };
  },
  /**
   * updates the parent combos' size and position
   * @param paramGraph param for debounce function, where 'this' is not available
   * @param paramTargets param for debounce function, where 'this' is not available
   */
  updateParentCombos: function updateParentCombos(paramGraph, paramTargets) {
    var graph = paramGraph || this.graph;
    var targets = paramTargets || this.targets;
    var comboParentMap = {};
    targets === null || targets === void 0 ? void 0 : targets.forEach(function(target) {
      var comboId = target.getModel().comboId;
      if (comboId)
        comboParentMap[comboId] = graph.findById(comboId);
    });
    Object.values(comboParentMap).forEach(function(combo) {
      if (combo)
        graph.updateCombo(combo);
    });
  }
};

// node_modules/@antv/g6-pc/es/behavior/activate-relations.js
init_esm();
var activate_relations_default = {
  getDefaultCfg: function getDefaultCfg4() {
    return {
      // 可选 mouseenter || click
      // 选择 click 会监听 touch，mouseenter 不会监听
      trigger: "mouseenter",
      activeState: "active",
      inactiveState: "inactive",
      resetSelected: false,
      shouldUpdate: function shouldUpdate3() {
        return true;
      }
    };
  },
  getEvents: function getEvents4() {
    if (this.get("trigger") === "mouseenter") {
      return {
        "node:mouseenter": "setAllItemStates",
        "combo:mouseenter": "setAllItemStates",
        "node:mouseleave": "clearActiveState",
        "combo:mouseleave": "clearActiveState"
      };
    }
    return {
      "node:click": "setAllItemStates",
      "combo:click": "setAllItemStates",
      "canvas:click": "clearActiveState",
      "node:touchstart": "setOnTouchStart",
      "combo:touchstart": "setOnTouchStart",
      "canvas:touchstart": "clearOnTouchStart"
    };
  },
  setOnTouchStart: function setOnTouchStart(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.setAllItemStates(e8);
  },
  clearOnTouchStart: function clearOnTouchStart(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.clearActiveState(e8);
  },
  setAllItemStates: function setAllItemStates(e8) {
    clearTimeout(this.timer);
    this.throttleSetAllItemStates(e8, this);
  },
  clearActiveState: function clearActiveState(e8) {
    var _this = this;
    this.timer = setTimeout(function() {
      _this.throttleClearActiveState(e8, _this);
    }, 50);
  },
  throttleSetAllItemStates: throttle_default(function(e8, self2) {
    var item = e8.item;
    var graph = self2.graph;
    if (!graph || graph.destroyed)
      return;
    self2.item = item;
    if (!self2.shouldUpdate(e8.item, {
      event: e8,
      action: "activate"
    }, self2)) {
      return;
    }
    var activeState = self2.activeState;
    var inactiveState = self2.inactiveState;
    var nodes = graph.getNodes();
    var combos = graph.getCombos();
    var edges = graph.getEdges();
    var vEdges = graph.get("vedges");
    var nodeLength = nodes.length;
    var comboLength = combos.length;
    var edgeLength = edges.length;
    var vEdgeLength = vEdges.length;
    var inactiveItems = self2.inactiveItems || {};
    var activeItems = self2.activeItems || {};
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var node = nodes[i2];
      var nodeId = node.getID();
      var hasSelected = node.hasState("selected");
      if (self2.resetSelected) {
        if (hasSelected) {
          graph.setItemState(node, "selected", false);
        }
      }
      if (activeItems[nodeId]) {
        graph.setItemState(node, activeState, false);
        delete activeItems[nodeId];
      }
      if (inactiveState && !inactiveItems[nodeId]) {
        graph.setItemState(node, inactiveState, true);
        inactiveItems[nodeId] = node;
      }
    }
    for (var i2 = 0; i2 < comboLength; i2++) {
      var combo = combos[i2];
      var comboId = combo.getID();
      var hasSelected = combo.hasState("selected");
      if (self2.resetSelected) {
        if (hasSelected) {
          graph.setItemState(combo, "selected", false);
        }
      }
      if (activeItems[comboId]) {
        graph.setItemState(combo, activeState, false);
        delete activeItems[comboId];
      }
      if (inactiveState && !inactiveItems[comboId]) {
        graph.setItemState(combo, inactiveState, true);
        inactiveItems[comboId] = combo;
      }
    }
    for (var i2 = 0; i2 < edgeLength; i2++) {
      var edge = edges[i2];
      var edgeId = edge.getID();
      if (activeItems[edgeId]) {
        graph.setItemState(edge, activeState, false);
        delete activeItems[edgeId];
      }
      if (inactiveState && !inactiveItems[edgeId]) {
        graph.setItemState(edge, inactiveState, true);
        inactiveItems[edgeId] = edge;
      }
    }
    for (var i2 = 0; i2 < vEdgeLength; i2++) {
      var vEdge = vEdges[i2];
      var vEdgeId = vEdge.getID();
      if (activeItems[vEdgeId]) {
        graph.setItemState(vEdge, activeState, false);
        delete activeItems[vEdgeId];
      }
      if (inactiveState && !inactiveItems[vEdgeId]) {
        graph.setItemState(vEdge, inactiveState, true);
        inactiveItems[vEdgeId] = vEdge;
      }
    }
    if (item && !item.destroyed) {
      if (inactiveState) {
        graph.setItemState(item, inactiveState, false);
        delete inactiveItems[item.getID()];
      }
      if (!activeItems[item.getID()]) {
        graph.setItemState(item, activeState, true);
        activeItems[item.getID()] = item;
      }
      var rEdges = item.getEdges();
      var rEdgeLegnth = rEdges.length;
      for (var i2 = 0; i2 < rEdgeLegnth; i2++) {
        var edge = rEdges[i2];
        var edgeId = edge.getID();
        var otherEnd = void 0;
        if (edge.getSource() === item) {
          otherEnd = edge.getTarget();
        } else {
          otherEnd = edge.getSource();
        }
        var otherEndId = otherEnd.getID();
        if (inactiveState && inactiveItems[otherEndId]) {
          graph.setItemState(otherEnd, inactiveState, false);
          delete inactiveItems[otherEndId];
        }
        if (!activeItems[otherEndId]) {
          graph.setItemState(otherEnd, activeState, true);
          activeItems[otherEndId] = otherEnd;
        }
        if (inactiveItems[edgeId]) {
          graph.setItemState(edge, inactiveState, false);
          delete inactiveItems[edgeId];
        }
        if (!activeItems[edgeId]) {
          graph.setItemState(edge, activeState, true);
          activeItems[edgeId] = edge;
        }
        edge.toFront();
      }
    }
    self2.activeItems = activeItems;
    self2.inactiveItems = inactiveItems;
    graph.emit("afteractivaterelations", {
      item: e8.item,
      action: "activate"
    });
  }, 50, {
    trailing: true,
    leading: true
  }),
  throttleClearActiveState: throttle_default(function(e8, self2) {
    var graph = self2.get("graph");
    if (!graph || graph.destroyed)
      return;
    if (!self2.shouldUpdate(e8.item, {
      event: e8,
      action: "deactivate"
    }, self2))
      return;
    var activeState = self2.activeState;
    var inactiveState = self2.inactiveState;
    var activeItems = self2.activeItems || {};
    var inactiveItems = self2.inactiveItems || {};
    Object.values(activeItems).filter(function(item) {
      return !item.destroyed;
    }).forEach(function(item) {
      graph.clearItemStates(item, activeState);
    });
    Object.values(inactiveItems).filter(function(item) {
      return !item.destroyed;
    }).forEach(function(item) {
      graph.clearItemStates(item, inactiveState);
    });
    self2.activeItems = {};
    self2.inactiveItems = {};
    graph.emit("afteractivaterelations", {
      item: e8.item || self2.get("item"),
      action: "deactivate"
    });
  }, 50, {
    trailing: true,
    leading: true
  })
};

// node_modules/@antv/g6-pc/es/behavior/brush-select.js
var min2 = Math.min;
var max3 = Math.max;
var abs2 = Math.abs;
var DEFAULT_TRIGGER = "shift";
var ALLOW_EVENTS3 = ["drag", "shift", "ctrl", "alt", "control"];
var brush_select_default = {
  getDefaultCfg: function getDefaultCfg5() {
    return {
      brushStyle: {
        fill: "#EEF6FF",
        fillOpacity: 0.4,
        stroke: "#DDEEFE",
        lineWidth: 1
      },
      onSelect: function onSelect() {
      },
      onDeselect: function onDeselect() {
      },
      selectedState: "selected",
      trigger: DEFAULT_TRIGGER,
      includeEdges: true,
      includeCombos: false,
      selectedEdges: [],
      selectedNodes: [],
      selectedCombos: []
    };
  },
  getEvents: function getEvents5() {
    if (!(ALLOW_EVENTS3.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER;
      console.warn("Behavior brush-select 的 trigger 参数不合法，请输入 'drag'、'shift'、'ctrl' 或 'alt'");
    }
    if (this.trigger === "drag") {
      return {
        "dragstart": "onMouseDown",
        "drag": "onMouseMove",
        "dragend": "onMouseUp",
        "canvas:click": "clearStates"
      };
    }
    return {
      "dragstart": "onMouseDown",
      "drag": "onMouseMove",
      "dragend": "onMouseUp",
      "canvas:click": "clearStates",
      "keyup": "onKeyUp",
      "keydown": "onKeyDown"
    };
  },
  onMouseDown: function onMouseDown3(e8) {
    var item = e8.item;
    var brush = this.brush;
    if (item) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    if (this.selectedNodes && this.selectedNodes.length !== 0) {
      this.clearStates();
    }
    if (!brush) {
      brush = this.createBrush();
    }
    this.originPoint = {
      x: e8.canvasX,
      y: e8.canvasY
    };
    brush.attr({
      width: 0,
      height: 0
    });
    brush.show();
    this.dragging = true;
  },
  onMouseMove: function onMouseMove(e8) {
    if (!this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.updateBrush(e8);
  },
  onMouseUp: function onMouseUp2(e8) {
    var graph = this.graph;
    if (!this.brush && !this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.brush.remove(true);
    this.brush = null;
    this.getSelectedNodes(e8);
    this.dragging = false;
  },
  clearStates: function clearStates() {
    var _a2 = this, graph = _a2.graph, selectedState = _a2.selectedState;
    var nodes = graph.findAllByState("node", selectedState);
    var edges = graph.findAllByState("edge", selectedState);
    var combos = graph.findAllByState("combo", selectedState);
    nodes.forEach(function(node) {
      return graph.setItemState(node, selectedState, false);
    });
    edges.forEach(function(edge) {
      return graph.setItemState(edge, selectedState, false);
    });
    combos.forEach(function(combo) {
      return graph.setItemState(combo, selectedState, false);
    });
    this.selectedNodes = [];
    this.selectedEdges = [];
    this.selectedCombos = [];
    if (this.onDeselect) {
      this.onDeselect(this.selectedNodes, this.selectedEdges, this.selectedCombos);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: [],
        combos: []
      },
      select: false
    });
  },
  isBBoxCenterInRect: function isBBoxCenterInRect(item, left, right, top, bottom) {
    var bbox = item.getBBox();
    return bbox.centerX >= left && bbox.centerX <= right && bbox.centerY >= top && bbox.centerY <= bottom;
  },
  getSelectedNodes: function getSelectedNodes(e8) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, originPoint = _a2.originPoint, shouldUpdate3 = _a2.shouldUpdate, isBBoxCenterInRect2 = _a2.isBBoxCenterInRect;
    var state = this.selectedState;
    var p1 = {
      x: e8.x,
      y: e8.y
    };
    var p2 = graph.getPointByCanvas(originPoint.x, originPoint.y);
    var left = min2(p1.x, p2.x);
    var right = max3(p1.x, p2.x);
    var top = min2(p1.y, p2.y);
    var bottom = max3(p1.y, p2.y);
    var selectedNodes = [];
    var selectedIds = [];
    graph.getNodes().forEach(function(node) {
      if (node.isVisible() && // 隐藏节点不能被选中
      isBBoxCenterInRect2(node, left, right, top, bottom) && shouldUpdate3(node, "select", _this)) {
        selectedNodes.push(node);
        var model = node.getModel();
        selectedIds.push(model.id);
        graph.setItemState(node, state, true);
      }
    });
    var selectedEdges = [];
    if (this.includeEdges) {
      selectedNodes.forEach(function(node) {
        var edges = node.getOutEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible())
            return;
          var model = edge.getModel();
          var source = model.source, target = model.target;
          if (selectedIds.includes(source) && selectedIds.includes(target) && shouldUpdate3(edge, "select", _this)) {
            selectedEdges.push(edge);
            graph.setItemState(edge, _this.selectedState, true);
          }
        });
      });
    }
    var selectedCombos = [];
    if (this.includeCombos) {
      graph.getCombos().forEach(function(combo) {
        if (combo.isVisible() && // 隐藏节点不能被选中
        isBBoxCenterInRect2(combo, left, right, top, bottom) && shouldUpdate3(combo, "select", _this)) {
          selectedCombos.push(combo);
          var model = combo.getModel();
          selectedIds.push(model.id);
          graph.setItemState(combo, state, true);
        }
      });
    }
    this.selectedEdges = selectedEdges;
    this.selectedNodes = selectedNodes;
    this.selectedCombos = selectedCombos;
    if (this.onSelect) {
      this.onSelect(selectedNodes, selectedEdges, selectedCombos);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: selectedNodes,
        edges: selectedEdges,
        combos: selectedCombos
      },
      select: true
    });
  },
  createBrush: function createBrush() {
    var self2 = this;
    var brush = self2.graph.get("canvas").addShape("rect", {
      attrs: self2.brushStyle,
      capture: false,
      name: "brush-shape"
    });
    this.brush = brush;
    this.delegate = brush;
    return brush;
  },
  updateBrush: function updateBrush(e8) {
    var originPoint = this.originPoint;
    this.brush.attr({
      width: abs2(e8.canvasX - originPoint.x),
      height: abs2(e8.canvasY - originPoint.y),
      x: min2(e8.canvasX, originPoint.x),
      y: min2(e8.canvasY, originPoint.y)
    });
  },
  onKeyDown: function onKeyDown2(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    var triggerLowerCase = this.trigger.toLowerCase();
    var codeLowerCase = code.toLowerCase();
    if (codeLowerCase === triggerLowerCase || codeLowerCase === "control" && triggerLowerCase === "ctrl" || codeLowerCase === "ctrl" && triggerLowerCase === "control") {
      this.keydown = true;
    } else {
      this.keydown = false;
    }
  },
  onKeyUp: function onKeyUp2() {
    if (this.brush) {
      this.brush.remove(true);
      this.brush = null;
      this.dragging = false;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/click-select.js
init_esm();
var DEFAULT_TRIGGER2 = "shift";
var ALLOW_EVENTS4 = ["shift", "ctrl", "alt", "control"];
var click_select_default = {
  getDefaultCfg: function getDefaultCfg6() {
    return {
      multiple: true,
      trigger: DEFAULT_TRIGGER2,
      selectedState: "selected",
      selectNode: true,
      selectEdge: false,
      selectCombo: true
    };
  },
  getEvents: function getEvents6() {
    var self2 = this;
    if (!(ALLOW_EVENTS4.indexOf(self2.trigger.toLowerCase()) > -1)) {
      self2.trigger = DEFAULT_TRIGGER2;
      console.warn("Behavior click-select 的 trigger 参数不合法，请输入 'drag'、'shift'、'ctrl' 或 'alt'");
    }
    if (!self2.multiple) {
      return {
        "node:click": "onClick",
        "combo:click": "onClick",
        "edge:click": "onClick",
        "canvas:click": "onCanvasClick"
      };
    }
    return {
      "node:click": "onClick",
      "combo:click": "onClick",
      "edge:click": "onClick",
      "canvas:click": "onCanvasClick",
      keyup: "onKeyUp",
      keydown: "onKeyDown"
    };
  },
  onClick: function onClick(evt) {
    var self2 = this;
    var item = evt.item;
    if (!item || item.destroyed) {
      return;
    }
    var type = item.getType();
    var graph = self2.graph, keydown = self2.keydown, multiple = self2.multiple, shouldUpdate3 = self2.shouldUpdate, shouldBegin2 = self2.shouldBegin;
    if (!shouldBegin2(evt, self2)) {
      return;
    }
    if (!keydown || !multiple) {
      var selected = graph.findAllByState("node", self2.selectedState).concat(graph.findAllByState("edge", self2.selectedState)).concat(graph.findAllByState("combo", self2.selectedState));
      each_default(selected, function(selectedItem) {
        if (selectedItem !== item) {
          graph.setItemState(selectedItem, self2.selectedState, false);
        }
      });
    }
    var itemSelectable = function() {
      switch (type) {
        case "node":
          return self2.selectNode;
        case "edge":
          return self2.selectEdge;
        case "combo":
          return self2.selectCombo;
        default:
          return false;
      }
    }();
    if (!itemSelectable) {
      var selectedNodes = graph.findAllByState("node", self2.selectedState);
      var selectedEdges = graph.findAllByState("edge", self2.selectedState);
      var selectedCombos = graph.findAllByState("combo", self2.selectedState);
      graph.emit("nodeselectchange", {
        selectedItems: {
          nodes: selectedNodes,
          edges: selectedEdges,
          combos: selectedCombos
        },
        select: false
      });
      return;
    }
    if (item.hasState(self2.selectedState)) {
      if (shouldUpdate3(evt, self2)) {
        graph.setItemState(item, self2.selectedState, false);
      }
      var selectedNodes = graph.findAllByState("node", self2.selectedState);
      var selectedEdges = graph.findAllByState("edge", self2.selectedState);
      var selectedCombos = graph.findAllByState("combo", self2.selectedState);
      graph.emit("nodeselectchange", {
        target: item,
        selectedItems: {
          nodes: selectedNodes,
          edges: selectedEdges,
          combos: selectedCombos
        },
        select: false
      });
    } else {
      if (shouldUpdate3(evt, self2)) {
        graph.setItemState(item, self2.selectedState, true);
      }
      var selectedNodes = graph.findAllByState("node", self2.selectedState);
      var selectedEdges = graph.findAllByState("edge", self2.selectedState);
      var selectedCombos = graph.findAllByState("combo", self2.selectedState);
      graph.emit("nodeselectchange", {
        target: item,
        selectedItems: {
          nodes: selectedNodes,
          edges: selectedEdges,
          combos: selectedCombos
        },
        select: true
      });
    }
  },
  onCanvasClick: function onCanvasClick(evt) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, shouldBegin2 = _a2.shouldBegin;
    if (!shouldBegin2(evt, this)) {
      return;
    }
    var selected = graph.findAllByState("node", this.selectedState);
    each_default(selected, function(node) {
      graph.setItemState(node, _this.selectedState, false);
    });
    var selectedEdges = graph.findAllByState("edge", this.selectedState);
    each_default(selectedEdges, function(edge) {
      graph.setItemState(edge, _this.selectedState, false);
    });
    var selectedCombos = graph.findAllByState("combo", this.selectedState);
    each_default(selectedCombos, function(combo) {
      graph.setItemState(combo, _this.selectedState, false);
    });
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: [],
        combos: []
      },
      select: false
    });
  },
  onKeyDown: function onKeyDown3(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === this.trigger.toLowerCase() || code.toLowerCase() === "control") {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp3() {
    var self2 = this;
    self2.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/zoom-canvas.js
init_esm();
var transform12 = ext_exports.transform;
var DELTA4 = 0.05;
var zoom_canvas_default = {
  getDefaultCfg: function getDefaultCfg7() {
    return {
      sensitivity: 2,
      minZoom: void 0,
      maxZoom: void 0,
      enableOptimize: false,
      optimizeZoom: 0.1,
      fixSelectedItems: {
        fixAll: false,
        fixLineWidth: false,
        fixLabel: false,
        fixState: "selected"
      },
      animate: false,
      animateCfg: {
        duration: 500
      }
    };
  },
  getEvents: function getEvents7() {
    var fixSelectedItems = this.fixSelectedItems;
    if (!fixSelectedItems.fixState)
      fixSelectedItems.fixState = "selected";
    if (fixSelectedItems.fixAll) {
      fixSelectedItems.fixLineWidth = true;
      fixSelectedItems.fixLabel = true;
    }
    return {
      wheel: "onWheel",
      touchstart: "onTouchStart",
      touchmove: "onTouchMove",
      touchend: "onTouchEnd"
    };
  },
  onTouchStart: function onTouchStart3(evt) {
    var touches = evt.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    evt.preventDefault();
    if (!event2) {
      return;
    }
    if (this.shouldBegin && !this.shouldBegin(evt, this)) {
      return;
    }
    this.startPoint = {
      pageX: event1.pageX,
      pageY: event1.pageY
    };
    this.moveable = true;
    if (event2) {
      this.endPoint = {
        pageX: event2.pageX,
        pageY: event2.pageY
      };
    }
    this.originScale = this.graph.getZoom() || this.currentScale || 1;
  },
  onTouchMove: function onTouchMove3(evt) {
    if (!this.moveable) {
      return;
    }
    evt.preventDefault();
    var touches = evt.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (!event2) {
      return;
    }
    if (!this.endPoint) {
      this.endPoint = {
        pageX: event2.pageX,
        pageY: event2.pageY
      };
    }
    var getDistance3 = function getDistance4(start, end2) {
      return Math.hypot(end2.x - start.x, end2.y - start.y);
    };
    var scale3 = getDistance3({
      x: event1.pageX,
      y: event1.pageY
    }, {
      x: event2.pageX,
      y: event2.pageY
    }) / getDistance3({
      x: this.startPoint.pageX,
      y: this.startPoint.pageY
    }, {
      x: this.endPoint.pageX,
      y: this.endPoint.pageY
    });
    var zoom = this.originScale * scale3;
    this.currentScale = zoom;
    var minZoom = this.get("minZoom") || this.graph.get("minZoom");
    var maxZoom = this.get("maxZoom") || this.graph.get("maxZoom");
    if (zoom > maxZoom || zoom < minZoom) {
      return;
    }
    var animate = this.get("animate");
    var animateCfg = this.get("animateCfg");
    var canvas = this.graph.get("canvas");
    var point = canvas.getPointByClient(evt.clientX, evt.clientY);
    this.graph.zoomTo(zoom, {
      x: point.x,
      y: point.y
    }, animate, animateCfg);
    this.graph.emit("wheelzoom", evt);
  },
  onTouchEnd: function onTouchEnd() {
    this.moveable = false;
    this.endPoint = null;
  },
  onWheel: function onWheel(e8) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, fixSelectedItems = _a2.fixSelectedItems;
    if (this.shouldBegin && !this.shouldBegin(e8, this)) {
      return;
    }
    if (!this.shouldUpdate(e8, this)) {
      return;
    }
    e8.preventDefault();
    var canvas = graph.get("canvas");
    var point = canvas.getPointByClient(e8.clientX, e8.clientY);
    var sensitivity = this.get("sensitivity");
    var graphZoom = graph.getZoom();
    var ratio = graphZoom;
    var zoom = graphZoom;
    if (e8.wheelDelta < 0) {
      ratio = 1 - DELTA4 * sensitivity;
    } else {
      ratio = 1 / (1 - DELTA4 * sensitivity);
    }
    zoom = graphZoom * ratio;
    var minZoom = this.get("minZoom") || graph.get("minZoom");
    var maxZoom = this.get("maxZoom") || graph.get("maxZoom");
    if (zoom > maxZoom) {
      zoom = maxZoom;
    } else if (zoom < minZoom) {
      zoom = minZoom;
    }
    var enableOptimize = this.get("enableOptimize");
    if (enableOptimize) {
      var optimizeZoom_1 = this.get("optimizeZoom");
      var optimized = this.get("optimized");
      var nodes_1 = graph.getNodes();
      var edges_1 = graph.getEdges();
      var nodesLength_1 = nodes_1.length;
      var edgesLength_1 = edges_1.length;
      if (!optimized) {
        for (var n2 = 0; n2 < nodesLength_1; n2++) {
          var node = nodes_1[n2];
          if (!node.destroyed) {
            var children = node.get("group").get("children");
            var childrenLength = children.length;
            for (var c3 = 0; c3 < childrenLength; c3++) {
              var shape = children[c3];
              if (!shape.destoryed && !shape.get("isKeyShape")) {
                shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
                shape.hide();
              }
            }
          }
        }
        for (var edgeIndex = 0; edgeIndex < edgesLength_1; edgeIndex++) {
          var edge = edges_1[edgeIndex];
          var children = edge.get("group").get("children");
          var childrenLength = children.length;
          for (var c3 = 0; c3 < childrenLength; c3++) {
            var shape = children[c3];
            shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
            shape.hide();
          }
        }
        this.set("optimized", true);
      }
      clearTimeout(this.get("timeout"));
      var timeout = setTimeout(function() {
        var currentZoom = graph.getZoom();
        var curOptimized = _this.get("optimized");
        if (curOptimized) {
          _this.set("optimized", false);
          for (var n3 = 0; n3 < nodesLength_1; n3++) {
            var node2 = nodes_1[n3];
            var children2 = node2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = node2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              keyShape.set("ori-visibility", void 0);
              if (oriVis)
                keyShape.show();
            } else {
              for (var c4 = 0; c4 < childrenLength2; c4++) {
                var shape2 = children2[c4];
                var oriVis = shape2.get("ori-visibility");
                shape2.set("ori-visibility", void 0);
                if (!shape2.get("visible") && oriVis) {
                  if (oriVis)
                    shape2.show();
                }
              }
            }
          }
          for (var edgeIndex2 = 0; edgeIndex2 < edgesLength_1; edgeIndex2++) {
            var edge2 = edges_1[edgeIndex2];
            var children2 = edge2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = edge2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              keyShape.set("ori-visibility", void 0);
              if (oriVis)
                keyShape.show();
            } else {
              for (var c4 = 0; c4 < childrenLength2; c4++) {
                var shape2 = children2[c4];
                if (!shape2.get("visible")) {
                  var oriVis = shape2.get("ori-visibility");
                  shape2.set("ori-visibility", void 0);
                  if (oriVis)
                    shape2.show();
                }
              }
            }
          }
        }
      }, 100);
      this.set("timeout", timeout);
    }
    if (graphZoom <= 1) {
      var fixNodes = void 0, fixEdges = void 0;
      if (fixSelectedItems.fixAll || fixSelectedItems.fixLineWidth || fixSelectedItems.fixLabel) {
        fixNodes = graph.findAllByState("node", fixSelectedItems.fixState);
        fixEdges = graph.findAllByState("edge", fixSelectedItems.fixState);
        var scale3 = graphZoom / zoom;
        var fixNodesLength = fixNodes.length;
        for (var fn2 = 0; fn2 < fixNodesLength; fn2++) {
          var node = fixNodes[fn2];
          var group = node.getContainer();
          var nodeModel = node.getModel();
          var originStyle = node.getOriginStyle();
          var itemStateStyle = node.getStateStyle(fixSelectedItems.fixState);
          var shapeStateStyle = node.get("shapeFactory").getShape(nodeModel.type).getStateStyle(fixSelectedItems.fixState, node)[fixSelectedItems.fixState];
          if (fixSelectedItems.fixAll) {
            if (zoom <= 1) {
              var groupMatrix = clone_default(group.getMatrix());
              if (!groupMatrix)
                groupMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
              var _b = node.getModel(), x4 = _b.x, y4 = _b.y;
              groupMatrix = transform12(groupMatrix, [["t", -x4, -y4], ["s", scale3, scale3], ["t", x4, y4]]);
              group.setMatrix(groupMatrix);
            }
          } else {
            var children = group.get("children");
            var childrenLength = children.length;
            for (var c3 = 0; c3 < childrenLength; c3++) {
              var shape = children[c3];
              var fontSize = void 0, lineWidth = void 0;
              if (fixSelectedItems.fixLabel) {
                var shapeType = shape.get("type");
                if (shapeType === "text") {
                  fontSize = shape.attr("fontSize") || 12;
                  var itemStyle = itemStateStyle[shape.get("name")];
                  var shapeStyle = shapeStateStyle[shape.get("name")];
                  var itemFontSize = itemStyle ? itemStyle.fontSize : 12;
                  var shapeFontSize = shapeStyle ? shapeStyle.fontSize : 12;
                  var oriFontSize = itemFontSize || shapeFontSize || 12;
                  if (zoom <= 1)
                    shape.attr("fontSize", oriFontSize / zoom);
                  if (lineWidth)
                    break;
                }
              }
              if (fixSelectedItems.fixLineWidth) {
                if (shape.get("isKeyShape")) {
                  lineWidth = shape.attr("lineWidth") || 0;
                  var oriLineWidth = itemStateStyle.lineWidth || shapeStateStyle.lineWidth || originStyle.lineWidth || 0;
                  if (zoom <= 1)
                    shape.attr("lineWidth", oriLineWidth / zoom);
                  if (fontSize)
                    break;
                }
              }
            }
          }
        }
        var fixEdgesLength = fixEdges.length;
        for (var fe2 = 0; fe2 < fixEdgesLength; fe2++) {
          var edge = fixEdges[fe2];
          var group = edge.getContainer();
          var children = group.get("children");
          var nodeModel = edge.getModel();
          var itemStateStyle = edge.getStateStyle(fixSelectedItems.fixState);
          var shapeStateStyle = edge.get("shapeFactory").getShape(nodeModel.type).getStateStyle(fixSelectedItems.fixState, edge)[fixSelectedItems.fixState];
          var childrenLength = children.length;
          for (var c3 = 0; c3 < childrenLength; c3++) {
            var shape = children[c3];
            var fontSize = void 0, lineWidth = void 0;
            if (fixSelectedItems.fixLabel || fixSelectedItems.fixAll) {
              var shapeType = shape.get("type");
              if (shapeType === "text") {
                fontSize = shape.attr("fontSize") || 12;
                var itemStyle = itemStateStyle[shape.get("name")];
                var shapeStyle = shapeStateStyle[shape.get("name")];
                var itemFontSize = itemStyle ? itemStyle.fontSize : 12;
                var shapeFontSize = shapeStyle ? shapeStyle.fontSize : 12;
                var oriFontSize = itemFontSize || shapeFontSize || 12;
                if (zoom <= 1)
                  shape.attr("fontSize", oriFontSize / zoom);
                if (lineWidth)
                  break;
              }
            }
            if (fixSelectedItems.fixLineWidth || fixSelectedItems.fixAll) {
              if (shape.get("isKeyShape")) {
                lineWidth = shape.attr("lineWidth") || 0;
                var oriLineWidth = itemStateStyle.lineWidth || shapeStateStyle.lineWidth || 1;
                if (zoom <= 1)
                  shape.attr("lineWidth", oriLineWidth / zoom);
                if (fontSize)
                  break;
              }
            }
          }
        }
      }
    }
    var animate = this.get("animate");
    var animateCfg = this.get("animateCfg");
    graph.zoomTo(zoom, {
      x: point.x,
      y: point.y
    }, animate, animateCfg);
    graph.emit("wheelzoom", e8);
  }
};

// node_modules/@antv/g6-pc/es/behavior/tooltip.js
init_tslib_es6();

// node_modules/@antv/g6-pc/es/behavior/tooltip-base.js
var tooltip_base_default = {
  onMouseEnter: function onMouseEnter(e8) {
    var item = e8.item;
    this.currentTarget = item;
    this.showTooltip(e8);
    this.graph.emit("tooltipchange", {
      item: e8.item,
      action: "show"
    });
  },
  onMouseMove: function onMouseMove2(e8) {
    if (!this.shouldUpdate(e8, this)) {
      this.hideTooltip();
      return;
    }
    if (!this.currentTarget || e8.item !== this.currentTarget) {
      return;
    }
    this.updatePosition(e8);
  },
  onMouseLeave: function onMouseLeave(e8) {
    if (!this.shouldEnd(e8, this)) {
      return;
    }
    this.hideTooltip();
    this.graph.emit("tooltipchange", {
      item: this.currentTarget,
      action: "hide"
    });
    this.currentTarget = null;
  },
  showTooltip: function showTooltip(e8) {
    var container = this.container;
    if (!e8.item || e8.item.destroyed) {
      return;
    }
    if (!container) {
      container = this.createTooltip(this.graph.get("canvas"));
      this.container = container;
    }
    var text = this.formatText(e8.item.get("model"), e8);
    container.innerHTML = text;
    modifyCSS(this.container, {
      visibility: "visible"
    });
    this.updatePosition(e8);
  },
  hideTooltip: function hideTooltip() {
    modifyCSS(this.container, {
      visibility: "hidden"
    });
  },
  updatePosition: function updatePosition(e8) {
    var shouldBegin2 = this.get("shouldBegin");
    var _a2 = this, width = _a2.width, height = _a2.height, container = _a2.container, graph = _a2.graph;
    if (!shouldBegin2(e8, this)) {
      modifyCSS(container, {
        visibility: "hidden"
      });
      return;
    }
    var point = graph.getPointByClient(e8.clientX, e8.clientY);
    var _b = graph.getCanvasByPoint(point.x, point.y), x4 = _b.x, y4 = _b.y;
    var bbox = container.getBoundingClientRect();
    if (x4 > width / 2) {
      x4 -= bbox.width;
    } else {
      x4 += this.offset;
    }
    if (y4 > height / 2) {
      y4 -= bbox.height;
    } else {
      y4 += this.offset;
    }
    var left = "".concat(x4, "px");
    var top = "".concat(y4, "px");
    modifyCSS(this.container, {
      left,
      top,
      visibility: "visible"
    });
  },
  createTooltip: function createTooltip(canvas) {
    var el = canvas.get("el");
    el.style.position = "relative";
    var container = createDom('<div class="g6-tooltip g6-'.concat(this.item, '-tooltip"></div>'));
    el.parentNode.appendChild(container);
    modifyCSS(container, {
      position: "absolute",
      visibility: "visible"
    });
    this.width = canvas.get("width");
    this.height = canvas.get("height");
    this.container = container;
    this.graph.get("tooltips").push(container);
    return container;
  }
};

// node_modules/@antv/g6-pc/es/behavior/tooltip.js
var tooltip_default2 = __assign({
  getDefaultCfg: function getDefaultCfg8() {
    return {
      item: "node",
      offset: 12,
      formatText: function formatText(model) {
        return model.label;
      }
    };
  },
  getEvents: function getEvents8() {
    return {
      "node:mouseenter": "onMouseEnter",
      "node:mouseleave": "onMouseLeave",
      "node:mousemove": "onMouseMove",
      afterremoveitem: "onMouseLeave"
    };
  }
}, tooltip_base_default);

// node_modules/@antv/g6-pc/es/behavior/edge-tooltip.js
init_tslib_es6();
var edge_tooltip_default = __assign({
  getDefaultCfg: function getDefaultCfg9() {
    return {
      item: "edge",
      offset: 12,
      formatText: function formatText(model) {
        return "source: ".concat(model.source, " target: ").concat(model.target);
      }
    };
  },
  getEvents: function getEvents9() {
    return {
      "edge:mouseenter": "onMouseEnter",
      "edge:mouseleave": "onMouseLeave",
      "edge:mousemove": "onMouseMove",
      afterremoveitem: "onMouseLeave"
    };
  }
}, tooltip_base_default);

// node_modules/@antv/g6-pc/es/behavior/collapse-expand.js
var DEFAULT_TRIGGER3 = "click";
var ALLOW_EVENTS5 = ["click", "dblclick"];
var collapse_expand_default = {
  getDefaultCfg: function getDefaultCfg10() {
    return {
      /**
       * 发生收缩/扩展变化时的回调
       */
      trigger: DEFAULT_TRIGGER3,
      onChange: function onChange() {
      }
    };
  },
  getEvents: function getEvents10() {
    var _a2;
    var trigger;
    if (ALLOW_EVENTS5.includes(this.trigger)) {
      trigger = this.trigger;
    } else {
      trigger = DEFAULT_TRIGGER3;
      console.warn("Behavior collapse-expand 的 trigger 参数不合法，请输入 'click' 或 'dblclick'");
    }
    return _a2 = {}, _a2["node:".concat(trigger)] = "onNodeClick", // 支持移动端事件
    _a2.touchstart = "onNodeClick", _a2;
  },
  onNodeClick: function onNodeClick(e8) {
    var _this = this;
    if (this.trigger === "click") {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = 0;
        return;
      }
      this.timer = setTimeout(function() {
        _this.toggle(e8);
        clearTimeout(_this.timer);
        _this.timer = 0;
      }, 200);
    } else {
      this.toggle(e8);
    }
  },
  toggle: function toggle(e8) {
    var item = e8.item;
    if (!item)
      return;
    var sourceData = this.graph.findDataById(item.get("id"));
    if (!sourceData) {
      return;
    }
    var children = sourceData.children;
    if (!children || children.length === 0) {
      return;
    }
    var collapsed = !sourceData.collapsed;
    if (!this.shouldBegin(e8, collapsed, this)) {
      return;
    }
    sourceData.collapsed = collapsed;
    item.getModel().collapsed = collapsed;
    this.graph.emit("itemcollapsed", {
      item: e8.item,
      collapsed
    });
    if (!this.shouldUpdate(e8, collapsed, this)) {
      return;
    }
    this.onChange(item, collapsed, this);
    this.graph.layout();
  }
};

// node_modules/@antv/g6-pc/es/behavior/drag-combo.js
init_tslib_es6();
init_esm();
var calculationItemsBBox3 = util_default2.calculationItemsBBox;
var traverseCombo = function traverseCombo2(data, fn2) {
  if (fn2(data) === false) {
    return;
  }
  if (data) {
    var combos = data.get("combos");
    if (combos.length === 0) {
      return false;
    }
    each_default(combos, function(child) {
      traverseCombo2(child, fn2);
    });
  }
};
var drag_combo_default = {
  getDefaultCfg: function getDefaultCfg11() {
    return {
      enableDelegate: false,
      delegateStyle: {},
      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构
      onlyChangeComboSize: false,
      // 拖动过程中目标 combo 状态样式
      activeState: "",
      selectedState: "selected",
      enableStack: true
    };
  },
  getEvents: function getEvents11() {
    return {
      "combo:dragstart": "onDragStart",
      "combo:drag": "onDrag",
      "combo:dragend": "onDragEnd",
      "combo:drop": "onDrop",
      "node:drop": "onNodeDrop",
      "combo:dragenter": "onDragEnter",
      "combo:dragleave": "onDragLeave"
    };
  },
  validationCombo: function validationCombo2(evt) {
    var item = evt.item;
    if (!item || item.destroyed) {
      return false;
    }
    if (!this.shouldUpdate(evt, this)) {
      return false;
    }
    var type = item.getType();
    if (type !== "combo") {
      return false;
    }
    return true;
  },
  onDragStart: function onDragStart3(evt) {
    var _this = this;
    var graph = this.graph;
    var item = evt.item;
    this.currentShouldEnd = true;
    if (!this.validationCombo(evt))
      return;
    this.targets = [];
    var combos = graph.findAllByState("combo", this.selectedState);
    var currentCombo = item.get("id");
    var dragCombos = combos.filter(function(combo) {
      var comboId = combo.get("id");
      return currentCombo === comboId;
    });
    if (dragCombos.length === 0) {
      this.targets.push(item);
    } else {
      this.targets = combos;
    }
    var beforeDragItems = [];
    this.targets.forEach(function(t2) {
      var _a2 = t2.getModel(), x4 = _a2.x, y4 = _a2.y, id = _a2.id;
      beforeDragItems.push({
        x: x4,
        y: y4,
        id
      });
    });
    this.set("beforeDragItems", beforeDragItems);
    if (this.activeState) {
      this.targets.map(function(combo) {
        var model = combo.getModel();
        if (model.parentId) {
          var parentCombo = graph.findById(model.parentId);
          if (parentCombo) {
            graph.setItemState(parentCombo, _this.activeState, true);
          }
        }
      });
    }
    this.point = {};
    this.originPoint = {};
    this.origin = {
      x: evt.x,
      y: evt.y
    };
    this.currentItemChildCombos = [];
    traverseCombo(item, function(param) {
      if (param.destroyed) {
        return false;
      }
      var model = param.getModel();
      _this.currentItemChildCombos.push(model.id);
      return true;
    });
  },
  onDrag: function onDrag3(evt) {
    var _this = this;
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt))
      return;
    if (this.enableDelegate) {
      this.updateDelegate(evt);
    } else {
      if (this.activeState) {
        var graph_1 = this.graph;
        var item = evt.item;
        var model_1 = item.getModel();
        var combos = graph_1.getCombos();
        var sourceBBox = item.getBBox();
        var centerX_1 = sourceBBox.centerX, centerY_1 = sourceBBox.centerY, width_1 = sourceBBox.width;
        var calcCombos = combos.filter(function(combo) {
          var cmodel = combo.getModel();
          if (!model_1.parentId) {
            return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);
          }
          return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);
        });
        calcCombos.map(function(combo) {
          var _a2 = combo.getBBox(), cx = _a2.centerX, cy = _a2.centerY, w2 = _a2.width;
          var disX = centerX_1 - cx;
          var disY = centerY_1 - cy;
          var distance6 = 2 * Math.sqrt(disX * disX + disY * disY);
          if (width_1 + w2 - distance6 > 0.8 * width_1) {
            graph_1.setItemState(combo, _this.activeState, true);
          } else {
            graph_1.setItemState(combo, _this.activeState, false);
          }
        });
      }
      each_default(this.targets, function(item2) {
        _this.updateCombo(item2, evt);
      });
      if (this.onlyChangeComboSize) {
        this.updateParentCombos();
      }
    }
  },
  updatePositions: function updatePositions2(evt, restore) {
    var _this = this;
    if (this.enableDelegate || restore) {
      each_default(this.targets, function(item) {
        _this.updateCombo(item, evt, restore);
      });
    }
  },
  onDrop: function onDrop(evt) {
    var _this = this;
    var item = evt.item;
    this.currentShouldEnd = this.shouldEnd(evt, item, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd || !item || !this.targets || item.destroyed)
      return;
    var graph = this.graph;
    var targetModel = item.getModel();
    this.targets.map(function(combo) {
      var model = combo.getModel();
      if (model.parentId !== targetModel.id) {
        if (_this.activeState) {
          graph.setItemState(item, _this.activeState, false);
        }
        if (!_this.onlyChangeComboSize) {
          graph.updateComboTree(combo, targetModel.id, false);
        } else {
          graph.updateCombo(combo);
        }
      } else {
        graph.updateCombo(item);
      }
    });
    this.end(item, evt);
    this.endComparison = true;
  },
  onNodeDrop: function onNodeDrop(evt) {
    var _this = this;
    if (!this.targets || this.targets.length === 0)
      return;
    var graph = this.graph;
    var item = evt.item;
    var comboId = item.getModel().comboId;
    var newParentCombo = comboId ? graph.findById(comboId) : void 0;
    this.currentShouldEnd = this.shouldEnd(evt, newParentCombo, this);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd)
      return;
    var droppedCombo;
    if (comboId) {
      if (this.activeState) {
        var combo = graph.findById(comboId);
        graph.setItemState(combo, this.activeState, false);
      }
      this.targets.map(function(combo2) {
        if (!_this.onlyChangeComboSize) {
          if (comboId !== combo2.getID()) {
            droppedCombo = graph.findById(comboId);
            if (comboId !== combo2.getModel().parentId)
              graph.updateComboTree(combo2, comboId, false);
          }
        } else {
          graph.updateCombo(combo2);
        }
      });
    } else {
      this.targets.map(function(combo2) {
        if (!_this.onlyChangeComboSize) {
          var model = combo2.getModel();
          if (model.comboId) {
            graph.updateComboTree(combo2, void 0, false);
          }
        } else {
          graph.updateCombo(combo2);
        }
      });
    }
    this.endComparison = true;
    this.end(droppedCombo, evt);
  },
  onDragEnter: function onDragEnter2(evt) {
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt))
      return;
    var item = evt.item;
    var graph = this.graph;
    if (this.activeState) {
      graph.setItemState(item, this.activeState, true);
    }
  },
  onDragLeave: function onDragLeave2(evt) {
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt))
      return;
    var item = evt.item;
    var graph = this.graph;
    if (this.activeState) {
      graph.setItemState(item, this.activeState, false);
    }
  },
  onDragEnd: function onDragEnd2(evt) {
    if (!this.targets || this.targets.length === 0)
      return;
    var item = evt.item;
    if (this.currentShouldEnd) {
      this.updatePositions(evt);
    }
    var parentCombo = this.getParentCombo(item.getModel().parentId);
    var graph = this.graph;
    if (parentCombo && this.activeState) {
      graph.setItemState(parentCombo, this.activeState, false);
    }
    this.end(void 0, evt);
  },
  end: function end(comboDropedOn, evt) {
    var _this = this;
    if (!this.origin)
      return;
    var graph = this.graph;
    if (this.delegateShape) {
      var delegateGroup = graph.get("delegateGroup");
      delegateGroup.clear();
      this.delegateShape = null;
    }
    if (comboDropedOn && this.activeState) {
      graph.setItemState(comboDropedOn, this.activeState, false);
    }
    if (!comboDropedOn) {
      var stack_1 = graph.get("enabledStack") && this.enableStack;
      var stackData_1 = {
        before: {
          nodes: [],
          edges: [],
          combos: [].concat(this.get("beforeDragItems"))
        },
        after: {
          nodes: [],
          edges: [],
          combos: []
        }
      };
      this.targets.map(function(combo) {
        if (!_this.onlyChangeComboSize) {
          graph.updateComboTree(combo, void 0, stack_1);
        } else {
          graph.updateCombo(combo);
          var _a2 = combo.getModel(), x4 = _a2.x, y4 = _a2.y, id = _a2.id;
          stackData_1.after.combos.push({
            x: x4,
            y: y4,
            id
          });
          graph.pushStack("update", stackData_1);
        }
      });
    }
    this.point = [];
    this.origin = null;
    this.originPoint = null;
    this.targets.length = 0;
  },
  /**
   * 遍历 comboTree，分别更新 node 和 combo
   * @param data
   * @param fn
   */
  traverse: function traverse3(data, fn2, edgesToBeUpdate) {
    var _this = this;
    if (edgesToBeUpdate === void 0) {
      edgesToBeUpdate = {};
    }
    if (fn2(data, edgesToBeUpdate) === false) {
      return;
    }
    if (data) {
      var combos = data.get("combos");
      each_default(combos, function(child) {
        _this.traverse(child, fn2, edgesToBeUpdate);
      });
      var nodes = data.get("nodes");
      each_default(nodes, function(child) {
        _this.traverse(child, fn2, edgesToBeUpdate);
      });
    }
  },
  updateCombo: function updateCombo(item, evt, restore) {
    this.updateSingleItem(item, evt, restore);
    var edgesToBeUpdate = {};
    this.traverse(item, function(paramItem, paramEdgesMap) {
      if (paramItem.destroyed) {
        return false;
      }
      paramItem.getEdges().forEach(function(edge) {
        return paramEdgesMap[edge.getID()] = edge;
      });
      return true;
    }, edgesToBeUpdate);
    Object.values(edgesToBeUpdate).forEach(function(edge) {
      return edge.refresh();
    });
  },
  /**
   *
   * @param item 当前正在拖动的元素
   * @param evt
   */
  updateSingleItem: function updateSingleItem(item, evt, restore) {
    var origin = this.origin;
    var graph = this.graph;
    var model = item.getModel();
    var itemId = item.get("id");
    if (!this.point[itemId]) {
      this.point[itemId] = {
        x: model.x,
        y: model.y
      };
    }
    var x4 = evt.x - origin.x + this.point[itemId].x;
    var y4 = evt.y - origin.y + this.point[itemId].y;
    if (restore) {
      x4 += origin.x - evt.x;
      y4 += origin.y - evt.y;
    }
    graph.updateItem(item, {
      x: x4,
      y: y4
    }, false);
  },
  /**
   * 根据 ID 获取父 Combo
   * @param parentId 父 Combo ID
   */
  getParentCombo: function getParentCombo(parentId) {
    var graph = this.graph;
    if (!parentId) {
      return void 0;
    }
    var parentCombo = graph.findById(parentId);
    if (!parentCombo) {
      return void 0;
    }
    return parentCombo;
  },
  updateDelegate: function updateDelegate2(evt) {
    var graph = this.graph;
    if (!this.delegateShape) {
      var delegateGroup = graph.get("delegateGroup");
      var bbox = null;
      if (this.targets.length > 1) {
        bbox = calculationItemsBBox3(this.targets);
      } else {
        bbox = this.targets[0].getBBox();
      }
      var x4 = bbox.x, y4 = bbox.y, width = bbox.width, height = bbox.height, minX = bbox.minX, minY = bbox.minY;
      this.originPoint = {
        x: x4,
        y: y4,
        width,
        height,
        minX,
        minY
      };
      var attrs = __assign(__assign({}, global_default2.delegateStyle), this.delegateStyle);
      this.delegateShape = delegateGroup.addShape("rect", {
        attrs: __assign({
          width: bbox.width,
          height: bbox.height,
          x: bbox.x,
          y: bbox.y
        }, attrs),
        name: "combo-delegate-shape"
      });
      this.delegateShape.set("capture", false);
      this.delegate = this.delegateShape;
    } else {
      var clientX = evt.x - this.origin.x + this.originPoint.minX;
      var clientY = evt.y - this.origin.y + this.originPoint.minY;
      this.delegateShape.attr({
        x: clientX,
        y: clientY
      });
    }
  },
  /**
   * updates the parent combos' size and position
   */
  updateParentCombos: function updateParentCombos2() {
    var _a2 = this, graph = _a2.graph, targets = _a2.targets;
    var comboParentMap = {};
    targets === null || targets === void 0 ? void 0 : targets.forEach(function(target) {
      var comboId = target.getModel().parentId;
      if (comboId)
        comboParentMap[comboId] = graph.findById(comboId);
    });
    Object.values(comboParentMap).forEach(function(combo) {
      if (combo)
        graph.updateCombo(combo);
    });
  }
};

// node_modules/@antv/g6-pc/es/behavior/collapse-expand-combo.js
var DEFAULT_TRIGGER4 = "dblclick";
var ALLOW_EVENTS6 = ["click", "dblclick"];
var collapse_expand_combo_default = {
  getDefaultCfg: function getDefaultCfg12() {
    return {
      trigger: DEFAULT_TRIGGER4,
      relayout: true
    };
  },
  getEvents: function getEvents12() {
    var _a2;
    var trigger;
    if (ALLOW_EVENTS6.includes(this.trigger)) {
      trigger = this.trigger;
    } else {
      trigger = DEFAULT_TRIGGER4;
      console.warn("Behavior collapse-expand-group 的 trigger 参数不合法，请输入 'click' 或 'dblclick'");
    }
    return _a2 = {}, _a2["combo:".concat(trigger)] = "onComboClick", _a2;
  },
  onComboClick: function onComboClick(evt) {
    var item = evt.item;
    var _a2 = this, graph = _a2.graph, relayout = _a2.relayout;
    if (!item || item.destroyed || item.getType() !== "combo")
      return;
    var model = item.getModel();
    var comboId = model.id;
    if (!comboId) {
      return;
    }
    graph.collapseExpandCombo(comboId);
    if (relayout && graph.get("layout"))
      graph.layout();
    else
      graph.refreshPositions();
  }
};

// node_modules/@antv/g6-pc/es/behavior/lasso-select.js
init_tslib_es6();
var isPolygonsIntersect4 = util_default2.isPolygonsIntersect;
var pathToPoints3 = util_default2.pathToPoints;
var DEFAULT_TRIGGER5 = "shift";
var ALLOW_EVENTS7 = ["drag", "shift", "ctrl", "alt", "control"];
var isItemIntersecPolygon = function isItemIntersecPolygon2(item, polyPoints) {
  var shapePoints;
  var shape = item.getKeyShape();
  if (item.get("type") === "path") {
    shapePoints = pathToPoints3(shape.attr("path"));
  } else {
    var shapeBBox = shape.getCanvasBBox();
    shapePoints = [[shapeBBox.minX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.maxY], [shapeBBox.minX, shapeBBox.maxY]];
  }
  return isPolygonsIntersect4(polyPoints, shapePoints);
};
var lasso_select_default = {
  getDefaultCfg: function getDefaultCfg13() {
    return {
      delegateStyle: {
        fill: "#EEF6FF",
        fillOpacity: 0.4,
        stroke: "#DDEEFE",
        lineWidth: 1
      },
      onSelect: function onSelect() {
      },
      onDeselect: function onDeselect() {
      },
      shouldDeselect: void 0,
      selectedState: "selected",
      trigger: DEFAULT_TRIGGER5,
      includeEdges: true,
      selectedEdges: [],
      selectedNodes: []
      // multiple: false,
    };
  },
  getEvents: function getEvents13() {
    if (!(ALLOW_EVENTS7.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER5;
      console.warn("Behavior lasso-select 的 trigger 参数不合法，请输入 'drag'、'shift'、'ctrl' 或 'alt'");
    }
    if (this.trigger === "drag") {
      return {
        dragstart: "onDragStart",
        drag: "onDragMove",
        dragend: "onDragEnd",
        "canvas:click": "clearStates"
      };
    }
    return {
      dragstart: "onDragStart",
      drag: "onDragMove",
      dragend: "onDragEnd",
      keyup: "onKeyUp",
      keydown: "onKeyDown",
      "canvas:click": "clearStates"
    };
  },
  onDragStart: function onDragStart4(e8) {
    var lasso = this.lasso;
    var item = e8.item;
    if (item) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    if (this.selectedNodes && this.selectedNodes.length !== 0) {
      this.clearStates("dragstart");
    }
    if (!lasso) {
      lasso = this.createLasso();
    }
    this.dragging = true;
    this.originPoint = {
      x: e8.x,
      y: e8.y
    };
    this.points.push(this.originPoint);
    lasso.show();
  },
  onDragMove: function onDragMove3(e8) {
    if (!this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.points.push({
      x: e8.x,
      y: e8.y
    });
    this.updateLasso(e8);
  },
  onDragEnd: function onDragEnd3(e8) {
    if (!this.lasso && !this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.points.push(this.originPoint);
    this.getSelectedItems();
    this.lasso.remove(true);
    this.lasso = null;
    this.points = [];
    this.dragging = false;
  },
  getLassoPath: function getLassoPath() {
    var points = this.points;
    var path = [];
    if (points.length) {
      points.forEach(function(point, index2) {
        if (index2 === 0) {
          path.push(["M", point.x, point.y]);
        } else {
          path.push(["L", point.x, point.y]);
        }
      });
      path.push(["L", points[0].x, points[0].y]);
    }
    return path;
  },
  clearStates: function clearStates2(action) {
    if (action === void 0) {
      action = "canvas:click";
    }
    var _a2 = this, graph = _a2.graph, selectedState = _a2.selectedState, shouldDeselect = _a2.shouldDeselect;
    var nodes = graph.findAllByState("node", selectedState);
    var edges = graph.findAllByState("edge", selectedState);
    if (!shouldDeselect || shouldDeselect({
      action,
      nodes,
      edges
    })) {
      nodes.forEach(function(node) {
        return graph.setItemState(node, selectedState, false);
      });
      edges.forEach(function(edge) {
        return graph.setItemState(edge, selectedState, false);
      });
    }
    if (this.onDeselect) {
      this.onDeselect(this.selectedNodes, this.selectedEdges);
    }
    this.selectedNodes = [];
    this.selectedEdges = [];
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: []
      },
      select: false
    });
  },
  getSelectedItems: function getSelectedItems() {
    var _this = this;
    var _a2 = this, graph = _a2.graph, shouldUpdate3 = _a2.shouldUpdate;
    var lassoContour = this.points.map(function(point) {
      return [graph.getCanvasByPoint(point.x, point.y).x, graph.getCanvasByPoint(point.x, point.y).y];
    });
    var state = this.selectedState;
    var selectedNodes = [];
    var selectedIds = [];
    graph.getNodes().forEach(function(node) {
      if (!node.isVisible())
        return;
      if (isItemIntersecPolygon(node, lassoContour)) {
        if (shouldUpdate3(node, "select", _this)) {
          selectedNodes.push(node);
          var model = node.getModel();
          selectedIds.push(model.id);
          graph.setItemState(node, state, true);
        }
      }
    });
    var selectedEdges = [];
    if (this.includeEdges) {
      selectedNodes.forEach(function(node) {
        var edges = node.getOutEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible())
            return;
          var model = edge.getModel();
          var source = model.source, target = model.target;
          if (selectedIds.includes(source) && selectedIds.includes(target) && shouldUpdate3(edge, "select", _this)) {
            selectedEdges.push(edge);
            graph.setItemState(edge, _this.selectedState, true);
          }
        });
      });
    }
    this.selectedEdges = selectedEdges;
    this.selectedNodes = selectedNodes;
    if (this.onSelect) {
      this.onSelect(selectedNodes, selectedEdges);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: selectedNodes,
        edges: selectedEdges
      },
      select: true
    });
  },
  createLasso: function createLasso() {
    var self2 = this;
    var lasso = self2.graph.get("delegateGroup").addShape("path", {
      attrs: __assign({
        path: []
      }, self2.delegateStyle),
      capture: false,
      name: "lasso-shape"
    });
    this.lasso = lasso;
    this.delegate = lasso;
    this.points = [];
    return lasso;
  },
  updateLasso: function updateLasso(e8) {
    var self2 = this;
    this.lasso.attr({
      path: self2.getLassoPath()
    });
  },
  onKeyDown: function onKeyDown4(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === this.trigger.toLowerCase()) {
      this.keydown = true;
    } else {
      this.keydown = false;
    }
  },
  onKeyUp: function onKeyUp4() {
    if (this.lasso) {
      this.lasso.remove(true);
      this.lasso = null;
      this.points = [];
      this.dragging = false;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/create-edge.js
init_tslib_es6();
init_esm();
var DEFAULT_TRIGGER6 = "click";
var ALLOW_EVENTS8 = ["click", "drag"];
var DEFAULT_KEY = void 0;
var ALLOW_KEYS = ["shift", "ctrl", "control", "alt", "meta", void 0];
var create_edge_default = {
  getDefaultCfg: function getDefaultCfg14() {
    return {
      trigger: DEFAULT_TRIGGER6,
      key: DEFAULT_KEY,
      edgeConfig: {},
      getEdgeConfig: void 0
    };
  },
  getEvents: function getEvents14() {
    var self2 = this;
    if (!(ALLOW_EVENTS8.indexOf(self2.trigger.toLowerCase()) > -1)) {
      self2.trigger = DEFAULT_TRIGGER6;
      console.warn("Behavior create-edge 的 trigger 参数不合法，请输入 'click'，'drag'");
    }
    if (self2.key && ALLOW_KEYS.indexOf(self2.key.toLowerCase()) === -1) {
      self2.trigger = DEFAULT_KEY;
      console.warn("Behavior create-edge 的 key 参数不合法，请输入 'shift'，'ctrl'，'alt'，'control'，或 undefined");
    }
    var events;
    if (self2.trigger === "drag") {
      events = {
        "node:dragstart": "onClick",
        "combo:dragstart": "onClick",
        drag: "updateEndPoint",
        "node:drop": "onClick",
        "combo:drop": "onClick",
        dragend: "onDragEnd"
      };
    } else if (self2.trigger === "click") {
      events = {
        "node:click": "onClick",
        mousemove: "updateEndPoint",
        "edge:click": "cancelCreating",
        "canvas:click": "cancelCreating",
        "combo:click": "onClick"
      };
    }
    if (self2.key) {
      events.keydown = "onKeyDown";
      events.keyup = "onKeyUp";
    }
    return events;
  },
  onDragEnd: function onDragEnd4(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown)
      return;
    var item = ev.item;
    if (!item || item.getID() === self2.source || item.getType() !== "node")
      self2.cancelCreating({
        item: self2.edge,
        x: ev.x,
        y: ev.y
      });
  },
  // 如果边的起点没有指定，则根据起点创建新边；如果起点已经指定而终点未指定，则指定终点
  onClick: function onClick2(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown)
      return;
    var node = ev.item;
    var graph = self2.graph;
    var model = node.getModel();
    var getEdgeConfig = self2.getEdgeConfig;
    if (self2.addingEdge && self2.edge) {
      if (!self2.shouldEnd(ev, self2))
        return;
      var edgeConfig = void 0;
      if (getEdgeConfig && is_function_default(getEdgeConfig)) {
        edgeConfig = getEdgeConfig({
          source: self2.source,
          target: model.id
        }, self2);
      } else {
        edgeConfig = self2.edgeConfig;
      }
      var updateCfg2 = __assign({
        target: model.id
      }, edgeConfig);
      if (self2.source === model.id) {
        updateCfg2.type = "loop";
      }
      graph.emit("beforecreateedge", {});
      graph.updateItem(self2.edge, updateCfg2, false);
      if (graph.get("enabledStack")) {
        var addedModel = __assign(__assign({}, self2.edge.getModel()), {
          itemType: "edge"
        });
        var after = {};
        after.edges = [addedModel];
        graph.pushStack("add", {
          before: {},
          after
        });
      }
      graph.emit("aftercreateedge", {
        edge: self2.edge
      });
      self2.edge.getKeyShape().set("capture", true);
      self2.edge = null;
      self2.addingEdge = false;
    } else {
      if (!self2.shouldBegin(ev, self2))
        return;
      var edgeConfig = void 0;
      if (getEdgeConfig && is_function_default(getEdgeConfig)) {
        edgeConfig = getEdgeConfig({
          source: model.id,
          target: model.id
        }, self2);
      } else {
        edgeConfig = self2.edgeConfig;
      }
      self2.edge = graph.addItem("edge", __assign({
        source: model.id,
        target: model.id
      }, edgeConfig), false);
      self2.source = model.id;
      self2.addingEdge = true;
      self2.edge.getKeyShape().set("capture", false);
    }
  },
  // 边的起点已经确定，边的末端跟随鼠标移动
  updateEndPoint: function updateEndPoint(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown)
      return;
    if (self2.edge && self2.edge.destroyed)
      self2.cancelCreating({
        item: self2.edge
      });
    var point = {
      x: ev.x,
      y: ev.y
    };
    if (!self2.graph.findById(self2.source)) {
      self2.addingEdge = false;
      return;
    }
    if (self2.addingEdge && self2.edge) {
      self2.graph.updateItem(self2.edge, {
        target: point
      }, false);
    }
  },
  // 取消增加边，删除该边；或指定终点
  cancelCreating: function cancelCreating(ev) {
    var _a2, _b;
    var self2 = this;
    if (self2.key && !self2.keydown)
      return;
    var graph = self2.graph;
    var currentEdge = ev.item;
    if (self2.addingEdge && (self2.edge === currentEdge || ((_b = (_a2 = ev.target) === null || _a2 === void 0 ? void 0 : _a2.isCanvas) === null || _b === void 0 ? void 0 : _b.call(_a2)))) {
      if (self2.edge && !self2.edge.destroyed)
        graph.removeItem(self2.edge, false);
      self2.edge = null;
      self2.addingEdge = false;
      return;
    }
  },
  onKeyDown: function onKeyDown5(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === self2.key.toLowerCase()) {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp5() {
    var self2 = this;
    if (self2.addingEdge && self2.edge) {
      self2.graph.removeItem(self2.edge, false);
      self2.addingEdge = false;
      self2.edge = null;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/shortcuts-call.js
var DEFAULT_TRIGGER7 = "ctrl";
var ALLOW_EVENTS9 = ["shift", "ctrl", "alt", "control"];
var DEFAULT_COMBINED_KEY = "1";
var shortcuts_call_default = {
  getDefaultCfg: function getDefaultCfg15() {
    return {
      trigger: DEFAULT_TRIGGER7,
      combinedKey: DEFAULT_COMBINED_KEY,
      functionName: "fitView",
      functionParams: []
    };
  },
  getEvents: function getEvents15() {
    if (!(ALLOW_EVENTS9.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER7;
      console.warn("Behavior shortcuts-fit-view 的 trigger 参数 '".concat(this.trigger, "' 不合法，请输入 'drag'、'shift'、'ctrl' 或 'alt'"));
    }
    if (this.combinedKey === this.trigger) {
      this.combinedKey = void 0;
    }
    return {
      keyup: "onKeyUp",
      keydown: "onKeyDown"
    };
  },
  onKeyDown: function onKeyDown6(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    var triggerLowerCase = this.trigger.toLowerCase();
    var codeLowerCase = code.toLowerCase();
    if (!this.triggerKeydown) {
      if (codeLowerCase === triggerLowerCase || codeLowerCase === "control" && triggerLowerCase === "ctrl" || codeLowerCase === "ctrl" && triggerLowerCase === "control") {
        this.triggerKeydown = true;
      } else {
        this.triggerKeydown = false;
      }
    }
    var graph = this.graph;
    if (!graph[this.functionName]) {
      console.warn("Behavior shortcuts-fit-view 的 functionName 参数 '".concat(this.functionName, "' 不合法，它不是 Graph 的一个函数名"));
      return {};
    }
    if (this.triggerKeydown && !this.combinedKey) {
      if (this.functionParams && this.functionParams.length)
        graph[this.functionName].apply(graph, this.functionParams);
      else
        graph[this.functionName]();
      return;
    }
    var combinedKeyLowerCase = this.combinedKey.toLowerCase();
    if (this.triggerKeydown) {
      if (codeLowerCase === combinedKeyLowerCase || codeLowerCase === "control" && combinedKeyLowerCase === "ctrl" || codeLowerCase === "ctrl" && combinedKeyLowerCase === "control") {
        if (this.functionParams && this.functionParams.length)
          graph[this.functionName].apply(graph, this.functionParams);
        else
          graph[this.functionName]();
      }
    }
  },
  onKeyUp: function onKeyUp6() {
    if (this.brush) {
      this.brush.remove(true);
      this.brush = null;
      this.dragging = false;
    }
    this.triggerKeydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/scroll-canvas.js
init_esm();
var ALLOW_EVENTS10 = ["shift", "ctrl", "alt", "control", "meta"];
var scroll_canvas_default = {
  getDefaultCfg: function getDefaultCfg16() {
    return {
      direction: "both",
      enableOptimize: false,
      zoomKey: "ctrl",
      // scroll-canvas 可滚动的扩展范围，默认为 0，即最多可以滚动一屏的位置
      // 当设置的值大于 0 时，即滚动可以超过一屏
      // 当设置的值小于 0 时，相当于缩小了可滚动范围
      // 具体实例可参考：https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*IFfoS67_HssAAAAAAAAAAAAAARQnAQ
      scalableRange: 0,
      allowDragOnItem: true
    };
  },
  getEvents: function getEvents16() {
    if (!this.zoomKey || ALLOW_EVENTS10.indexOf(this.zoomKey) === -1)
      this.zoomKey = "ctrl";
    return {
      wheel: "onWheel"
    };
  },
  onWheel: function onWheel2(ev) {
    var _this = this;
    if (!this.allowDrag(ev))
      return;
    var graph = this.graph;
    var zoomKeys = Array.isArray(this.zoomKey) ? [].concat(this.zoomKey) : [this.zoomKey];
    if (zoomKeys.includes("control"))
      zoomKeys.push("ctrl");
    var keyDown = zoomKeys.some(function(ele) {
      return ev["".concat(ele, "Key")];
    });
    if (keyDown) {
      var canvas = graph.get("canvas");
      var point = canvas.getPointByClient(ev.clientX, ev.clientY);
      var ratio = graph.getZoom();
      if (ev.wheelDelta > 0) {
        ratio = ratio + ratio * 0.05;
      } else {
        ratio = ratio - ratio * 0.05;
      }
      graph.zoomTo(ratio, {
        x: point.x,
        y: point.y
      });
    } else {
      var dx = ev.deltaX || ev.movementX;
      var dy = ev.deltaY || ev.movementY;
      if (!dy && navigator.userAgent.indexOf("Firefox") > -1)
        dy = -ev.wheelDelta * 125 / 3;
      var width = this.graph.get("width");
      var height = this.graph.get("height");
      var graphCanvasBBox = this.graph.get("canvas").getCanvasBBox();
      var expandWidth = this.scalableRange;
      var expandHeight = this.scalableRange;
      if (expandWidth < 1 && expandWidth > -1) {
        expandWidth = width * expandWidth;
        expandHeight = height * expandHeight;
      }
      var minX = graphCanvasBBox.minX, maxX = graphCanvasBBox.maxX, minY = graphCanvasBBox.minY, maxY = graphCanvasBBox.maxY;
      if (dx > 0) {
        if (maxX < -expandWidth) {
          dx = 0;
        } else if (maxX - dx < -expandWidth) {
          dx = maxX + expandWidth;
        }
      } else if (dx < 0) {
        if (minX > width + expandWidth) {
          dx = 0;
        } else if (minX - dx > width + expandWidth) {
          dx = minX - (width + expandWidth);
        }
      }
      if (dy > 0) {
        if (maxY < -expandHeight) {
          dy = 0;
        } else if (maxY - dy < -expandHeight) {
          dy = maxY + expandHeight;
        }
      } else if (dy < 0) {
        if (minY > height + expandHeight) {
          dy = 0;
        } else if (minY - dy > height + expandHeight) {
          dy = minY - (height + expandHeight);
        }
      }
      if (this.get("direction") === "x") {
        dy = 0;
      } else if (this.get("direction") === "y") {
        dx = 0;
      }
      graph.translate(-dx, -dy);
    }
    ev.preventDefault();
    var enableOptimize = this.get("enableOptimize");
    if (enableOptimize) {
      var optimizeZoom_1 = this.get("optimizeZoom");
      var optimized = this.get("optimized");
      var nodes_1 = graph.getNodes();
      var edges_1 = graph.getEdges();
      var nodesLength_1 = nodes_1.length;
      var edgesLength_1 = edges_1.length;
      if (!optimized) {
        for (var n2 = 0; n2 < nodesLength_1; n2++) {
          var node = nodes_1[n2];
          if (!node.destroyed) {
            var children = node.get("group").get("children");
            var childrenLength = children.length;
            for (var c3 = 0; c3 < childrenLength; c3++) {
              var shape = children[c3];
              if (!shape.destoryed && !shape.get("isKeyShape")) {
                shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
                shape.hide();
              }
            }
          }
        }
        for (var edgeIndex = 0; edgeIndex < edgesLength_1; edgeIndex++) {
          var edge = edges_1[edgeIndex];
          var children = edge.get("group").get("children");
          var childrenLength = children.length;
          for (var c3 = 0; c3 < childrenLength; c3++) {
            var shape = children[c3];
            shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
            shape.hide();
          }
        }
        this.set("optimized", true);
      }
      clearTimeout(this.get("timeout"));
      var timeout = setTimeout(function() {
        var currentZoom = graph.getZoom();
        var curOptimized = _this.get("optimized");
        if (curOptimized) {
          _this.set("optimized", false);
          for (var n3 = 0; n3 < nodesLength_1; n3++) {
            var node2 = nodes_1[n3];
            var children2 = node2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = node2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              if (oriVis)
                keyShape.show();
            } else {
              for (var c4 = 0; c4 < childrenLength2; c4++) {
                var shape2 = children2[c4];
                var oriVis = shape2.get("ori-visibility");
                if (!shape2.get("visible") && oriVis) {
                  if (oriVis)
                    shape2.show();
                }
              }
            }
          }
          for (var edgeIndex2 = 0; edgeIndex2 < edgesLength_1; edgeIndex2++) {
            var edge2 = edges_1[edgeIndex2];
            var children2 = edge2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = edge2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              if (oriVis)
                keyShape.show();
            } else {
              for (var c4 = 0; c4 < childrenLength2; c4++) {
                var shape2 = children2[c4];
                if (!shape2.get("visible")) {
                  var oriVis = shape2.get("ori-visibility");
                  if (oriVis)
                    shape2.show();
                }
              }
            }
          }
        }
      }, 100);
      this.set("timeout", timeout);
    }
  },
  allowDrag: function allowDrag2(evt) {
    var _a2, _b;
    var target = evt.target;
    var targetIsCanvas = target && target.isCanvas && target.isCanvas();
    if (is_boolean_default(this.allowDragOnItem) && !this.allowDragOnItem && !targetIsCanvas)
      return false;
    if (is_object_default(this.allowDragOnItem)) {
      var _c = this.allowDragOnItem, node = _c.node, edge = _c.edge, combo = _c.combo;
      var itemType = (_b = (_a2 = evt.item) === null || _a2 === void 0 ? void 0 : _a2.getType) === null || _b === void 0 ? void 0 : _b.call(_a2);
      if (!node && itemType === "node")
        return false;
      if (!edge && itemType === "edge")
        return false;
      if (!combo && itemType === "combo")
        return false;
    }
    return true;
  }
};

// node_modules/@antv/g6-pc/es/behavior/index.js
var behaviors = {
  "drag-canvas": drag_canvas_default,
  "zoom-canvas": zoom_canvas_default,
  "drag-node": drag_node_default,
  "activate-relations": activate_relations_default,
  "brush-select": brush_select_default,
  "click-select": click_select_default,
  "lasso-select": lasso_select_default,
  tooltip: tooltip_default2,
  "edge-tooltip": edge_tooltip_default,
  "collapse-expand": collapse_expand_default,
  "drag-combo": drag_combo_default,
  "collapse-expand-combo": collapse_expand_combo_default,
  "create-edge": create_edge_default,
  "shortcuts-call": shortcuts_call_default,
  "scroll-canvas": scroll_canvas_default
};
each_default(behaviors, function(behavior, type) {
  registerBehavior(type, behavior);
});

// node_modules/@antv/g6-pc/es/index.js
var Algorithm = __assign(__assign({}, es_exports), AlgorithmAsync);
var Grid2 = plugin_default.Grid;
var Minimap = plugin_default.Minimap;
var Bundling2 = plugin_default.Bundling;
var Menu2 = plugin_default.Menu;
var Fisheye2 = plugin_default.Fisheye;
var ToolBar2 = plugin_default.ToolBar;
var Tooltip2 = plugin_default.Tooltip;
var TimeBar2 = plugin_default.TimeBar;
var ImageMinimap = plugin_default.ImageMinimap;
var EdgeFilterLens2 = plugin_default.EdgeFilterLens;
var SnapLine2 = plugin_default.SnapLine;
var Legend2 = plugin_default.Legend;
var Annotation2 = plugin_default.Annotation;
var es_default4 = {
  version: global_default2.version,
  Graph: graph_default2,
  TreeGraph: tree_graph_default,
  Util: util_default2,
  Layout: import_lib.Layouts,
  TreeLayout: tree_layout_default,
  registerLayout,
  Global: global_default2,
  registerBehavior,
  registerCombo,
  registerEdge,
  registerNode,
  Minimap: plugin_default.Minimap,
  Grid: plugin_default.Grid,
  Bundling: plugin_default.Bundling,
  Menu: plugin_default.Menu,
  ToolBar: plugin_default.ToolBar,
  Tooltip: plugin_default.Tooltip,
  Legend: plugin_default.Legend,
  TimeBar: TimeBar2,
  SnapLine: SnapLine2,
  Fisheye: Fisheye2,
  ImageMinimap,
  EdgeFilterLens: EdgeFilterLens2,
  Annotation: Annotation2,
  Algorithm,
  Arrow: arrow_default,
  Marker: marker_default,
  Shape: element_default
};

// node_modules/@antv/g6/es/index.js
es_default4.version = "4.8.7";
var es_default5 = es_default4;
var version = "4.8.7";
var export_Layout = import_lib.Layouts;
export {
  event_default as AbstractEvent,
  graph_default as AbstractGraph,
  layout_default as AbstractLayout,
  Algorithm,
  Annotation2 as Annotation,
  arrow_default as Arrow,
  BaseGlobal,
  Bundling2 as Bundling,
  combo_default as Combo,
  edge_default as Edge,
  EdgeFilterLens2 as EdgeFilterLens,
  Fisheye2 as Fisheye,
  G6GraphEvent,
  global_default2 as Global,
  graph_default2 as Graph,
  Grid2 as Grid,
  hull_default as Hull,
  ImageMinimap,
  export_Layout as Layout,
  Legend2 as Legend,
  marker_default as Marker,
  Menu2 as Menu,
  Minimap,
  node_default as Node,
  element_default as Shape,
  SnapLine2 as SnapLine,
  TimeBar2 as TimeBar,
  ToolBar2 as ToolBar,
  Tooltip2 as Tooltip,
  tree_graph_default as TreeGraph,
  tree_layout_default as TreeLayout,
  util_default2 as Util,
  es_default5 as default,
  registerBehavior,
  registerCombo,
  registerEdge,
  registerLayout,
  registerNode,
  version
};
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=@antv_g6.js.map
