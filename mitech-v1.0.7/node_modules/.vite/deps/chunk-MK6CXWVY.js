import {
  __assign,
  __extends,
  __rest,
  __spreadArrays,
  cancelAnimationFrame,
  dot,
  each_default,
  exactEquals,
  ext_exports,
  filter_default,
  fixed_base_default,
  get_range_default,
  head,
  index_of_default,
  init_esm,
  init_esm2,
  init_esm3,
  init_tslib_es6,
  init_vec2,
  init_vec3,
  isNumberEqual,
  is_array_default,
  is_date_default,
  is_empty_default,
  is_equal_default,
  is_function_default,
  is_nil_default,
  is_number_default,
  is_object_default,
  is_string_default,
  last,
  map_default,
  max_default,
  min_default,
  mix,
  mod_default,
  noop_default,
  normalize,
  requestAnimationFrame,
  size,
  to_array_default,
  to_radian_default,
  transformMat3,
  unique_id_default,
  upper_first_default,
  vec2_exports
} from "./chunk-FCE3RKM2.js";
import {
  __esm,
  __export
} from "./chunk-CLC6CPQL.js";

// node_modules/d3-timer/src/timer.js
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time)
        time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
var frame, timeout, interval, pokeDelay, taskHead, taskTail, clockLast, clockNow, clockSkew, clock, setFrame;
var init_timer = __esm({
  "node_modules/d3-timer/src/timer.js"() {
    frame = 0;
    timeout = 0;
    interval = 0;
    pokeDelay = 1e3;
    clockLast = 0;
    clockNow = 0;
    clockSkew = 0;
    clock = typeof performance === "object" && performance.now ? performance : Date;
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
      setTimeout(f, 17);
    };
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
  }
});

// node_modules/d3-timer/src/timeout.js
var init_timeout = __esm({
  "node_modules/d3-timer/src/timeout.js"() {
    init_timer();
  }
});

// node_modules/d3-timer/src/interval.js
var init_interval = __esm({
  "node_modules/d3-timer/src/interval.js"() {
    init_timer();
  }
});

// node_modules/d3-timer/src/index.js
var init_src = __esm({
  "node_modules/d3-timer/src/index.js"() {
    init_timer();
    init_timeout();
    init_interval();
  }
});

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter2() {
      this._events = {};
    }
    EventEmitter2.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter2.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter2.prototype.emit = function(evt) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length = es.length;
        for (var i = 0; i < length; i++) {
          if (!es[i]) {
            continue;
          }
          var _a = es[i], callback = _a.callback, once = _a.once;
          if (once) {
            es.splice(i, 1);
            if (es.length === 0) {
              delete _this._events[evt];
            }
            length--;
            i--;
          }
          callback.apply(_this, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter2.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i = 0; i < length_1; i++) {
            if (events[i].callback === callback) {
              events.splice(i, 1);
              length_1--;
              i--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter2.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter2;
  }()
);
var esm_default = EventEmitter;

// node_modules/@antv/g-base/esm/event/graph-event.js
var GraphEvent = (
  /** @class */
  function() {
    function GraphEvent2(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent2.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent2.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent2.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent2.prototype.save = function() {
    };
    GraphEvent2.prototype.restore = function() {
    };
    return GraphEvent2;
  }()
);
var graph_event_default = GraphEvent;

// node_modules/@antv/path-util/esm/parse-path-string.js
init_esm();
var SPACES = "	\n\v\f\r   ᠎             　\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b, params[0]]);
    }
    if (name === "r") {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data;
}

// node_modules/@antv/path-util/esm/parse-path.js
init_esm();
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p) {
  var path = p || [];
  if (is_array_default(path)) {
    return path;
  }
  if (is_string_default(path)) {
    path = path.match(regexTags);
    each_default(path, function(item, index) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each_default(item, function(sub, i) {
        if (!isNaN(sub)) {
          item[i] = +sub;
        }
      });
      path[index] = item;
    });
    return path;
  }
}
var parse_path_default = parsePath;

// node_modules/@antv/path-util/node_modules/@antv/matrix-util/esm/index.js
init_esm2();

// node_modules/@antv/path-util/node_modules/@antv/matrix-util/esm/ext.js
init_esm2();

// node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js
function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min;
  var max;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min = constraint[0], max = constraint[1];
    for (var i = 0, l = points.length; i < l; i += 1) {
      var point = points[i];
      min = vec2_exports.min([0, 0], min, point);
      max = vec2_exports.max([0, 0], max, point);
    }
  }
  for (var i = 0, len = points.length; i < len; i += 1) {
    var point = points[i];
    if (i === 0 && !isLoop) {
      cp0 = point;
    } else if (i === len - 1 && !isLoop) {
      cp1 = point;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i + 1) % len : i + 1];
      var v = [0, 0];
      v = vec2_exports.sub(v, nextPoint, prevPoint);
      v = vec2_exports.scale(v, v, smooth);
      var d0 = vec2_exports.distance(point, prevPoint);
      var d1 = vec2_exports.distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = vec2_exports.scale([0, 0], v, -d0);
      var v2 = vec2_exports.scale([0, 0], v, d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      nextCp0 = vec2_exports.add([0, 0], point, v2);
      nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
      nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
      v1 = vec2_exports.sub([0, 0], nextCp0, point);
      v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
      cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
      v2 = vec2_exports.sub([0, 0], point, cp1);
      v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
      nextCp0 = vec2_exports.add([0, 0], point, v2);
      if (hasConstraint) {
        cp1 = vec2_exports.max([0, 0], cp1, min);
        cp1 = vec2_exports.min([0, 0], cp1, max);
        nextCp0 = vec2_exports.max([0, 0], nextCp0, min);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, max);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len - 1; i += 1) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
var catmull_rom_2_bezier_default = catmullRom2Bezier;

// node_modules/@antv/path-util/esm/fill-path-by-diff.js
init_esm();

// node_modules/@antv/path-util/esm/path-intersection.js
init_esm();

// node_modules/@antv/path-util/esm/path-2-absolute.js
var REGEX_MD = /[a-z]/;
function toSymmetry(p, c) {
  return [
    c[0] + (c[0] - p[0]),
    c[1] + (c[1] - p[1])
  ];
}
function pathToAbsolute(pathString) {
  var pathArray = parsePathString(pathString);
  if (!pathArray || !pathArray.length) {
    return [
      ["M", 0, 0]
    ];
  }
  var needProcess = false;
  for (var i = 0; i < pathArray.length; i++) {
    var cmd = pathArray[i][0];
    if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  var first = pathArray[0];
  if (first[0] === "M" || first[0] === "m") {
    x = +first[1];
    y = +first[2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  for (var i = start, ii = pathArray.length; i < ii; i++) {
    var pa = pathArray[i];
    var preParams = res[i - 1];
    var r = [];
    var cmd = pa[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r[0] = upCmd;
      switch (upCmd) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          r[1] = mx;
          r[2] = my;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else {
      r = pathArray[i];
    }
    switch (upCmd) {
      case "Z":
        x = +mx;
        y = +my;
        break;
      case "H":
        x = r[1];
        r = ["L", x, y];
        break;
      case "V":
        y = r[1];
        r = ["L", x, y];
        break;
      case "T":
        x = r[1];
        y = r[2];
        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r = ["Q", symetricT[0], symetricT[1], x, y];
        break;
      case "S":
        x = r[r.length - 2];
        y = r[r.length - 1];
        var length_1 = preParams.length;
        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r = ["C", symetricS[0], symetricS[1], r[1], r[2], x, y];
        break;
      case "M":
        mx = r[r.length - 2];
        my = r[r.length - 1];
        break;
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
    }
    res.push(r);
  }
  return res;
}

// node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;

// node_modules/@antv/path-util/esm/get-arc-params.js
init_esm();
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/path-util/esm/path-2-segments.js
function toSymmetry2(point, center) {
  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}
function getSegments(path) {
  path = parse_path_default(path);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    nextParams = path[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var cp = toSymmetry2(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i - 1];
      var cp1 = toSymmetry2(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d = 1e-3;
      var _a = segment["arcParams"] || {}, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, _d = _a.rx, rx = _d === void 0 ? 0 : _d, _e = _a.ry, ry = _e === void 0 ? 0 : _e, _f = _a.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d) + cx;
      var dy1 = ry * Math.sin(startAngle - d) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}

// node_modules/@antv/path-util/esm/get-line-intersect.js
var isBetween = function(value, min, max) {
  return value >= min && value <= max;
};
function getLineIntersect(p0, p1, p2, p3) {
  var tolerance3 = 1e-3;
  var E2 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point = null;
  if (sqrKross > tolerance3 * sqrLen0 * sqrLen1) {
    var s = (E2.x * D1.y - E2.y * D1.x) / kross;
    var t = (E2.x * D0.y - E2.y * D0.x) / kross;
    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {
      point = {
        x: p0.x + s * D0.x,
        y: p0.y + s * D0.y
      };
    }
  }
  return point;
}

// node_modules/@antv/path-util/esm/point-in-polygon.js
var tolerance = 1e-6;
function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

// node_modules/@antv/path-util/esm/is-polygons-intersect.js
init_esm();
function parseToLines(points) {
  var lines = [];
  var count = points.length;
  for (var i = 0; i < count - 1; i++) {
    var point = points[i];
    var next = points[i + 1];
    lines.push({
      from: {
        x: point[0],
        y: point[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }
  if (lines.length > 1) {
    var first = points[0];
    var last2 = points[count - 1];
    lines.push({
      from: {
        x: last2[0],
        y: last2[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }
  return lines;
}
function lineIntersectPolygon(lines, line) {
  var isIntersect = false;
  each_default(lines, function(l) {
    if (getLineIntersect(l.from, l.to, line.from, line.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getBBox(points) {
  var xArr = points.map(function(p) {
    return p[0];
  });
  var yArr = points.map(function(p) {
    return p[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}
function intersectBBox(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect(points1, points2) {
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox(points1);
  var bbox2 = getBBox(points2);
  if (!intersectBBox(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each_default(points2, function(point) {
    if (isInPolygon(points1, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each_default(points1, function(point) {
    if (isInPolygon(points2, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  each_default(lines2, function(line) {
    if (lineIntersectPolygon(lines1, line)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}

// node_modules/@antv/g-base/esm/util/path.js
var path_exports = {};
__export(path_exports, {
  catmullRomToBezier: () => catmullRomToBezier,
  fillPath: () => fillPath2,
  fillPathByDiff: () => fillPathByDiff2,
  formatPath: () => formatPath2,
  intersection: () => intersection,
  parsePathArray: () => parsePathArray2,
  parsePathString: () => parsePathString2,
  pathToAbsolute: () => pathToAbsolute2,
  pathToCurve: () => pathToCurve2,
  rectPath: () => rectPath2
});
init_esm();
var SPACES2 = "	\n\v\f\r   ᠎             　\u2028\u2029";
var PATH_COMMAND2 = new RegExp("([a-z])[" + SPACES2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES2 + "]*,?[" + SPACES2 + "]*)+)", "ig");
var PATH_VALUES2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES2 + "]*,?[" + SPACES2 + "]*", "ig");
var parsePathString2 = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND2, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES2, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b, params[0]]);
    }
    if (name === "r") {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data;
};
var catmullRomToBezier = function(crp, z) {
  var d = [];
  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [
      {
        x: +crp[i - 2],
        y: +crp[i - 1]
      },
      {
        x: +crp[i],
        y: +crp[i + 1]
      },
      {
        x: +crp[i + 2],
        y: +crp[i + 3]
      },
      {
        x: +crp[i + 4],
        y: +crp[i + 5]
      }
    ];
    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }
    d.push([
      "C",
      (-p[0].x + 6 * p[1].x + p[2].x) / 6,
      (-p[0].y + 6 * p[1].y + p[2].y) / 6,
      (p[1].x + 6 * p[2].x - p[3].x) / 6,
      (p[1].y + 6 * p[2].y - p[3].y) / 6,
      p[2].x,
      p[2].y
    ]);
  }
  return d;
};
var ellipsePath = function(x, y, rx, ry, a) {
  var res = [];
  if (a === null && ry === null) {
    ry = rx;
  }
  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;
  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [
      ["M", x1, y1],
      ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]
    ];
  } else {
    res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
  }
  return res;
};
var pathToAbsolute2 = function(pathArray) {
  pathArray = parsePathString2(pathArray);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === "M") {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
  for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];
    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();
      switch (r[0]) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "R":
          dots = [x, y].concat(pa.slice(1));
          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case "O":
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case "U":
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ["U"].concat(res[res.length - 1].slice(-2));
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else if (pa0 === "R") {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r = ["R"].concat(pa.slice(-2));
    } else if (pa0 === "O") {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === "U") {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ["U"].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== "O") {
      switch (r[0]) {
        case "Z":
          x = +mx;
          y = +my;
          break;
        case "H":
          x = r[1];
          break;
        case "V":
          y = r[1];
          break;
        case "M":
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }
  return res;
};
var l2c = function(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};
var q2c = function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate2 = function(x3, y3, rad2) {
    var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
    var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
    return {
      x: X,
      y: Y
    };
  };
  if (!recursive) {
    xy = rotate2(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate2(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      x2 += 1;
      y2 += 1;
    }
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(",");
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate2(res[i - 1], res[i], rad).y : rotate2(res[i], res[i + 1], rad).x;
  }
  return newres;
};
var pathToCurve2 = function(path, path2) {
  var p = pathToAbsolute2(path);
  var p2 = path2 && pathToAbsolute2(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = [];
  var pcoms2 = [];
  var pfirst = "";
  var pcom = "";
  var ii;
  var processPath = function(path3, d, pcom2) {
    var nx;
    var ny;
    if (!path3) {
      return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
    }
    !(path3[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);
    switch (path3[0]) {
      case "M":
        d.X = path3[1];
        d.Y = path3[2];
        break;
      case "A":
        path3 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
        break;
      case "S":
        if (pcom2 === "C" || pcom2 === "S") {
          nx = d.x * 2 - d.bx;
          ny = d.y * 2 - d.by;
        } else {
          nx = d.x;
          ny = d.y;
        }
        path3 = ["C", nx, ny].concat(path3.slice(1));
        break;
      case "T":
        if (pcom2 === "Q" || pcom2 === "T") {
          d.qx = d.x * 2 - d.qx;
          d.qy = d.y * 2 - d.qy;
        } else {
          d.qx = d.x;
          d.qy = d.y;
        }
        path3 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
        break;
      case "Q":
        d.qx = path3[1];
        d.qy = path3[2];
        path3 = ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
        break;
      case "L":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], path3[2]));
        break;
      case "H":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], d.y));
        break;
      case "V":
        path3 = ["C"].concat(l2c(d.x, d.y, d.x, path3[1]));
        break;
      case "Z":
        path3 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
        break;
      default:
        break;
    }
    return path3;
  };
  var fixArc = function(pp, i2) {
    if (pp[i2].length > 7) {
      pp[i2].shift();
      var pi2 = pp[i2];
      while (pi2.length) {
        pcoms1[i2] = "A";
        p2 && (pcoms2[i2] = "A");
        pp.splice(i2++, 0, ["C"].concat(pi2.splice(0, 6)));
      }
      pp.splice(i2, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  var fixM = function(path1, path22, a1, a2, i2) {
    if (path1 && path22 && path1[i2][0] === "M" && path22[i2][0] !== "M") {
      path22.splice(i2, 0, ["M", a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i2][1];
      a1.y = path1[i2][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  ii = Math.max(p.length, p2 && p2.length || 0);
  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]);
    if (pfirst !== "C") {
      pcoms1[i] = pfirst;
      i && (pcom = pcoms1[i - 1]);
    }
    p[i] = processPath(p[i], attrs, pcom);
    if (pcoms1[i] !== "A" && pfirst === "C")
      pcoms1[i] = "C";
    fixArc(p, i);
    if (p2) {
      p2[i] && (pfirst = p2[i][0]);
      if (pfirst !== "C") {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }
      p2[i] = processPath(p2[i], attrs2, pcom);
      if (pcoms2[i] !== "A" && pfirst === "C") {
        pcoms2[i] = "C";
      }
      fixArc(p2, i);
    }
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }
  return p2 ? [p, p2] : p;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray2 = function(path) {
  return path.join(",").replace(p2s, "$1");
};
var base3 = function(t, p1, p2, p3, p4) {
  var t12 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t22 = t * t12 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t22 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }
  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }
  return z2 * sum;
};
var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;
  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (t > 0 && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t12 = (-b + sqrtb2ac) / (2 * a);
    if (t12 > 0 && t12 < 1) {
      tvalues.push(t12);
    }
    var t22 = (-b - sqrtb2ac) / (2 * a);
    if (t22 > 0 && t22 < 1) {
      tvalues.push(t22);
    }
  }
  var j = tvalues.length;
  var jlen = j;
  var mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var rectPath2 = function(x, y, w, h, r) {
  if (r) {
    return [
      ["M", +x + +r, y],
      ["l", w - r * 2, 0],
      ["a", r, r, 0, 0, 1, r, r],
      ["l", 0, h - r * 2],
      ["a", r, r, 0, 0, 1, -r, r],
      ["l", r * 2 - w, 0],
      ["a", r, r, 0, 0, 1, -r, -r],
      ["l", 0, r * 2 - h],
      ["a", r, r, 0, 0, 1, r, -r],
      ["z"]
    ];
  }
  var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
  res.parsePathArray = parsePathArray2;
  return res;
};
var box = function(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }
  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  return {
    x,
    y,
    width,
    w: width,
    height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath2(x, y, width, height),
    vb: [x, y, width, height].join(" ")
  };
};
var isBBoxIntersect = function(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!is_array_default(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t12 = 1 - t;
  var t13 = Math.pow(t12, 3);
  var t122 = Math.pow(t12, 2);
  var t22 = t * t;
  var t32 = t22 * t;
  var x = t13 * p1x + t122 * 3 * t * c1x + t12 * 3 * t * t * c2x + t32 * p2x;
  var y = t13 * p1y + t122 * 3 * t * c1y + t12 * 3 * t * t * c2y + t32 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t22 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t22 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t22 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t22 * (p2y - 2 * c2y + c1y);
  var ax = t12 * p1x + t * c1x;
  var ay = t12 * p1y + t * c1y;
  var cx = t12 * c2x + t * p2x;
  var cy = t12 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  return {
    x,
    y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha
  };
};
var interHelper = function(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }
  for (var i = 0; i < n2 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({
      x: d.x,
      y: d.y,
      t: i / n2
    });
  }
  for (var i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i];
      var di1 = dots1[i + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 1e-3 ? "y" : "x";
      var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t12 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t22 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t12 >= 0 && t12 <= 1 && t22 >= 0 && t22 <= 1) {
          if (justCount) {
            res += 1;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t12,
              t2: t22
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function(path1, path2, justCount) {
  path1 = pathToCurve2(path1);
  path2 = pathToCurve2(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi2 = path1[i];
    if (pi2[0] === "M") {
      x1 = x1m = pi2[1];
      y1 = y1m = pi2[2];
    } else {
      if (pi2[0] === "C") {
        bez1 = [x1, y1].concat(pi2.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];
        if (pj[0] === "M") {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === "C") {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function(path1, path2) {
  return interPathHelper(path1, path2);
};
function decasteljau(points, t) {
  var left = [];
  var right = [];
  function recurse(points2, t4) {
    if (points2.length === 1) {
      left.push(points2[0]);
      right.push(points2[0]);
    } else {
      var middlePoints = [];
      for (var i = 0; i < points2.length - 1; i++) {
        if (i === 0) {
          left.push(points2[0]);
        }
        if (i === points2.length - 2) {
          right.push(points2[i + 1]);
        }
        middlePoints[i] = [
          (1 - t4) * points2[i][0] + t4 * points2[i + 1][0],
          (1 - t4) * points2[i][1] + t4 * points2[i + 1][1]
        ];
      }
      recurse(middlePoints, t4);
    }
  }
  if (points.length) {
    recurse(points, t);
  }
  return { left, right: right.reverse() };
}
function splitCurve(start, end, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];
  if (end[0] === "A") {
    points.push(end[6]);
    points.push(end[7]);
  } else if (end[0] === "C") {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
    points.push([end[5], end[6]]);
  } else if (end[0] === "S" || end[0] === "Q") {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
  } else {
    points.push([end[1], end[2]]);
  }
  var leftSegments = points;
  var t = 1 / count;
  for (var i = 0; i < count - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function(segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push("C");
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push("Q");
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push("L");
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}
var splitSegment = function(start, end, count) {
  if (count === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end[0] === "L" || end[0] === "C" || end[0] === "Q") {
    segments = segments.concat(splitCurve(start, end, count));
  } else {
    var temp = [].concat(start);
    if (temp[0] === "M") {
      temp[0] = "L";
    }
    for (var i = 0; i <= count - 1; i++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath2 = function(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === "M") {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i = 0; i < targetLen; i++) {
    var index = Math.floor(ratio * i);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function(filled2, count, i2) {
    if (i2 === sourceLen) {
      return filled2.concat(source[sourceLen]);
    }
    return filled2.concat(splitSegment(source[i2], source[i2 + 1], count));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === "Z" || target[targetLen] === "z") {
    filled.push("Z");
  }
  return filled;
};
var isEqual = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each_default(obj1, function(item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add, modify) {
  var type = null;
  var min = modify;
  if (add < min) {
    min = add;
    type = "add";
  }
  if (del < min) {
    min = del;
    type = "del";
  }
  return {
    type,
    min
  };
}
var levenshteinDistance = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist = [];
  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = { min: i };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = { min: j };
  }
  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];
    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];
      if (isEqual(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist[i - 1][j].min + 1;
      var add = dist[i][j - 1].min + 1;
      var modify = dist[i - 1][j - 1].min + temp;
      dist[i][j] = getMinDiff(del, add, modify);
    }
  }
  return dist;
};
var fillPathByDiff2 = function(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i = 1; i <= sourceLen; i++) {
      var min = diffMatrix[i][i].min;
      minPos = i;
      for (var j = index; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min) {
          min = diffMatrix[i][j].min;
          minPos = j;
        }
      }
      index = minPos;
      if (diffMatrix[i][index].type) {
        changes.push({ index: i - 1, type: diffMatrix[i][index].type });
      }
    }
    for (var i = changes.length - 1; i >= 0; i--) {
      index = changes[i].index;
      if (changes[i].type === "add") {
        source.splice(index, 0, [].concat(source[index]));
      } else {
        source.splice(index, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i = 0; i < diff; i++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index;
  var t = 1 / (count + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i = 1; i <= count; i++) {
    t *= i;
    index = Math.floor(points.length * t);
    if (index === 0) {
      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    } else {
      result.splice(index, 0, [
        formerEnd[0] * t + points[index][0] * (1 - t),
        formerEnd[1] * t + points[index][1] * (1 - t)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points = [];
  switch (segment[0]) {
    case "M":
      points.push([segment[1], segment[2]]);
      break;
    case "L":
      points.push([segment[1], segment[2]]);
      break;
    case "A":
      points.push([segment[6], segment[7]]);
      break;
    case "Q":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "T":
      points.push([segment[1], segment[2]]);
      break;
    case "C":
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case "S":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "H":
      points.push([segment[1], segment[1]]);
      break;
    case "V":
      points.push([segment[1], segment[1]]);
      break;
    default:
  }
  return points;
}
var formatPath2 = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points;
  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      points = _getSegmentPoints(fromPath[i]);
      switch (toPath[i][0]) {
        case "M":
          fromPath[i] = ["M"].concat(points[0]);
          break;
        case "L":
          fromPath[i] = ["L"].concat(points[0]);
          break;
        case "A":
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;
        case "Q":
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["Q"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "T":
          fromPath[i] = ["T"].concat(points[0]);
          break;
        case "C":
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["C"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "S":
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["S"].concat(points.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        default:
          fromPath[i] = toPath[i];
      }
    }
  }
  return fromPath;
};

// node_modules/@antv/g-base/esm/abstract/base.js
init_tslib_es6();

// node_modules/@antv/g-base/esm/util/util.js
init_esm();
function removeFromArray(arr, obj) {
  var index = arr.indexOf(obj);
  if (index !== -1) {
    arr.splice(index, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}

// node_modules/@antv/g-base/esm/abstract/base.js
var Base = (
  /** @class */
  function(_super) {
    __extends(Base2, _super);
    function Base2(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg, cfg);
      return _this;
    }
    Base2.prototype.getDefaultCfg = function() {
      return {};
    };
    Base2.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base2.prototype.set = function(name, value) {
      this.cfg[name] = value;
    };
    Base2.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base2;
  }(esm_default)
);
var base_default = Base;

// node_modules/@antv/g-base/esm/abstract/canvas.js
init_tslib_es6();

// node_modules/detect-browser/es/index.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name, version3, os) {
      this.name = name;
      this.version = version3;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version3) {
      this.version = version3;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name, version3, os, bot) {
      this.name = name;
      this.version = version3;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version3 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version3, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version3, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@antv/g-base/esm/abstract/container.js
init_tslib_es6();

// node_modules/@antv/g-base/esm/abstract/element.js
init_tslib_es6();
init_esm();
init_esm3();

// node_modules/@antv/g-base/esm/util/matrix.js
function multiplyMatrix(a, b) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b10 = b[3];
  var b11 = b[4];
  var b12 = b[5];
  var b20 = b[6];
  var b21 = b[7];
  var b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2(m, v) {
  var out = [];
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function invert(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

// node_modules/@antv/g-base/esm/abstract/element.js
var transform = ext_exports.transform;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD2 = "*";
function _cloneArrayAttr(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if (is_array_default(arr[i])) {
      result.push([].concat(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each_default(props, function(v, k) {
    if (RESERVED_PORPS.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation) {
  if (animation.onFrame) {
    return animations;
  }
  var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  each_default(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each_default(animation.toAttrs, function(v, k) {
        if (hasOwnProperty.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}
var Element2 = (
  /** @class */
  function(_super) {
    __extends(Element3, _super);
    function Element3(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element3.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element3.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element3.prototype.onCanvasChange = function(changeType) {
    };
    Element3.prototype.initAttrs = function(attrs) {
    };
    Element3.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element3.prototype.isGroup = function() {
      return false;
    };
    Element3.prototype.getParent = function() {
      return this.get("parent");
    };
    Element3.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element3.prototype.attr = function() {
      var _a;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var name = args[0], value = args[1];
      if (!name)
        return this.attrs;
      if (is_object_default(name)) {
        for (var k in name) {
          this.setAttr(k, name[k]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value);
        this.afterAttrsChange((_a = {}, _a[name] = value, _a));
        return this;
      }
      return this.attrs[name];
    };
    Element3.prototype.isClipped = function(refX, refY) {
      var clip = this.getClip();
      return clip && !clip.isHit(refX, refY);
    };
    Element3.prototype.setAttr = function(name, value) {
      var originValue = this.attrs[name];
      if (originValue !== value) {
        this.attrs[name] = value;
        this.onAttrChange(name, value, originValue);
      }
    };
    Element3.prototype.onAttrChange = function(name, value, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element3.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element3.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element3.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element3.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent = this.getParent();
      if (parent) {
        parent.sort();
      }
      return this;
    };
    Element3.prototype.toFront = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element3.prototype.toBack = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element3.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent = this.getParent();
      if (parent) {
        removeFromArray(parent.getChildren(), this);
        if (!parent.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element3.prototype.resetMatrix = function() {
      this.attr(MATRIX, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element3.prototype.getMatrix = function() {
      return this.attr(MATRIX);
    };
    Element3.prototype.setMatrix = function(m) {
      this.attr(MATRIX, m);
      this.onCanvasChange("matrix");
    };
    Element3.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element3.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element3.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element3.prototype.applyToMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec2(matrix, v);
      }
      return v;
    };
    Element3.prototype.invertFromMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix = invert(matrix);
        if (invertMatrix) {
          return multiplyVec2(invertMatrix, v);
        }
      }
      return v;
    };
    Element3.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase3 = this.getShapeBase();
        var shapeType = upper_first_default(clipCfg.type);
        var Cons = ShapeBase3[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element3.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element3.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each_default(originAttrs, function(i, k) {
        if (is_array_default(originAttrs[k])) {
          attrs[k] = _cloneArrayAttr(originAttrs[k]);
        } else {
          attrs[k] = originAttrs[k];
        }
      });
      var cons = this.constructor;
      var clone = new cons({ attrs });
      each_default(CLONE_CFGS, function(cfgName) {
        clone.set(cfgName, _this.get(cfgName));
      });
      return clone;
    };
    Element3.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element3.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element3.prototype.animate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a = args[2], easing = _a === void 0 ? "easeLinear" : _a, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (is_function_default(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat = toAttrs.repeat;
      }
      if (is_object_default(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay = animateCfg.delay || 0;
        repeat = animateCfg.repeat || repeat || false;
        callback = animateCfg.callback || noop_default;
        pauseCallback = animateCfg.pauseCallback || noop_default;
        resumeCallback = animateCfg.resumeCallback || noop_default;
      } else {
        if (is_number_default(callback)) {
          delay = callback;
          callback = null;
        }
        if (is_function_default(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs(toAttrs, this);
      var animation = {
        fromAttrs: getFormatFromAttrs(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat,
        callback,
        pauseCallback,
        resumeCallback,
        delay,
        startTime: timeline.getTime(),
        id: unique_id_default(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs(animations, animation);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element3.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each_default(animations, function(animation) {
        if (toEnd) {
          if (animation.onFrame) {
            _this.attr(animation.onFrame(1));
          } else {
            _this.attr(animation.toAttrs);
          }
        }
        if (animation.callback) {
          animation.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element3.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each_default(animations, function(animation) {
        animation._paused = true;
        animation._pauseTime = pauseTime;
        if (animation.pauseCallback) {
          animation.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element3.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each_default(animations, function(animation) {
        animation.startTime = animation.startTime + (current - pauseTime);
        animation._paused = false;
        animation._pauseTime = null;
        if (animation.resumeCallback) {
          animation.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element3.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      var events = this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i2) {
        var element = paths[i2];
        var name_1 = element.get("name");
        if (name_1) {
          if (
            // 只有 element 是 Group 或者 Canvas 的时候，才需要判断 isParent
            (element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)
          ) {
            return "break";
          }
          if (is_array_default(name_1)) {
            each_default(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i = 0; i < paths.length; i++) {
        var state_1 = _loop_1(i);
        if (state_1 === "break")
          break;
      }
    };
    Element3.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT + eventObj.type;
      if (events[eventName] || events[WILDCARD2]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element3.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element3.prototype.move = function(targetX, targetY) {
      var x = this.attr("x") || 0;
      var y = this.attr("y") || 0;
      this.translate(targetX - x, targetY - y);
      return this;
    };
    Element3.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element3.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element3.prototype.rotate = function(radian) {
      var matrix = this.getMatrix();
      var newMatrix = transform(matrix, [["r", radian]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element3.prototype.rotateAtStart = function(rotate2) {
      var _a = this.attr(), x = _a.x, y = _a.y;
      var matrix = this.getMatrix();
      var newMatrix = transform(matrix, [
        ["t", -x, -y],
        ["r", rotate2],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element3.prototype.rotateAtPoint = function(x, y, rotate2) {
      var matrix = this.getMatrix();
      var newMatrix = transform(matrix, [
        ["t", -x, -y],
        ["r", rotate2],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element3;
  }(base_default)
);
var element_default = Element2;

// node_modules/@antv/g-base/esm/abstract/container.js
var SHAPE_MAP = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container.getChildren(), element);
}
function getComparer(compare) {
  return function(left, right) {
    var result = compare(left, right);
    return result === 0 ? left[INDEX] - right[INDEX] : result;
  };
}
var Container = (
  /** @class */
  function(_super) {
    __extends(Container2, _super);
    function Container2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container2.prototype.isCanvas = function() {
      return false;
    };
    Container2.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var _a = child.getBBox(), childMinX = _a.minX, childMaxX = _a.maxX, childMinY = _a.minY, childMaxY = _a.maxY;
          if (childMinX < minX) {
            minX = childMinX;
          }
          if (childMaxX > maxX) {
            maxX = childMaxX;
          }
          if (childMinY < minY) {
            minY = childMinY;
          }
          if (childMaxY > maxY) {
            maxY = childMaxY;
          }
        });
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container2.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var _a = child.getCanvasBBox(), childMinX = _a.minX, childMaxX = _a.maxX, childMinY = _a.minY, childMaxY = _a.maxY;
          if (childMinX < minX) {
            minX = childMinX;
          }
          if (childMaxX > maxX) {
            maxX = childMaxX;
          }
          if (childMinY < minY) {
            minY = childMinY;
          }
          if (childMaxY > maxY) {
            maxY = childMaxY;
          }
        });
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container2.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container2.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each_default(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container2.prototype.addShape = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var type = args[0];
      var cfg = args[1];
      if (is_object_default(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP[cfg.type];
      if (!shapeType) {
        shapeType = upper_first_default(cfg.type);
        SHAPE_MAP[cfg.type] = shapeType;
      }
      var ShapeBase3 = this.getShapeBase();
      var shape = new ShapeBase3[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container2.prototype.addGroup = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var groupClass = args[0], cfg = args[1];
      var group;
      if (is_function_default(groupClass)) {
        if (cfg) {
          group = new groupClass(cfg);
        } else {
          group = new groupClass({
            // canvas,
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group = new TmpGroupClass(tmpCfg);
      }
      this.add(group);
      return group;
    };
    Container2.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container2.prototype.getShape = function(x, y, ev) {
      if (!isAllowCapture(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v = [x, y, 1];
        v = this.invertFromMatrix(v);
        if (!this.isClipped(v[0], v[1])) {
          shape = this._findShape(children, v[0], v[1], ev);
        }
      } else {
        shape = this._findShape(children, x, y, ev);
      }
      return shape;
    };
    Container2.prototype._findShape = function(children, x, y, ev) {
      var shape = null;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        if (isAllowCapture(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x, y, ev);
          } else if (child.isHit(x, y)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container2.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas(element, canvas);
      }
      if (timeline) {
        setTimeline(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container2.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container2.prototype.getChildren = function() {
      return this.get("children");
    };
    Container2.prototype.sort = function() {
      var children = this.getChildren();
      each_default(children, function(child, index) {
        child[INDEX] = index;
        return child;
      });
      children.sort(getComparer(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container2.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i = children.length - 1; i >= 0; i--) {
        children[i].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container2.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container2.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container2.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container2.prototype.getChildByIndex = function(index) {
      var children = this.getChildren();
      return children[index];
    };
    Container2.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container2.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container2.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container2.prototype.findAll = function(fn) {
      var rst = [];
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn));
        }
      });
      return rst;
    };
    Container2.prototype.find = function(fn) {
      var rst = null;
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container2.prototype.findById = function(id) {
      return this.find(function(element) {
        return element.get("id") === id;
      });
    };
    Container2.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container2.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container2;
  }(element_default)
);
var container_default = Container;

// node_modules/@antv/g-base/esm/animate/timeline.js
init_esm();
init_src();

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r === max)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b)
    x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function array_default(a, b) {
  return (isNumberArray(b) ? numberArray_default : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate2(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse2(a), b = parse2(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate2(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-ease/src/index.js
var src_exports = {};
__export(src_exports, {
  easeBack: () => backInOut,
  easeBackIn: () => backIn,
  easeBackInOut: () => backInOut,
  easeBackOut: () => backOut,
  easeBounce: () => bounceOut,
  easeBounceIn: () => bounceIn,
  easeBounceInOut: () => bounceInOut,
  easeBounceOut: () => bounceOut,
  easeCircle: () => circleInOut,
  easeCircleIn: () => circleIn,
  easeCircleInOut: () => circleInOut,
  easeCircleOut: () => circleOut,
  easeCubic: () => cubicInOut,
  easeCubicIn: () => cubicIn,
  easeCubicInOut: () => cubicInOut,
  easeCubicOut: () => cubicOut,
  easeElastic: () => elasticOut,
  easeElasticIn: () => elasticIn,
  easeElasticInOut: () => elasticInOut,
  easeElasticOut: () => elasticOut,
  easeExp: () => expInOut,
  easeExpIn: () => expIn,
  easeExpInOut: () => expInOut,
  easeExpOut: () => expOut,
  easeLinear: () => linear2,
  easePoly: () => polyInOut,
  easePolyIn: () => polyIn,
  easePolyInOut: () => polyInOut,
  easePolyOut: () => polyOut,
  easeQuad: () => quadInOut,
  easeQuadIn: () => quadIn,
  easeQuadInOut: () => quadInOut,
  easeQuadOut: () => quadOut,
  easeSin: () => sinInOut,
  easeSinIn: () => sinIn,
  easeSinInOut: () => sinInOut,
  easeSinOut: () => sinOut
});

// node_modules/d3-ease/src/linear.js
function linear2(t) {
  return +t;
}

// node_modules/d3-ease/src/quad.js
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

// node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

// node_modules/d3-ease/src/math.js
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/d3-ease/src/exp.js
function expIn(t) {
  return tpmt(1 - +t);
}
function expOut(t) {
  return 1 - tpmt(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}

// node_modules/d3-ease/src/circle.js
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

// node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

// node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/@antv/g-base/esm/animate/register.js
var EASING_MAP = {};
function getEasing(type) {
  return EASING_MAP[type.toLowerCase()] || src_exports[type];
}
function registerEasing(type, easeFn) {
  EASING_MAP[type.toLowerCase()] = easeFn;
}

// node_modules/@antv/g-base/esm/util/color.js
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

// node_modules/@antv/g-base/esm/animate/timeline.js
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation, ratio) {
  var cProps = {};
  var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k in toAttrs) {
    if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
      if (k === "path") {
        var toPath = toAttrs[k];
        var fromPath = fromAttrs[k];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString2(toAttrs[k]);
          fromPath = parsePathString2(fromAttrs[k]);
          fromPath = fillPathByDiff2(fromPath, toPath);
          fromPath = formatPath2(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
        } else if (!animation.pathFormatted) {
          toPath = parsePathString2(toAttrs[k]);
          fromPath = parsePathString2(fromAttrs[k]);
          fromPath = formatPath2(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
          animation.pathFormatted = true;
        }
        cProps[k] = [];
        for (var i = 0; i < toPath.length; i++) {
          var toPathPoint = toPath[i];
          var fromPathPoint = fromPath[i];
          var cPathPoint = [];
          for (var j = 0; j < toPathPoint.length; j++) {
            if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
              interf = value_default(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }
          cProps[k].push(cPathPoint);
        }
      } else if (k === "matrix") {
        var matrixFn = array_default(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k] = currentMatrix;
      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {
        cProps[k] = toAttrs[k];
      } else if (!is_function_default(toAttrs[k])) {
        interf = value_default(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation, elapsed) {
  var startTime = animation.startTime, delay = animation.delay;
  if (elapsed < startTime + delay || animation._paused) {
    return false;
  }
  var ratio;
  var duration = animation.duration;
  var easing = animation.easing;
  var easeFn = getEasing(easing);
  elapsed = elapsed - startTime - animation.delay;
  if (animation.repeat) {
    ratio = elapsed % duration / duration;
    ratio = easeFn(ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = easeFn(ratio);
    } else {
      if (animation.onFrame) {
        shape.attr(animation.onFrame(1));
      } else {
        shape.attr(animation.toAttrs);
      }
      return true;
    }
  }
  if (animation.onFrame) {
    var attrs = animation.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation, ratio);
  }
  return false;
}
var Timeline = (
  /** @class */
  function() {
    function Timeline2(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline2.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i = _this.animators.length - 1; i >= 0; i--) {
            shape = _this.animators[i];
            if (shape.destroyed) {
              _this.removeAnimator(i);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j = animations.length - 1; j >= 0; j--) {
                animation = animations[j];
                isFinished = update(shape, animation, elapsed);
                if (isFinished) {
                  animations.splice(j, 1);
                  isFinished = false;
                  if (animation.callback) {
                    animation.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline2.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline2.prototype.removeAnimator = function(index) {
      this.animators.splice(index, 1);
    };
    Timeline2.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline2.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline2.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline2.prototype.getTime = function() {
      return this.current;
    };
    return Timeline2;
  }()
);
var timeline_default = Timeline;

// node_modules/@antv/g-base/esm/event/event-contoller.js
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
}
function bubbleEvent(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}
var EventController = (
  /** @class */
  function() {
    function EventController2(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController2.prototype.init = function() {
      this._bindEvents();
    };
    EventController2.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController2.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController2.prototype._getEventObj = function(type, event, point, target, fromShape, toShape) {
      var eventObj = new graph_event_default(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point.x;
      eventObj.y = point.y;
      eventObj.clientX = point.clientX;
      eventObj.clientY = point.clientY;
      eventObj.propagationPath.push(target);
      return eventObj;
    };
    EventController2.prototype._getShape = function(point, ev) {
      return this.canvas.getShape(point.x, point.y, ev);
    };
    EventController2.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point = canvas.getPointByEvent(ev);
      return {
        x: point.x,
        y: point.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController2.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method = this["_on" + type];
      var leaveCanvas = false;
      if (method) {
        method.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController2.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController2.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController2.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController2.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController2.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController2.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController2.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now2 = event.timeStamp;
          var timeWindow = now2 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist = dx * dx + dy * dy;
          if (timeWindow > 120 || dist > CLICK_OFFSET) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController2.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent(canvas, type, eventObj);
      }
    };
    EventController2.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController2;
  }()
);
var event_contoller_default = EventController;

// node_modules/@antv/g-base/esm/abstract/canvas.js
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas = (
  /** @class */
  function(_super) {
    __extends(Canvas4, _super);
    function Canvas4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas4.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas4.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas4.prototype.initEvents = function() {
      var eventController = new event_contoller_default({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas4.prototype.initTimeline = function() {
      var timeline = new timeline_default(this);
      this.set("timeline", timeline);
    };
    Canvas4.prototype.setDOMSize = function(width, height) {
      var el = this.get("el");
      if (isBrowser) {
        el.style.width = width + PX_SUFFIX;
        el.style.height = height + PX_SUFFIX;
      }
    };
    Canvas4.prototype.changeSize = function(width, height) {
      this.setDOMSize(width, height);
      this.set("width", width);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas4.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas4.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas4.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas4.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!is_nil_default(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a = this.getClientByEvent(ev), clientX = _a.x, clientY = _a.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas4.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas4.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas4.prototype.getClientByPoint = function(x, y) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x + bbox.left,
        y: y + bbox.top
      };
    };
    Canvas4.prototype.draw = function() {
    };
    Canvas4.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas4.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas4.prototype.isCanvas = function() {
      return true;
    };
    Canvas4.prototype.getParent = function() {
      return null;
    };
    Canvas4.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas4;
  }(container_default)
);
var canvas_default = Canvas;

// node_modules/@antv/g-base/esm/abstract/group.js
init_tslib_es6();
var AbstractGroup = (
  /** @class */
  function(_super) {
    __extends(AbstractGroup2, _super);
    function AbstractGroup2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup2.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup2.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup2.prototype.clone = function() {
      var clone = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        clone.add(child.clone());
      }
      return clone;
    };
    return AbstractGroup2;
  }(container_default)
);
var group_default = AbstractGroup;

// node_modules/@antv/g-base/esm/abstract/shape.js
init_tslib_es6();
var AbstractShape = (
  /** @class */
  function(_super) {
    __extends(AbstractShape2, _super);
    function AbstractShape2(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape2.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape2.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape2.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape2.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a = attrs.shadowBlur, shadowBlur = _a === void 0 ? 0 : _a, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY = Math.max(maxY, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    AbstractShape2.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape2.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape2.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape2.prototype.isHit = function(x, y) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x, y, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape2;
  }(element_default)
);
var shape_default = AbstractShape;

// node_modules/@antv/g-base/esm/bbox/register.js
var cache = /* @__PURE__ */ new Map();
function register(type, method) {
  cache.set(type, method);
}
function getMethod(type) {
  return cache.get(type);
}

// node_modules/@antv/g-base/esm/bbox/rect.js
function rect_default(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x,
    y,
    width,
    height
  };
}

// node_modules/@antv/g-base/esm/bbox/circle.js
function circle_default(shape) {
  var _a = shape.attr(), x = _a.x, y = _a.y, r = _a.r;
  return {
    x: x - r,
    y: y - r,
    width: r * 2,
    height: r * 2
  };
}

// node_modules/@antv/g-math/esm/util.js
var util_exports = {};
__export(util_exports, {
  distance: () => distance,
  getBBoxByArray: () => getBBoxByArray,
  getBBoxRange: () => getBBoxRange,
  isNumberEqual: () => isNumberEqual2,
  piMod: () => piMod
});
init_esm();
function distance(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual2(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: min_default([x1, x2]),
    maxX: max_default([x1, x2]),
    minY: min_default([y1, y2]),
    maxY: max_default([y1, y2])
  };
}
function piMod(angle) {
  return (angle + Math.PI * 2) % (Math.PI * 2);
}

// node_modules/@antv/g-math/esm/line.js
init_vec2();
var line_default = {
  /**
   * 计算线段的包围盒
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {object} 包围盒对象
   */
  box: function(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  /**
   * 线段的长度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 距离
   */
  length: function(x1, y1, x2, y2) {
    return distance(x1, y1, x2, y2);
  },
  /**
   * 根据比例获取点
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} t 指定比例
   * @return {object} 包含 x, y 的点
   */
  pointAt: function(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  /**
   * 点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointDistance: function(x1, y1, x2, y2, x, y) {
    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross < 0) {
      return distance(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross > lengthSquare) {
      return distance(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  /**
   * 点到直线的距离，而不是点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointToLine: function(x1, y1, x2, y2, x, y) {
    var d = [x2 - x1, y2 - y1];
    if (exactEquals(d, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d[1], d[0]];
    normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(dot(a, u));
  },
  /**
   * 线段的角度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 导数
   */
  tangentAngle: function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};

// node_modules/@antv/g-math/esm/bezier.js
var EPSILON = 1e-4;
function nearestPoint(xArr, yArr, x, y, tCallback, length) {
  var t;
  var d = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length && length > 200) {
    segNum = length / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval2 < EPSILON) {
      break;
    }
    var prev = t - interval2;
    var next = t + interval2;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d2 = distance(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t])),
    y: tCallback.apply(null, yArr.concat([t]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += distance(x, y, nextX, nextY);
  }
  return totalLength / 2;
}

// node_modules/@antv/g-math/esm/quadratic.js
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual2(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t);
  var controlPoint1 = line_default.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = line_default.pointAt(x2, y2, x3, y3, t);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
  ];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance(x1, y1, x2, y2) + distance(x2, y2, x3, y3) + distance(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
}
var quadratic_default = {
  box: function(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema(x1, x2, x3)[0];
    var yExtrema2 = extrema(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt(x1, x2, x3, t);
    var dy = derivativeAt(y1, y2, y3, t);
    var angle = Math.atan2(dy, dx);
    return piMod(angle);
  }
};

// node_modules/@antv/g-math/esm/cubic.js
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt2(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema2(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual2(a, 0)) {
    if (!isNumberEqual2(b, 0)) {
      t12 = -c / b;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual2(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b + discSqrt) / (2 * a);
      t22 = (-b - discSqrt) / (2 * a);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t);
  var c1 = line_default.pointAt(x1, y1, x2, y2, t);
  var c2 = line_default.pointAt(x2, y2, x3, y3, t);
  var c3 = line_default.pointAt(x3, y3, x4, y4, t);
  var c12 = line_default.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = line_default.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = cubics[0];
  var right = cubics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return cubicLength.apply(null, left) + cubicLength.apply(null, right);
}
var cubic_default = {
  extrema: extrema2,
  box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema2(x1, x2, x3, x4);
    var yExtrema2 = extrema2(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var i = 0; i < yExtrema2.length; i++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);
    return distance(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt2(x1, x2, x3, x4, t);
    var dy = derivativeAt2(y1, y2, y3, y4, t);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/ellipse.js
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse_default = {
  /**
   * 包围盒计算
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @return {object} 包围盒
   */
  box: function(x, y, rx, ry) {
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  /**
   * 计算周长，使用近似法
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @return {number} 椭圆周长
   */
  length: function(x, y, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  /**
   * 距离椭圆最近的点
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} x0  指定的点 x
   * @param {number} y0  指定的点 y
   * @return {object} 椭圆上距离指定点最近的点
   */
  nearestPoint: function(x, y, rx, ry, x0, y0) {
    var a = rx;
    var b = ry;
    if (a === 0 || b === 0) {
      return {
        x,
        y
      };
    }
    var relativeX = x0 - x;
    var relativeY = y0 - y;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b * b;
    var t = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i = 0; i < 4; i++) {
      nearestX = a * Math.cos(t);
      nearestY = b * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }
    return {
      x: x + copysign(nearestX, relativeX),
      y: y + copysign(nearestY, relativeY)
    };
  },
  /**
   * 点到椭圆最近的距离
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} x0  指定的点 x
   * @param {number} y0  指定的点 y
   * @return {number} 点到椭圆的距离
   */
  pointDistance: function(x, y, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x, y, rx, ry, x0, y0);
    return distance(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  /**
   * 根据比例获取点
   * @param {number} x 椭圆中心 x
   * @param {number} y 椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} t 指定比例，x轴方向为 0
   * @return {object} 点
   */
  pointAt: function(x, y, rx, ry, t) {
    var angle = 2 * Math.PI * t;
    return {
      x: x + rx * Math.cos(angle),
      y: y + ry * Math.sin(angle)
    };
  },
  /**
   * 根据比例计算切线角度
   * @param {number} x 椭圆中心 x
   * @param {number} y 椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整
   * @return {number} 角度，在 0 - 2PI 之间
   */
  tangentAngle: function(x, y, rx, ry, t) {
    var angle = 2 * Math.PI * t;
    var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));
    return piMod(tangentAngle);
  }
};

// node_modules/@antv/g-math/esm/arc.js
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle) {
  return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle) {
  return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;
}
function getAngle(rx, ry, x0, y0) {
  var angle = Math.atan2(y0 * rx, x0 * ry);
  return (angle + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle) {
  return {
    x: rx * Math.cos(angle),
    y: ry * Math.sin(angle)
  };
}
function rotate(x, y, angle) {
  var cos2 = Math.cos(angle);
  var sin2 = Math.sin(angle);
  return [x * cos2 - y * sin2, x * sin2 + y * cos2];
}
var arc_default = {
  /**
   * 计算包围盒
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   * @return {object} 包围盒对象
   */
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i = 0; i < xs.length; i++) {
      var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var yAngle = yDim + i;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i = 0; i < ys.length; i++) {
      var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
      if (y < minY) {
        minY = y;
      }
      if (y > maxY) {
        maxY = y;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  /**
   * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，
   * 仅跟 rx, ry, startAngle, endAngle 相关
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   */
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  /**
   * 获取指定点到圆弧的最近距离的点
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   * @param {number} x0         指定点的 x
   * @param {number} y0         指定点的 y
   * @return {object} 到指定点最近距离的点
   */
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse_default.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);
    if (angle < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle),
      y: yAt(cx, cy, rx, ry, xRotation, angle)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/segments.js
function analyzePoints(points) {
  var totalLength = 0;
  var segments = [];
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    var length_1 = distance(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += distance(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return null;
  }
  var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  var startRatio = 0;
  var point = null;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point = line_default.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point;
}
function angleAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return 0;
  }
  var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;
  var startRatio = 0;
  var angle = 0;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle;
}
function distanceAtSegment(points, x, y) {
  var minDistance = Infinity;
  for (var i = 0; i < points.length - 1; i++) {
    var point = points[i];
    var nextPoint = points[i + 1];
    var distance_1 = line_default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}

// node_modules/@antv/g-math/esm/polyline.js
var polyline_default = {
  /**
   * 计算多折线的包围盒
   * @param {array} points 点的集合 [x,y] 的形式
   * @return {object} 包围盒
   */
  box: function(points) {
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  /**
   * 计算多折线的长度
   * @param {array} points 点的集合 [x,y] 的形式
   * @return {object} 多条边的长度
   */
  length: function(points) {
    return lengthOfSegment(points);
  },
  /**
   * 根据比例获取多折线的点
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} t 在多折线的长度上的比例
   * @return {object} 根据比例值计算出来的点
   */
  pointAt: function(points, t) {
    return pointAtSegments(points, t);
  },
  /**
   * 指定点到多折线的距离
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} x 指定点的 x
   * @param {number} y 指定点的 y
   * @return {number} 点到多折线的距离
   */
  pointDistance: function(points, x, y) {
    return distanceAtSegment(points, x, y);
  },
  /**
   * 根据比例获取多折线的切线角度
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} t 在多折线的长度上的比例
   * @return {object} 根据比例值计算出来的角度
   */
  tangentAngle: function(points, t) {
    return angleAtSegments(points, t);
  }
};

// node_modules/@antv/g-base/esm/bbox/util.js
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}

// node_modules/@antv/g-base/esm/bbox/polyline.js
function polyline_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }
  var _a = util_exports.getBBoxByArray(xArr, yArr), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/polygon.js
function polygon_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }
  return util_exports.getBBoxByArray(xArr, yArr);
}

// node_modules/@antv/g-base/esm/util/offscreen.js
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}

// node_modules/@antv/g-base/esm/util/text.js
function getTextHeight(text, fontSize, lineHeight) {
  var lineCount = 1;
  if (is_string_default(text)) {
    lineCount = text.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text, font) {
  var context = getOffScreenContext();
  var width = 0;
  if (is_nil_default(text) || text === "") {
    return width;
  }
  context.save();
  context.font = font;
  if (is_string_default(text) && text.includes("\n")) {
    var textArr = text.split("\n");
    each_default(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text).width;
  }
  context.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}

// node_modules/@antv/g-base/esm/bbox/text.js
function text_default(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width = getTextWidth(text, font);
  var bbox;
  if (!width) {
    bbox = {
      x,
      y,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text, fontSize, lineHeight);
    var point = {
      x,
      y: y - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point.x -= width;
      } else if (textAlign === "center") {
        point.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point.y += height;
      } else if (textBaseline === "middle") {
        point.y += height / 2;
      }
    }
    bbox = {
      x: point.x,
      y: point.y,
      width,
      height
    };
  }
  return bbox;
}

// node_modules/@antv/g-base/esm/bbox/path.js
init_esm();
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var i = 0; i < segmentsWithAngle.length; i++) {
    var segment = segmentsWithAngle[i];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 水平方向投影
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 垂直方向投影
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path_default(shape) {
  var attrs = shape.attr();
  var path = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path);
  var _a = getPathBox(segments, lineWidth), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/line.js
function line_default2(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/ellipse.js
function ellipse_default2(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x - rx,
    y: y - ry,
    width: rx * 2,
    height: ry * 2
  };
}

// node_modules/@antv/g-base/esm/bbox/index.js
register("rect", rect_default);
register("image", rect_default);
register("circle", circle_default);
register("marker", circle_default);
register("polyline", polyline_default2);
register("polygon", polygon_default2);
register("text", text_default);
register("path", path_default);
register("line", line_default2);
register("ellipse", ellipse_default2);

// node_modules/@antv/g-canvas/esm/canvas.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/hit.js
function invertFromMatrix(v, matrix) {
  if (matrix) {
    var invertMatrix = invert(matrix);
    return multiplyVec2(invertMatrix, v);
  }
  return v;
}
function getRefXY(element, x, y) {
  var totalMatrix = element.getTotalMatrix();
  if (totalMatrix) {
    var _a = invertFromMatrix([x, y, 1], totalMatrix), refX = _a[0], refY = _a[1];
    return [refX, refY];
  }
  return [x, y];
}
function preTest(element, x, y) {
  if (element.isCanvas && element.isCanvas()) {
    return true;
  }
  if (!isAllowCapture(element) || element.cfg.isInView === false) {
    return false;
  }
  if (element.cfg.clipShape) {
    var _a = getRefXY(element, x, y), refX = _a[0], refY = _a[1];
    if (element.isClipped(refX, refY)) {
      return false;
    }
  }
  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
    return false;
  }
  return true;
}
function getShape(container, x, y) {
  if (!preTest(container, x, y)) {
    return null;
  }
  var shape = null;
  var children = container.getChildren();
  var count = children.length;
  for (var i = count - 1; i >= 0; i--) {
    var child = children[i];
    if (child.isGroup()) {
      shape = getShape(child, x, y);
    } else if (preTest(child, x, y)) {
      var curShape = child;
      var _a = getRefXY(child, x, y), refX = _a[0], refY = _a[1];
      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }
    if (shape) {
      break;
    }
  }
  return shape;
}

// node_modules/@antv/g-canvas/esm/shape/index.js
var shape_exports = {};
__export(shape_exports, {
  Base: () => base_default2,
  Circle: () => circle_default2,
  Ellipse: () => ellipse_default3,
  Image: () => image_default,
  Line: () => line_default3,
  Marker: () => marker_default,
  Path: () => path_default2,
  Polygon: () => polygon_default3,
  Polyline: () => polyline_default3,
  Rect: () => rect_default2,
  Text: () => text_default2
});

// node_modules/@antv/g-canvas/esm/shape/base.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/util.js
init_esm();
function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}
function distance2(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint2(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

// node_modules/@antv/g-canvas/esm/util/draw.js
init_esm();

// node_modules/@antv/g-canvas/esm/util/parse.js
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop(steps, gradient) {
  var arr = steps.match(regexColorStop);
  each_default(arr, function(item) {
    var itemArr = item.split(":");
    gradient.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG.exec(gradientStr);
  var angle = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box2 = element.getBBox();
  var start;
  var end;
  if (angle >= 0 && angle < 1 / 2 * Math.PI) {
    start = {
      x: box2.minX,
      y: box2.minY
    };
    end = {
      x: box2.maxX,
      y: box2.maxY
    };
  } else if (1 / 2 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.minY
    };
    end = {
      x: box2.minX,
      y: box2.maxY
    };
  } else if (Math.PI <= angle && angle < 3 / 2 * Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.maxY
    };
    end = {
      x: box2.minX,
      y: box2.minY
    };
  } else {
    start = {
      x: box2.minX,
      y: box2.maxY
    };
    end = {
      x: box2.maxX,
      y: box2.minY
    };
  }
  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient = context.createLinearGradient(start.x, start.y, x, y);
  addStop(steps, gradient);
  return gradient;
}
function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4];
  if (fr === 0) {
    var colors = steps.match(regexColorStop);
    return colors[colors.length - 1].split(":")[1];
  }
  var box2 = element.getBBox();
  var width = box2.maxX - box2.minX;
  var height = box2.maxY - box2.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr * r);
  addStop(steps, gradient);
  return gradient;
}
function parsePattern(context, element, patternStr) {
  if (element.get("patternSource") && element.get("patternSource") === patternStr) {
    return element.get("pattern");
  }
  var pattern;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  function onload() {
    pattern = context.createPattern(img, repeat);
    element.set("pattern", pattern);
    element.set("patternSource", patternStr);
  }
  switch (repeat) {
    case "a":
      repeat = "repeat";
      break;
    case "x":
      repeat = "repeat-x";
      break;
    case "y":
      repeat = "repeat-y";
      break;
    case "n":
      repeat = "no-repeat";
      break;
    default:
      repeat = "no-repeat";
  }
  img = new Image();
  if (!source.match(/^data:/i)) {
    img.crossOrigin = "Anonymous";
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    img.src = img.src;
  }
  return pattern;
}
function parseStyle(context, element, color2) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color2;
  }
  if (is_string_default(color2)) {
    if (color2[1] === "(" || color2[2] === "(") {
      if (color2[0] === "l") {
        return parseLineGradient(context, element, color2);
      }
      if (color2[0] === "r") {
        return parseRadialGradient(context, element, color2);
      }
      if (color2[0] === "p") {
        return parsePattern(context, element, color2);
      }
    }
    return color2;
  }
  if (color2 instanceof CanvasPattern) {
    return color2;
  }
}
function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}

// node_modules/@antv/g-canvas/esm/util/arc-params.js
function vMag2(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio2(u, v) {
  return vMag2(u) * vMag2(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag2(u) * vMag2(v)) : 1;
}
function vAngle2(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio2(u, v));
}
function getArcParams2(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle2([1, 0], u);
  var dTheta = vAngle2(u, v);
  if (vRatio2(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio2(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint2(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint2(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/g-canvas/esm/util/arrow.js
init_tslib_es6();
var sin = Math.sin;
var cos = Math.cos;
var atan2 = Math.atan2;
var PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: {
      // 默认箭头的边长为 10，夹角为 60 度
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      // 使用 shape stroke 值
      stroke,
      lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: __assign(__assign({}, restAttrs), {
      // 支持单独设置箭头的 stroke 和 lineWidth，若为空则使用 shape 的值
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      // 箭头是否填充需要手动设置，不会继承自 shape 的值
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.startArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set("startArrowShape", null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.endArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set("startArrowShape", null);
  }
}

// node_modules/@antv/g-canvas/esm/util/draw.js
var SHAPE_ATTRS_MAP = {
  fill: "fillStyle",
  stroke: "strokeStyle",
  opacity: "globalAlpha"
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k in attrs) {
    var v = attrs[k];
    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
    if (name_1 === "matrix" && v) {
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === "lineDash" && context.setLineDash) {
      is_array_default(v) && context.setLineDash(v);
    } else {
      if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
        v = parseStyle(context, element, v);
      } else if (name_1 === "globalAlpha") {
        v = v * context.globalAlpha;
      }
      context[name_1] = v;
    }
  }
}
function drawChildren(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}
function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get("refreshElements");
  each_default(refreshElements, function(el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    checkChildrenRefresh(children, region);
  }
}
function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      if (child.cfg.hasChanged) {
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false;
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (!child.cfg.visible) {
      continue;
    }
    child.cfg.refresh = true;
    if (child.isGroup()) {
      setChildrenRefresh(child.get("children"), region);
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);
  return isAllow;
}
function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
  if (!path) {
    return;
  }
  var currentPoint = [0, 0];
  var startMovePoint = [0, 0];
  var distance3 = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i = 0; i < path.length; i++) {
    var params = path[i];
    var command = params[0];
    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance3 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path.length - 2 && path[i + 1][0] === "Z" && endArrow && endArrow.d) {
      var lastPath = path[i + 1];
      if (lastPath[0] === "Z") {
        var tangent = shape.getEndTangent();
        distance3 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== "Z") {
        var tangent = shape.getEndTangent();
        distance3 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance3.dx, dy = distance3.dy;
    switch (command) {
      case "M":
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case "L":
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case "A": {
        var arcParams = void 0;
        if (arcParamsCache) {
          arcParams = arcParamsCache[i];
          if (!arcParams) {
            arcParams = getArcParams2(currentPoint, params);
            arcParamsCache[i] = arcParams;
          }
        } else {
          arcParams = getArcParams2(currentPoint, params);
        }
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
  }
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas) {
    if (changeType === "remove") {
      element._cacheCanvasBBox = element.get("cacheCanvasBBox");
    }
    if (!element.get("hasChanged")) {
      element.set("hasChanged", true);
      if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get("autoDraw")) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get("cacheCanvasBBox");
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    if (validCache && validBBox) {
      region = mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    region = element["_cacheCanvasBBox"];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  each_default(elements, function(el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: min_default(minXArr),
    minY: min_default(minYArr),
    maxX: max_default(maxXArr),
    maxY: max_default(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  if (!intersectRect(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}

// node_modules/@antv/g-canvas/esm/group.js
init_tslib_es6();
init_esm();
var Group = (
  /** @class */
  function(_super) {
    __extends(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    Group3.prototype.cacheCanvasBBox = function() {
      var children = this.cfg.children;
      var xArr = [];
      var yArr = [];
      each_default(children, function(child) {
        var bbox2 = child.cfg.cacheCanvasBBox;
        if (bbox2 && child.cfg.isInView) {
          xArr.push(bbox2.minX, bbox2.maxX);
          yArr.push(bbox2.minY, bbox2.maxY);
        }
      });
      var bbox = null;
      if (xArr.length) {
        var minX = min_default(xArr);
        var maxX = max_default(xArr);
        var minY = min_default(yArr);
        var maxY = max_default(yArr);
        bbox = {
          minX,
          minY,
          x: minX,
          y: minY,
          maxX,
          maxY,
          width: maxX - minX,
          height: maxY - minY
        };
        var canvas = this.cfg.canvas;
        if (canvas) {
          var viewRange = canvas.getViewRange();
          this.set("isInView", intersectRect(bbox, viewRange));
        }
      } else {
        this.set("isInView", false);
      }
      this.set("cacheCanvasBBox", bbox);
    };
    Group3.prototype.draw = function(context, region) {
      var children = this.cfg.children;
      var allowDraw = region ? this.cfg.refresh : true;
      if (children.length && allowDraw) {
        context.save();
        applyAttrsToContext(context, this);
        this._applyClip(context, this.getClip());
        drawChildren(context, children, region);
        context.restore();
        this.cacheCanvasBBox();
      }
      this.cfg.refresh = null;
      this.set("hasChanged", false);
    };
    Group3.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("hasChanged", false);
    };
    return Group3;
  }(group_default)
);
var group_default2 = Group;

// node_modules/@antv/g-canvas/esm/shape/base.js
var ShapeBase = (
  /** @class */
  function(_super) {
    __extends(ShapeBase3, _super);
    function ShapeBase3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeBase3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase3.prototype.getShapeBase = function() {
      return shape_exports;
    };
    ShapeBase3.prototype.getGroupBase = function() {
      return group_default2;
    };
    ShapeBase3.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    ShapeBase3.prototype.calculateBBox = function() {
      var type = this.get("type");
      var lineWidth = this.getHitLineWidth();
      var bboxMethod = getMethod(type);
      var box2 = bboxMethod(this);
      var halfLineWidth = lineWidth / 2;
      var minX = box2.x - halfLineWidth;
      var minY = box2.y - halfLineWidth;
      var maxX = box2.x + box2.width + halfLineWidth;
      var maxY = box2.y + box2.height + halfLineWidth;
      return {
        x: minX,
        minX,
        y: minY,
        minY,
        width: box2.width + lineWidth,
        height: box2.height + lineWidth,
        maxX,
        maxY
      };
    };
    ShapeBase3.prototype.isFill = function() {
      return !!this.attrs["fill"] || this.isClipShape();
    };
    ShapeBase3.prototype.isStroke = function() {
      return !!this.attrs["stroke"];
    };
    ShapeBase3.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    ShapeBase3.prototype.draw = function(context, region) {
      var clip = this.cfg.clipShape;
      if (region) {
        if (this.cfg.refresh === false) {
          this.set("hasChanged", false);
          return;
        }
        var bbox = this.getCanvasBBox();
        if (!intersectRect(region, bbox)) {
          this.set("hasChanged", false);
          if (this.cfg.isInView) {
            this._afterDraw();
          }
          return;
        }
      }
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, clip);
      this.drawPath(context);
      context.restore();
      this._afterDraw();
    };
    ShapeBase3.prototype.getCanvasViewBox = function() {
      var canvas = this.cfg.canvas;
      if (canvas) {
        return canvas.getViewRange();
      }
      return null;
    };
    ShapeBase3.prototype.cacheCanvasBBox = function() {
      var canvasBBox = this.getCanvasViewBox();
      if (canvasBBox) {
        var bbox = this.getCanvasBBox();
        var isInView = intersectRect(bbox, canvasBBox);
        this.set("isInView", isInView);
        if (isInView) {
          this.set("cacheCanvasBBox", bbox);
        } else {
          this.set("cacheCanvasBBox", null);
        }
      }
    };
    ShapeBase3.prototype._afterDraw = function() {
      this.cacheCanvasBBox();
      this.set("hasChanged", false);
      this.set("refresh", null);
    };
    ShapeBase3.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("isInView", null);
      this.set("hasChanged", false);
    };
    ShapeBase3.prototype.drawPath = function(context) {
      this.createPath(context);
      this.strokeAndFill(context);
      this.afterDrawPath(context);
    };
    ShapeBase3.prototype.fill = function(context) {
      context.fill();
    };
    ShapeBase3.prototype.stroke = function(context) {
      context.stroke();
    };
    ShapeBase3.prototype.strokeAndFill = function(context) {
      var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = strokeOpacity;
          }
          this.stroke(context);
        }
      }
      this.afterDrawPath(context);
    };
    ShapeBase3.prototype.createPath = function(context) {
    };
    ShapeBase3.prototype.afterDrawPath = function(context) {
    };
    ShapeBase3.prototype.isInShape = function(refX, refY) {
      var isStroke = this.isStroke();
      var isFill = this.isFill();
      var lineWidth = this.getHitLineWidth();
      return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
    };
    ShapeBase3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      return false;
    };
    ShapeBase3.prototype.getHitLineWidth = function() {
      if (!this.isStroke()) {
        return 0;
      }
      var attrs = this.attrs;
      return attrs["lineWidth"] + attrs["lineAppendWidth"];
    };
    return ShapeBase3;
  }(shape_default)
);
var base_default2 = ShapeBase;

// node_modules/@antv/g-canvas/esm/shape/circle.js
init_tslib_es6();
var Circle = (
  /** @class */
  function(_super) {
    __extends(Circle3, _super);
    function Circle3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      var halfLineWidth = lineWidth / 2;
      var absDistance = distance2(cx, cy, x, y);
      if (isFill && isStroke) {
        return absDistance <= r + halfLineWidth;
      }
      if (isFill) {
        return absDistance <= r;
      }
      if (isStroke) {
        return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
      }
      return false;
    };
    Circle3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      context.beginPath();
      context.arc(cx, cy, r, 0, Math.PI * 2, false);
      context.closePath();
    };
    return Circle3;
  }(base_default2)
);
var circle_default2 = Circle;

// node_modules/@antv/g-canvas/esm/shape/ellipse.js
init_tslib_es6();
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse = (
  /** @class */
  function(_super) {
    __extends(Ellipse3, _super);
    function Ellipse3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var halfLineWith = lineWidth / 2;
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx, ry = attrs.ry;
      var squareX = (x - cx) * (x - cx);
      var squareY = (y - cy) * (y - cy);
      if (isFill && isStroke) {
        return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      if (isFill) {
        return ellipseDistance(squareX, squareY, rx, ry) <= 1;
      }
      if (isStroke) {
        return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      return false;
    };
    Ellipse3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx;
      var ry = attrs.ry;
      context.beginPath();
      if (context.ellipse) {
        context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
      } else {
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        context.save();
        context.translate(cx, cy);
        context.scale(scaleX, scaleY);
        context.arc(0, 0, r, 0, Math.PI * 2);
        context.restore();
        context.closePath();
      }
    };
    return Ellipse3;
  }(base_default2)
);
var ellipse_default3 = Ellipse;

// node_modules/@antv/g-canvas/esm/shape/image.js
init_tslib_es6();
function isCanvas(dom) {
  return dom instanceof HTMLElement && is_string_default(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = (
  /** @class */
  function(_super) {
    __extends(ImageShape2, _super);
    function ImageShape2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageShape2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    ImageShape2.prototype.initAttrs = function(attrs) {
      this._setImage(attrs.img);
    };
    ImageShape2.prototype.isStroke = function() {
      return false;
    };
    ImageShape2.prototype.isOnlyHitBox = function() {
      return true;
    };
    ImageShape2.prototype._afterLoading = function() {
      if (this.get("toDraw") === true) {
        var canvas = this.get("canvas");
        if (canvas) {
          canvas.draw();
        } else {
          this.createPath(this.get("context"));
        }
      }
    };
    ImageShape2.prototype._setImage = function(img) {
      var _this = this;
      var attrs = this.attrs;
      if (is_string_default(img)) {
        var image_1 = new Image();
        image_1.onload = function() {
          if (_this.destroyed) {
            return false;
          }
          _this.attr("img", image_1);
          _this.set("loading", false);
          _this._afterLoading();
          var callback = _this.get("callback");
          if (callback) {
            callback.call(_this);
          }
        };
        image_1.crossOrigin = "Anonymous";
        image_1.src = img;
        this.set("loading", true);
      } else if (img instanceof Image) {
        if (!attrs.width) {
          attrs.width = img.width;
        }
        if (!attrs.height) {
          attrs.height = img.height;
        }
      } else if (isCanvas(img)) {
        if (!attrs.width) {
          attrs.width = Number(img.getAttribute("width"));
        }
        if (!attrs.height) {
          attrs.height, Number(img.getAttribute("height"));
        }
      }
    };
    ImageShape2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "img") {
        this._setImage(value);
      }
    };
    ImageShape2.prototype.createPath = function(context) {
      if (this.get("loading")) {
        this.set("toDraw", true);
        this.set("context", context);
        return;
      }
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
      var img = attrs.img;
      if (img instanceof Image || isCanvas(img)) {
        if (!is_nil_default(sx) && !is_nil_default(sy) && !is_nil_default(swidth) && !is_nil_default(sheight)) {
          context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
        } else {
          context.drawImage(img, x, y, width, height);
        }
      }
    };
    return ImageShape2;
  }(base_default2)
);
var image_default = ImageShape;

// node_modules/@antv/g-canvas/esm/shape/line.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/in-stroke/line.js
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  }
  return line_default.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/shape/line.js
var Line = (
  /** @class */
  function(_super) {
    __extends(Line3, _super);
    function Line3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line3.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    Line3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      this.setArrow();
    };
    Line3.prototype.setArrow = function() {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        addStartArrow(this, attrs, x2, y2, x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, x1, y1, x2, y2);
      }
    };
    Line3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
      return inLine(x1, y1, x2, y2, lineWidth, x, y);
    };
    Line3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      var startArrowDistance = {
        dx: 0,
        dy: 0
      };
      var endArrowDistance = {
        dx: 0,
        dy: 0
      };
      if (startArrow && startArrow.d) {
        startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
      }
      if (endArrow && endArrow.d) {
        endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
      }
      context.beginPath();
      context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
      context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
    };
    Line3.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Line3.prototype.getTotalLength = function() {
      var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
      return line_default.length(x1, y1, x2, y2);
    };
    Line3.prototype.getPoint = function(ratio) {
      var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
      return line_default.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line3;
  }(base_default2)
);
var line_default3 = Line;

// node_modules/@antv/g-canvas/esm/shape/marker.js
init_tslib_es6();
init_esm();
var Symbols = {
  // 圆
  circle: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r, r, 0, 1, 0, x + r, y],
      ["A", r, r, 0, 1, 0, x - r, y]
    ];
  },
  // 正方形
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  // 菱形
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  // 三角形
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["Z"]];
  },
  // 倒三角形
  "triangle-down": function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker3, _super);
    function Marker3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker3.prototype.initAttrs = function(attrs) {
      this._resetParamsCache();
    };
    Marker3.prototype._resetParamsCache = function() {
      this.set("paramsCache", {});
    };
    Marker3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
        this._resetParamsCache();
      }
    };
    Marker3.prototype.isOnlyHitBox = function() {
      return true;
    };
    Marker3.prototype._getR = function(attrs) {
      return is_nil_default(attrs.r) ? attrs.radius : attrs.r;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var symbol = attrs.symbol || "circle";
      var r = this._getR(attrs);
      var method;
      var path;
      if (is_function_default(symbol)) {
        method = symbol;
        path = method(x, y, r);
        path = pathToAbsolute(path);
      } else {
        method = Marker3.Symbols[symbol];
        if (!method) {
          console.warn(symbol + " marker is not supported.");
          return null;
        }
        path = method(x, y, r);
      }
      return path;
    };
    Marker3.prototype.createPath = function(context) {
      var path = this._getPath();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, { path }, paramsCache);
    };
    Marker3.Symbols = Symbols;
    return Marker3;
  }(base_default2)
);
var marker_default = Marker;

// node_modules/@antv/g-canvas/esm/shape/path.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js
function isPointInPath(shape, x, y) {
  var ctx = getOffScreenContext();
  shape.createPath(ctx);
  return ctx.isPointInPath(x, y);
}

// node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
var tolerance2 = 1e-6;
function dcmp2(x) {
  if (Math.abs(x) < tolerance2) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment2(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon2(points, x, y) {
  var isHit = false;
  var n = points.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];
    if (onSegment2(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp2(p1[1] - y) > 0 !== dcmp2(p2[1] - y) > 0 && dcmp2(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

// node_modules/@antv/g-canvas/esm/util/path.js
init_tslib_es6();
init_esm3();
init_vec3();

// node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js
function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
  if (angle < startAngle || angle > endAngle) {
    return false;
  }
  var point = {
    x: cx + r * Math.cos(angle),
    y: cy + r * Math.sin(angle)
  };
  return distance2(point.x, point.y, x, y) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/util/path.js
var transform2 = ext_exports.transform;
function hasArc(path) {
  var hasArc2 = false;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc2 = true;
      break;
    }
  }
  return hasArc2;
}
function isPointInStroke(segments, lineWidth, x, y, length) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x, y)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
        break;
      case "Q":
        var qDistance = quadratic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
        isHit = qDistance <= lineWidth / 2;
        break;
      case "C":
        var cDistance = cubic_default.pointDistance(
          prePoint[0],
          // 上一段结束位置, 即 C 的起始点
          prePoint[1],
          params[1],
          // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          x,
          y,
          length
        );
        isHit = cDistance <= lineWidth / 2;
        break;
      case "A":
        var arcParams = segment.arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
        var p = [x, y, 1];
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m = transform2(null, [
          ["t", -cx, -cy],
          ["r", -xRotation],
          ["s", 1 / scaleX, 1 / scaleY]
        ]);
        transformMat3(p, p, m);
        isHit = arc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
        break;
      default:
        break;
    }
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function extractPolygons(path) {
  var count = path.length;
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
var path_default3 = __assign({
  hasArc,
  extractPolygons,
  isPointInStroke
}, path_exports);

// node_modules/@antv/g-canvas/esm/shape/path.js
function isInPolygons(polygons, x, y) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = isInPolygon2(points, x, y);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
var Path = (
  /** @class */
  function(_super) {
    __extends(Path3, _super);
    function Path3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Path3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    Path3.prototype.initAttrs = function(attrs) {
      this._setPathArr(attrs.path);
      this.setArrow();
    };
    Path3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "path") {
        this._setPathArr(value);
      }
      this.setArrow();
    };
    Path3.prototype._setPathArr = function(path) {
      this.attrs.path = pathToAbsolute(path);
      var hasArc2 = path_default3.hasArc(path);
      this.set("hasArc", hasArc2);
      this.set("paramsCache", {});
      this.set("segments", null);
      this.set("curve", null);
      this.set("tCache", null);
      this.set("totalLength", null);
    };
    Path3.prototype.getSegments = function() {
      var segments = this.get("segements");
      if (!segments) {
        segments = getSegments(this.attr("path"));
        this.set("segments", segments);
      }
      return segments;
    };
    Path3.prototype.setArrow = function() {
      var attrs = this.attr();
      var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        var tangent = this.getStartTangent();
        addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
      if (endArrow) {
        var tangent = this.getEndTangent();
        addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
    };
    Path3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var segments = this.getSegments();
      var hasArc2 = this.get("hasArc");
      var isHit = false;
      if (isStroke) {
        var length_1 = this.getTotalLength();
        isHit = path_default3.isPointInStroke(segments, lineWidth, x, y, length_1);
      }
      if (!isHit && isFill) {
        if (hasArc2) {
          isHit = isPointInPath(this, x, y);
        } else {
          var path = this.attr("path");
          var extractResutl = path_default3.extractPolygons(path);
          isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
        }
      }
      return isHit;
    };
    Path3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, attrs, paramsCache);
    };
    Path3.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Path3.prototype.getTotalLength = function() {
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this._calculateCurve();
      this._setTcache();
      return this.get("totalLength");
    };
    Path3.prototype.getPoint = function(ratio) {
      var tCache = this.get("tCache");
      if (!tCache) {
        this._calculateCurve();
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      var curve = this.get("curve");
      if (!tCache || tCache.length === 0) {
        if (curve) {
          return {
            x: curve[0][1],
            y: curve[0][2]
          };
        }
        return null;
      }
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      var seg = curve[index];
      if (is_nil_default(seg) || is_nil_default(index)) {
        return null;
      }
      var l = seg.length;
      var nextSeg = curve[index + 1];
      return cubic_default.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
    };
    Path3.prototype._calculateCurve = function() {
      var path = this.attr().path;
      this.set("curve", path_default3.pathToCurve(path));
    };
    Path3.prototype._setTcache = function() {
      var totalLength = 0;
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      var segmentN;
      var l;
      var curve = this.get("curve");
      if (!curve) {
        return;
      }
      each_default(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          totalLength += cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
        }
      });
      this.set("totalLength", totalLength);
      if (totalLength === 0) {
        this.set("tCache", []);
        return;
      }
      each_default(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
          tempLength += segmentL || 0;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Path3.prototype.getStartTangent = function() {
      var segments = this.getSegments();
      var result;
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    };
    Path3.prototype.getEndTangent = function() {
      var segments = this.getSegments();
      var length = segments.length;
      var result;
      if (length > 1) {
        var startPoint = segments[length - 2].currentPoint;
        var endPoint = segments[length - 1].currentPoint;
        var tangent = segments[length - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    };
    return Path3;
  }(base_default2)
);
var path_default2 = Path;

// node_modules/@antv/g-canvas/esm/shape/polygon.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js
function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];
    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last2 = points[count - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}

// node_modules/@antv/g-canvas/esm/shape/polygon.js
var Polygon = (
  /** @class */
  function(_super) {
    __extends(Polygon3, _super);
    function Polygon3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Polygon3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var points = this.attr().points;
      var isHit = false;
      if (isStroke) {
        isHit = inPolyline(points, lineWidth, x, y, true);
      }
      if (!isHit && isFill) {
        isHit = isInPolygon2(points, x, y);
      }
      return isHit;
    };
    Polygon3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var points = attrs.points;
      if (points.length < 2) {
        return;
      }
      context.beginPath();
      for (var i = 0; i < points.length; i++) {
        var point = points[i];
        if (i === 0) {
          context.moveTo(point[0], point[1]);
        } else {
          context.lineTo(point[0], point[1]);
        }
      }
      context.closePath();
    };
    return Polygon3;
  }(base_default2)
);
var polygon_default3 = Polygon;

// node_modules/@antv/g-canvas/esm/shape/polyline.js
init_tslib_es6();
init_esm();
var PolyLine = (
  /** @class */
  function(_super) {
    __extends(PolyLine2, _super);
    function PolyLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolyLine2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    PolyLine2.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    PolyLine2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      this.setArrow();
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    PolyLine2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    PolyLine2.prototype.setArrow = function() {
      var attrs = this.attr();
      var _a = this.attrs, points = _a.points, startArrow = _a.startArrow, endArrow = _a.endArrow;
      var length = points.length;
      var x1 = points[0][0];
      var y1 = points[0][1];
      var x2 = points[length - 1][0];
      var y2 = points[length - 1][1];
      if (startArrow) {
        addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, points[length - 2][0], points[length - 2][1], x2, y2);
      }
    };
    PolyLine2.prototype.isFill = function() {
      return false;
    };
    PolyLine2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var points = this.attr().points;
      return inPolyline(points, lineWidth, x, y, false);
    };
    PolyLine2.prototype.isStroke = function() {
      return true;
    };
    PolyLine2.prototype.createPath = function(context) {
      var _a = this.attr(), points = _a.points, startArrow = _a.startArrow, endArrow = _a.endArrow;
      var length = points.length;
      if (points.length < 2) {
        return;
      }
      var x1 = points[0][0];
      var y1 = points[0][1];
      var x2 = points[length - 1][0];
      var y2 = points[length - 1][1];
      if (startArrow && startArrow.d) {
        var distance3 = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
        x1 += distance3.dx;
        y1 += distance3.dy;
      }
      if (endArrow && endArrow.d) {
        var distance3 = getShortenOffset(points[length - 2][0], points[length - 2][1], x2, y2, endArrow.d);
        x2 -= distance3.dx;
        y2 -= distance3.dy;
      }
      context.beginPath();
      context.moveTo(x1, y1);
      for (var i = 0; i < length - 1; i++) {
        var point = points[i];
        context.lineTo(point[0], point[1]);
      }
      context.lineTo(x2, y2);
    };
    PolyLine2.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    PolyLine2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    PolyLine2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
    };
    PolyLine2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p, i) {
        if (points[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    PolyLine2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    PolyLine2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    };
    return PolyLine2;
  }(base_default2)
);
var polyline_default3 = PolyLine;

// node_modules/@antv/g-canvas/esm/shape/rect.js
init_tslib_es6();

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js
function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 右边
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 下边
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
}

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}

// node_modules/@antv/g-canvas/esm/shape/rect.js
var Rect = (
  /** @class */
  function(_super) {
    __extends(Rect3, _super);
    function Rect3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var minX = attrs.x;
      var minY = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        var halfWidth = lineWidth / 2;
        if (isFill && isStroke) {
          return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
        }
        if (isFill) {
          return inBox(minX, minY, width, height, x, y);
        }
        if (isStroke) {
          return inRect(minX, minY, width, height, lineWidth, x, y);
        }
      } else {
        var isHit = false;
        if (isStroke) {
          isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
        }
        if (!isHit && isFill) {
          isHit = isPointInPath(this, x, y);
        }
        return isHit;
      }
    };
    Rect3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      context.beginPath();
      if (radius === 0) {
        context.rect(x, y, width, height);
      } else {
        var _a = parseRadius(radius), r1 = _a[0], r2 = _a[1], r3 = _a[2], r4 = _a[3];
        context.moveTo(x + r1, y);
        context.lineTo(x + width - r2, y);
        r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
        context.lineTo(x + width, y + height - r3);
        r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
        context.lineTo(x + r4, y + height);
        r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
        context.lineTo(x, y + r1);
        r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
        context.closePath();
      }
    };
    return Rect3;
  }(base_default2)
);
var rect_default2 = Rect;

// node_modules/@antv/g-canvas/esm/shape/text.js
init_tslib_es6();
var Text = (
  /** @class */
  function(_super) {
    __extends(Text3, _super);
    function Text3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Text3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text3.prototype.isOnlyHitBox = function() {
      return true;
    };
    Text3.prototype.initAttrs = function(attrs) {
      this._assembleFont();
      if (attrs.text) {
        this._setText(attrs.text);
      }
    };
    Text3.prototype._assembleFont = function() {
      var attrs = this.attrs;
      attrs.font = assembleFont(attrs);
    };
    Text3.prototype._setText = function(text) {
      var textArr = null;
      if (is_string_default(text) && text.indexOf("\n") !== -1) {
        textArr = text.split("\n");
      }
      this.set("textArr", textArr);
    };
    Text3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name.startsWith("font")) {
        this._assembleFont();
      }
      if (name === "text") {
        this._setText(value);
      }
    };
    Text3.prototype._getSpaceingY = function() {
      var attrs = this.attrs;
      var lineHeight = attrs.lineHeight;
      var fontSize = attrs.fontSize * 1;
      return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    };
    Text3.prototype._drawTextArr = function(context, textArr, isFill) {
      var attrs = this.attrs;
      var textBaseline = attrs.textBaseline;
      var x = attrs.x;
      var y = attrs.y;
      var fontSize = attrs.fontSize * 1;
      var spaceingY = this._getSpaceingY();
      var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
      var subY;
      each_default(textArr, function(subText, index) {
        subY = y + index * (spaceingY + fontSize) - height + fontSize;
        if (textBaseline === "middle")
          subY += height - fontSize - (height - fontSize) / 2;
        if (textBaseline === "top")
          subY += height - fontSize;
        if (!is_nil_default(subText)) {
          if (isFill) {
            context.fillText(subText, x, subY);
          } else {
            context.strokeText(subText, x, subY);
          }
        }
      });
    };
    Text3.prototype._drawText = function(context, isFill) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var textArr = this.get("textArr");
      if (textArr) {
        this._drawTextArr(context, textArr, isFill);
      } else {
        var text = attrs.text;
        if (!is_nil_default(text)) {
          if (isFill) {
            context.fillText(text, x, y);
          } else {
            context.strokeText(text, x, y);
          }
        }
      }
    };
    Text3.prototype.strokeAndFill = function(context) {
      var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = opacity;
          }
          this.stroke(context);
        }
      }
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      this.afterDrawPath(context);
    };
    Text3.prototype.fill = function(context) {
      this._drawText(context, true);
    };
    Text3.prototype.stroke = function(context) {
      this._drawText(context, false);
    };
    return Text3;
  }(base_default2)
);
var text_default2 = Text;

// node_modules/@antv/g-canvas/esm/canvas.js
var Canvas2 = (
  /** @class */
  function(_super) {
    __extends(Canvas4, _super);
    function Canvas4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Canvas4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["renderer"] = "canvas";
      cfg["autoDraw"] = true;
      cfg["localRefresh"] = true;
      cfg["refreshElements"] = [];
      cfg["clipView"] = true;
      cfg["quickHit"] = false;
      return cfg;
    };
    Canvas4.prototype.onCanvasChange = function(changeType) {
      if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
        this.set("refreshElements", [this]);
        this.draw();
      }
    };
    Canvas4.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Canvas4.prototype.getGroupBase = function() {
      return group_default2;
    };
    Canvas4.prototype.getPixelRatio = function() {
      var pixelRatio = this.get("pixelRatio") || getPixelRatio();
      return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
    };
    Canvas4.prototype.getViewRange = function() {
      return {
        minX: 0,
        minY: 0,
        maxX: this.cfg.width,
        maxY: this.cfg.height
      };
    };
    Canvas4.prototype.createDom = function() {
      var element = document.createElement("canvas");
      var context = element.getContext("2d");
      this.set("context", context);
      return element;
    };
    Canvas4.prototype.setDOMSize = function(width, height) {
      _super.prototype.setDOMSize.call(this, width, height);
      var context = this.get("context");
      var el = this.get("el");
      var pixelRatio = this.getPixelRatio();
      el.width = pixelRatio * width;
      el.height = pixelRatio * height;
      if (pixelRatio > 1) {
        context.scale(pixelRatio, pixelRatio);
      }
    };
    Canvas4.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this._clearFrame();
      var context = this.get("context");
      var element = this.get("el");
      context.clearRect(0, 0, element.width, element.height);
    };
    Canvas4.prototype.getShape = function(x, y) {
      var shape;
      if (this.get("quickHit")) {
        shape = getShape(this, x, y);
      } else {
        shape = _super.prototype.getShape.call(this, x, y, null);
      }
      return shape;
    };
    Canvas4.prototype._getRefreshRegion = function() {
      var elements = this.get("refreshElements");
      var viewRegion = this.getViewRange();
      var region;
      if (elements.length && elements[0] === this) {
        region = viewRegion;
      } else {
        region = getMergedRegion(elements);
        if (region) {
          region.minX = Math.floor(region.minX);
          region.minY = Math.floor(region.minY);
          region.maxX = Math.ceil(region.maxX);
          region.maxY = Math.ceil(region.maxY);
          region.maxY += 1;
          var clipView = this.get("clipView");
          if (clipView) {
            region = mergeView(region, viewRegion);
          }
        }
      }
      return region;
    };
    Canvas4.prototype.refreshElement = function(element) {
      var refreshElements = this.get("refreshElements");
      refreshElements.push(element);
    };
    Canvas4.prototype._clearFrame = function() {
      var drawFrame = this.get("drawFrame");
      if (drawFrame) {
        cancelAnimationFrame(drawFrame);
        this.set("drawFrame", null);
        this.set("refreshElements", []);
      }
    };
    Canvas4.prototype.draw = function() {
      var drawFrame = this.get("drawFrame");
      if (this.get("autoDraw") && drawFrame) {
        return;
      }
      this._startDraw();
    };
    Canvas4.prototype._drawAll = function() {
      var context = this.get("context");
      var element = this.get("el");
      var children = this.getChildren();
      context.clearRect(0, 0, element.width, element.height);
      applyAttrsToContext(context, this);
      drawChildren(context, children);
      this.set("refreshElements", []);
    };
    Canvas4.prototype._drawRegion = function() {
      var context = this.get("context");
      var refreshElements = this.get("refreshElements");
      var children = this.getChildren();
      var region = this._getRefreshRegion();
      if (region) {
        context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.save();
        context.beginPath();
        context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.clip();
        applyAttrsToContext(context, this);
        checkRefresh(this, children, region);
        drawChildren(context, children, region);
        context.restore();
      } else if (refreshElements.length) {
        clearChanged(refreshElements);
      }
      each_default(refreshElements, function(element) {
        if (element.get("hasChanged")) {
          element.set("hasChanged", false);
        }
      });
      this.set("refreshElements", []);
    };
    Canvas4.prototype._startDraw = function() {
      var _this = this;
      var drawFrame = this.get("drawFrame");
      if (!drawFrame) {
        drawFrame = requestAnimationFrame(function() {
          if (_this.get("localRefresh")) {
            _this._drawRegion();
          } else {
            _this._drawAll();
          }
          _this.set("drawFrame", null);
        });
        this.set("drawFrame", drawFrame);
      }
    };
    Canvas4.prototype.skipDraw = function() {
    };
    Canvas4.prototype.removeDom = function() {
      var el = this.get("el");
      el.width = 0;
      el.height = 0;
      el.parentNode.removeChild(el);
    };
    return Canvas4;
  }(canvas_default)
);
var canvas_default2 = Canvas2;

// node_modules/@antv/g-canvas/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AbstractCanvas: () => canvas_default,
  AbstractGroup: () => group_default,
  AbstractShape: () => shape_default,
  Base: () => base_default,
  Canvas: () => canvas_default2,
  Event: () => graph_event_default,
  Group: () => group_default2,
  PathUtil: () => path_exports,
  Shape: () => shape_exports,
  assembleFont: () => assembleFont,
  getArcParams: () => getArcParams2,
  getBBoxMethod: () => getMethod,
  getOffScreenContext: () => getOffScreenContext,
  getTextHeight: () => getTextHeight,
  invert: () => invert,
  isAllowCapture: () => isAllowCapture,
  multiplyVec2: () => multiplyVec2,
  registerBBox: () => register,
  registerEasing: () => registerEasing,
  version: () => version
});
var version = "0.5.12";

// node_modules/@antv/g-svg/esm/canvas.js
init_tslib_es6();

// node_modules/@antv/g-svg/esm/constant.js
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};

// node_modules/@antv/g-svg/esm/util/dom.js
init_esm();
function createSVGElement(type) {
  return document.createElementNS("http://www.w3.org/2000/svg", type);
}
function createDom(shape) {
  var type = SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent) {
    var parentNode = parent.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent.createDom();
      parent.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = to_array_default(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(
    // 要求为元素节点，且不能为 defs 节点
    function(node) {
      return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
    }
  );
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  if (target) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

// node_modules/@antv/g-svg/esm/util/svg.js
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id = context.find("filter", cfg);
    if (!id) {
      id = context.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform3 = [];
    for (var i = 0; i < 9; i += 3) {
      transform3.push(matrix[i] + "," + matrix[i + 1]);
    }
    transform3 = transform3.join(",");
    if (transform3.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform3 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id + ")");
  }
}

// node_modules/@antv/g-svg/esm/util/draw.js
function drawChildren2(context, children) {
  children.forEach(function(child) {
    child.draw(context);
  });
}
function refreshElement2(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context);
    } else if (changeType === "attr") {
    } else if (changeType === "add") {
      element.draw(context);
    }
  }
}

// node_modules/@antv/g-svg/esm/shape/index.js
var shape_exports2 = {};
__export(shape_exports2, {
  Base: () => base_default3,
  Circle: () => circle_default3,
  Dom: () => dom_default,
  Ellipse: () => ellipse_default4,
  Image: () => image_default2,
  Line: () => line_default4,
  Marker: () => marker_default2,
  Path: () => path_default4,
  Polygon: () => polygon_default4,
  Polyline: () => polyline_default4,
  Rect: () => rect_default3,
  Text: () => text_default3
});

// node_modules/@antv/g-svg/esm/shape/base.js
init_tslib_es6();

// node_modules/@antv/g-svg/esm/group.js
init_tslib_es6();
init_esm();
var Group2 = (
  /** @class */
  function(_super) {
    __extends(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.isEntityGroup = function() {
      return true;
    };
    Group3.prototype.createDom = function() {
      var element = createSVGElement("g");
      this.set("el", element);
      var parent = this.getParent();
      if (parent) {
        var parentNode = parent.get("el");
        if (parentNode) {
          parentNode.appendChild(element);
        } else {
          parentNode = parent.createDom();
          parent.set("el", parentNode);
          parentNode.appendChild(element);
        }
      }
      return element;
    };
    Group3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.createPath(context, targetAttrs);
      }
    };
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype.draw = function(context) {
      var children = this.getChildren();
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          this.createDom();
        }
        setClip(this, context);
        this.createPath(context);
        if (children.length) {
          drawChildren2(context, children);
        }
      }
    };
    Group3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      setTransform(this);
    };
    return Group3;
  }(group_default)
);
var group_default3 = Group2;

// node_modules/@antv/g-svg/esm/shape/base.js
var ShapeBase2 = (
  /** @class */
  function(_super) {
    __extends(ShapeBase3, _super);
    function ShapeBase3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "svg";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    ShapeBase3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.draw(context, targetAttrs);
      }
    };
    ShapeBase3.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    ShapeBase3.prototype.getGroupBase = function() {
      return group_default3;
    };
    ShapeBase3.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    ShapeBase3.prototype.calculateBBox = function() {
      var el = this.get("el");
      var bbox = null;
      if (el) {
        bbox = el.getBBox();
      } else {
        var bboxMethod = getMethod(this.get("type"));
        if (bboxMethod) {
          bbox = bboxMethod(this);
        }
      }
      if (bbox) {
        var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2;
        var minX = x - halfWidth;
        var minY = y - halfWidth;
        var maxX = x + width + halfWidth;
        var maxY = y + height + halfWidth;
        return {
          x: minX,
          y: minY,
          minX,
          minY,
          maxX,
          maxY,
          width: width + lineWidth,
          height: height + lineWidth
        };
      }
      return {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
    };
    ShapeBase3.prototype.isFill = function() {
      var _a = this.attr(), fill = _a.fill, fillStyle = _a.fillStyle;
      return (fill || fillStyle || this.isClipShape()) && this.canFill;
    };
    ShapeBase3.prototype.isStroke = function() {
      var _a = this.attr(), stroke = _a.stroke, strokeStyle = _a.strokeStyle;
      return (stroke || strokeStyle) && this.canStroke;
    };
    ShapeBase3.prototype.draw = function(context, targetAttrs) {
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          createDom(this);
        }
        setClip(this, context);
        this.createPath(context, targetAttrs);
        this.shadow(context, targetAttrs);
        this.strokeAndFill(context, targetAttrs);
        this.transform(targetAttrs);
      }
    };
    ShapeBase3.prototype.createPath = function(context, targetAttrs) {
    };
    ShapeBase3.prototype.strokeAndFill = function(context, targetAttrs) {
      var attrs = targetAttrs || this.attr();
      var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
      var el = this.get("el");
      if (this.canFill) {
        if (!targetAttrs) {
          this._setColor(context, "fill", fill || fillStyle);
        } else if ("fill" in attrs) {
          this._setColor(context, "fill", fill);
        } else if ("fillStyle" in attrs) {
          this._setColor(context, "fill", fillStyle);
        }
        if (fillOpacity) {
          el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
        }
      }
      if (this.canStroke && lineWidth > 0) {
        if (!targetAttrs) {
          this._setColor(context, "stroke", stroke || strokeStyle);
        } else if ("stroke" in attrs) {
          this._setColor(context, "stroke", stroke);
        } else if ("strokeStyle" in attrs) {
          this._setColor(context, "stroke", strokeStyle);
        }
        if (strokeOpacity) {
          el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
        }
        if (lineWidth) {
          el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
        }
      }
    };
    ShapeBase3.prototype._setColor = function(context, attr, value) {
      var el = this.get("el");
      if (!value) {
        el.setAttribute(SVG_ATTR_MAP[attr], "none");
        return;
      }
      value = value.trim();
      if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
        var id = context.find("gradient", value);
        if (!id) {
          id = context.addGradient(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
        var id = context.find("pattern", value);
        if (!id) {
          id = context.addPattern(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    };
    ShapeBase3.prototype.shadow = function(context, targetAttrs) {
      var attrs = this.attr();
      var _a = targetAttrs || attrs, shadowOffsetX = _a.shadowOffsetX, shadowOffsetY = _a.shadowOffsetY, shadowBlur = _a.shadowBlur, shadowColor = _a.shadowColor;
      if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
        setShadow(this, context);
      }
    };
    ShapeBase3.prototype.transform = function(targetAttrs) {
      var attrs = this.attr();
      var matrix = (targetAttrs || attrs).matrix;
      if (matrix) {
        setTransform(this);
      }
    };
    ShapeBase3.prototype.isInShape = function(refX, refY) {
      return this.isPointInPath(refX, refY);
    };
    ShapeBase3.prototype.isPointInPath = function(refX, refY) {
      var el = this.get("el");
      var canvas = this.get("canvas");
      var bbox = canvas.get("el").getBoundingClientRect();
      var clientX = refX + bbox.left;
      var clientY = refY + bbox.top;
      var element = document.elementFromPoint(clientX, clientY);
      if (element && element.isEqualNode(el)) {
        return true;
      }
      return false;
    };
    ShapeBase3.prototype.getHitLineWidth = function() {
      var _a = this.attrs, lineWidth = _a.lineWidth, lineAppendWidth = _a.lineAppendWidth;
      if (this.isStroke()) {
        return lineWidth + lineAppendWidth;
      }
      return 0;
    };
    return ShapeBase3;
  }(shape_default)
);
var base_default3 = ShapeBase2;

// node_modules/@antv/g-svg/esm/shape/circle.js
init_tslib_es6();
init_esm();
var Circle2 = (
  /** @class */
  function(_super) {
    __extends(Circle3, _super);
    function Circle3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "circle";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Circle3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Circle3;
  }(base_default3)
);
var circle_default3 = Circle2;

// node_modules/@antv/g-svg/esm/shape/dom.js
init_tslib_es6();
init_esm();
var Dom = (
  /** @class */
  function(_super) {
    __extends(Dom2, _super);
    function Dom2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dom";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Dom2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      if (typeof attrs["html"] === "function") {
        var element = attrs["html"].call(this, attrs);
        if (element instanceof Element || element instanceof HTMLDocument) {
          var children = el.childNodes;
          for (var i = children.length - 1; i >= 0; i--) {
            el.removeChild(children[i]);
          }
          el.appendChild(element);
        } else {
          el.innerHTML = element;
        }
      } else {
        el.innerHTML = attrs["html"];
      }
    };
    return Dom2;
  }(base_default3)
);
var dom_default = Dom;

// node_modules/@antv/g-svg/esm/shape/ellipse.js
init_tslib_es6();
init_esm();
var Ellipse2 = (
  /** @class */
  function(_super) {
    __extends(Ellipse3, _super);
    function Ellipse3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ellipse";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Ellipse3;
  }(base_default3)
);
var ellipse_default4 = Ellipse2;

// node_modules/@antv/g-svg/esm/shape/image.js
init_tslib_es6();
init_esm();
var Image2 = (
  /** @class */
  function(_super) {
    __extends(Image3, _super);
    function Image3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "image";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Image3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    Image3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "img") {
          _this._setImage(attrs.img);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Image3.prototype.setAttr = function(name, value) {
      this.attrs[name] = value;
      if (name === "img") {
        this._setImage(value);
      }
    };
    Image3.prototype._setImage = function(img) {
      var attrs = this.attr();
      var el = this.get("el");
      if (is_string_default(img)) {
        el.setAttribute("href", img);
      } else if (img instanceof window.Image) {
        if (!attrs.width) {
          el.setAttribute("width", img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", img.src);
      } else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
        el.setAttribute("href", img.toDataURL());
      } else if (img instanceof ImageData) {
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width", "" + img.width);
        canvas.setAttribute("height", "" + img.height);
        canvas.getContext("2d").putImageData(img, 0, 0);
        if (!attrs.width) {
          el.setAttribute("width", "" + img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", "" + img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", canvas.toDataURL());
      }
    };
    return Image3;
  }(base_default3)
);
var image_default2 = Image2;

// node_modules/@antv/g-svg/esm/shape/line.js
init_tslib_es6();
init_esm();
var Line2 = (
  /** @class */
  function(_super) {
    __extends(Line3, _super);
    function Line3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      _this.canFill = false;
      _this.canStroke = true;
      return _this;
    }
    Line3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Line3.prototype.getTotalLength = function() {
      var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
      return line_default.length(x1, y1, x2, y2);
    };
    Line3.prototype.getPoint = function(ratio) {
      var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
      return line_default.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line3;
  }(base_default3)
);
var line_default4 = Line2;

// node_modules/@antv/g-svg/esm/shape/marker/index.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g-svg/esm/shape/marker/symbols.js
var Symbols2 = {
  // 圆
  circle: function(x, y, r) {
    return [
      ["M", x, y],
      ["m", -r, 0],
      ["a", r, r, 0, 1, 0, r * 2, 0],
      ["a", r, r, 0, 1, 0, -r * 2, 0]
    ];
  },
  // 正方形
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  // 菱形
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  // 三角形
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["z"]];
  },
  // 倒三角形
  triangleDown: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var symbols_default = {
  get: function(type) {
    return Symbols2[type];
  },
  register: function(type, func) {
    Symbols2[type] = func;
  },
  remove: function(type) {
    delete Symbols2[type];
  },
  getAll: function() {
    return Symbols2;
  }
};

// node_modules/@antv/g-svg/esm/shape/marker/index.js
var Marker2 = (
  /** @class */
  function(_super) {
    __extends(Marker3, _super);
    function Marker3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "marker";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Marker3.prototype.createPath = function(context) {
      var el = this.get("el");
      el.setAttribute("d", this._assembleMarker());
    };
    Marker3.prototype._assembleMarker = function() {
      var d = this._getPath();
      if (is_array_default(d)) {
        return d.map(function(path) {
          return path.join(" ");
        }).join("");
      }
      return d;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var r = attrs.r || attrs.radius;
      var symbol = attrs.symbol || "circle";
      var method;
      if (is_function_default(symbol)) {
        method = symbol;
      } else {
        method = symbols_default.get(symbol);
      }
      if (!method) {
        console.warn(method + " symbol is not exist.");
        return null;
      }
      return method(x, y, r);
    };
    Marker3.symbolsFactory = symbols_default;
    return Marker3;
  }(base_default3)
);
var marker_default2 = Marker2;

// node_modules/@antv/g-svg/esm/shape/path.js
init_tslib_es6();
init_esm();
var Path2 = (
  /** @class */
  function(_super) {
    __extends(Path3, _super);
    function Path3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "path";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Path3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    Path3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "path" && is_array_default(value)) {
          el.setAttribute("d", _this._formatPath(value));
        } else if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Path3.prototype._formatPath = function(value) {
      var newValue = value.map(function(path) {
        return path.join(" ");
      }).join("");
      if (~newValue.indexOf("NaN")) {
        return "";
      }
      return newValue;
    };
    Path3.prototype.getTotalLength = function() {
      var el = this.get("el");
      return el ? el.getTotalLength() : null;
    };
    Path3.prototype.getPoint = function(ratio) {
      var el = this.get("el");
      var totalLength = this.getTotalLength();
      if (totalLength === 0) {
        return null;
      }
      var point = el ? el.getPointAtLength(ratio * totalLength) : null;
      return point ? {
        x: point.x,
        y: point.y
      } : null;
    };
    return Path3;
  }(base_default3)
);
var path_default4 = Path2;

// node_modules/@antv/g-svg/esm/shape/polygon.js
init_tslib_es6();
init_esm();
var Polygon2 = (
  /** @class */
  function(_super) {
    __extends(Polygon3, _super);
    function Polygon3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polygon3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point) {
            return point[0] + "," + point[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Polygon3;
  }(base_default3)
);
var polygon_default4 = Polygon2;

// node_modules/@antv/g-svg/esm/shape/polyline.js
init_tslib_es6();
init_esm();
var Polyline = (
  /** @class */
  function(_super) {
    __extends(Polyline2, _super);
    function Polyline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polyline";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polyline2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    Polyline2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    Polyline2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    Polyline2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point) {
            return point[0] + "," + point[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Polyline2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    Polyline2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
    };
    Polyline2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p, i) {
        if (points[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Polyline2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    Polyline2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    };
    return Polyline2;
  }(base_default3)
);
var polyline_default4 = Polyline;

// node_modules/@antv/g-svg/esm/shape/rect.js
init_tslib_es6();
init_esm();

// node_modules/@antv/g-svg/esm/util/format.js
init_esm();
function parseRadius2(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}

// node_modules/@antv/g-svg/esm/shape/rect.js
var Rect2 = (
  /** @class */
  function(_super) {
    __extends(Rect3, _super);
    function Rect3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rect";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Rect3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      var completed = false;
      var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
      each_default(targetAttrs || attrs, function(value, attr) {
        if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
          el.setAttribute("d", _this._assembleRect(attrs));
          completed = true;
        } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Rect3.prototype._assembleRect = function(attrs) {
      var x = attrs.x;
      var y = attrs.y;
      var w = attrs.width;
      var h = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
      }
      var r = parseRadius2(radius);
      if (is_array_default(radius)) {
        if (radius.length === 1) {
          r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
        } else if (radius.length === 2) {
          r.r1 = r.r3 = radius[0];
          r.r2 = r.r4 = radius[1];
        } else if (radius.length === 3) {
          r.r1 = radius[0];
          r.r2 = r.r4 = radius[1];
          r.r3 = radius[2];
        } else {
          r.r1 = radius[0];
          r.r2 = radius[1];
          r.r3 = radius[2];
          r.r4 = radius[3];
        }
      } else {
        r.r1 = r.r2 = r.r3 = r.r4 = radius;
      }
      var d = [
        ["M " + (x + r.r1) + "," + y],
        ["l " + (w - r.r1 - r.r2) + ",0"],
        ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
        ["l 0," + (h - r.r2 - r.r3)],
        ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
        ["l " + (r.r3 + r.r4 - w) + ",0"],
        ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
        ["l 0," + (r.r4 + r.r1 - h)],
        ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
        ["z"]
      ];
      return d.join(" ");
    };
    return Rect3;
  }(base_default3)
);
var rect_default3 = Rect2;

// node_modules/@antv/g-svg/esm/shape/text.js
init_tslib_es6();
init_esm();
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text2 = (
  /** @class */
  function(_super) {
    __extends(Text3, _super);
    function Text3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "text";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Text3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      this._setFont();
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "text") {
          _this._setText("" + value);
        } else if (attr === "matrix" && value) {
          setTransform(_this);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      el.setAttribute("paint-order", "stroke");
      el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
    };
    Text3.prototype._setFont = function() {
      var el = this.get("el");
      var _a = this.attr(), textBaseline = _a.textBaseline, textAlign = _a.textAlign;
      var browser2 = detect();
      if (browser2 && browser2.name === "firefox") {
        el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
      } else {
        el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
      }
      el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
    };
    Text3.prototype._setText = function(text) {
      var el = this.get("el");
      var _a = this.attr(), x = _a.x, _b = _a.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
      if (!text) {
        el.innerHTML = "";
      } else if (~text.indexOf("\n")) {
        var textArr = text.split("\n");
        var textLen_1 = textArr.length - 1;
        var arr_1 = "";
        each_default(textArr, function(segment, i) {
          if (i === 0) {
            if (baseline === "alphabetic") {
              arr_1 += '<tspan x="' + x + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
            } else if (baseline === "top") {
              arr_1 += '<tspan x="' + x + '" dy="0.9em">' + segment + "</tspan>";
            } else if (baseline === "middle") {
              arr_1 += '<tspan x="' + x + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
            } else if (baseline === "bottom") {
              arr_1 += '<tspan x="' + x + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
            } else if (baseline === "hanging") {
              arr_1 += '<tspan x="' + x + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
            }
          } else {
            arr_1 += '<tspan x="' + x + '" dy="1em">' + segment + "</tspan>";
          }
        });
        el.innerHTML = arr_1;
      } else {
        el.innerHTML = text;
      }
    };
    return Text3;
  }(base_default3)
);
var text_default3 = Text2;

// node_modules/@antv/g-svg/esm/defs/index.js
init_esm();

// node_modules/@antv/g-svg/esm/defs/gradient.js
init_esm();
var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop2 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop2(steps) {
  var arr = steps.match(regexColorStop2);
  if (!arr) {
    return "";
  }
  var stops = "";
  arr.sort(function(a, b) {
    a = a.split(":");
    b = b.split(":");
    return Number(a[0]) - Number(b[0]);
  });
  each_default(arr, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient2(color2, el) {
  var arr = regexLG2.exec(color2);
  var angle = mod_default(to_radian_default(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;
  if (angle >= 0 && angle < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x);
  el.setAttribute("y2", y);
  el.innerHTML = addStop2(steps);
}
function parseRadialGradient2(color2, self) {
  var arr = regexRG2.exec(color2);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r = parseFloat(arr[3]);
  var steps = arr[4];
  self.setAttribute("cx", cx);
  self.setAttribute("cy", cy);
  self.setAttribute("r", r);
  self.innerHTML = addStop2(steps);
}
var Gradient = (
  /** @class */
  function() {
    function Gradient2(cfg) {
      this.cfg = {};
      var el = null;
      var id = unique_id_default("gradient_");
      if (cfg.toLowerCase()[0] === "l") {
        el = createSVGElement("linearGradient");
        parseLineGradient2(cfg, el);
      } else {
        el = createSVGElement("radialGradient");
        parseRadialGradient2(cfg, el);
      }
      el.setAttribute("id", id);
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      return this;
    }
    Gradient2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Gradient2;
  }()
);
var gradient_default = Gradient;

// node_modules/@antv/g-svg/esm/defs/shadow.js
init_esm();
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = (
  /** @class */
  function() {
    function Shadow2(cfg) {
      this.type = "filter";
      this.cfg = {};
      this.type = "filter";
      var el = createSVGElement("filter");
      each_default(SHADOW_DIMENSION, function(v, k) {
        el.setAttribute(k, v);
      });
      this.el = el;
      this.id = unique_id_default("filter_");
      this.el.id = this.id;
      this.cfg = cfg;
      this._parseShadow(cfg, el);
      return this;
    }
    Shadow2.prototype.match = function(type, cfg) {
      if (this.type !== type) {
        return false;
      }
      var flag = true;
      var config = this.cfg;
      each_default(Object.keys(config), function(attr) {
        if (config[attr] !== cfg[attr]) {
          flag = false;
          return false;
        }
      });
      return flag;
    };
    Shadow2.prototype.update = function(name, value) {
      var config = this.cfg;
      config[ATTR_MAP[name]] = value;
      this._parseShadow(config, this.el);
      return this;
    };
    Shadow2.prototype._parseShadow = function(config, el) {
      var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
      el.innerHTML = child;
    };
    return Shadow2;
  }()
);
var shadow_default = Shadow;

// node_modules/@antv/g-svg/esm/defs/arrow.js
init_esm();
var Arrow = (
  /** @class */
  function() {
    function Arrow2(attrs, type) {
      this.cfg = {};
      var el = createSVGElement("marker");
      var id = unique_id_default("marker_");
      el.setAttribute("id", id);
      var shape = createSVGElement("path");
      shape.setAttribute("stroke", attrs.stroke || "none");
      shape.setAttribute("fill", attrs.fill || "none");
      el.appendChild(shape);
      el.setAttribute("overflow", "visible");
      el.setAttribute("orient", "auto-start-reverse");
      this.el = el;
      this.child = shape;
      this.id = id;
      var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
      this.stroke = attrs.stroke || "#000";
      if (cfg === true) {
        this._setDefaultPath(type, shape);
      } else {
        this.cfg = cfg;
        this._setMarker(attrs.lineWidth, shape);
      }
      return this;
    }
    Arrow2.prototype.match = function() {
      return false;
    };
    Arrow2.prototype._setDefaultPath = function(type, el) {
      var parent = this.el;
      el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
      parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
      parent.setAttribute("refY", "" + 5);
    };
    Arrow2.prototype._setMarker = function(r, el) {
      var parent = this.el;
      var path = this.cfg.path;
      var d = this.cfg.d;
      if (is_array_default(path)) {
        path = path.map(function(segment) {
          return segment.join(" ");
        }).join("");
      }
      el.setAttribute("d", path);
      parent.appendChild(el);
      if (d) {
        parent.setAttribute("refX", "" + d / r);
      }
    };
    Arrow2.prototype.update = function(fill) {
      var child = this.child;
      if (child.attr) {
        child.attr("fill", fill);
      } else {
        child.setAttribute("fill", fill);
      }
    };
    return Arrow2;
  }()
);
var arrow_default = Arrow;

// node_modules/@antv/g-svg/esm/defs/clip.js
init_esm();
var Clip = (
  /** @class */
  function() {
    function Clip2(cfg) {
      this.type = "clip";
      this.cfg = {};
      var el = createSVGElement("clipPath");
      this.el = el;
      this.id = unique_id_default("clip_");
      el.id = this.id;
      var shapeEl = cfg.cfg.el;
      el.appendChild(shapeEl);
      this.cfg = cfg;
      return this;
    }
    Clip2.prototype.match = function() {
      return false;
    };
    Clip2.prototype.remove = function() {
      var el = this.el;
      el.parentNode.removeChild(el);
    };
    return Clip2;
  }()
);
var clip_default = Clip;

// node_modules/@antv/g-svg/esm/defs/pattern.js
init_esm();
var regexPR2 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = (
  /** @class */
  function() {
    function Pattern2(cfg) {
      this.cfg = {};
      var el = createSVGElement("pattern");
      el.setAttribute("patternUnits", "userSpaceOnUse");
      var child = createSVGElement("image");
      el.appendChild(child);
      var id = unique_id_default("pattern_");
      el.id = id;
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      var arr = regexPR2.exec(cfg);
      var source = arr[2];
      child.setAttribute("href", source);
      var img = new Image();
      if (!source.match(/^data:/i)) {
        img.crossOrigin = "Anonymous";
      }
      img.src = source;
      function onload() {
        el.setAttribute("width", "" + img.width);
        el.setAttribute("height", "" + img.height);
      }
      if (img.complete) {
        onload();
      } else {
        img.onload = onload;
        img.src = img.src;
      }
      return this;
    }
    Pattern2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Pattern2;
  }()
);
var pattern_default = Pattern;

// node_modules/@antv/g-svg/esm/defs/index.js
var Defs = (
  /** @class */
  function() {
    function Defs2(canvas) {
      var el = createSVGElement("defs");
      var id = unique_id_default("defs_");
      el.id = id;
      canvas.appendChild(el);
      this.children = [];
      this.defaultArrow = {};
      this.el = el;
      this.canvas = canvas;
    }
    Defs2.prototype.find = function(type, attr) {
      var children = this.children;
      var result = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].match(type, attr)) {
          result = children[i].id;
          break;
        }
      }
      return result;
    };
    Defs2.prototype.findById = function(id) {
      var children = this.children;
      var flag = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].id === id) {
          flag = children[i];
          break;
        }
      }
      return flag;
    };
    Defs2.prototype.add = function(item) {
      this.children.push(item);
      item.canvas = this.canvas;
      item.parent = this;
    };
    Defs2.prototype.getDefaultArrow = function(attrs, name) {
      var stroke = attrs.stroke || attrs.strokeStyle;
      if (this.defaultArrow[stroke]) {
        return this.defaultArrow[stroke].id;
      }
      var arrow = new arrow_default(attrs, name);
      this.defaultArrow[stroke] = arrow;
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addGradient = function(cfg) {
      var gradient = new gradient_default(cfg);
      this.el.appendChild(gradient.el);
      this.add(gradient);
      return gradient.id;
    };
    Defs2.prototype.addArrow = function(attrs, name) {
      var arrow = new arrow_default(attrs, name);
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addShadow = function(cfg) {
      var shadow = new shadow_default(cfg);
      this.el.appendChild(shadow.el);
      this.add(shadow);
      return shadow.id;
    };
    Defs2.prototype.addPattern = function(cfg) {
      var pattern = new pattern_default(cfg);
      this.el.appendChild(pattern.el);
      this.add(pattern);
      return pattern.id;
    };
    Defs2.prototype.addClip = function(cfg) {
      var clip = new clip_default(cfg);
      this.el.appendChild(clip.el);
      this.add(clip);
      return clip.id;
    };
    return Defs2;
  }()
);
var defs_default = Defs;

// node_modules/@antv/g-svg/esm/canvas.js
var Canvas3 = (
  /** @class */
  function(_super) {
    __extends(Canvas4, _super);
    function Canvas4(cfg) {
      return _super.call(this, __assign(__assign({}, cfg), {
        autoDraw: true,
        // 设置渲染引擎为 canvas，只读属性
        renderer: "svg"
      })) || this;
    }
    Canvas4.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Canvas4.prototype.getGroupBase = function() {
      return group_default3;
    };
    Canvas4.prototype.getShape = function(x, y, ev) {
      var target = ev.target || ev.srcElement;
      if (!SHAPE_TO_TAGS[target.tagName]) {
        var parent_1 = target.parentNode;
        while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
          parent_1 = parent_1.parentNode;
        }
        target = parent_1;
      }
      return this.find(function(child) {
        return child.get("el") === target;
      });
    };
    Canvas4.prototype.createDom = function() {
      var element = createSVGElement("svg");
      var context = new defs_default(element);
      element.setAttribute("width", "" + this.get("width"));
      element.setAttribute("height", "" + this.get("height"));
      this.set("context", context);
      return element;
    };
    Canvas4.prototype.onCanvasChange = function(changeType) {
      var context = this.get("context");
      var el = this.get("el");
      if (changeType === "sort") {
        var children_1 = this.get("children");
        if (children_1 && children_1.length) {
          sortDom(this, function(a, b) {
            return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
          var defsEl = context.el;
          defsEl.innerHTML = "";
          el.appendChild(defsEl);
        }
      } else if (changeType === "matrix") {
        setTransform(this);
      } else if (changeType === "clip") {
        setClip(this, context);
      } else if (changeType === "changeSize") {
        el.setAttribute("width", "" + this.get("width"));
        el.setAttribute("height", "" + this.get("height"));
      }
    };
    Canvas4.prototype.draw = function() {
      var context = this.get("context");
      var children = this.getChildren();
      setClip(this, context);
      if (children.length) {
        drawChildren2(context, children);
      }
    };
    return Canvas4;
  }(canvas_default)
);
var canvas_default3 = Canvas3;

// node_modules/@antv/g-svg/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  AbstractCanvas: () => canvas_default,
  AbstractGroup: () => group_default,
  AbstractShape: () => shape_default,
  Base: () => base_default,
  Canvas: () => canvas_default3,
  Event: () => graph_event_default,
  Group: () => group_default3,
  PathUtil: () => path_exports,
  Shape: () => shape_exports2,
  assembleFont: () => assembleFont,
  getBBoxMethod: () => getMethod,
  getOffScreenContext: () => getOffScreenContext,
  getTextHeight: () => getTextHeight,
  invert: () => invert,
  isAllowCapture: () => isAllowCapture,
  multiplyVec2: () => multiplyVec2,
  registerBBox: () => register,
  registerEasing: () => registerEasing,
  version: () => version2
});
var version2 = "0.5.6";

// node_modules/@antv/dom-util/esm/create-dom.js
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
  TABLE = document.createElement("table");
  TABLE_TR = document.createElement("tr");
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement("tbody"),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    "*": document.createElement("div")
  };
}
function createDom2(str) {
  if (!TABLE) {
    initConstants();
  }
  var name = FRAGMENT_REG.test(str) && RegExp.$1;
  if (!name || !(name in CONTAINERS)) {
    name = "*";
  }
  var container = CONTAINERS[name];
  str = typeof str === "string" ? str.replace(/(^\s*)|(\s*$)/g, "") : str;
  container.innerHTML = "" + str;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}

// node_modules/@antv/dom-util/esm/add-event-listener.js
function addEventListener(target, eventType, callback) {
  if (target) {
    if (typeof target.addEventListener === "function") {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    }
    if (typeof target.attachEvent === "function") {
      target.attachEvent("on" + eventType, callback);
      return {
        remove: function() {
          target.detachEvent("on" + eventType, callback);
        }
      };
    }
  }
}

// node_modules/@antv/dom-util/esm/get-style.js
function getStyle(dom, name, defaultValue) {
  var v;
  try {
    v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
  } catch (e) {
  } finally {
    v = v === void 0 ? defaultValue : v;
  }
  return v;
}

// node_modules/@antv/dom-util/esm/get-height.js
function getHeight(el, defaultValue) {
  var height = getStyle(el, "height", defaultValue);
  if (height === "auto") {
    height = el.offsetHeight;
  }
  return parseFloat(height);
}

// node_modules/@antv/dom-util/esm/get-outer-height.js
function getOuterHeight(el, defaultValue) {
  var height = getHeight(el, defaultValue);
  var bTop = parseFloat(getStyle(el, "borderTopWidth")) || 0;
  var pTop = parseFloat(getStyle(el, "paddingTop")) || 0;
  var pBottom = parseFloat(getStyle(el, "paddingBottom")) || 0;
  var bBottom = parseFloat(getStyle(el, "borderBottomWidth")) || 0;
  var mTop = parseFloat(getStyle(el, "marginTop")) || 0;
  var mBottom = parseFloat(getStyle(el, "marginBottom")) || 0;
  return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}

// node_modules/@antv/dom-util/esm/get-width.js
function getHeight2(el, defaultValue) {
  var width = getStyle(el, "width", defaultValue);
  if (width === "auto") {
    width = el.offsetWidth;
  }
  return parseFloat(width);
}

// node_modules/@antv/dom-util/esm/get-outer-width.js
function getOuterWidth(el, defaultValue) {
  var width = getHeight2(el, defaultValue);
  var bLeft = parseFloat(getStyle(el, "borderLeftWidth")) || 0;
  var pLeft = parseFloat(getStyle(el, "paddingLeft")) || 0;
  var pRight = parseFloat(getStyle(el, "paddingRight")) || 0;
  var bRight = parseFloat(getStyle(el, "borderRightWidth")) || 0;
  var mRight = parseFloat(getStyle(el, "marginRight")) || 0;
  var mLeft = parseFloat(getStyle(el, "marginLeft")) || 0;
  return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}

// node_modules/@antv/dom-util/esm/modify-css.js
function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }
  return dom;
}

// node_modules/@antv/scale/esm/base.js
init_esm();

// node_modules/@antv/scale/esm/tick-method/register.js
var methodCache = {};
function getTickMethod(key) {
  return methodCache[key];
}
function registerTickMethod(key, method) {
  methodCache[key] = method;
}

// node_modules/@antv/scale/esm/base.js
var Scale = (
  /** @class */
  function() {
    function Scale2(cfg) {
      this.type = "base";
      this.isCategory = false;
      this.isLinear = false;
      this.isContinuous = false;
      this.isIdentity = false;
      this.values = [];
      this.range = [0, 1];
      this.ticks = [];
      this.__cfg__ = cfg;
      this.initCfg();
      this.init();
    }
    Scale2.prototype.translate = function(v) {
      return v;
    };
    Scale2.prototype.change = function(cfg) {
      mix(this.__cfg__, cfg);
      this.init();
    };
    Scale2.prototype.clone = function() {
      return this.constructor(this.__cfg__);
    };
    Scale2.prototype.getTicks = function() {
      var _this = this;
      return map_default(this.ticks, function(tick, idx) {
        if (is_object_default(tick)) {
          return tick;
        }
        return {
          text: _this.getText(tick, idx),
          tickValue: tick,
          value: _this.scale(tick)
        };
      });
    };
    Scale2.prototype.getText = function(value, key) {
      var formatter = this.formatter;
      var res = formatter ? formatter(value, key) : value;
      if (is_nil_default(res) || !is_function_default(res.toString)) {
        return "";
      }
      return res.toString();
    };
    Scale2.prototype.getConfig = function(key) {
      return this.__cfg__[key];
    };
    Scale2.prototype.init = function() {
      mix(this, this.__cfg__);
      this.setDomain();
      if (is_empty_default(this.getConfig("ticks"))) {
        this.ticks = this.calculateTicks();
      }
    };
    Scale2.prototype.initCfg = function() {
    };
    Scale2.prototype.setDomain = function() {
    };
    Scale2.prototype.calculateTicks = function() {
      var tickMethod = this.tickMethod;
      var ticks = [];
      if (is_string_default(tickMethod)) {
        var method = getTickMethod(tickMethod);
        if (!method) {
          throw new Error("There is no method to to calculate ticks!");
        }
        ticks = method(this);
      } else if (is_function_default(tickMethod)) {
        ticks = tickMethod(this);
      }
      return ticks;
    };
    Scale2.prototype.rangeMin = function() {
      return this.range[0];
    };
    Scale2.prototype.rangeMax = function() {
      return this.range[1];
    };
    Scale2.prototype.calcPercent = function(value, min, max) {
      if (is_number_default(value)) {
        return (value - min) / (max - min);
      }
      return NaN;
    };
    Scale2.prototype.calcValue = function(percent, min, max) {
      return min + percent * (max - min);
    };
    return Scale2;
  }()
);
var base_default4 = Scale;

// node_modules/@antv/scale/esm/category/base.js
init_tslib_es6();
init_esm();
var Category = (
  /** @class */
  function(_super) {
    __extends(Category2, _super);
    function Category2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "cat";
      _this.isCategory = true;
      return _this;
    }
    Category2.prototype.buildIndexMap = function() {
      if (!this.translateIndexMap) {
        this.translateIndexMap = /* @__PURE__ */ new Map();
        for (var i = 0; i < this.values.length; i++) {
          this.translateIndexMap.set(this.values[i], i);
        }
      }
    };
    Category2.prototype.translate = function(value) {
      this.buildIndexMap();
      var idx = this.translateIndexMap.get(value);
      if (idx === void 0) {
        idx = is_number_default(value) ? value : NaN;
      }
      return idx;
    };
    Category2.prototype.scale = function(value) {
      var order = this.translate(value);
      var percent = this.calcPercent(order, this.min, this.max);
      return this.calcValue(percent, this.rangeMin(), this.rangeMax());
    };
    Category2.prototype.invert = function(scaledValue) {
      var domainRange = this.max - this.min;
      var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
      var idx = Math.round(domainRange * percent) + this.min;
      if (idx < this.min || idx > this.max) {
        return NaN;
      }
      return this.values[idx];
    };
    Category2.prototype.getText = function(value) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var v = value;
      if (is_number_default(value) && !this.values.includes(value)) {
        v = this.values[v];
      }
      return _super.prototype.getText.apply(this, __spreadArrays([v], args));
    };
    Category2.prototype.initCfg = function() {
      this.tickMethod = "cat";
    };
    Category2.prototype.setDomain = function() {
      if (is_nil_default(this.getConfig("min"))) {
        this.min = 0;
      }
      if (is_nil_default(this.getConfig("max"))) {
        var size2 = this.values.length;
        this.max = size2 > 1 ? size2 - 1 : size2;
      }
      if (this.translateIndexMap) {
        this.translateIndexMap = void 0;
      }
    };
    return Category2;
  }(base_default4)
);
var base_default5 = Category;

// node_modules/@antv/scale/esm/category/time.js
init_tslib_es6();
init_esm();

// node_modules/@antv/scale/esm/util/time.js
init_esm();

// node_modules/fecha/lib/fecha.js
var fecha_exports = {};
__export(fecha_exports, {
  assign: () => assign,
  default: () => fecha_default,
  defaultI18n: () => defaultI18n,
  format: () => format,
  parse: () => parse,
  setGlobalDateI18n: () => setGlobalDateI18n,
  setGlobalDateMasks: () => setGlobalDateMasks
});
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v2) {
      return v2.toLowerCase();
    });
    var index = lowerCaseArr.indexOf(v.toLowerCase());
    if (index > -1) {
      return index;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
    var obj = args_1[_a];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function(i18n) {
  return globalI18n = assign(globalI18n, i18n);
};
var regexEscape = function(str) {
  return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function(val, len) {
  if (len === void 0) {
    len = 2;
  }
  val = String(val);
  while (val.length < len) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
  },
  Z: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
  }
};
var monthParse = function(v) {
  return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v) {
    var parts = (v + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v) {
      var now2 = new Date();
      var cent = +("" + now2.getFullYear()).substr(0, 2);
      return +("" + (+v > 68 ? cent - 1 : cent) + v);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function(v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function(masks) {
  return assign(globalMasks, masks);
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};
function parse(dateStr, format2, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format2 = globalMasks[format2] || format2;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format2.replace(literal, function($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field2 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " specified twice in format");
    }
    specifiedFields[field2] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field2) {
    if (!specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i = 1; i < matches.length; i++) {
    var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
    var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
    if (value == null) {
      return null;
    }
    dateInfo[field] = value;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateTZ;
  if (dateInfo.timezoneOffset == null) {
    dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ];
    for (var i = 0, len = validateFields.length; i < len; i++) {
      if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
        return null;
      }
    }
  } else {
    dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
    if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
      return null;
    }
  }
  return dateTZ;
}
var fecha = {
  format,
  parse,
  defaultI18n,
  setGlobalDateI18n,
  setGlobalDateMasks
};
var fecha_default = fecha;

// node_modules/@antv/scale/esm/util/bisector.js
init_esm();
function bisector_default(getter) {
  return function(a, x, _lo, _hi) {
    var lo = is_nil_default(_lo) ? 0 : _lo;
    var hi = is_nil_default(_hi) ? a.length : _hi;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (getter(a[mid]) > x) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return lo;
  };
}

// node_modules/@antv/scale/esm/util/time.js
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
  var method = fecha_exports[FORMAT_METHOD] || fecha_default[FORMAT_METHOD];
  return method(time, mask);
}
function toTimeStamp(value) {
  if (is_string_default(value)) {
    if (value.indexOf("T") > 0) {
      value = new Date(value).getTime();
    } else {
      value = new Date(value.replace(/-/gi, "/")).getTime();
    }
  }
  if (is_date_default(value)) {
    value = value.getTime();
  }
  return value;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
  ["HH:mm:ss", SECOND],
  ["HH:mm:ss", SECOND * 10],
  ["HH:mm:ss", SECOND * 30],
  ["HH:mm", MINUTE],
  ["HH:mm", MINUTE * 10],
  ["HH:mm", MINUTE * 30],
  ["HH", HOUR],
  ["HH", HOUR * 6],
  ["HH", HOUR * 12],
  ["YYYY-MM-DD", DAY],
  ["YYYY-MM-DD", DAY * 4],
  ["YYYY-WW", DAY * 7],
  ["YYYY-MM", MONTH],
  ["YYYY-MM", MONTH * 4],
  ["YYYY-MM", MONTH * 6],
  ["YYYY", DAY * 380]
];
function getTickInterval(min, max, tickCount) {
  var target = (max - min) / tickCount;
  var idx = bisector_default(function(o) {
    return o[1];
  })(intervals, target) - 1;
  var interval2 = intervals[idx];
  if (idx < 0) {
    interval2 = intervals[0];
  } else if (idx >= intervals.length) {
    interval2 = last(intervals);
  }
  return interval2;
}

// node_modules/@antv/scale/esm/category/time.js
var TimeCat = (
  /** @class */
  function(_super) {
    __extends(TimeCat2, _super);
    function TimeCat2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "timeCat";
      return _this;
    }
    TimeCat2.prototype.translate = function(value) {
      value = toTimeStamp(value);
      var index = this.values.indexOf(value);
      if (index === -1) {
        if (is_number_default(value) && value < this.values.length) {
          index = value;
        } else {
          index = NaN;
        }
      }
      return index;
    };
    TimeCat2.prototype.getText = function(value, tickIndex) {
      var index = this.translate(value);
      if (index > -1) {
        var result = this.values[index];
        var formatter = this.formatter;
        result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
        return result;
      }
      return value;
    };
    TimeCat2.prototype.initCfg = function() {
      this.tickMethod = "time-cat";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
    };
    TimeCat2.prototype.setDomain = function() {
      var values = this.values;
      each_default(values, function(v, i) {
        values[i] = toTimeStamp(v);
      });
      values.sort(function(v1, v2) {
        return v1 - v2;
      });
      _super.prototype.setDomain.call(this);
    };
    return TimeCat2;
  }(base_default5)
);
var time_default = TimeCat;

// node_modules/@antv/scale/esm/continuous/linear.js
init_tslib_es6();

// node_modules/@antv/scale/esm/continuous/base.js
init_tslib_es6();
init_esm();
var Continuous = (
  /** @class */
  function(_super) {
    __extends(Continuous2, _super);
    function Continuous2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isContinuous = true;
      return _this;
    }
    Continuous2.prototype.scale = function(value) {
      if (is_nil_default(value)) {
        return NaN;
      }
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      var max = this.max;
      var min = this.min;
      if (max === min) {
        return rangeMin;
      }
      var percent = this.getScalePercent(value);
      return rangeMin + percent * (rangeMax - rangeMin);
    };
    Continuous2.prototype.init = function() {
      _super.prototype.init.call(this);
      var ticks = this.ticks;
      var firstTick = head(ticks);
      var lastTick = last(ticks);
      if (firstTick < this.min) {
        this.min = firstTick;
      }
      if (lastTick > this.max) {
        this.max = lastTick;
      }
      if (!is_nil_default(this.minLimit)) {
        this.min = firstTick;
      }
      if (!is_nil_default(this.maxLimit)) {
        this.max = lastTick;
      }
    };
    Continuous2.prototype.setDomain = function() {
      var _a = get_range_default(this.values), min = _a.min, max = _a.max;
      if (is_nil_default(this.min)) {
        this.min = min;
      }
      if (is_nil_default(this.max)) {
        this.max = max;
      }
      if (this.min > this.max) {
        this.min = min;
        this.max = max;
      }
    };
    Continuous2.prototype.calculateTicks = function() {
      var _this = this;
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        ticks = filter_default(ticks, function(tick) {
          return tick >= _this.min && tick <= _this.max;
        });
      }
      return ticks;
    };
    Continuous2.prototype.getScalePercent = function(value) {
      var max = this.max;
      var min = this.min;
      return (value - min) / (max - min);
    };
    Continuous2.prototype.getInvertPercent = function(value) {
      return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    };
    return Continuous2;
  }(base_default4)
);
var base_default6 = Continuous;

// node_modules/@antv/scale/esm/continuous/linear.js
var Linear = (
  /** @class */
  function(_super) {
    __extends(Linear2, _super);
    function Linear2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "linear";
      _this.isLinear = true;
      return _this;
    }
    Linear2.prototype.invert = function(value) {
      var percent = this.getInvertPercent(value);
      return this.min + percent * (this.max - this.min);
    };
    Linear2.prototype.initCfg = function() {
      this.tickMethod = "wilkinson-extended";
      this.nice = false;
    };
    return Linear2;
  }(base_default6)
);
var linear_default = Linear;

// node_modules/@antv/scale/esm/continuous/log.js
init_tslib_es6();

// node_modules/@antv/scale/esm/util/math.js
init_esm();
function calBase(a, b) {
  var e = Math.E;
  var value;
  if (b >= 0) {
    value = Math.pow(e, Math.log(b) / a);
  } else {
    value = Math.pow(e, Math.log(-b) / a) * -1;
  }
  return value;
}
function log(a, b) {
  if (a === 1) {
    return 1;
  }
  return Math.log(b) / Math.log(a);
}
function getLogPositiveMin(values, base, max) {
  if (is_nil_default(max)) {
    max = Math.max.apply(null, values);
  }
  var positiveMin = max;
  each_default(values, function(value) {
    if (value > 0 && value < positiveMin) {
      positiveMin = value;
    }
  });
  if (positiveMin === max) {
    positiveMin = max / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}

// node_modules/@antv/scale/esm/continuous/log.js
var Log = (
  /** @class */
  function(_super) {
    __extends(Log2, _super);
    function Log2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "log";
      return _this;
    }
    Log2.prototype.invert = function(value) {
      var base = this.base;
      var max = log(base, this.max);
      var rangeMin = this.rangeMin();
      var range = this.rangeMax() - rangeMin;
      var min;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        if (value === 0) {
          return 0;
        }
        min = log(base, positiveMin / base);
        var appendPercent = 1 / (max - min) * range;
        if (value < appendPercent) {
          return value / appendPercent * positiveMin;
        }
      } else {
        min = log(base, this.min);
      }
      var percent = (value - rangeMin) / range;
      var tmp = percent * (max - min) + min;
      return Math.pow(base, tmp);
    };
    Log2.prototype.initCfg = function() {
      this.tickMethod = "log";
      this.base = 10;
      this.tickCount = 6;
      this.nice = true;
    };
    Log2.prototype.setDomain = function() {
      _super.prototype.setDomain.call(this);
      var min = this.min;
      if (min < 0) {
        throw new Error("When you use log scale, the minimum value must be greater than zero!");
      }
      if (min === 0) {
        this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
      }
    };
    Log2.prototype.getScalePercent = function(value) {
      var max = this.max;
      var min = this.min;
      if (max === min) {
        return 0;
      }
      if (value <= 0) {
        return 0;
      }
      var base = this.base;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        min = positiveMin * 1 / base;
      }
      var percent;
      if (value < positiveMin) {
        percent = value / positiveMin / (log(base, max) - log(base, min));
      } else {
        percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));
      }
      return percent;
    };
    return Log2;
  }(base_default6)
);
var log_default = Log;

// node_modules/@antv/scale/esm/continuous/pow.js
init_tslib_es6();
var Pow = (
  /** @class */
  function(_super) {
    __extends(Pow2, _super);
    function Pow2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pow";
      return _this;
    }
    Pow2.prototype.invert = function(value) {
      var percent = this.getInvertPercent(value);
      var exponent2 = this.exponent;
      var max = calBase(exponent2, this.max);
      var min = calBase(exponent2, this.min);
      var tmp = percent * (max - min) + min;
      var factor = tmp >= 0 ? 1 : -1;
      return Math.pow(tmp, exponent2) * factor;
    };
    Pow2.prototype.initCfg = function() {
      this.tickMethod = "pow";
      this.exponent = 2;
      this.tickCount = 5;
      this.nice = true;
    };
    Pow2.prototype.getScalePercent = function(value) {
      var max = this.max;
      var min = this.min;
      if (max === min) {
        return 0;
      }
      var exponent2 = this.exponent;
      var percent = (calBase(exponent2, value) - calBase(exponent2, min)) / (calBase(exponent2, max) - calBase(exponent2, min));
      return percent;
    };
    return Pow2;
  }(base_default6)
);
var pow_default = Pow;

// node_modules/@antv/scale/esm/continuous/time.js
init_tslib_es6();
init_esm();
var Time = (
  /** @class */
  function(_super) {
    __extends(Time2, _super);
    function Time2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "time";
      return _this;
    }
    Time2.prototype.getText = function(value, index) {
      var numberValue = this.translate(value);
      var formatter = this.formatter;
      return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
    };
    Time2.prototype.scale = function(value) {
      var v = value;
      if (is_string_default(v) || is_date_default(v)) {
        v = this.translate(v);
      }
      return _super.prototype.scale.call(this, v);
    };
    Time2.prototype.translate = function(v) {
      return toTimeStamp(v);
    };
    Time2.prototype.initCfg = function() {
      this.tickMethod = "time-pretty";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
      this.nice = false;
    };
    Time2.prototype.setDomain = function() {
      var values = this.values;
      var minConfig = this.getConfig("min");
      var maxConfig = this.getConfig("max");
      if (!is_nil_default(minConfig) || !is_number_default(minConfig)) {
        this.min = this.translate(this.min);
      }
      if (!is_nil_default(maxConfig) || !is_number_default(maxConfig)) {
        this.max = this.translate(this.max);
      }
      if (values && values.length) {
        var timeStamps_1 = [];
        var min_1 = Infinity;
        var secondMin_1 = min_1;
        var max_1 = 0;
        each_default(values, function(v) {
          var timeStamp = toTimeStamp(v);
          if (isNaN(timeStamp)) {
            throw new TypeError("Invalid Time: " + v + " in time scale!");
          }
          if (min_1 > timeStamp) {
            secondMin_1 = min_1;
            min_1 = timeStamp;
          } else if (secondMin_1 > timeStamp) {
            secondMin_1 = timeStamp;
          }
          if (max_1 < timeStamp) {
            max_1 = timeStamp;
          }
          timeStamps_1.push(timeStamp);
        });
        if (values.length > 1) {
          this.minTickInterval = secondMin_1 - min_1;
        }
        if (is_nil_default(minConfig)) {
          this.min = min_1;
        }
        if (is_nil_default(maxConfig)) {
          this.max = max_1;
        }
      }
    };
    return Time2;
  }(linear_default)
);
var time_default2 = Time;

// node_modules/@antv/scale/esm/continuous/quantize.js
init_tslib_es6();
init_esm();
var Quantize = (
  /** @class */
  function(_super) {
    __extends(Quantize2, _super);
    function Quantize2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantize";
      return _this;
    }
    Quantize2.prototype.invert = function(value) {
      var ticks = this.ticks;
      var length = ticks.length;
      var percent = this.getInvertPercent(value);
      var minIndex = Math.floor(percent * (length - 1));
      if (minIndex >= length - 1) {
        return last(ticks);
      }
      if (minIndex < 0) {
        return head(ticks);
      }
      var minTick = ticks[minIndex];
      var nextTick = ticks[minIndex + 1];
      var minIndexPercent = minIndex / (length - 1);
      var maxIndexPercent = (minIndex + 1) / (length - 1);
      return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
    };
    Quantize2.prototype.initCfg = function() {
      this.tickMethod = "r-pretty";
      this.tickCount = 5;
      this.nice = true;
    };
    Quantize2.prototype.calculateTicks = function() {
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        if (last(ticks) !== this.max) {
          ticks.push(this.max);
        }
        if (head(ticks) !== this.min) {
          ticks.unshift(this.min);
        }
      }
      return ticks;
    };
    Quantize2.prototype.getScalePercent = function(value) {
      var ticks = this.ticks;
      if (value < head(ticks)) {
        return 0;
      }
      if (value > last(ticks)) {
        return 1;
      }
      var minIndex = 0;
      each_default(ticks, function(tick, index) {
        if (value >= tick) {
          minIndex = index;
        } else {
          return false;
        }
      });
      return minIndex / (ticks.length - 1);
    };
    return Quantize2;
  }(base_default6)
);
var quantize_default2 = Quantize;

// node_modules/@antv/scale/esm/continuous/quantile.js
init_tslib_es6();
var Quantile = (
  /** @class */
  function(_super) {
    __extends(Quantile2, _super);
    function Quantile2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantile";
      return _this;
    }
    Quantile2.prototype.initCfg = function() {
      this.tickMethod = "quantile";
      this.tickCount = 5;
      this.nice = true;
    };
    return Quantile2;
  }(quantize_default2)
);
var quantile_default = Quantile;

// node_modules/@antv/scale/esm/factory.js
var map = {};
function getClass(key) {
  return map[key];
}
function registerClass(key, cls) {
  if (getClass(key)) {
    throw new Error("type '" + key + "' existed.");
  }
  map[key] = cls;
}

// node_modules/@antv/scale/esm/identity/index.js
init_tslib_es6();
init_esm();
var Identity = (
  /** @class */
  function(_super) {
    __extends(Identity2, _super);
    function Identity2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "identity";
      _this.isIdentity = true;
      return _this;
    }
    Identity2.prototype.calculateTicks = function() {
      return this.values;
    };
    Identity2.prototype.scale = function(value) {
      if (this.values[0] !== value && is_number_default(value)) {
        return value;
      }
      return this.range[0];
    };
    Identity2.prototype.invert = function(value) {
      var range = this.range;
      if (value < range[0] || value > range[1]) {
        return NaN;
      }
      return this.values[0];
    };
    return Identity2;
  }(base_default4)
);
var identity_default = Identity;

// node_modules/@antv/scale/esm/tick-method/cat.js
init_esm();
function calculateCatTicks(cfg) {
  var values = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount, showLast = cfg.showLast;
  if (is_number_default(tickInterval)) {
    var ticks_1 = filter_default(values, function(__, i2) {
      return i2 % tickInterval === 0;
    });
    var lastValue = last(values);
    if (showLast && last(ticks_1) !== lastValue) {
      ticks_1.push(lastValue);
    }
    return ticks_1;
  }
  var len = values.length;
  var min = cfg.min, max = cfg.max;
  if (is_nil_default(min)) {
    min = 0;
  }
  if (is_nil_default(max)) {
    max = values.length - 1;
  }
  if (!is_number_default(tickCount) || tickCount >= len)
    return values.slice(min, max + 1);
  if (tickCount <= 0 || max <= 0)
    return [];
  var interval2 = tickCount === 1 ? len : Math.floor(len / (tickCount - 1));
  var ticks = [];
  var idx = min;
  for (var i = 0; i < tickCount; i++) {
    if (idx >= max)
      break;
    idx = Math.min(min + i * interval2, max);
    if (i === tickCount - 1 && showLast)
      ticks.push(values[max]);
    else
      ticks.push(values[idx]);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/d3-linear.js
init_esm();

// node_modules/@antv/scale/esm/util/d3-linear.js
function d3Linear(cfg) {
  var min = cfg.min, max = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
  var linear4 = new D3Linear();
  linear4.domain([min, max]);
  if (nice) {
    linear4.nice(tickCount);
  }
  return linear4.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var D3Linear = (
  /** @class */
  function() {
    function D3Linear2() {
      this._domain = [0, 1];
    }
    D3Linear2.prototype.domain = function(domain) {
      if (domain) {
        this._domain = Array.from(domain, Number);
        return this;
      }
      return this._domain.slice();
    };
    D3Linear2.prototype.nice = function(count) {
      var _a, _b;
      if (count === void 0) {
        count = DEFAULT_COUNT;
      }
      var d = this._domain.slice();
      var i0 = 0;
      var i1 = this._domain.length - 1;
      var start = this._domain[i0];
      var stop = this._domain[i1];
      var step;
      if (stop < start) {
        _a = [stop, start], start = _a[0], stop = _a[1];
        _b = [i1, i0], i0 = _b[0], i1 = _b[1];
      }
      step = tickIncrement(start, stop, count);
      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement(start, stop, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement(start, stop, count);
      }
      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        this.domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        this.domain(d);
      }
      return this;
    };
    D3Linear2.prototype.ticks = function(count) {
      if (count === void 0) {
        count = DEFAULT_COUNT;
      }
      return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);
    };
    return D3Linear2;
  }()
);
function d3ArrayTicks(start, stop, count) {
  var reverse;
  var i = -1;
  var n;
  var ticks;
  var step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) {
    return [start];
  }
  if (reverse = stop < start) {
    n = start, start = stop, stop = n;
  }
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }
  if (reverse) {
    ticks.reverse();
  }
  return ticks;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count);
  var power = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

// node_modules/@antv/scale/esm/util/interval.js
init_esm();
function snapMultiple(v, base, snapType) {
  var div;
  if (snapType === "ceil") {
    div = Math.ceil(v / base);
  } else if (snapType === "floor") {
    div = Math.floor(v / base);
  } else {
    div = Math.round(v / base);
  }
  return div * base;
}
function intervalTicks(min, max, interval2) {
  var minTick = snapMultiple(min, interval2, "floor");
  var maxTick = snapMultiple(max, interval2, "ceil");
  minTick = fixed_base_default(minTick, interval2);
  maxTick = fixed_base_default(maxTick, interval2);
  var ticks = [];
  var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval2);
  for (var i = minTick; i <= maxTick; i = i + availableInterval) {
    var tickValue = fixed_base_default(i, availableInterval);
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks
  };
}

// node_modules/@antv/scale/esm/util/strict-limit.js
init_esm();
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a;
  var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min = cfg.min, max = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
  var tickMin = is_nil_default(minLimit) ? is_nil_default(defaultMin) ? min : defaultMin : minLimit;
  var tickMax = is_nil_default(maxLimit) ? is_nil_default(defaultMax) ? max : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a = [tickMin, tickMax], tickMax = _a[0], tickMin = _a[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    ticks.push(tickMin + step * i);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/d3-linear.js
function d3LinearTickMethod(cfg) {
  var min = cfg.min, max = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = d3Linear(cfg);
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min, max, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/linear.js
init_esm();

// node_modules/@antv/scale/esm/util/extended.js
init_esm();

// node_modules/@antv/scale/esm/util/pretty-number.js
function prettyNumber(n) {
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
}

// node_modules/@antv/scale/esm/util/extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod(n, m) {
  return (n % m + m) % m;
}
function round(n) {
  return Math.round(n * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  var n = size(Q);
  var i = index_of_default(Q, q);
  var v = 0;
  var m = mod(lmin, lstep);
  if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  var n = size(Q);
  var i = index_of_default(Q, q);
  var v = 1;
  return 1 - i / (n - 1) - j + v;
}
function density(k, m, dMin, dMax, lMin, lMax) {
  var r = (k - 1) / (lMax - lMin);
  var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k, m) {
  if (k >= m) {
    return 2 - (k - 1) / (m - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  var range = dMax - dMin;
  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range, 2);
}
function coverageMax(dMin, dMax, span) {
  var range = dMax - dMin;
  if (span > range) {
    var half = (span - range) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
function extended(dMin, dMax, n, onlyLoose, Q, w) {
  if (n === void 0) {
    n = 5;
  }
  if (onlyLoose === void 0) {
    onlyLoose = true;
  }
  if (Q === void 0) {
    Q = DEFAULT_Q;
  }
  if (w === void 0) {
    w = [0.25, 0.2, 0.5, 0.05];
  }
  var m = n < 0 ? 0 : Math.round(n);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m) {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }
  if (dMax - dMin < 1e-15 || m === 1) {
    return {
      min: dMin,
      max: dMax,
      ticks: [dMin]
    };
  }
  if (dMax - dMin > 1e148) {
    var count = n || 5;
    var step_1 = (dMax - dMin) / count;
    return {
      min: dMin,
      max: dMax,
      ticks: Array(count).fill(null).map(function(_, idx) {
        return prettyNumber(dMin + step_1 * idx);
      })
    };
  }
  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j = 1;
  while (j < Infinity) {
    for (var i = 0; i < Q.length; i += 1) {
      var q = Q[i];
      var sm = simplicityMax(q, Q, j);
      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
        j = Infinity;
        break;
      }
      var k = 2;
      while (k < Infinity) {
        var dm = densityMax(k, m);
        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
          break;
        }
        var delta = (dMax - dMin) / (k + 1) / j / q;
        var z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          var step = j * q * Math.pow(10, z);
          var cm = coverageMax(dMin, dMax, step * (k - 1));
          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
            break;
          }
          var minStart = Math.floor(dMax / step) * j - (k - 1) * j;
          var maxStart = Math.ceil(dMin / step) * j;
          if (minStart <= maxStart) {
            var count = maxStart - minStart;
            for (var i_1 = 0; i_1 <= count; i_1 += 1) {
              var start = minStart + i_1;
              var lMin = start * (step / j);
              var lMax = lMin + step * (k - 1);
              var lStep = step;
              var s = simplicity(q, Q, j, lMin, lMax, lStep);
              var c = coverage(dMin, dMax, lMin, lMax);
              var g = density(k, m, dMin, dMax, lMin, lMax);
              var l = legibility();
              var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
              if (score > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score;
              }
            }
          }
          z += 1;
        }
        k += 1;
      }
    }
    j += 1;
  }
  var lmax = prettyNumber(best.lmax);
  var lmin = prettyNumber(best.lmin);
  var lstep = prettyNumber(best.lstep);
  var tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;
  var ticks = new Array(tickCount);
  ticks[0] = prettyNumber(lmin);
  for (var i = 1; i < tickCount; i++) {
    ticks[i] = prettyNumber(ticks[i - 1] + lstep);
  }
  return {
    min: Math.min(dMin, head(ticks)),
    max: Math.max(dMax, last(ticks)),
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/linear.js
function linear3(cfg) {
  var min = cfg.min, max = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = extended(min, max, tickCount, nice).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min, max, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/log.js
function calculateLogTicks(cfg) {
  var base = cfg.base, tickCount = cfg.tickCount, min = cfg.min, max = cfg.max, values = cfg.values;
  var minTick;
  var maxTick = log(base, max);
  if (min > 0) {
    minTick = Math.floor(log(base, min));
  } else {
    var positiveMin = getLogPositiveMin(values, base, max);
    minTick = Math.floor(log(base, positiveMin));
  }
  var count = maxTick - minTick;
  var avg = Math.ceil(count / tickCount);
  var ticks = [];
  for (var i = minTick; i < maxTick + avg; i = i + avg) {
    ticks.push(Math.pow(base, i));
  }
  if (min <= 0) {
    ticks.unshift(0);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/pretty.js
function pretty(min, max, m) {
  if (m === void 0) {
    m = 5;
  }
  if (min === max) {
    return {
      max,
      min,
      ticks: [min]
    };
  }
  var n = m < 0 ? 0 : Math.round(m);
  if (n === 0)
    return { max, min, ticks: [] };
  var h = 1.5;
  var h5 = 0.5 + 1.5 * h;
  var d = max - min;
  var c = d / n;
  var base = Math.pow(10, Math.floor(Math.log10(c)));
  var unit = base;
  if (2 * base - c < h * (c - unit)) {
    unit = 2 * base;
    if (5 * base - c < h5 * (c - unit)) {
      unit = 5 * base;
      if (10 * base - c < h * (c - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu = Math.ceil(max / unit);
  var ns = Math.floor(min / unit);
  var hi = Math.max(nu * unit, max);
  var lo = Math.min(ns * unit, min);
  var size2 = Math.floor((hi - lo) / unit) + 1;
  var ticks = new Array(size2);
  for (var i = 0; i < size2; i++) {
    ticks[i] = prettyNumber(lo + i * unit);
  }
  return {
    min: lo,
    max: hi,
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/pow.js
function calculatePowTicks(cfg) {
  var exponent2 = cfg.exponent, tickCount = cfg.tickCount;
  var max = Math.ceil(calBase(exponent2, cfg.max));
  var min = Math.floor(calBase(exponent2, cfg.min));
  var ticks = pretty(min, max, tickCount).ticks;
  return ticks.map(function(tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent2) * factor;
  });
}

// node_modules/@antv/scale/esm/tick-method/quantile.js
function quantileSorted(x, p) {
  var idx = x.length * p;
  if (p === 1) {
    return x[x.length - 1];
  } else if (p === 0) {
    return x[0];
  } else if (idx % 1 !== 0) {
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    return x[idx];
  }
}
function calculateTicks(cfg) {
  var tickCount = cfg.tickCount, values = cfg.values;
  if (!values || !values.length) {
    return [];
  }
  var sorted = values.slice().sort(function(a, b) {
    return a - b;
  });
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    var p = i / (tickCount - 1);
    ticks.push(quantileSorted(sorted, p));
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/r-prettry.js
init_esm();
function linearPretty(cfg) {
  var min = cfg.min, max = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = pretty(min, max, tickCount).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min, max, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time.js
function calculateTimeTicks(cfg) {
  var min = cfg.min, max = cfg.max, minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount;
  if (tickInterval) {
    tickCount = Math.ceil((max - min) / tickInterval);
  } else {
    tickInterval = getTickInterval(min, max, tickCount)[1];
    var count = (max - min) / tickInterval;
    var ratio = count / tickCount;
    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    }
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max - min) / (Math.pow(2, 12) - 1)), tickInterval);
  var ticks = [];
  for (var i = min; i < max + tickInterval; i += tickInterval) {
    ticks.push(i);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-cat.js
init_tslib_es6();
function timeCat(cfg) {
  var ticks = calculateCatTicks(__assign({ showLast: true }, cfg));
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-pretty.js
function getYear(date) {
  return new Date(date).getFullYear();
}
function createYear(year) {
  return new Date(year, 0, 1).getTime();
}
function getMonth(date) {
  return new Date(date).getMonth();
}
function diffMonth(min, max) {
  var minYear = getYear(min);
  var maxYear = getYear(max);
  var minMonth = getMonth(min);
  var maxMonth = getMonth(max);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}
function diffDay(min, max) {
  return Math.ceil((max - min) / DAY);
}
function diffHour(min, max) {
  return Math.ceil((max - min) / HOUR);
}
function diffMinus(min, max) {
  return Math.ceil((max - min) / (60 * 1e3));
}
function timePretty(cfg) {
  var min = cfg.min, max = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = [];
  if (!tickInterval) {
    tickInterval = (max - min) / tickCount;
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max - min) / (Math.pow(2, 12) - 1)), tickInterval);
  var minYear = getYear(min);
  if (tickInterval > YEAR) {
    var maxYear = getYear(max);
    var yearInterval = Math.ceil(tickInterval / YEAR);
    for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
      ticks.push(createYear(i));
    }
  } else if (tickInterval > MONTH) {
    var monthInterval = Math.ceil(tickInterval / MONTH);
    var mmMoth = getMonth(min);
    var dMonths = diffMonth(min, max);
    for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
      ticks.push(creatMonth(minYear, i + mmMoth));
    }
  } else if (tickInterval > DAY) {
    var date = new Date(min);
    var year = date.getFullYear();
    var month = date.getMonth();
    var mday = date.getDate();
    var day = Math.ceil(tickInterval / DAY);
    var ddays = diffDay(min, max);
    for (var i = 0; i < ddays + day; i = i + day) {
      ticks.push(new Date(year, month, mday + i).getTime());
    }
  } else if (tickInterval > HOUR) {
    var date = new Date(min);
    var year = date.getFullYear();
    var month = date.getMonth();
    var day = date.getDate();
    var hour = date.getHours();
    var hours = Math.ceil(tickInterval / HOUR);
    var dHours = diffHour(min, max);
    for (var i = 0; i <= dHours + hours; i = i + hours) {
      ticks.push(new Date(year, month, day, hour + i).getTime());
    }
  } else if (tickInterval > MINUTE) {
    var dMinus = diffMinus(min, max);
    var minutes = Math.ceil(tickInterval / MINUTE);
    for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
      ticks.push(min + i * MINUTE);
    }
  } else {
    var interval2 = tickInterval;
    if (interval2 < SECOND) {
      interval2 = SECOND;
    }
    var minSecond = Math.floor(min / SECOND) * SECOND;
    var dSeconds = Math.ceil((max - min) / SECOND);
    var seconds = Math.ceil(interval2 / SECOND);
    for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
      ticks.push(minSecond + i * SECOND);
    }
  }
  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/index.js
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", timeCat);
registerTickMethod("wilkinson-extended", linear3);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);

// node_modules/@antv/scale/esm/index.js
registerClass("cat", base_default5);
registerClass("category", base_default5);
registerClass("identity", identity_default);
registerClass("linear", linear_default);
registerClass("log", log_default);
registerClass("pow", pow_default);
registerClass("time", time_default2);
registerClass("timeCat", time_default);
registerClass("quantize", quantize_default2);
registerClass("quantile", quantile_default);

export {
  esm_default,
  graph_event_default,
  base_default,
  timer,
  init_src,
  catmull_rom_2_bezier_default,
  parsePathString,
  isPolygonsIntersect,
  getArcParams2 as getArcParams,
  canvas_default2 as canvas_default,
  esm_exports,
  canvas_default3 as canvas_default2,
  esm_exports2,
  addEventListener,
  createDom2 as createDom,
  getOuterHeight,
  getOuterWidth,
  modifyCSS,
  base_default4 as base_default2,
  base_default5 as base_default3,
  linear_default,
  getClass
};
//# sourceMappingURL=chunk-MK6CXWVY.js.map
